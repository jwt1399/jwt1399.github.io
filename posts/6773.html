<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java-集合, 简简,简简博客,网络安全,计算机,Java开发">
    <meta name="description" content="前言哈喽！大家好，我是小简。今天开始学习《Java-集合》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 Java-学习路线，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html;charset=gb2312" />
    <meta name="sogou_site_verification" content="VTcD33rrfd" />
    <meta name="google-site-verification" content="mHsYpjV9Rl0e0UzjioJFLg8RMtOhxw8HB3D21dIWvmc" />
	<meta name="referrer" content="unsafe-url">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Java-集合 | 简言之</title>
    <link rel="icon" type="image/png" href="/favicon.png">
	<!--变灰-->
	<!-- <link href="http://static.isenyu.cn/file/css/MemorialDay.css"; rel="stylesheet" type="text/css" /> -->
    <!-- <style type="text/css">
     html{ filter: grayscale(100%); /* 标准写法 just for IE6-9 */ 
        -webkit-filter: grayscale(100%); /* webkit 内核支持程度较好 */ 
        -moz-filter: grayscale(100%); /* 其他内核现在并不支持，为了将来兼容性书写 */ 
        -ms-filter: grayscale(100%); 
        -o-filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);
        filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); /* Firefox 3.5+ */ }
     </style> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/aos/0.1.0/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js"></script>
	<!--valine_人机验证-->
	<script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
	<script src="/js/Valine-RJyanzheng.js"></script>

    
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="简言之" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img no-lazy src="/medias/logo.png" class="logo-img" alt="">
                    
                    <span class="logo-span">简言之</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Home</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-user-secret" style="zoom: 0.6;"></i>
      
      <span>Sec</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Web/">
          
          <i class="fab fa-internet-explorer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Web</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/CTF/">
          
          <i class="fas fa-flag" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CTF</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Crypto/">
          
          <i class="fa-solid fa-shield" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Data</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fab fa-java" style="zoom: 0.6;"></i>
      
      <span>Java</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/JavaSE/">
          
          <i class="fa-solid fa-mug-saucer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaSE</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/JavaWeb/">
          
          <i class="fa-solid fa-earth-americas" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaWeb</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Spring/">
          
          <i class="fa-solid fa-leaf" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Spring</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Q-A/">
          
          <i class="fa-solid fa-bell" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Q&A</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-desktop" style="zoom: 0.6;"></i>
      
      <span>CS</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/CS%E5%9F%BA%E7%A1%80/">
          
          <i class="fa-solid fa-server" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CS基础</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/SQL/">
          
          <i class="fas fa-database" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>数据库</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">
          
          <i class="fa-solid fa-bezier-curve" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>结构-算法</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-layer-group" style="zoom: 0.6;"></i>
      
      <span>Others</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Python/">
          
          <i class="fab fa-python" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Python</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Course/">
          
          <i class="fa-solid fa-graduation-cap" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Course</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Share/">
          
          <i class="fa-solid fa-crown" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Share~</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Tools/">
          
          <i class="fas fa-tools" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Tools~</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>整理</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/tags/">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归类</span>
        </a>
      </li>
      
      <li>
        <a href="/archives/">
          
          <i class="fas fa-file-contract" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归档</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-paper-plane" style="zoom: 0.6;"></i>
      
      <span>交流</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/friends/">
          
          <i class="fas fa-venus-mars" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>友链</span>
        </a>
      </li>
      
      <li>
        <a href="/artitalk/">
          
          <i class="fa-solid fa-message" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>说说</span>
        </a>
      </li>
      
      <li>
        <a href="/contact/">
          
          <i class="fas fa-envelope" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>留言</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-id-card-alt" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img no-lazy src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">简言之</div>
        <div class="logo-desc">
            
            悄无声息地变坚强，安静地变优秀！
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Home
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-secret"></i>
			
			Sec
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Web/ " style="margin-left:50px";>
				  
				   <i class="fab fa-internet-explorer" style="position: absolute;left:28px" ></i>
			      
		          <span>Web</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/CTF/ " style="margin-left:50px";>
				  
				   <i class="fas fa-flag" style="position: absolute;left:28px" ></i>
			      
		          <span>CTF</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Crypto/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-shield" style="position: absolute;left:28px" ></i>
			      
		          <span>Data</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fab fa-java"></i>
			
			Java
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/JavaSE/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-mug-saucer" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaSE</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/JavaWeb/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-earth-americas" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaWeb</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Spring/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-leaf" style="position: absolute;left:28px" ></i>
			      
		          <span>Spring</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Q-A/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bell" style="position: absolute;left:28px" ></i>
			      
		          <span>Q&A</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-desktop"></i>
			
			CS
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/CS%E5%9F%BA%E7%A1%80/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-server" style="position: absolute;left:28px" ></i>
			      
		          <span>CS基础</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/SQL/ " style="margin-left:50px";>
				  
				   <i class="fas fa-database" style="position: absolute;left:28px" ></i>
			      
		          <span>数据库</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bezier-curve" style="position: absolute;left:28px" ></i>
			      
		          <span>结构-算法</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-layer-group"></i>
			
			Others
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Python/ " style="margin-left:50px";>
				  
				   <i class="fab fa-python" style="position: absolute;left:28px" ></i>
			      
		          <span>Python</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Course/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-graduation-cap" style="position: absolute;left:28px" ></i>
			      
		          <span>Course</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Share/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-crown" style="position: absolute;left:28px" ></i>
			      
		          <span>Share~</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Tools/ " style="margin-left:50px";>
				  
				   <i class="fas fa-tools" style="position: absolute;left:28px" ></i>
			      
		          <span>Tools~</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			整理
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/tags/ " style="margin-left:50px";>
				  
				   <i class="fas fa-bookmark" style="position: absolute;left:28px" ></i>
			      
		          <span>归类</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/archives/ " style="margin-left:50px";>
				  
				   <i class="fas fa-file-contract" style="position: absolute;left:28px" ></i>
			      
		          <span>归档</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-paper-plane"></i>
			
			交流
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/friends/ " style="margin-left:50px";>
				  
				   <i class="fas fa-venus-mars" style="position: absolute;left:28px" ></i>
			      
		          <span>友链</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/artitalk/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-message" style="position: absolute;left:28px" ></i>
			      
		          <span>说说</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact/ " style="margin-left:50px";>
				  
				   <i class="fas fa-envelope" style="position: absolute;left:28px" ></i>
			      
		          <span>留言</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-id-card-alt"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('猜猜密码是什么呢ヾﾉ≧∀≦)o')).toString(CryptoJS.enc.Hex)) {
                alert('哎呦！密码好像不对哟，将返回主页！');
                location.href = '/';	
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://img.jwt1399.top/img/images-20220225131654751.jpeg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java-集合</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    /*.toc-widget {
        width: 345px;
        padding-left: 20px;
    }*/
    .toc-widget {
        width: 345px;
        padding-left: 20px;
        /* 毛玻璃 */
        /*background-color: rgba(162,101,228, 0.08);*/
        /*backdrop-filter: saturate(180%) blur(20px);*/
        /*目录样式修改*/
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }
    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9B%86%E5%90%88/">
                                <span class="chip bg-color">集合</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaSE/" class="post-category">
                                JavaSE
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-20
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-03-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12k
                </div>
                

                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈喽！大家好，我是小简。今天开始学习《Java-集合》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 <a href="https://jwt1399.top/posts/29829.html">Java-学习路线</a>，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！&lt;有同样想法的小伙伴，可以联系我一起交流学习哦！&gt;</p>
<ul>
<li>[x] 🚩时间安排：预计7天更新完</li>
<li>[x] 🎯开始时间：03-20</li>
<li>[x] 🎉结束时间：03-28</li>
<li>[x] 🍀总结：超时啦！这周花了一半时间看论文，耽搁啦！集合这章节是难点也是重点，算是勉勉强强算学完了，还不是很熟，后续再加强吧。</li>
</ul>
<h1 id="零、集合简介"><a href="#零、集合简介" class="headerlink" title="零、集合简介"></a>零、集合简介</h1><h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><p>以往我们保存多个数据使用的是数组，但是数组有不足的地方，我们分析一下</p>
<ul>
<li>数组<ul>
<li>1)长度开始时必须指定，而且一旦指定，不能更改</li>
<li>2)保存的必须为同一类型的元素</li>
<li>3)使用数组进行增加/删除元素比较麻烦</li>
</ul>
</li>
<li>集合<ul>
<li>1)可以动态保存任意多个对象，使用比较方便!</li>
<li>2)提供了一系列方便的操作对象的方法: add、remove、set、get等</li>
<li>3)使用集合添加，删除新元素简洁了</li>
</ul>
</li>
</ul>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p>Java 的集合类很多，主要分为两大类(单列集合和双列集合)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>单列集合</th>
<th>双列集合</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img.jwt1399.top/img/202302212335757.png" alt=""></td>
<td><img src="https://img.jwt1399.top/img/image-20220320114413942.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h2 id="List-Set-Queue-Map-的区别"><a href="#List-Set-Queue-Map-的区别" class="headerlink" title="List, Set, Queue, Map 的区别"></a>List, Set, Queue, Map 的区别</h2><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对存储，key 是无序的、不可重复的，value 是无序的、可重复的。</li>
</ul>
<h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>ArrayList</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><code>HashMap</code>： <ul>
<li>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
<li>JDK1.8 以后 <code>HashMap</code> 由数组+链表+红黑树，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
</ul>
</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h1 id="一、Collection-接口"><a href="#一、Collection-接口" class="headerlink" title="一、Collection 接口"></a>一、Collection 接口</h1><h2 id="⓪Collection用法"><a href="#⓪Collection用法" class="headerlink" title="⓪Collection用法"></a>⓪Collection用法</h2><h3 id="⓿特点"><a href="#⓿特点" class="headerlink" title="⓿特点"></a>⓿特点</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface Collection<E> extends Iterable< E>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>Collection 实现子类可以存放多个元素，每个元素可以是 Object</li>
<li>Collection 的实现类，有些可以存放重复的元素，有些不可以</li>
<li><p>Collection 的实现类，有些是有序的(List)，有些不是有序(Set)</p>
</li>
<li><p>Collection 接口<strong>没有直接的实现子类</strong>，是通过它的子接口 List 和 Set 来实现的</p>
</li>
</ul>
<h3 id="❶常用方法"><a href="#❶常用方法" class="headerlink" title="❶常用方法"></a>❶常用方法</h3><ul>
<li>add() 添加单个元素</li>
<li>remove() 删除指定元素<ul>
<li>remove(index) //删除指定索引元素</li>
<li>remove(Object) //删除指定某个元素</li>
</ul>
</li>
<li>contains() 查找元素是否存在</li>
<li>size() 获取元素个数</li>
<li>isEmpty() 判断是否为空</li>
<li>clear() 清空</li>
<li>addAll(Collection) 添加多个元素</li>
<li>containsAll(Collection) 查找多个元素是否都存在</li>
<li>removeAll(Collection)  删除多个元素</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CollectionMethod {
    public static void main(String[] args) {
        // 说明：以ArrayList 实现类来演示
        Collection col = new ArrayList();
        // add:添加单个元素
        col.add("jack");
        col.add(10); //col.add(new Integer(10))
        col.add(true);
        System.out.println("col=" + col);
        // remove:删除指定元素
        col.remove(0);//删除第一个元素
        System.out.println("col=" + col);
        col.remove(true);//指定删除某个元素
        System.out.println("col=" + col);
        // contains:查找元素是否存在
        System.out.println(col.contains("jack"));//F
        // size:获取元素个数
        System.out.println(col.size());//1
        // isEmpty:判断是否为空
        System.out.println(col.isEmpty());//F
        // clear:清空
        col.clear();
        System.out.println("col=" + col);
        // addAll:添加多个元素
        Collection col2 = new ArrayList();
        col2.add("红楼梦");
        col2.add("三国演义");
        col.addAll(col2);
        System.out.println("col2=" + col2);
        System.out.println("col=" + col);
        // containsAll:查找多个元素是否都存在
        System.out.println(col.containsAll(col2));//T
        // removeAll：删除多个元素
        col.add("聊斋");
        col.removeAll(col2);
        System.out.println("col=" + col);//[聊斋]
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❷遍历"><a href="#❷遍历" class="headerlink" title="❷遍历"></a>❷遍历</h3><h4 id="Iterator遍历"><a href="#Iterator遍历" class="headerlink" title="Iterator遍历"></a>Iterator遍历</h4><p><strong>简介</strong></p>
<ul>
<li>Iterator 对象称为迭代器， 主要仅用于遍历 Collection 集合中的元素，Iterator 本身并不存放对象。</li>
<li>所有实现了Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了Iterator 接口的对象， 即可以返回一个迭代器。</li>
</ul>
<p><strong>Iterator 接口方法</strong></p>
<ul>
<li>literator() 得到一个集合的迭代器</li>
<li>hasNext() 判断是否还有下一个元素</li>
<li>next() 下移并将下移以后集合位置上的元素返回</li>
<li>remove() 移除集合元素</li>
</ul>
<p>在调用 iterator.next() 方法之前必须要调用 iterator.hasNext() 进行检测。若不调用，如果下一条记录无效，直接调用 it.next() 会抛出NoSuchElementException异常。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CollectionIterator {
    public static void main(String[] args) {
        Collection col = new ArrayList();
        col.add(new Book_("三国演义", "罗贯中", 10.1));
        col.add(new Book_("小李飞刀", "古龙", 5.1));
        col.add(new Book_("红楼梦", "曹雪芹", 34.6));
        System.out.println("col=" + col);
        //1. 先得到col 对应的迭代器
        Iterator iterator = col.iterator();
        //2. 使用while 循环遍历  快捷键：itit
        while (iterator.hasNext()) {//判断是否还有数据
            Object obj = iterator.next();//读取当前集合数据元素
            System.out.println("col=" + obj);
        }
        //3. 当退出while 循环后, 这时iterator 迭代器，指向最后的元素
        // iterator.next();//NoSuchElementException
        //4. 如果希望再次遍历，需要重置我们的迭代器
        iterator = col.iterator();
        System.out.println("===第二次遍历===");
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("col=" + obj);
        }
        //5.移除集合元素
        iterator = col.iterator();
        System.out.println("===移除集合元素===");
        while(iterator.hasNext()){
            Object obj = iterator.next();
            iterator.remove();
            System.out.println("col=" + col);
        }
    }
}

class Book_ {
    private String name;
    private String author;
    private double price;

    public Book_(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book_{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h4><ul>
<li><p>增强 for 循环， 可以代替 iterator 迭代器， 增强 for 底层就是迭代器</p>
</li>
<li><p>增强 for 就是简化版的 iterator，本质一样。只能用于遍历集合或数组。</p>
</li>
<li><p>基本语法：<code>for(元素类型 元素名:集合名或数组名) &#123;&#125;</code></p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CollectionFor {
    public static void main(String[] args) {
        Collection col = new ArrayList();
        col.add(new Book_("三国演义", "罗贯中", 10.1));
        col.add(new Book_("小李飞刀", "古龙", 5.1));
        col.add(new Book_("红楼梦", "曹雪芹", 34.6));
        System.out.println("col=" + col);
                //增强for  快捷键：I
        for (Object o :col) {
            System.out.println("col=" + o);
        }
    }
}

class Book_ {
    private String name;
    private String author;
    private double price;

    public Book_(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book_{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="①Collection子接口-List"><a href="#①Collection子接口-List" class="headerlink" title="①Collection子接口-List"></a>①Collection子接口-List</h2><h3 id="⓿List用法"><a href="#⓿List用法" class="headerlink" title="⓿List用法"></a>⓿List用法</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>List 接口是 Collection 接口的子接口</p>
<ul>
<li>List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">List list = new ArrayList();
list.add("tom");
list.add("tom");//可以重复
list.add("mary");
list.add("jwt");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>List 集合中的每个元素都有其对应的顺序索引，即支持索引。</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">System.out.println(list.get(3));//jwt
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>List 接口实现类常用的有：ArrayList、LinkedList、Vector</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>add() 添加单个元素</li>
<li>add(int index, Object ele) 在 index 位置插入 ele 元素</li>
<li>addAll(int index, Collection eles) 从 index 位置开始将 eles 中的所有元素添加进来</li>
<li>get(int index) 获取指定 index 位置的元素</li>
<li>indexOf(Object obj) 返回 obj 在集合中首次出现的位置</li>
<li>lastIndexOf(Object obj) 返回 obj 在当前集合中末次出现的位置</li>
<li>remove(int index) 移除指定 index 位置的元素，并返回此元素</li>
<li>set(int index, Object ele) 设置指定 index 位置的元素为 ele , 相当于是替换</li>
<li>subList(int fromIndex, int toIndex)  返回从 [fromIndex,toIndex) 位置的子集合</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ListMethod {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("张三丰");
        list.add("贾宝玉");
        // void add(int index, Object ele):在index 位置插入ele 元素
        //在index = 1 的位置插入一个对象
        list.add(1, "简简");
        System.out.println("list=" + list);
        // boolean addAll(int index, Collection eles):从index 位置开始将eles 中的所有元素添加进来
        List list2 = new ArrayList();
        list2.add("jack");
        list2.add("tom");
        list.addAll(1, list2);
        System.out.println("list2=" + list2);
        System.out.println("list=" + list);
        // Object get(int index):获取指定index 位置的元素
        System.out.println(list.get(3));
        // int indexOf(Object obj):返回obj 在集合中首次出现的位置
        System.out.println(list.indexOf("tom"));//2
        // int lastIndexOf(Object obj):返回obj 在当前集合中末次出现的位置
        list.add("简简");
        System.out.println("list=" + list);
        System.out.println(list.lastIndexOf("简简"));
        // Object remove(int index):移除指定index 位置的元素，并返回此元素
        Object remove = list.remove(0);
        System.out.println("remove = " + remove);
        System.out.println("list=" + list);
        // Object set(int index, Object ele):设置指定index 位置的元素为ele , 相当于是替换.
        list.set(1, "玛丽");
        System.out.println("list=" + list);
        // List subList(int fromIndex, int toIndex):返回从[fromIndex,toIndex) 位置的子集合
        List returnlist = list.subList(0, 2);
        System.out.println("returnlist=" + returnlist);

    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ListFor {
    public static void main(String[] args) {
        //List 接口的实现子类ArrayList、Vector、LinkedList
        //List list = new ArrayList();
        //List list = new Vector();
        List list = new LinkedList();
        list.add("jack");
        list.add("tom");
        list.add("鱼香肉丝");
        list.add("北京烤鸭子");
        //遍历
        //1. 迭代器 快捷代码itit
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println(obj);
        }

        //2. 增强for 快捷代码I
        System.out.println("=====增强for=====");
        for (Object o : list) {
            System.out.println("o=" + o);
        }

        //3. 使用普通for
        System.out.println("=====普通for====");
        for (int i = 0; i < list.size(); i++) {
            System.out.println("对象=" + list.get(i));
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><h5 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h5><p>添加10个以上的元素，在2号位插入一个元素”简简”，获得第5个元素，删除第6个元素，修改第7个元素，在使用迭代器遍历集合，要求：使用 List 的实现类 ArrayList 完成。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.list_;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListExercise {
    public static void main(String[] args) {
        List list = new ArrayList();
        for (int i = 0; i < 10; i++) {
            list.add(i);
        }
        System.out.println(list);
        //在2号位插入一个元素
        list.add(1,"简简");
        System.out.println(list);
        //获得第5个元素
        System.out.println(list.get(4));
        //删除第6个元素
        list.remove(5);
        System.out.println(list);
        //修改第7个元素
        list.set(6,"简简");
        System.out.println(list);
        //迭代器遍历
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h5><p>使用 List 的实现类添加三本图书，并遍历，打印如下效果<br>名称: xx    价格: xx    作者: xx<br>名称: xx    价格: xx    作者: xx<br>名称: xx    价格: xx    作者: xx</p>
<ul>
<li><p>1)按价格排序，从低到高(使用冒泡法)</p>
</li>
<li><p>2)要求使用ArrayList、LinkedList 和Vector三种集合实现</p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.list_;

import java.util.List;
import java.util.Vector;

public class ListExercise02 {
    public static void main(String[] args) {
        //List<Book2> books = new ArrayList<Book2>();
        //LinkedList<Book2> books = new LinkedList<Book2>();
        Vector<Book2> books = new Vector<>();
        books.add(new Book2("红楼梦", "曹雪芹", 90));
        books.add(new Book2("西游记", "吴承恩", 100));
        books.add(new Book2("水浒传", "施耐庵", 80));
        System.out.println("==排序前==");
        for (Object o : books) {
            System.out.println(o);
        }
        System.out.println("==排序后==");
        bubblesort(books);
        for (Object o : books) {
            System.out.println(o);
        }
    }
    //冒泡排序
    public static void bubblesort(List list) {
        int listSize = list.size();
        for (int i = 0; i < listSize - 1; i++) {
            for (int j = 0; j < listSize - 1 - i; j++) {
                //取出对象Book
                Book2 book1 = (Book2) list.get(j);
                Book2 book2 = (Book2) list.get(j + 1);
                if (book1.getPrice() > book2.getPrice()) {//交换
                    list.set(j, book2);
                    list.set(j + 1, book1);
                }
            }
        }
    }
}

class Book2{
    private String name;
    private String author;
    private double price;

    public Book2(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "名称：" + name + "\t价格:" + price + "\t作者" + author ;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❶ArrayList"><a href="#❶ArrayList" class="headerlink" title="❶ArrayList"></a>❶ArrayList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="https://img.jwt1399.top/img/image-20220321110347767.png" alt=""></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。</p>
</li>
<li><p>ArrayList 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p>
<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>ArrayList 底层实现是一个 <code>Object</code> 数组</p>
<ul>
<li><code>transient Object[] elementData;</code></li>
</ul>
</li>
<li><p>ArrayList 只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 <code>int</code>、<code>float</code> 等基本数据类型的时候，必须把它们转换成对应的包装类</p>
</li>
<li><p>ArrayList 可以加入 null，并且可以多个 null</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">list.add(null);
list.add("jianjian");
list.add(null);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全(执行效率高)，在多线程情况下，不建议使用 ArrayList</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//ArrayList 是线程不安全，没有 synchronized
//add源码
public boolean add(E e) {
  ensureCapacityInternal(size + 1);  
  elementData[size++] = e;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * 默认初始容量大小
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 空数组（用于空实例）。
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

     //用于默认大小空实例的共享空数组实例。
    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * 保存ArrayList数据的数组
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList 所包含的元素个数
     */
    private int size;

    /**
     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            //如果传入的参数大于0，创建initialCapacity大小的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //如果传入的参数等于0，创建空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //其他情况，抛出异常
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    /**
     *默认无参构造函数
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
     */
    public ArrayList(Collection<? extends E> c) {
        //将指定集合转换为数组
        elementData = c.toArray();
        //如果elementData数组的长度不为0
        if ((size = elementData.length) != 0) {
            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）
            if (elementData.getClass() != Object[].class)
                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 其他情况，用空数组代替
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    /**
     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。
     */
    public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }
    //下面是ArrayList的扩容机制
    //ArrayList的扩容机制提高了性能，如果每次只扩充一个，
    //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。
    /**
     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
     * @param   minCapacity   所需的最小容量
     */
    public void ensureCapacity(int minCapacity) {
        //如果是true，minExpand的值为0，如果是false,minExpand的值为10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It's already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;
        //如果最小容量大于已有的最大容量
        if (minCapacity > minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }
    //得到最小扩容量
    private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
              // 获取“默认的容量”和“传入参数”两者之间的最大值
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }
    //判断是否需要扩容
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            //调用grow方法进行扩容，调用此方法代表已经开始扩容了
            grow(minCapacity);
    }

    /**
     * 要分配的最大数组大小
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * ArrayList扩容的核心方法。
     */
    private void grow(int minCapacity) {
        // oldCapacity为旧容量，newCapacity为新容量
        int oldCapacity = elementData.length;
        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        //再检查新容量是否超出了ArrayList所定义的最大容量，
        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，
        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    //比较minCapacity和 MAX_ARRAY_SIZE
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    /**
     *返回此列表中的元素数。
     */
    public int size() {
        return size;
    }

    /**
     * 如果此列表不包含元素，则返回 true 。
     */
    public boolean isEmpty() {
        //注意=和==的区别
        return size == 0;
    }

    /**
     * 如果此列表包含指定的元素，则返回true 。
     */
    public boolean contains(Object o) {
        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
        return indexOf(o) >= 0;
    }

    /**
     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
     */
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                //equals()方法比较
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
     */
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
     */
    public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // 这不应该发生，因为我们是可以克隆的
            throw new InternalError(e);
        }
    }

    /**
     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    /**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // 新建一个运行时类型的数组，但是ArrayList数组的内容
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
            //调用System提供的arraycopy()方法实现数组之间的复制
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    // Positional Access Operations

    @SuppressWarnings("unchecked")
    E elementData(int index) {
        return (E) elementData[index];
    }

    /**
     * 返回此列表中指定位置的元素。
     */
    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }

    /**
     * 用指定的元素替换此列表中指定位置的元素。
     */
    public E set(int index, E element) {
        //对index进行界限检查
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        //返回原来在这个位置的元素
        return oldValue;
    }

    /**
     * 将指定的元素追加到此列表的末尾。
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //这里看到ArrayList添加元素的实质就相当于为数组赋值
        elementData[size++] = e;
        return true;
    }

    /**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

    /**
     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。
     */
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
      //从列表中删除的元素
        return oldValue;
    }

    /**
     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
     *返回true，如果此列表包含指定的元素
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * 从列表中删除所有元素。
     */
    public void clear() {
        modCount++;

        // 把数组中所有的元素的值设为null
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }

    /**
     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
     */
    public boolean addAll(Collection<? extends E> c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。
     *将任何后续元素移动到左侧（减少其索引）。
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

    /**
     * 检查给定的索引是否在范围内。
     */
    private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * add和addAll使用的rangeCheck的一个版本
     */
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 返回IndexOutOfBoundsException细节信息
     */
    private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }

    /**
     * 从此列表中删除指定集合中包含的所有元素。
     */
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        //如果此列表被修改则返回true
        return batchRemove(c, false);
    }

    /**
     * 仅保留此列表中包含在指定集合中的元素。
     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。
     */
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }


    /**
     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。
     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *返回的列表迭代器是fail-fast 。
     */
    public ListIterator<E> listIterator(int index) {
        if (index < 0 || index > size)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }

    /**
     *返回列表中的列表迭代器（按适当的顺序）。
     *返回的列表迭代器是fail-fast 。
     */
    public ListIterator<E> listIterator() {
        return new ListItr(0);
    }

    /**
     *以正确的顺序返回该列表中的元素的迭代器。
     *返回的迭代器是fail-fast 。
     */
    public Iterator<E> iterator() {
        return new Itr();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><blockquote>
<p>为了方便复习先给出扩容源码分析的结论，然后再进行详细分析，分析流程是先把创建和扩容用到的属性和方法单独讲解，然后模拟一个场景来一步一步来 debug</p>
</blockquote>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li><p>1.ArrayList 中维护了一个 Object 类型的数组 elementData</p>
<ul>
<li>transient Object[] elementData; //transient表示瞬间,短暂的，表示该属性不会被序<br>列化</li>
</ul>
</li>
<li><p>2.创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0</p>
<ul>
<li>第 1 次添加，则扩容 elementData 为 10</li>
<li>如需再次扩容，则扩容 elementData 为 1.5 倍</li>
</ul>
</li>
<li>3.创建 ArrayList 对象时，如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小<ul>
<li>如果需要扩容，则直接扩容 elementData 为 1.5 倍</li>
</ul>
</li>
</ul>
<h5 id="属性-amp-方法"><a href="#属性-amp-方法" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h5><p>如下是 ArrayList 创建和扩容用到的主要属性和方法，这里先列出来，后面再详细讲解</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    // 默认初始的容量
    private static final int DEFAULT_CAPACITY = 10;
    // 一个空数组
    private static final Object[] EMPTY_ELEMENTDATA = {};
    // 一个空数组，如果使用无参构造函数创建，则使用该值
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    // 当前数据对象存放地方，当前对象不参与序列化
    transient Object[] elementData;
    // 当前数组所包含的元素个数
    private int size;
    // 数组最大长度
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    //protected transient int modCount = 0;
    // modCount属性从AbstractList继承过来的，代表ArrayList集合的修改次数。

      //如下是ArrayList创建和扩容主要方法，省略了方法体

    public ArrayList(int initialCapacity) {}

    public ArrayList() {}

    public ArrayList(Collection<? extends E> c) {}

    public boolean add(E e) {}

    public void ensureCapacity(int minCapacity) {}

    private static int calculateCapacity(Object[] elementData, int minCapacity) {}

    private void ensureCapacityInternal(int minCapacity) {}

    private void ensureExplicitCapacity(int minCapacity) {}

    private void grow(int minCapacity) {}

    private static int hugeCapacity(int minCapacity) {}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><h5 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public ArrayList() {
  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5 id="带int类型构造函数"><a href="#带int类型构造函数" class="headerlink" title="带int类型构造函数"></a>带int类型构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public ArrayList(int initialCapacity) {
  if (initialCapacity > 0) {//初始容量大于0
    //创建initialCapacity大小的数组
    this.elementData = new Object[initialCapacity];
  } else if (initialCapacity == 0) {//初始容量等于0
    //创建空数组
    this.elementData = EMPTY_ELEMENTDATA;
  } else {//初始容量小于0，抛出异常
    throw new IllegalArgumentException("Illegal Capacity: "+
                                       initialCapacity);
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="带Collection对象构造函数"><a href="#带Collection对象构造函数" class="headerlink" title="带Collection对象构造函数"></a>带Collection对象构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public ArrayList(Collection<? extends E> c) {
  Object[] a = c.toArray();
  if ((size = a.length) != 0) {
    if (c.getClass() == ArrayList.class) {
      elementData = a;
    } else {
      elementData = Arrays.copyOf(a, size, Object[].class);
    }
  } else {
    // replace with empty array.
    elementData = EMPTY_ELEMENTDATA;
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h5><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//将指定的元素追加到此列表的末尾
public boolean add(E e) {
  //添加元素之前，先调用ensureCapacityInternal方法
  ensureCapacityInternal(size + 1);  // Increments modCount!!
  //这里看到ArrayList添加元素的实质就相当于为数组赋值
  elementData[size++] = e;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal"></a>ensureCapacityInternal</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//得到最小扩容量
private void ensureCapacityInternal(int minCapacity) {
  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
    // 获取默认的容量和传入参数的较大值
    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
  }
  ensureExplicitCapacity(minCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</p>
<h5 id="ensureExplicitCapacity"><a href="#ensureExplicitCapacity" class="headerlink" title="ensureExplicitCapacity"></a>ensureExplicitCapacity</h5><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) {
  modCount++;
  // overflow-conscious code
  if (minCapacity - elementData.length > 0)
    //调用grow方法进行扩容，调用此方法代表已经开始扩容了
    grow(minCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<h5 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//要分配的最大数组大小
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

//ArrayList扩容的核心方法。
private void grow(int minCapacity) {
  // oldCapacity为旧容量，newCapacity为新容量
  int oldCapacity = elementData.length;
  //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
  //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
  int newCapacity = oldCapacity + (oldCapacity >> 1);
  //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
  if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
  // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
  //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。
  if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
  // minCapacity is usually close to size, so this is a win:
  elementData = Arrays.copyOf(elementData, newCapacity);//扩容
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>
<p> “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源</p>
<h5 id="hugeCapacity"><a href="#hugeCapacity" class="headerlink" title="hugeCapacity"></a>hugeCapacity</h5><p>如果新容量大于 MAX_ARRAY_SIZE，进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static int hugeCapacity(int minCapacity) {
  if (minCapacity < 0) // overflow
    throw new OutOfMemoryError();
  //对minCapacity和MAX_ARRAY_SIZE进行比较
  //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小
  //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小
  //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
  return (minCapacity > MAX_ARRAY_SIZE) ?Integer.MAX_VALUE :
  MAX_ARRAY_SIZE;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p>
<p><img src="https://img.jwt1399.top/img/202208232323066.jpg" alt="扩容流程"></p>
<h4 id="扩容场景模拟"><a href="#扩容场景模拟" class="headerlink" title="扩容场景模拟"></a>扩容场景模拟</h4><h5 id="案例1：无参构造函数"><a href="#案例1：无参构造函数" class="headerlink" title="案例1：无参构造函数"></a>案例1：无参构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//模拟代码
import java.util.ArrayList;
public class ArrayListSource {
    public static void main(String[] args) {
        //使用无参构造器创建ArrayList 对象
        ArrayList list = new ArrayList();

        //使用for 给list 集合添加1-10 数据
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
        //使用for 给list 集合添加11-15 数据
        for (int i = 11; i <= 15; i++) {
            list.add(i);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h6><p>执行<code>ArrayList list = new ArrayList();</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//该步骤底层代码
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
transient Object[] elementData;

public ArrayList() {
  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行时会调用无参数构造方法创建  ArrayList  ，实际上创建了一个名为<code>elementData</code> 的<code>Object[]</code> 空数组，也就是说该数组可以放任何对象</p>
<h6 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h6><p>执行 <code>for (int i = 1; i &lt;= 10; i++) &#123;list.add(i);&#125;</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//该步骤底层代码
private int size;// 当前数组所包含的元素个数
public boolean add(E e) {
  ensureCapacityInternal(size + 1);  
  elementData[size++] = e;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加元素之前，先调用 <code>ensureCapacityInternal</code> 方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//得到最小扩容量
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

//计算最小扩容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
     // 如果元素数组为默认的空
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // 获取“默认的容量”和“传入参数 minCapacity ”两者之间的最大值
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要 add 进第 1 个元素时，minCapacity 为 1，DEFAULT_CAPACITY 为 10，在 Math.max() 方法比较后，minCapacity 为 10，然后调用 <code>ensureExplicitCapacity</code> 方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;//记录修改次数
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要 add 进第 1 个元素时，<code>elementData.length = 0</code> （因为还是一个空的 list），因为上步骤执行了 ensureCapacityInternal()  方法 ，所以 <code>minCapacity = 10</code>。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以<strong>会执行</strong> <code>grow()</code> 方法。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//扩容方法
private void grow(int minCapacity) {
  // 取到旧数组的长度
  int oldCapacity = elementData.length;
  //计算新数组的长度
  //>>是移位运算符，相当于int newCapacity = oldCapacity + (oldCapacity/2)，但性能会好一些
  int newCapacity = oldCapacity + (oldCapacity >> 1);
  //保证长度在正常范围内
  if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
  if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
  // 用计算出来的数组长度,往下传继续处理
  elementData = Arrays.copyOf(elementData, newCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时 oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity =  10。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会执行 <code>hugeCapacity</code> 方法。然后调用 <code>Arrays.copyOf()</code> 方法进行扩容，数组扩容为 10，add 方法中 return true,size 增为 1。</p>
<ul>
<li><p>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length 在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以<code>不会执行 grow()</code> 方法。</p>
</li>
<li><p>添加第 3、4···到第 10 个元素时，依然<code>不会执行 grow()</code> 方法，数组容量都为 10。</p>
</li>
<li><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow () 方法进行扩容</p>
</li>
</ul>
<h6 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h6><p>执行 <code>for (int i = 11; i &lt;= 15; i++) &#123;list.add(i);&#125;</code></p>
<ul>
<li><p>当 add 第 11 个元素进入 grow() 方法时，newCapacity 为 15，比 minCapacity 为 11大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。扩容 elementData 为 1.5 倍，数组容量扩为 15，add 方法中 return true，size 增为 11。</p>
</li>
<li><p>以此类推······</p>
</li>
</ul>
<h5 id="案例2：有参构造函数"><a href="#案例2：有参构造函数" class="headerlink" title="案例2：有参构造函数"></a>案例2：有参构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.list_;
import java.util.ArrayList;

public class ArrayListSource {
    public static void main(String[] args) {
        //使用有参构造器创建ArrayList 对象
                ArrayList list = new ArrayList(8);

        //使用for 给list 集合添加1-10 数据
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
        //使用for 给list 集合添加11-15 数据
        for (int i = 11; i <= 15; i++) {
            list.add(i);
        }
        list.add(100);
        list.add(200);
        list.add(null);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有参构造与上面无参构造类似，区别在于第一步，有参构造是以传入的参数创建了一个名为<code>elementData</code> 的<code>Object[指定大小]</code> 空数组 ，如果需要扩容，也是调用无参构造相同的方法来进行扩容，第一次扩容就按照 elementData 的 1.5 倍扩容</p>
<h3 id="❷Vector"><a href="#❷Vector" class="headerlink" title="❷Vector"></a>❷Vector</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>Vector 底层也是一个对象数组</p>
<ul>
<li><code>protected Object[] elementData;</code></li>
</ul>
</li>
<li><p>Vector是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public synchronized boolean add(E e) {
  modCount++;
  ensureCapacityHelper(elementCount + 1);
  elementData[elementCount++] = e;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>需要线程同步安全是，考虑使用</p>
</li>
</ul>
<h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><ul>
<li>1、创建 Vector 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0<ul>
<li>第 1 次添加，则扩容 elementData 为 10</li>
<li>如需再次扩容，则扩容 elementData 为 2 倍</li>
</ul>
</li>
<li>2、创建 Vector 对象时，如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小<ul>
<li>如果需要扩容，则直接扩容 elementData 为 2倍</li>
</ul>
</li>
<li>3、创建 Vector 对象时，如果使用的是指定大小和增量的构造器(自定义扩容)，则初始 elementData 容量为指定大小<ul>
<li>如果需要扩容，则直接扩容原容量+容量增量</li>
</ul>
</li>
</ul>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Vector(int initialCapacity, int capacityIncrement) {
  super();
  if (initialCapacity < 0)
    throw new IllegalArgumentException("Illegal Capacity: "+
                                       initialCapacity);
  this.elementData = new Object[initialCapacity];
  this.capacityIncrement = capacityIncrement;
}

public Vector(int initialCapacity) {
  this(initialCapacity, 0);//0代表容量增量
}


public Vector() {
  this(10);
}

public Vector(Collection<? extends E> c) {
  Object[] a = c.toArray();
  elementCount = a.length;
  if (c.getClass() == ArrayList.class) {
    elementData = a;
  } else {
    elementData = Arrays.copyOf(a, elementCount, Object[].class);
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩容方法-1"><a href="#扩容方法-1" class="headerlink" title="扩容方法"></a>扩容方法</h4><h5 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public synchronized boolean add(E e) {
  modCount++;
  ensureCapacityHelper(elementCount + 1);
  elementData[elementCount++] = e;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="ensureCapacityHelper"><a href="#ensureCapacityHelper" class="headerlink" title="ensureCapacityHelper"></a>ensureCapacityHelper</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">private void ensureCapacityHelper(int minCapacity) {
  // overflow-conscious code
  if (minCapacity - elementData.length > 0)
    grow(minCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>判断最小容量是否超出 elementData 数组的长度，如果超出就调用 grow() 进行扩容</p>
<h5 id="grow-1"><a href="#grow-1" class="headerlink" title="grow"></a>grow</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">private void grow(int minCapacity) {
  // overflow-conscious code
  int oldCapacity = elementData.length;
  int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                   capacityIncrement : oldCapacity);
  if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
  if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
  elementData = Arrays.copyOf(elementData, newCapacity);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>capacityIncrement 未指定的话，新容量就为原容量的 2 倍</li>
<li>capacityIncrement 指定的话，新容量就为原容量+容量增量</li>
</ul>
<h5 id="Vector和ArrayList对比"><a href="#Vector和ArrayList对比" class="headerlink" title="Vector和ArrayList对比"></a>Vector和ArrayList对比</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程安全/效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>Jdk1.2</td>
<td>不安全、效率高</td>
<td>如果无参构造第一次10，第二次1.5倍；如果有参数构造按1.5倍扩</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>Jdk1.0</td>
<td>安全、效率不高</td>
<td>如果无参构造默认10，第二次2倍；如果有参数构造按2倍扩；如果指定增量按增量扩</td>
</tr>
</tbody>
</table>
</div>
<h3 id="❸LinkedList"><a href="#❸LinkedList" class="headerlink" title="❸LinkedList"></a>❸LinkedList</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p><img src="https://img.jwt1399.top/img/202208232322266.png" alt=""></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>LinkedList底层实现了双向链表和双端队列特点，和 Deque 接口</li>
<li>可以添加任意元素(元素可以重复)，包括 null</li>
<li>线程不安全，没有实现同步</li>
</ul>
<p>模拟一个简单的双向链表</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//定义一个Node 类，Node 对象表示双向链表的一个结点
class Node {
    public Object item; //真正存放数据
    public Node next; //指向后一个结点
    public Node pre; //指向前一个结点

    public Node(Object name) {
        this.item = name;
    }
    public String toString() {
        return "Node name=" + item;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用双向链表</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class LinkedList01 {
    public static void main(String[] args) {
        //模拟一个简单的双向链表
        Node jack = new Node("jack");
        Node tom = new Node("tom");
        Node jwt = new Node("jwt");
        //连接三个结点，形成双向链表
        //jack -> tom -> jwt
        jack.next = tom;
        tom.next = jwt;
        //jwt -> tom -> jack
        jwt.pre = tom;
        tom.pre = jack;
        Node first = jack; //让first 引用指向jack,就是双向链表的头结点
        Node last = jwt; //让last 引用指向jwt,就是双向链表的尾结点
        //从头到尾进行遍历
        System.out.println("===从头到尾进行遍历===");
        while (true) {
            if (first == null) {
                break;
            }
            //输出first 信息
            System.out.println(first);
            first = first.next;
        }
        //从尾到头的遍历
        System.out.println("===从尾到头的遍历===");
        while (true) {
            if (last == null) {
                break;
            }
            //输出last 信息
            System.out.println(last);
            last = last.pre;
        }
        //链表的添加对象/数据，是多么的方便
        //要求，是在tom--jwt之间，插入一个对象smith
        //1. 先创建一个Node 结点，name 就是smith
        Node smith = new Node("smith");
        //下面就把smith 加入到双向链表了
        smith.next = jwt;
        smith.pre = tom;
        jwt.pre = smith;
        tom.next = smith;
        //让first 再次指向jack
        first = jack;//让first 引用指向jack,就是双向链表的头结点
        System.out.println("===从头到尾进行遍历===");
        while (true) {
            if (first == null) {
                break;
            }
            //输出first 信息
            System.out.println(first);
            first = first.next;
        }
        last = jwt; //让last 重新指向最后一个结点
        //从尾到头的遍历
        System.out.println("===从尾到头的遍历===");
        while (true) {
            if (last == null) {
                break;
            }
            //输出last 信息
            System.out.println(last);
            last = last.pre;
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="增删改查使用"><a href="#增删改查使用" class="headerlink" title="增删改查使用"></a>增删改查使用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class LinkedListCRUD {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        linkedList.add(4);
        linkedList.add(4,5);
        System.out.println("linkedList=" + linkedList);
        //演示一个删除结点的
        linkedList.remove(); //默认删除的是第一个结点
        linkedList.remove(2);//删除索引为2的结点
        System.out.println("linkedList=" + linkedList);
        //修改某个结点对象
        linkedList.set(1, 999);
        System.out.println("linkedList=" + linkedList);
        //得到某个结点对象
        Object o = linkedList.get(1);//得到双向链表的第二个对象
        System.out.println(o);//999
        //因为LinkedList 是实现了List 接口, 遍历方式
        System.out.println("===LinkeList 遍历迭代器====");
        Iterator iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            Object next = iterator.next();
            System.out.println("next=" + next);
        }
        System.out.println("===LinkeList 遍历增强for====");
        for (Object o1 : linkedList) {
            System.out.println("o1=" + o1);
        }
        System.out.println("===LinkeList 遍历普通for====");
        for (int i = 0; i < linkedList.size(); i++) {
            System.out.println(linkedList.get(i));
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h4><ul>
<li><p>LinkedList 底层维护了一个双向链表</p>
</li>
<li><p>LinkedList 中维护了两个属性 first 和 last 分别指向首节点和尾节点</p>
</li>
<li>每个结点(Node对象)，里面又维护了 prev、 next、 item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点，最终实现双向链表。</li>
<li>LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</li>
</ul>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 元素个数
transient int size = 0;
// 链表头节点
transient Node<E> first;
// 链表尾节点
transient Node<E> last;

//链表节点结构
private static class Node<E> {
  //数据
  E item;
  // 前驱，后继指针
  Node<E> next;
  Node<E> prev;
  // 构造函数
  Node(Node<E> prev, E element, Node<E> next) {
    this.item = element;
    this.next = next;
    this.prev = prev;
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//无参构造
public LinkedList() {
}

//带Collection对象构造函数
public LinkedList(Collection<? extends E> c) {
  this();
  addAll(c);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="增加结点"><a href="#增加结点" class="headerlink" title="增加结点"></a>增加结点</h5><h6 id="增加单个结点"><a href="#增加单个结点" class="headerlink" title="增加单个结点"></a>增加单个结点</h6><pre class="line-numbers language-lang-java"><code class="language-lang-java">//默认增加
public boolean add(E e) {
  linkLast(e);//调用增加尾结点方法
  return true;
}

//根据索引增加
public void add(int index, E element) {
  //判断下标是否越界，越界就抛出异常
  checkPositionIndex(index);
  //如果增加位置是尾部index，和上面调用的同一个方法
  if (index == size)
    linkLast(element);
  else
    linkBefore(element, node(index));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="增加尾结点"><a href="#增加尾结点" class="headerlink" title="增加尾结点"></a>增加尾结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">void linkLast(E e) {
  //得到当前的最后一个元素节点
  final Node<E> l = last;
  //构造新节点，并设置当前上一个节点是l,元素为e,下一个节点为null
  final Node<E> newNode = new Node<>(l, e, null);
  //现在最新的last节点为新插入的节点
  last = newNode;
  //判断l节点是否为空，为空的话则代表当前插入的是第一个元素，则需要设置首节点也为当前的新节点，反之则设置原先的最后一个节点的next节点是当前新的节点
  if (l == null)
    first = newNode;
  else
    l.next = newNode;
  //元素数量+1    
  size++;
  //链表改动次数+1
  modCount++;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="增加头结点"><a href="#增加头结点" class="headerlink" title="增加头结点"></a>增加头结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">private void linkFirst(E e) {
    final Node<E> f = first;
    // 创建新节点，后继为原头节点
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    // 若之前链表为空，设置 last
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="增加中间结点"><a href="#增加中间结点" class="headerlink" title="增加中间结点"></a>增加中间结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">void linkBefore(E e, Node<E> succ) {
  // assert succ != null;
  //得到index下标节点的前一个
  final Node<E> pred = succ.prev;
  //构造新节点，新节点的前一个节点为原先这个index位置的前一个节点，设置新节点的下一个节点为原先index节点
  final Node<E> newNode = new Node<>(pred, e, succ);
  //设置原先index位置的节点的前一个为新节点
  succ.prev = newNode;
  //如果pred节点为null，则代表succ是头节点，现在设置头节点为新节点
  if (pred == null)
    first = newNode;
  else
    //如果pred节点不为null，则修改pred的下一个节点为新节点
    pred.next = newNode;
  //元素数量+1    
  size++;
  //链表修改次数+1
  modCount++;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean addAll(int index, Collection<? extends E> c) {
  //先判断下标是否越界，越界就抛出异常
  checkPositionIndex(index);
  //将拆入的元素集合转换为数组
  Object[] a = c.toArray();
  //得到数组的大小
  int numNew = a.length;
  if (numNew == 0)
    return false;
  //定义前一个节点，当前节点    
  Node<E> pred, succ;
  //拆入位置是size，即接着尾部拆入
  if (index == size) {
    //当前节点没有，前一个节点就是当前最后一个节点
    succ = null;
    pred = last;
  } else {
    //当前节点就是index位置的节点，前一个节点直接拿prev获取
    succ = node(index);
    pred = succ.prev;
  }
  //快速for处理待拆入元素的数组
  for (Object o : a) {
    //元素转换
    @SuppressWarnings("unchecked") E e = (E) o;
    //构建新节点的前一个是pred,元素为e，下一个节点为null
    Node<E> newNode = new Node<>(pred, e, null);
    //如果pred节点为null，则代表原先index位置的节点为头节点，则需要重新设置头节点
    if (pred == null)
      first = newNode;
    else
      //如果pred节点不为null，则设置原先index位置的节点的下一个节点为当前新节点
      pred.next = newNode;
    //一个新节点完成后，设置上一个为当前新节点，直到把所有元素拆入完成    
    pred = newNode;
  }
  //index位置的原先节点为null,则代表index原先的前一个节点就是最后一个节点，则设置最后一个节点就是最新最后的那个节点
  if (succ == null) {
    last = pred;
  } else {
    //index位置的原先节点不为null，则设置拆入数组的最后一个元素的最后一个节点的next是succ,succ的前一个是当前这个
    pred.next = succ;
    succ.prev = pred;
  }
  //得到新链表元素的数量
  size += numNew;
  //链表改动次数+1
  modCount++;
  return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="扩展的方法"><a href="#扩展的方法" class="headerlink" title="扩展的方法"></a>扩展的方法</h5><p>如下方法都是基于上面方法扩展出来的</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void addFirst(E e) {
    linkFirst(e);
}
public void addLast(E e) {
    linkLast(e);
}
public boolean offer(E e) {
    return add(e);
}
public boolean offerFirst(E e) {
    addFirst(e);
    return true;
}
public boolean offerLast(E e) {
    addLast(e);
    return true;
}
public void push(E e) {
    addFirst(e);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h5><h5 id="删除单个结点"><a href="#删除单个结点" class="headerlink" title="删除单个结点"></a>删除单个结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//默认删除
public E remove() {
  return removeFirst();//调用删除头结点的方法
}

//根据索引删除
public E remove(int index) {
  //下标都先判断下标是否越界，越界就抛出异常
  checkElementIndex(index);
  return unlink(node(index));//调用删除中间结点的方法
}

//找到需要删除的节点
Node<E> node(int index) {
  // assert isElementIndex(index);
  //二分查找的思想，判断一下是在链表的前半部分还是后半部分
  if (index < (size >> 1)) {
    //从头节点一直找到index位置拿到节点
    Node<E> x = first;
    for (int i = 0; i < index; i++)
      x = x.next;
    return x;
  } else {
    //从尾节点一直找到index位置拿到节点
    Node<E> x = last;
    for (int i = size - 1; i > index; i--)
      x = x.prev;
    return x;
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="删除头节点"><a href="#删除头节点" class="headerlink" title="删除头节点"></a>删除头节点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">private E unlinkFirst(Node<E> f) {
    // assert f == first && f != null;
    final E element = f.item;
    final Node<E> next = f.next;
    // 相应数据设为 null，从而之后GC清理
    f.item = null;
    f.next = null; // help GC
    first = next;
    // 就一个节点，删完了
    if (next == null)
        last = null;
    else
        next.prev = null;
    size--;
    modCount++;
    return element;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="删除尾节点"><a href="#删除尾节点" class="headerlink" title="删除尾节点"></a>删除尾节点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">private E unlinkLast(Node<E> l) {
    // assert l == last && l != null;
    final E element = l.item;
    final Node<E> prev = l.prev;
    // 相应数据设为 null，从而之后GC清理
    l.item = null;
    l.prev = null; // help GC
    last = prev;
    // 就一个节点，删完了
    if (prev == null)
        first = null;
    else
        prev.next = null;
    size--;
    modCount++;
    return element;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;
    // 为头节点，则设置新头节点
    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }
    // 为尾节点，则设置新尾节点
    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="扩展的方法-1"><a href="#扩展的方法-1" class="headerlink" title="扩展的方法"></a>扩展的方法</h5><p>和增加一样，删除也有很多扩展版本，不过基础还是上面三个方法。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public E removeFirst() {
    final Node<E> f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
}
public E removeLast() {
    final Node<E> l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}
public E pollFirst() {
    final Node<E> f = first;
    return (f == null) ? null : unlinkFirst(f);
}
public E pollLast() {
    final Node<E> l = last;
    return (l == null) ? null : unlinkLast(l);
}
public E pop() {
    return removeFirst();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="更新结点"><a href="#更新结点" class="headerlink" title="更新结点"></a>更新结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public E set(int index, E element) {
    // 下标合法性检查
    checkElementIndex(index);
    // 获取index下标节点
    Node<E> x = node(index);
    // 获取旧值
    E oldVal = x.item;
    // 设置新值
    x.item = element;
    // 返回旧值
    return oldVal;
}

// 采用二分法遍历每个Node节点，直到找到index位置的节点
Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}

// 采用二分法遍历每个Node节点，直到找到index位置的节点
Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低，数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高，链表追加</td>
<td>较低</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>如果我们改查的操作多，选择 ArrayList </li>
<li>如果我们增删的操作多，选择 LinkedList</li>
<li>一般来说，在程序中，80%-90% 都是查询，因此大部分情况下会选择 ArrayList</li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是 ArrayList，另外一个模块是 LinkedList，要根据业务来进行选择</li>
</ul>
<h2 id="②Collection子接口-Set"><a href="#②Collection子接口-Set" class="headerlink" title="②Collection子接口-Set"></a>②Collection子接口-Set</h2><h3 id="⓿Set用法"><a href="#⓿Set用法" class="headerlink" title="⓿Set用法"></a>⓿Set用法</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p>Set 接口是 Collection 接口的子接口</p>
<ul>
<li><strong>无序性</strong>：无序（添加和取出顺序不一致），取出的顺序的顺序虽然不是添加的顺序，但是每次取出顺序是固定的</li>
<li><strong>不重复性</strong>：不允许重复元素，因此最多只包含一个 null</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Set set = new HashSet();
set.add("jack");
set.add("lucy");
set.add("jack");//重复，添加不成功
set.add("jwt");
set.add(null);
set.add(null);//再次添加null，添加不成功
for(int i = 0; i <3;i ++) {
  System.out.println("set=" + set);
}

/*
set=[null, jwt, lucy, jack]
set=[null, jwt, lucy, jack]
set=[null, jwt, lucy, jack]
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>不能使用索引的方式来获取</p>
</li>
<li><p>Set 接口实现类常用的有：HashSet、LinkedHashSet、TreeSet</p>
</li>
</ul>
<h4 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>同 Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口。</p>
<ul>
<li>1.可以使用迭代器</li>
<li>2.增强 for</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class SetMethod {
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add("jack");
        set.add("lucy");
        set.add("jwt");
        set.add(null);

        System.out.println("=====使用迭代器====");
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("obj=" + obj);
        }
        set.remove(null);
        //方式2: 增强for
        System.out.println("=====增强for====");
        for (Object o : set) {
            System.out.println("o=" + o);
        }

    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❶HashSet"><a href="#❶HashSet" class="headerlink" title="❶HashSet"></a>❶HashSet</h3><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>HashSet 实现了 Set 接口</li>
<li>HashSet 底层实际上是 HashMap，HashMap 底层是数组 + 链表 + 红黑树</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public HashSet() {
    map = new HashMap<>();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>不重复性</strong>：HashSet 可以存放 null 值，但是只能有一个 null，不能有重复元素/对象，下面会详细分析</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">HashSet hashSet = new HashSet();
hashSet.add(null);
hashSet.add(null);//添加失败
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>无序性</strong>：HashSet 不保证元素是有序的(即，不保证存放元素的插入顺序和取出顺序一致)</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">HashSet<String> hashSet = new HashSet<>();
hashSet.add("深圳");
hashSet.add("北京");
hashSet.add("西安");
// 循环打印 HashSet 中的所有元素
hashSet.forEach(m -> System.out.println(m));

/*
西安
北京
深圳
*/
//HashSet 插入的顺序是：深圳 -> 北京 -> 西安，而循环打印的顺序却是：西安 -> 深圳 -> 北京，所以 HashSet 是无序的，不能保证插入和迭代的顺序一致。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="添加元素机制"><a href="#添加元素机制" class="headerlink" title="添加元素机制"></a>添加元素机制</h4><h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><ul>
<li>HashSet 底层是 HashMap，HashMap 底层是数组 + 链表 + 红黑树</li>
<li>添加一个元素时，先计算 hash 值，得出索引值，找到存储数据表 table，看这个索引位置是否已经存放元素，如果没有，直接加入；如果有，调用 equals 比较<ul>
<li>如果相同，就放弃添加；</li>
<li>如果不相同，则添加到最后，形成链表</li>
</ul>
</li>
<li>在 Java 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且 table 的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)</li>
</ul>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">//debug如下代码
import java.util.HashSet;
public class HashSetSource {
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();
        hashSet.add("java");//第一次
        hashSet.add("java");//第二次
        System.out.println("set=" + hashSet);
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="Step1-1"><a href="#Step1-1" class="headerlink" title="Step1"></a>Step1</h6><p>执行<code>HashSet hashSet = new HashSet();</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//该步骤底层代码
public HashSet() {
    map = new HashMap<>();
}

public HashMap() {
      this.loadFactor = DEFAULT_LOAD_FACTOR; 
}

//其他构造方法
//指定集合转化为HashSet, 完成map的创建
public HashSet(Collection<? extends E> c) {
   map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
   addAll(c);
}
//指定初始化大小，和负载因子
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap<>(initialCapacity, loadFactor);
}
//指定初始化大小
public HashSet(int initialCapacity) {
    map = new HashMap<>(initialCapacity);
}
//指定初始化大小和负载因子，dummy 无实际意义
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="Step2-1"><a href="#Step2-1" class="headerlink" title="Step2"></a>Step2</h6><p>执行<code>hashSet.add(&quot;java&quot;);</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//1、执行add()，调用put()
public boolean add(E e) {
        return map.put(e, PRESENT)==null;// hashmap 中 put() 返回 null 时，表示操作成功
}

// 虚拟对象
private static final Object PRESENT = new Object();
//HashSet是通过HashMap来保存元素，由于只需要在key中保存，所以采用虚拟对象PRESENT对应map中插入key-value的value值的引用。每次向map中添加元素时，键值对对应的value都是PRESENT。


//2、执行put()，调用hash()和putVal()
public V put(K key, V value) {
      return putVal(hash(key), key, value, false, true);
}

//3、执行hash()，调用hashCode()
static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);//并不是直接返回hash值，做了处理，为了避免hash碰撞
}//先计算key的hash值，再计算该hash值无符号右移16位的值，再将两者进行^按位异或

//4、执行hashCode()，计算key的hash值
public int hashCode() {
  int h = hash;
  if (h == 0 && value.length > 0) {
    char val[] = value;
    for (int i = 0; i < value.length; i++) {
      h = 31 * h + val[i];
    }
    hash = h;
  }
  return h;
}

//5.执行putVal()
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;//定义了辅助变量
    //table是HashMap的一个属性，存放结点的，类型是Node[]
    //这里就是第一次扩容，到16个空间.
    if ((tab = table) == null || (n = tab.length) == 0)
      //如果哈希表为空，调用resize(),创建一个哈希表，并用变量n记录哈希表长度
      n = (tab = resize()).length;//执行完resize(),tab大小为16

     //(1)根据key，得到hash 去计算该key 应该存放到table 表的哪个索引位置
    //并把这个位置的对象，赋给p
    //(2)判断p是否为null
    //(2.1) 如果p为null, 表示还没有存放元素, 就创建一个Node (key="java",value=PRESENT)
    //(2.2) 就放在该位置tab[i] = newNode(hash, key, value, null)
    if ((p = tab[i = (n - 1) & hash]) == null)
      tab[i] = newNode(hash, key, value, null);
      /*第一次add都不执行
    else {
      Node<K,V> e; K k;
      if (p.hash == hash &&
          ((k = p.key) == key || (key != null && key.equals(k))))
        e = p;
      else if (p instanceof TreeNode)//第一次add不进入
        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
      else {
        for (int binCount = 0; ; ++binCount) {
          if ((e = p.next) == null) {
            p.next = newNode(hash, key, value, null);
            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
              treeifyBin(tab, hash);
            break;
          }
          if (e.hash == hash &&
              ((k = e.key) == key || (key != null && key.equals(k))))
            break;
          p = e;
        }
      }
      if (e != null) { // existing mapping for key
        V oldValue = e.value;
        if (!onlyIfAbsent || oldValue == null)
          e.value = value;
        afterNodeAccess(e);
        return oldValue;
      }
    }*/
    ++modCount;
    if (++size > threshold)//每加入一个结点Node(k,v,h,next), size++
      resize();
    afterNodeInsertion(evict);//空方法，HashMap留给子类去实现
    return null;
}

//创建一个哈希表或者扩容哈希表
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;//默认容量
            //static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //默认值16
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//临界值
            //static final float DEFAULT_LOAD_FACTOR = 0.75f;//加载因子0.75
           //临界值=加载因子(0.75)*默认容量
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;//临界值
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建容量为16的节点数组
        table = newTab;//把建好的数组赋给table
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="Step3-1"><a href="#Step3-1" class="headerlink" title="Step3"></a>Step3</h6><p>执行<code>hashSet.add(&quot;java&quot;);//第二次</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
  Node<K,V>[] tab; Node<K,V> p; int n, i;
  /*第二次add不执行
  if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
  if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
  */
  else {
    Node<K,V> e; K k;
    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样
    //并且满足下面两个条件之一
    //1.准备加入的key和p指向的Node结点的key是同一个对象
    //2.p指向的Node结点的key的equals()和准备加入的key比较后相同
    //就不能加入
    if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
      e = p;
    //再判断p是不是一颗红黑树
    //如果是一颗红黑树，就调用putTreeVal，来进行添加
    else if (p instanceof TreeNode)
      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
    //如果table对应索引位置，已经是一个链表，就用for循环比较
    else {
      for (int binCount = 0; ; ++binCount) {
        //依次和该链表的每一个元素比较后，都不相同，则加入到该链表最后
        if ((e = p.next) == null) {
          p.next = newNode(hash, key, value, null);
          //注意在把元素添加到链表后，立即判断该链表是否已经达到8个结点 
          if (binCount >= TREEIFY_THRESHOLD - 1) // 8-1
            //就调用treeifyBin(),对当前这个链表进行树化(转成红黑树)
            treeifyBin(tab, hash);
            //注意，转成红黑树时，要进行判断，如果该table数组的大小>64,小于到话先扩容再转成红黑树
          break;
        }
        //依次和该链表的每个元素比较过程中，如果有相同情况,就直接break
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
          break;
        p = e;//p往后移
      }
    }
    if (e != null) { // existing mapping for key
      V oldValue = e.value;
      if (!onlyIfAbsent || oldValue == null)
        e.value = value;
      afterNodeAccess(e);
      return oldValue;
    }
  }
  ++modCount;
  if (++size > threshold)
    resize();
  afterNodeInsertion(evict);
  return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩容机制-2"><a href="#扩容机制-2" class="headerlink" title="扩容机制"></a>扩容机制</h4><h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><ul>
<li><p>HashSet 底层是 HashMap，第一次添加时，table 数组扩容到 16，临界值 threshold =  16 * loadFactor(加载因子:0.75) = 12</p>
<ul>
<li>如果 table 数组使用到了临界值 12，就会扩容到 16 <em> 2 = 32，新的临界值就是32</em>0.75 = 24，依次类推</li>
</ul>
</li>
<li><p>在 Java 8 中，如果一条链表的元素个数到达 TREEIFY_TH RESHOLD(默认是8)，<br>并且 table 的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制</p>
</li>
</ul>
<h5 id="扩容源码"><a href="#扩容源码" class="headerlink" title="扩容源码"></a>扩容源码</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">int threshold;//临界值，该数值决定什么时候开始下一次扩容
static final int MAXIMUM_CAPACITY = 1 << 30;//很大的数，基本不会碰上
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //16
static final float DEFAULT_LOAD_FACTOR = 0.75f;//负载因子，决定临界值大小

final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;//获得table大小
    int oldThr = threshold;//获得临界值，新数组则为0
    int newCap, newThr = 0;//新数组容量和临界值
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        //原数组大小大于16时，临界值设置为原来的两倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0)//意味着老数组没有元素
        //初始容量设置为临界值
        newCap = oldThr;
    else {
        //说明是调用无参构造器创建的旧数组，并且第一次添加元素
        newCap = DEFAULT_INITIAL_CAPACITY;//16
        //新临界值 = 负载因子 * 默认容量
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//0.75 * 16
    }

    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    //将新临界值赋值给 threshold
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})

    //new 一个新的 Node 数组
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    //原数组不为空，说明是扩容操作，则涉及到元素转移操作
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            //如果当前位置元素不为空，那么需要转移该元素到新数组
            if ((e = oldTab[j]) != null) {
                //置空 oldTab[j]，便于虚拟机回收
                oldTab[j] = null;
                //如果 e 的后结点为空，则计算 e 在 newTab 中的位置并置入
                if (e.next == null)
                    //如果这个oldTab[j]就一个元素，那么就直接放到newTab里面
                    // 把元素存储到新的数组中，存储到数组的哪个位置需要根据hash值和数组长度来进行取模
                    // 【hash值  %  数组长度】 = 【 hash值  & （数组长度-1）】
                    // 数组扩容后，所有元素都需要重新计算在新数组中的位置。
                    newTab[e.hash & (newCap - 1)] = e;
                //如果此时 e 已经转为红黑树结点
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // e 有后结点
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;

                        //重点难点！！！
                        //与运算 & 是 两个位都为1时，结果才为1
                        //(e.hash & oldCap) 得到的是 元素在数组中的位置是否需要移动
                        // 示例1：
                        // e.hash=10 0000 1010
                        // oldCap=16 0001 0000
                        //   &   =0  0000 0000       比较高位的第一位 0
                        //结论：元素位置在扩容后数组中的位置没有发生改变
                        // 示例2：
                        // e.hash=17 0001 0001
                        // oldCap=16 0001 0000
                        //   &   =1  0001 0000
                        //结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度

                        if ((e.hash & oldCap) == 0) {//扩容后不需要移动的链表
                            if (loTail == null) 
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {//扩容后需要移动的链表
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="HashSet-检查重复"><a href="#HashSet-检查重复" class="headerlink" title="HashSet 检查重复"></a>HashSet 检查重复</h4><p>我们只要了解了 HashSet 执行添加元素的流程，就能知道为什么 HashSet 能保证元素不重复了？</p>
<p>HashSet 添加元素的执行流程是：当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现，会将对象插入到相应的位置中。但是如果发现有相同 hashcode 值的对象，这时会调用对象的 equals() 方法来检查对象是否真的相同，如果相同，则 HashSet 就不会让重复的对象加入到 HashSet 中，这样就保证了元素的不重复。 </p>
<p><strong>总结</strong></p>
<p>HashSet 底层是由 HashMap 实现的，它可以实现重复元素的去重功能，如果存储的是自定义对象必须重写 hashCode 和 equals 方法。HashSet 保证元素不重复是利用 HashMap 的 put 方法实现的，在存储之前先根据 key 的 hashCode 和 equals 判断是否已存在，如果存在就不在重复插入了，这样就保证了元素的不重复。</p>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><h5 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.set_;

import java.util.HashSet;

public class HashSet01 {
    public static void main(String[] args) {
        HashSet set = new HashSet();
        //1. 在执行add 方法后，会返回一个boolean 值
        //2. 如果添加成功，返回true, 否则返回false
        System.out.println(set.add("john"));//T
        System.out.println(set.add("lucy"));//T
        System.out.println(set.add("john"));//F
        System.out.println(set.add("jack"));//T
        System.out.println(set.add("Rose"));//T
        //3. 可以通过remove 指定删除哪个对象
        set.remove("john");
        System.out.println("set=" + set);//3 个

        //4. Hashset 不能添加相同的元素/数据
        set.add("lucy");//添加成功
        set.add("lucy");//加入不了
        set.add(new Dog("tom"));//OK
        set.add(new Dog("tom"));//Ok
        System.out.println("set=" + set);

        set.add(new String("jwt"));//ok
        set.add(new String("jwt"));//加入不了
        System.out.println("set=" + set);
    }

}

class Dog { //定义了Dog 类
    private String name;
    public Dog(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h5><p>定义一个 Employee 类，该类包含: private成员属性name,age 要求:</p>
<ul>
<li>创建 3 个 Employee 对象放入 HashSet 中</li>
<li>当 name 和 age 的值相同时，认为是相同员工，不能添加到 HashSet 集合中</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.set_;

import java.util.HashSet;
import java.util.Objects;
public class HashSetExercise {
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee("milan", 18));//ok
        hashSet.add(new Employee("smith", 28));//ok
        hashSet.add(new Employee("milan", 18));//加入不成功.
        System.out.println("hashSet=" + hashSet);
    }
}

class Employee{
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "\nEmployee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    //如果name 和age 值相同，则返回相同的hash 值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age && Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h5><p>定义一个Employee02类，该类包含: private 成员属性name，sal，birthday(MyDate) 类<br>型)，其中 birthday 为 MyDate 类型(属性包括: year，month，day) 要求:</p>
<ol>
<li>创建 3 个 Employee02 对象放入 HashSet 中</li>
<li>当 name 和 birthday 的值相同时，认为是相同员工，不能添加到 HashSet 集合中</li>
</ol>
<p>要点：Employee02 类和 MyDate 类都要重写 equals 和 hashCode 方法，因为都是创建了新对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.set_;

import java.util.HashSet;
import java.util.Objects;

public class HashSetExercise02 {
    public static void main(String[] args) {
        HashSet<Employee02> hashSet = new HashSet<>();
        hashSet.add(new Employee02("tom",new MyDate(2000,7,1)));
        hashSet.add(new Employee02("jack",new MyDate(2001,9,1)));
        hashSet.add(new Employee02("tom",new MyDate(2000,7,1)));
        System.out.println("hashSet = " + hashSet);
    }

}

class Employee02{
    private String name;
    private  MyDate birthday;

    public Employee02(String name, MyDate birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return "\nEmployee02{" +
                "name='" + name + '\'' +
                ", birthday=" + birthday +
                '}';
    }
    //如果name 和birthday 值相同，则返回相同的hash 值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee02 that = (Employee02) o;
        return Objects.equals(name, that.name) && Objects.equals(birthday, that.birthday);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, birthday);
    }
}

class MyDate{
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year=" + year +
                ", month=" + month +
                ", day=" + day +
                '}';
    }
    //birthday 的year、month、day相同，则返回相同的hash 值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return year == myDate.year && month == myDate.month && day == myDate.day;
    }

    @Override
    public int hashCode() {
        return Objects.hash(year, month, day);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❷LinkedHashSet"><a href="#❷LinkedHashSet" class="headerlink" title="❷LinkedHashSet"></a>❷LinkedHashSet</h3><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>LinkedHashSet 是 HashSet 的子类</li>
<li>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个数组+双<br>向链表</li>
<li><strong>有序性</strong>：LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li>
<li><strong>不重复性</strong>：LinkedHashSet 不允许添重复元素</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202208232322187.png" alt=""></p>
<p>栗子🌰：Car类(属性:name,price),如果 name 和 price 一样，则认为是相同元素，就不能添加。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.set_;

import java.util.LinkedHashSet;
import java.util.Objects;

public class LinkedHashSetExercise {
    public static void main(String[] args) {
        LinkedHashSet linkedHashSet = new LinkedHashSet();
        linkedHashSet.add(new Car("奥拓", 1000));//OK
        linkedHashSet.add(new Car("奥迪", 300000));//OK
        linkedHashSet.add(new Car("法拉利", 10000000));//OK
        linkedHashSet.add(new Car("奥迪", 300000));//加入不了
        linkedHashSet.add(new Car("保时捷", 70000000));//OK
        linkedHashSet.add(new Car("奥迪", 300000));//加入不了
        System.out.println("linkedHashSet = " + linkedHashSet);
    }

}

class Car{
    private String name;
    private double price;

    public Car(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return "\nCar{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
    //重写equals方法和hashCode
    //当name 和price 相同时， 就返回相同的hashCode 值, equals 返回t
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Car car = (Car) o;
        return Double.compare(car.price, price) == 0 && Objects.equals(name, car.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, price);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❸TreeSet"><a href="#❸TreeSet" class="headerlink" title="❸TreeSet"></a>❸TreeSet</h3><ul>
<li><p>可以按照添加对象指定属性进行排序</p>
</li>
<li><p>向TreeSet中添加的数据，要求是相同类的对象</p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">TreeSet set = new TreeSet();
set.add(456);
set.add(123);
set.add("AA");//报错，此处向TreeSet中添加的必须是同一类的对象
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>两种排序方式：</p>
<ul>
<li>自然排序（实现Comparable接口）<ul>
<li>自然排序中，比较两个对象是否相等的标准为：compareTo()返回0，不再是equals()</li>
</ul>
</li>
<li>定制排序（comparator）<ul>
<li>定制排序中，比较两个对象是否相同的标准为：compare() 返回0，而不是equals()</li>
</ul>
</li>
</ul>
<p>TreeSet 中是通过红黑二叉树来实现对添加的数据进行去重排序，其中排序需要两种比较方式的重写来规定进行排序的类的属性。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TreeSet_ {
    public static void main(String[] args) {
          //默认从小到大排序
        TreeSet set = new TreeSet();
        set.add(34);
        set.add(-34);
        set.add(43);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TreeSet_ {
    public static void main(String[] args) {

        TreeSet set = new TreeSet();
        set.add(new Person("Tom", 12));
        set.add(new Person("Jerry", 32));
        set.add(new Person("Jim", 2));
        set.add(new Person("Mike", 65));
        set.add(new Person("Jack", 33));
        set.add(new Person("Jack", 56));

        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}


class Person implements Comparable{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Object o) {
        if (o instanceof Person) {
            Person p1 = (Person) o;
//            return Integer.compare(this.getAge(), p1.getAge());//按年龄从小到大
            return this.name.compareTo(p1.name);//按姓名从大到小
        } else {
            throw new RuntimeException("输入类型不一致");
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TreeSet_ {
    public static void main(String[] args) {

        TreeSet set = new TreeSet();

        //通过定制排序实现年龄从小到大的顺序
        Comparator com=new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Person && o2 instanceof Person) {
                    Person p1 = (Person) o1;
                    Person p2 = (Person) o2;
                    return Integer.compare(p1.getAge(), p2.getAge());
                } else {
                    throw new RuntimeException("输入类型不一致");
                }

            }
        };

        TreeSet set2 = new TreeSet(com);
        set2.add(new Person("Tom", 12));
        set2.add(new Person("Jerry", 32));
        set2.add(new Person("Jim", 2));
        set2.add(new Person("Mike", 65));
        set2.add(new Person("Jack", 33));

        Iterator iterator = set2.iterator();

        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}

class Person{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="二、Map-接口"><a href="#二、Map-接口" class="headerlink" title="二、Map 接口"></a>二、Map 接口</h1><h2 id="⓪Map用法"><a href="#⓪Map用法" class="headerlink" title="⓪Map用法"></a>⓪Map用法</h2><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><p>1) Map 用于保存具有映射关系的数据：Key-Value（双列元素）<br>2) Map 中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中<br>3) Map 中的 key 不允许重复，原因和 HashSet 一样，前面分析过源码，当当有相同的k，后添加的 value 会覆盖之前的，相当于替换</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Map map = new HashMap();
map.put("no1", "小明");//k-v
map.put("no1", "小红");//当有相同的k,就等价于替换
//输出:{no1=小红}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>Map 中的 value 可以重复</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">map.put("no1", "小明");
map.put("no2", "小明");
//输出:{no2=小明, no1=小明}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>Map 的 key 可以为 null, value 也可以为null <ol>
<li>但是 key 为 null，只能有一个</li>
<li>value 为 null 可以有多个</li>
<li>常用 String 类作为 Map 的 key</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">map.put(null, "abc"); //ok
map.put("no4", null); //ok
map.put(null, "abcd"); //会覆盖abc
map.put("no5", null);//ok
//输出：{null=abcd,, no4=null, no5=null}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>key 和 value 之间存在单向对一关系，即通过指定的 key 总能找到对应的 value</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">System.out.println(map.get("no1"));//小明
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol>
<li>Map 接口的常用实现类：HashMap、Hashtable、TreeMap、LinkedHashMap、Properties</li>
</ol>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>put() 添加映射关系</li>
<li>remove() 根据键删除映射关系</li>
<li>get() 根据键获取值</li>
<li>size() 获取元素个数</li>
<li>isEmpty() 判断个数是否为0</li>
<li>containsKey() 查找键是否存在</li>
<li>clear() 清除映射关系</li>
<li>getOrDefault(key, defaultValue) 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MapMethod {
    public static void main(String[] args) {
        Map map = new HashMap();
        //put:添加映射关系
        map.put("no1", "小明");//OK
        map.put("no2", "小红");//OK
        System.out.println("map=" + map);
        // remove:根据键删除映射关系
        map.remove("no2");
        System.out.println("map=" + map);
        // get：根据键获取值
        Object val = map.get("no1");
        System.out.println("val=" + val);
        // size:获取元素个数
        System.out.println("k-v=" + map.size());
        // isEmpty:判断个数是否为0
        System.out.println(map.isEmpty());//F
        // containsKey:查找键是否存在
        System.out.println("结果=" + map.containsKey("no1"));//T
        // clear:清除k-v
        map.clear();
        System.out.println("map = " + map);
    }
}

/*
map={no2=小红, no1=小明}
map={no1=小明}
val=小明
k-v=1
false
结果=true
map = {}
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="keySet-获取所有的键"><a href="#keySet-获取所有的键" class="headerlink" title="keySet:获取所有的键"></a>keySet:获取所有的键</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");
        //方法1: 先取出所有的Key , 通过Key 取出对应的Value
        Set keyset = map.keySet();
        //(1) 增强for
        System.out.println("-----第一种方式-------");
        for (Object key : keyset) {
            System.out.println(key + "-" + map.get(key));
        }
        //(2) 迭代器
        System.out.println("----第二种方式--------");
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + "-" + map.get(key));
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="values-获取所有的值"><a href="#values-获取所有的值" class="headerlink" title="values:获取所有的值"></a>values:获取所有的值</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //方法2: 把所有的values 取出
        Collection values = map.values();
        //这里可以使用所有的Collections 使用的遍历方法
        //(1) 增强for
        System.out.println("---取出所有的value 增强for----");
        for (Object value : values) {
            System.out.println(value);
        }
        //(2) 迭代器
        System.out.println("---取出所有的value 迭代器----");
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) {
            Object value = iterator2.next();
            System.out.println(value);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="entrySet-获取所有关系k-V"><a href="#entrySet-获取所有关系k-V" class="headerlink" title="entrySet:获取所有关系k-V"></a>entrySet:获取所有关系k-V</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //方法3: 通过EntrySet 来获取k-v
        Set entrySet = map.entrySet();// EntrySet<Map.Entry<K,V>>
        //(1) 增强for
        System.out.println("----使用EntrySet 的for 增强----");
        for (Object entry : entrySet) {
            //将entry 转成Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
        //(2) 迭代器
        System.out.println("----使用EntrySet 的迭代器----");
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) {
            Object entry = iterator3.next();
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p>使用 HashMap 添加 3 个员工对象，要求 键:员工id、值:员工对象，并遍历显示工资 &gt; 18000的员工(遍历方式最少两种)，员工类:姓名、工资、员工id</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MapExercise {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("1",new Employee("小明",20000,1));
        map.put("2",new Employee("小红",30000,2));
        map.put("3",new Employee("小刚",10000,3));

        //方法1 使用keySet -> 增强for
        Set set = map.keySet();
        for (Object key :set) {
            //先获取value
            Employee emp = (Employee) map.get(key);
            if (emp.getSal() > 18000){
                System.out.println("emp = " + emp);
            }
        }

        //方法2 使用EntrySet -> 迭代器
        Set set1 = map.entrySet();
        Iterator iterator = set1.iterator();
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            Employee emp = (Employee) entry.getValue();
            if (emp.getSal() > 18000){
                System.out.println("emp = " + emp);
            }
        }
    }
}

class Employee{
    private String name;
    private double sal;
    private int id;

    public Employee(String name, double sal, int id) {
        this.name = name;
        this.sal = sal;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public double getSal() {
        return sal;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", sal=" + sal +
                ", id=" + id +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="①HashMap"><a href="#①HashMap" class="headerlink" title="①HashMap"></a>①HashMap</h2><h3 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h3><ul>
<li>HashMap 是 Map 接口使用频率最高的实现类。</li>
<li>HashMap 是以 key-val  的方式来存储数据(HashMap$Node类型) </li>
<li>key不能重复，但是值可以重复，允许使用 null 键和 null 值。</li>
<li>如果添加相同的 key，则会覆盖原来的 key-val ，等同于修改（key不会替换，val 会替换）</li>
<li>与 HashSet 一样，不保证映射的顺序，因为底层是以 hash 表的方式来存储的（hashMap底层 数组+链表+红黑树)</li>
<li>HashMap 没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有 synchronized</li>
</ul>
<h3 id="底层机制及源码剖析"><a href="#底层机制及源码剖析" class="headerlink" title="底层机制及源码剖析"></a>底层机制及源码剖析</h3><ul>
<li>HashMap 底层维护了 Node 类型的数组 table，默认为 null</li>
<li>当创建对象时，将加载因子(loadfactor)初始化为 0.75</li>
<li>当添加 key-val 时通过 key 的哈希值得到在 table 的索引，然后判断该索引处是否有元素<ul>
<li>如果没有元素直接添加</li>
<li>如果该索引处有元素，判断该元素的 key 和准备加入的 key 是否相等<ul>
<li>如果相等，则直接替换 val</li>
<li>如果不相等需要判断是树结构还是链表结构，做出相应处理</li>
<li>如果添加时发现容量不够，则需要扩容。</li>
</ul>
</li>
</ul>
</li>
<li>第1次添加，则需要扩容 table 容量为 16，临界值(threshold)为12 (16*0.75)</li>
<li>以后再扩容，则需要扩容 table 容量为原来的 2 倍(32)，临界值为原来的 2倍，即24，依次类推</li>
<li>在 Java8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且 table 的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) </li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.map_;

import java.util.HashMap;

public class HashMapSource1 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("java", 10);//ok
        map.put("php", 10);//ok
        map.put("java", 20);//替换value
        System.out.println("map=" + map);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>执行构造器new HashMap()</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">初始化加载因子loadfactor = 0.75
HashMap$Node[] table = null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>执行put 调用 hash 方法</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//计算key 的hash 值(h = key.hashCode()) ^ (h >>> 16)
public V put(K key, V value) {//K = "java" value = 10
  return putVal(hash(key), key, value, false, true);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>执行putVal</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K, V>[] tab;Node<K, V> p;int n, i;//辅助变量
//如果底层的table 数组为null, 或者length =0 , 就扩容到16
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
//取出hash值对应table的索引位置的Node, 如果为null, 就直接加入k-v
    if ((p = tab[i = (n - 1) & hash]) == null)
        //创建成一个Node ,加入该位置即可
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K, V> e;K k;//辅助变量
// 如果table的索引位置的key的hash和新的key的hash值相同，
// 并满足(table现有的结点的key和准备添加的key是同一个对象||equals 返回真)
// 就认为不能加入新的k-v
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
//如果当前的table已有的Node是红黑树，就按照红黑树的方式处理
        else if (p instanceof TreeNode)
            e = ((TreeNode<K, V>) p).putTreeVal(this, tab, hash, key, value);
        else {
//如果找到的结点，后面是链表，就循环比较
            for (int binCount = 0; ; ++binCount) {//死循环
                if ((e = p.next) == null) {//如果整个链表，没有和他相同,就加到该链表的最后
                    p.next = newNode(hash, key, value, null);
//加入后，判断当前链表的个数，是否已经到8个，到8个后
//就调用treeifyBin 方法进行红黑树的转换
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash && //如果在循环比较过程中，发现有相同,就break,就只是替换value
                        ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value; //替换，key 对应value
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;//每增加一个Node ,就size++
    if (++size > threshold)//如size > 临界值，就扩容
        resize();
    afterNodeInsertion(evict);
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>关于树化(转成红黑树)</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//如果table为null ,或者大小还没有到64，暂时不树化，而是进行扩容.
//否则才会真正的树化-> 剪枝

final void treeifyBin(Node<K,V>[] tab, int hash) {
  int n, index; Node<K,V> e;
  if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
      resize();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="②Hashtable"><a href="#②Hashtable" class="headerlink" title="②Hashtable"></a>②Hashtable</h2><h3 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h3><ul>
<li>存放的元素是键值对：即 K-V</li>
<li>Hashtable 的键和值都不能为 null，否则会抛出 NullPointerException</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Hashtable table = new Hashtable();//ok
table.put( "john", 100); //ok
table.put(null, 100); //异常
table.put("john", null);//异常
table.put("john", 200);//替换
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>Hashtable 使用方法基本上和 HashMap 一样</li>
<li>Hashtable 是线程安全的 (synchronized)， HashMap 是线程不安全的</li>
</ul>
<h3 id="Hashtable和HashMap对比"><a href="#Hashtable和HashMap对比" class="headerlink" title="Hashtable和HashMap对比"></a>Hashtable和HashMap对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全(同步)</th>
<th>效率</th>
<th>允许null键null值</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>Hashtable</td>
<td>1.0</td>
<td>安全</td>
<td>较低</td>
<td>不可以</td>
</tr>
</tbody>
</table>
</div>
<h2 id="③Properties"><a href="#③Properties" class="headerlink" title="③Properties"></a>③Properties</h2><h3 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>Properties 类继承自 Hashtable 类并且实现了 Map 接口，也是使用一种键值对的形式来保存数据。</p>
</li>
<li><p>Properties 使用特点和 Hashtable 类似，key 和 value 不能为 null</p>
</li>
<li>Properties 还可以用于从 xxx.properties 文件中，加载数据到 Properties 类对象，并进行读取和修改</li>
<li>xxx.properties 文件通常作为配置文件，这个知识点在 IO 流会讲解</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.set_;

import java.util.Properties;
public class Properties_ {
    public static void main(String[] args) {
        //创建
        Properties properties = new Properties();
        //properties.put(null, "abc");//抛出空指针异常
        //properties.put("abc", null); //抛出空指针异常
        //增加
        properties.put("john", 100);//k-v
        properties.put("lucy", 100);
        properties.put("lic", 100);
        properties.put("lic", 88);//如果有相同的key，value被替换
        System.out.println("properties=" + properties);
        //通过k 获取对应值
        System.out.println(properties.get("lic"));//88
        //删除
        properties.remove("lic");
        System.out.println("properties=" + properties);
        //修改
        properties.put("john", "约翰");
        System.out.println("properties=" + properties);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="④TreeMap"><a href="#④TreeMap" class="headerlink" title="④TreeMap"></a>④TreeMap</h2><p>TreeMap 保证按照添加的 key-value 对进行排序，实现排序遍历。此时使用 key 的自然排序或定制排序。底层使用红黑树</p>
<h3 id="自然排序-1"><a href="#自然排序-1" class="headerlink" title="自然排序"></a>自然排序</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Student implements Comparable{

     ....

    @Override
    public int compareTo(Object o) {
        if (o instanceof Student) {
            Student s = (Student) o;
            int com = -this.name.compareTo(s.name);
            if (com != 0) {
                return com;
            } else {
                return Integer.compare(this.age, s.age);
            }
        }else
            throw new RuntimeException();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="定制排序-1"><a href="#定制排序-1" class="headerlink" title="定制排序"></a>定制排序</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">TreeMap map1 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Student && o2 instanceof Student) {
                    Student s1 = (Student) o1;
                    Student s2 = (Student) o2;
                    return Integer.compare(s1.getAge(), s2.getAge());
                } else {
                    throw new RuntimeException("类型不匹配");
                }
            }
        });
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="⑤LinkedHashMap"><a href="#⑤LinkedHashMap" class="headerlink" title="⑤LinkedHashMap"></a>⑤LinkedHashMap</h2><ul>
<li><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。</p>
</li>
<li><p>另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40050586/article/details/105851970?ops_request_misc=%7B%22request%5Fid%22%3A%22164138590416780265473460%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164138590416780265473460&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-105851970.pc_search_insert_es_download_v2&amp;utm_term=LinkHashMap&amp;spm=1018.2226.3001.4187">超详细LinkedHashMap解析</a></p>
<h2 id="⑥ConcurrentHashMap"><a href="#⑥ConcurrentHashMap" class="headerlink" title="⑥ConcurrentHashMap"></a>⑥ConcurrentHashMap</h2><p>线程安全的HashMap</p>
<h3 id="集合对比"><a href="#集合对比" class="headerlink" title="集合对比"></a>集合对比</h3><p>三种集合：</p>
<ul>
<li>HashMap 是线程不安全的，性能好</li>
<li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li>
<li>ConcurrentHashMap 保证了线程安全，综合性能较好</li>
</ul>
<p>集合对比：</p>
<ol>
<li>Hashtable 继承 Dictionary 类，HashMap、ConcurrentHashMap 继承 AbstractMap，均实现 Map 接口</li>
<li>Hashtable 底层是数组 + 链表，JDK8 以后 HashMap 和 ConcurrentHashMap 底层是数组 + 链表 + 红黑树</li>
<li>HashMap 线程不安全，Hashtable 线程安全，Hashtable 的方法都加了 synchronized 关来确保线程同步</li>
<li>ConcurrentHashMap、Hashtable <strong>不允许 null 值</strong>，HashMap 允许 null 值</li>
<li>ConcurrentHashMap、HashMap 的初始容量为 16，Hashtable 初始容量为11，填充因子默认都是 0.75，两种 Map 扩容是当前容量翻倍：capacity <em> 2，Hashtable 扩容时是容量翻倍 + 1：capacity</em>2 + 1</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202301062156037.png" alt="ConcurrentHashMap数据结构"></p>
<h3 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h3><ol>
<li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table</p>
</li>
<li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 链表节点数 &gt; 8 时，会将<strong>链表树化</strong>，树化过程会用 synchronized 锁住链表头</p>
<p>说明：锁住某个槽位的对象头，是一种很好的<strong>细粒度的加锁</strong>方式，类似 MySQL 中的行锁</p>
</li>
<li><p>put，如果该 节点 尚未创建，只需要使用 cas 创建 节点；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 节点 的尾部</p>
</li>
<li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 会让 get 操作在新 table 进行搜索</p>
</li>
<li><p>扩容，扩容时以 bin节点 为单位进行，需要对 bin节点 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin节点 进行扩容</p>
</li>
<li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中，最后统计数量时累加</p>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//需求：多个线程同时往HashMap容器中存入数据会出现安全问题
public class ConcurrentHashMapDemo{
    public static Map<String,String> map = new ConcurrentHashMap();

    public static void main(String[] args){
        new AddMapDataThread().start();
        new AddMapDataThread().start();

        Thread.sleep(1000 * 5);//休息5秒，确保两个线程执行完毕
        System.out.println("Map大小：" + map.size());//20万
    }
}

public class AddMapDataThread extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 1000000 ; i++ ){
            ConcurrentHashMapDemo.map.put("键："+i , "值"+i);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="三、Collections-工具类"><a href="#三、Collections-工具类" class="headerlink" title="三、Collections 工具类"></a>三、Collections 工具类</h1><h2 id="①简介"><a href="#①简介" class="headerlink" title="①简介"></a>①简介</h2><ul>
<li><p>Collections 是一个操作 Set、List 和Map 等集合的工具类</p>
</li>
<li><p>Collections 中提供了一系列静态的方法对集合元索进行排序、查询和修改等操作</p>
</li>
</ul>
<h2 id="②常用方法"><a href="#②常用方法" class="headerlink" title="②常用方法"></a>②常用方法</h2><ul>
<li>reverse(List): 反转 List 中元素的顺序</li>
<li>shuffle(List): 对List 集合元索进行随机排序</li>
<li>sort(List): 根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List, Comparator): 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List, int, int): 将指定 List 集合中的 i 处元素和 j 处元素进行交换</li>
<li>Object max(Collection): 根据元素的自然顺序，返回给定集合中的最大元素</li>
<li>Object max(Collection, Comparator): 根据Comparator 指定的顺序，返回给定集合中的最大元素<br>3) Object min(Collection)<br>4) Object min(Collection, Comparator)<br>5) int frequency(Collection, Object): 返回指定集合中指定元素的出现次数<br>6) void copy(List dest,List src): 将 src 中的内容复制到 dest 中</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换List对象的所有旧值</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.map_;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
public class Collections_ {
    public static void main(String[] args) {
        //创建ArrayList 集合，用于测试.
        List list = new ArrayList();
        list.add("tom");
        list.add("smith");
        list.add("king");
        list.add("milan");
        list.add("tom");
        System.out.println("自然顺序list=" + list);
        // reverse(List)：反转List 中元素的顺序
        Collections.reverse(list);
        System.out.println("反转list=" + list);

        // shuffle(List)：对List 集合元素进行随机排序
         for (int i = 0; i < 3; i++) {
         Collections.shuffle(list);
         System.out.println("随机排序list=" + list);
         }

        // sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序
        Collections.sort(list);
        System.out.println("自然排序后list=" + list);

        // sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序
        //我们希望按照字符串的长度大小排序
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        System.out.println("字符串长度大小排序=" + list);

        // swap(List，int， int)：将指定list 集合中的i 处元素和j 处元素进行交换
        Collections.swap(list, 0, 1);
        System.out.println("交换后的情况");
        System.out.println("list=" + list);


        //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
        System.out.println("自然顺序最大元素=" + Collections.max(list));

        //Object max(Collection，Comparator)：根据Comparator 指定的顺序，返回给定集合中的最大元素
        //比如，我们要返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String)o1).length() - ((String)o2).length();
            }
        });
        System.out.println("长度最大的元素=" + maxObject);

        //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
        System.out.println("tom 出现的次数=" + Collections.frequency(list, "tom"));

        //void copy(List dest,List src)：将src 中的内容复制到dest 中
        ArrayList dest = new ArrayList();
        //为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样
        for(int i = 0; i < list.size(); i++) {
            dest.add("");
        }
        //拷贝
        Collections.copy(dest, list);
        System.out.println("dest=" + dest);

        //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值
        //如果list 中，有tom 就替换成汤姆
        Collections.replaceAll(list, "tom", "汤姆");
        System.out.println("list 替换后=" + list);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="四、集合总结"><a href="#四、集合总结" class="headerlink" title="四、集合总结"></a>四、集合总结</h1><h2 id="①集合数据结构"><a href="#①集合数据结构" class="headerlink" title="①集合数据结构"></a>①集合数据结构</h2><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><div class="table-container">
<table>
<thead>
<tr>
<th>List</th>
<th>结构</th>
<th>图</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>Object数组</td>
<td><img src="https://img.jwt1399.top/img/interview-8-01.png" alt=""></td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td><img src="https://img.jwt1399.top/img/interview-9-03.png" alt=""></td>
</tr>
<tr>
<td>Vector</td>
<td>Object数组</td>
<td>同 ArrayList</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Map</th>
<th>结构</th>
<th>图</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>数组+链表+红黑树</td>
<td><img src="https://img.jwt1399.top/img/image-20220328194142473.png" alt=""></td>
</tr>
<tr>
<td>Hashtable</td>
<td>数组+链表</td>
<td><img src="https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDUwNTg2,size_16,color_FFFFFF,t_70-20220328201449674.png" alt=""></td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>数组+双向链表+红黑树</td>
<td><img src="https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDUwNTg2,size_16,color_FFFFFF,t_70.png" alt=""></td>
</tr>
<tr>
<td>TreeMap</td>
<td>红黑树</td>
<td><img src="https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyMDU0Mg==,size_16,color_FFFFFF,t_70.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><ul>
<li>HashSet：数组+链表+红黑树(同HashMap)</li>
<li>LinkedHashSet： 数组+双向链表+红黑树(同LinkedHashMap)</li>
<li>TreeSet：红黑树(同 TreeMap)</li>
</ul>
<h2 id="②集合选取"><a href="#②集合选取" class="headerlink" title="②集合选取"></a>②集合选取</h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下:</p>
<p>先判断存储的类型(一组对象[单列]或一组键值对[双列])</p>
<ol>
<li>一组对象[单列]: Collection 接口</li>
</ol>
<ul>
<li>允许重复: List<ul>
<li>增删多: LinkedList-线程不安全</li>
<li>改查多: ArrayList-线程不安全、Vector-线程安全</li>
</ul>
</li>
<li>不允许重复: Set<ul>
<li>无序: HashSet</li>
<li>排序: TreeSet</li>
<li>插入和取出顺序一致: LinkedHashSet </li>
</ul>
</li>
</ul>
<ol>
<li>一组键值对[双列]: Map 接口</li>
</ol>
<ul>
<li>键无序: HashMap-线程不安全 、Hashtable-线程安全</li>
<li>键排序: TreeMap</li>
<li>键插入和取出顺序一致: LinkedHashMap-线程不安全</li>
<li>读取文件: Properties</li>
</ul>
<p><img src="https://img.jwt1399.top/img/webp.png" alt=""></p>
<p>参考</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.codebaoku.com/it-java/it-java-233918.html">http://www.codebaoku.com/it-java/it-java-233918.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/oman001/article/details/104843676">Java集合框架图解_Zhou Jiang的博客-CSDN博客_java集合图解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28033239/article/details/98204664">java-集合框架底层数据结构总结_Devil_566的博客-CSDN博客_java集合底层数据结构</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://bugstack.cn/md/java/interview/2020-08-30-面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》.html">面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》 | bugstack 虫洞栈</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40050586/article/details/105720295?spm=1001.2014.3001.5502">HashTable详解_求offer的菜鸡的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40050586/article/details/105851970?ops_request_misc=%7B%22request%5Fid%22%3A%22164138590416780265473460%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164138590416780265473460&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-105851970.pc_search_insert_es_download_v2&amp;utm_term=LinkHashMap&amp;spm=1018.2226.3001.4187">超详细LinkedHashMap解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43820542/article/details/99626015">java集合包数据结构图解</a></li>
</ul>
<h1 id="五、本章练习"><a href="#五、本章练习" class="headerlink" title="五、本章练习"></a>五、本章练习</h1><h2 id="1-编程题Homework01-java"><a href="#1-编程题Homework01-java" class="headerlink" title="1.编程题Homework01.java"></a>1.编程题Homework01.java</h2><p>按要求实现:<br>(1)封装一个新闻类，包含标题和内容属性，提供get、 set方法，重写toString方法，打印对象时只打印标题:<br>(2)只提供一个带参数的构造器，实例化对象时，只初始化标题;并且实例化两个对象:</p>
<ul>
<li>新闻一:新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧</li>
<li>新闻二:男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生</li>
</ul>
<p>(3)将新闻对象添加到ArrayList集合中，并且进行倒序遍历;<br>(4)在遍历集合过程中，对新闻标题进行处理，超过15字的只保留前15个，然后在后边加“…”<br>(5)在控制台打印遍历出经过处理的新闻标题;</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.map_;

import java.util.ArrayList;
import java.util.Collections;

public class Homework01 {
    public static void main(String[] args) {
        News news1 = new News("新闻一:新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧");
        News news2 = new News("新闻二:男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生");
        ArrayList<News> arrayList = new ArrayList<>();
        arrayList.add(news1);
        arrayList.add(news2);

        //方法一：使用for循环倒序 + 处理title函数
        for (int i = arrayList.size()-1; i >= 0 ; i--) {
            News news = arrayList.get(i);
            System.out.println(processTitle(news.getTitle()));
        }

        //方法二：使用Collections工具类倒序 +if
        Collections.reverse(arrayList);//反转List 中元素的顺序
        for (News news :arrayList) {
            if (news.getTitle().length() > 15){
                char[] chars = news.getTitle().toCharArray();
                for (int i = 0; i < 15; i++) {
                    System.out.print(chars[i]);
                }
                System.out.println("...");
            }
        }

    }

    public static String processTitle(String title) {
        if (title.length() > 15) {
            return title.substring(0, 15) + "...";
        } else {
            return  title;
        }
    }

}


class News{
    private String title;
    private String content;

    public News(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return "News{" +
                "title='" + title + '\'' +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-编程题Homework02-java"><a href="#2-编程题Homework02-java" class="headerlink" title="2.编程题Homework02.java"></a>2.编程题Homework02.java</h2><p>使用 ArrayList 完成对对象 Car{name, price} 的各种操作</p>
<ul>
<li>1.add:添加单个元素</li>
<li>2.remove:删除指定元素</li>
<li>3.contains:查找元素是否存在</li>
<li>4.size:获取元素个数</li>
<li>5.isEmpty:判断是否为空</li>
<li>6.clear:清空</li>
<li>7.addAlI:添加多个元素</li>
<li>8.containsAll:查找多个元素是否都存在</li>
<li>9.使用增强for和迭代器来遍历所有的car ,需要重写Car的toString方法</li>
<li>10.removeAll: 删除多个元素</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.map_;

import java.util.ArrayList;
import java.util.Iterator;
public class Homework02 {
    public static void main(String[] args) {
        Car car = new Car("宝马",400000);
        Car car2 = new Car("宾利", 5000000);

        ArrayList<Car> arraylist = new ArrayList<>();
        //1.add:添加单个元素
        arraylist.add(car);
        arraylist.add(car2);
        System.out.println("arraylist = " + arraylist);
        //2.remove:删除指定元素
        arraylist.remove(car2);
        System.out.println("arraylist = " + arraylist);
        //3.contains:查找元素是否存在
        System.out.println(arraylist.contains(car));
        //4.size:获取元素个数
        System.out.println(arraylist.size());
        //5.isEmpty:判断是否为空
        System.out.println(arraylist.isEmpty());
        //6.clear:清空
        arraylist.clear();
        System.out.println("arraylist = " + arraylist);
        //7.addAlI:添加多个元素
        ArrayList<Car> arraylist2 = new ArrayList<>();
        arraylist2.add(car);
        arraylist2.add(car2);
        arraylist.addAll(arraylist2);
        System.out.println("arraylist = " + arraylist);
        //8.containsAll:查找多个元素是否都存在
        System.out.println(arraylist.containsAll(arraylist2));

        //9.使用增强for和迭代器来遍历所有的car ,需要重写Car的toString方法
        //增强for
        for (Object o :arraylist) {
            System.out.println("o = " + o);
        }
        //迭代器
        Iterator<Car> iterator = arraylist.iterator();
        while (iterator.hasNext()) {
            Car next = iterator.next();
            System.out.println("next = " + next);
        }

        //10.removeAll: 删除多个元素
        arraylist.removeAll(arraylist2);
        System.out.println("arraylist = " + arraylist);
    }

}

class Car{
    private String name;
    private double price;

    public Car(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-编程题Homework03-java"><a href="#3-编程题Homework03-java" class="headerlink" title="3.编程题Homework03.java"></a>3.编程题Homework03.java</h2><p>按要求完成下列任务<br>1)使用 HashMap 类实例化一个 Map 类型的对象 m,键(String) 和值(int) 分别用于存储员工的姓名和工资，存入数据如下: jack-650元; tom-1200元; smith-2900元;<br>2)将jack的工资更改为2600元<br>3)为所有员工工资加薪100元<br>4)遍历集合中所有的员工<br>5)遍历售合中所有的工资</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.jwt.map_;

import java.util.*;
public class Homework03 {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("jack",650);
        map.put("tom",1200);
        map.put("smith",2900);
        //将jack的工资更改为2600元
        map.put("jack",2600);
        System.out.println("map = " + map);
        //为所有员工工资加薪100元
        Set set = map.keySet();
        for (Object key :set) {
            map.put(key,(Integer)map.get(key)+100);
        }
        System.out.println("map = " + map);
        //遍历集合中所有的员工
        Set set1 = map.entrySet();
        Iterator iterator = set1.iterator();
        while (iterator.hasNext()) {
            Object next =  iterator.next();
            Map.Entry m = (Map.Entry) next;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
        //遍历售合中所有的工资
        Collection values = map.values();
        for (Object o :values) {
            System.out.println("工资 = " + o);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="4-简答题"><a href="#4-简答题" class="headerlink" title="4.简答题"></a>4.简答题</h2><p>试分析 HashSet 和 TreeSet 分别如何实现去重的？</p>
<ul>
<li>(1) HashSet 的去重机制: hashCode() + equals() ，底层先通过存入对象，进行运算得到一个 hash 值，通过 hash 值得到对应的索引，如果发现 table索引所在的位置，没有数据，就直接存放如果有数据，就进行 equals 比较[遍历比较]， 如果比较后，不相同，就加入，否则就不加入。</li>
<li>(2) TreeSet的去重机制：如果你传入了一个 Comparator 匿名对象，就使用实现的 compare 去重，如果方法返回 0，就认为是相同的元素/数据，就不添加；如果你没有传入一个 Comparator 匿名对象，则以你添加的对象实现的 Compareable 接口的 compareTo 去重。</li>
</ul>
<h2 id="5-代码分析题"><a href="#5-代码分析题" class="headerlink" title="5.代码分析题"></a>5.代码分析题</h2><p>下面代码运行会不会抛出异常，并从源码层面说明原因[考察读源码+接口编程+动态绑定]</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">TreeSet treeSet = new TreeSet();
treeSet.add(new Person());
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>会报转换异常(ClassCastException)，Person 类要实现 Compareable 才行</p>
<p>因为 TreeSet() 构造器没有传入 Comparator 接口的匿名内部类，所以在底层会执行 ComparabLe&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; 即把 Perosn 转成 Comparable 类型，所以 Person 类要实现 Compareable 才不报错</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person implements Comparable{

    ....

    @Override
    public int compareTo(Object o) {
      return 0；
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="6-代码分析题"><a href="#6-代码分析题" class="headerlink" title="6.代码分析题"></a>6.代码分析题</h2><p>已知: Person 类按照 id 和 name 重写了 hashCode 和 equals 方法，问下面代码输出什么?</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">HashSet set = new HashSet();//ok
Person p1 = new Person(1001,"AA");//ok
Person p2 = new Person(1002,"BB");//ok
set.add(p1);//ok
set.add(p2);//ok
p1.name = "CC";
set.remove(p1);//此处计算“1001-CC”的hash值，p1还存在“1001-AA”的hash值的位置，所以删除不成功
System.out.println(set); //2个对象
set.add(new Person(1001,"CC"));//计算“1001-CC”的hash，此处为空，可以添加
System.out.println(set); //3个对象 
set.add(new Person(1001," AA"));//计算“1001-AA”的hash，此处不为空，进行equals比较，p1已经变成“1001-CC”，不相同，会挂在p1后面，添加成功
System.out.println(set) //4个对象
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1810587?from=article.detail.1874923">送分题，ArrayList 的扩容机制了解吗？ - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1124770?from=article.detail.1874923">ArrayList源码解析(基于Java8)扩容删除 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1874923">ArrayList源码+扩容机制分析 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fighterandknight/article/details/61240861">ArrayList源码分析（基于JDK8）_Fighter168的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://hulunhao.com/2021/07/20/0defba1aec05404f1fa7b3f3956027b3/">ArrayList 从源码角度剖析底层原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7029148988473344014">LinkedList 源码解析 - 掘金 (juejin.cn)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7010260543504138254">LinkedList 源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40839718/article/details/123464047">IDEA调试debug时，stepinto 进不去方法和数据显示不完整的解决方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chiangchou/p/idea-debug.html">在Intellij IDEA中使用Debug - bojiangzhou - 博客园 (cnblogs.com)</a></li>
</ul>
<h1 id="❤️Sponsor"><a href="#❤️Sponsor" class="headerlink" title="❤️Sponsor"></a>❤️Sponsor</h1><p>您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰</p>
<table>
  <tbody>
     <tr>
         <td style="text-align:center;">支付宝支付</td>
         <td style="text-align:center;">微信支付</td>
     </tr>
   <tr>
    <td style="text-align:center;" ><img width="200" src="https://jwt1399.top/medias/reward/alipay.png"></td>    
      <td style="text-align:center;"><img width="200" src="https://jwt1399.top/medias/reward/sponor_wechat.png"></td>     
  </tr>
</tbody></table>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top" rel="external nofollow noreferrer">简简</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top/posts/6773.html">https://jwt1399.top/posts/6773.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jwt1399.top" target="_blank">简简</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9B%86%E5%90%88/">
                                    <span class="chip bg-color">集合</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,linkedin,facebook,twitter,google,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">打</a>
	<a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>
    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        /*max-width: 100%;*/
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    .v[data-class=v] .vinput {
     padding: 0px 0px;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论<center>填上邮箱会收到评论回复提醒哦!!!</center></span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/valine/1.4.18/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Awf92dhT3VWqTfENqbCDoqbA-gzGzoHsz',
        appKey: '9uN7ODvigK9GAp8CYBz0fOrX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: '',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '[填上邮箱，会给你发送评论提醒]，ヾﾉ≧∀≦)o 请畅所欲言~',
        enableQQ: true,
        boolean: true,
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/35196.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top/img/v2-027434c9abbed55ab3181e13e0b03cb2_1440w.jpg" class="responsive-img" alt="数据结构：布隆/布谷鸟">
                        
                        <span class="card-title">数据结构：布隆/布谷鸟</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            布隆过滤器原理论文名称：《Space/time trade-offs in hash coding with allowable errors》(在允许错误的哈希编码中，空间/时间的权衡)  ——该篇论文是布隆过滤器的开山之作

作者：Bu
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" class="post-category">
                                    结构-算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/33453.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top/img/1584764210@3316edd99d795f35cd23a28f7173fd82-20220318110115983.jpg" class="responsive-img" alt="Java-常用类">
                        
                        <span class="card-title">Java-常用类</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前言哈喽！大家好，我是小简。今天开始学习《Java-常用类》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 Java-学习路线，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaSE/" class="post-category">
                                    JavaSE
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/">
                        <span class="chip bg-color">常用类</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 简言之<br />'
            + '文章作者: 简简<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://jwt1399.top" target="_blank">简简</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;|

			<!-- <span>为♥️️发电</span> -->
            <a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img no-lazy src="https://img.jwt1399.top/img/20200824181422.png" style="width: 47px; vertical-align: middle;" ></a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">712.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "7";
                    var startDate = "2";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            <a href="https://search.google.com/search-console?resource_id=http%3A%2F%2Fjwt1399.top%2F" target="_blank"
                rel="nofollow noopener">谷歌统计</a>&nbsp;|
            
            <span id="icp"><img no-lazy src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://www.beian.miit.gov.cn/" target="_blank">蜀ICP备19020450号</a>
            </span>
            |
            
            <a href="https://tongji.baidu.com/web/10000159136/overview/index?siteId=14519996" target="_blank"
                rel="nofollow noopener">百度统计</a>

        </div>
        <div class="col s12 m4 l4 social-link social-statis">

    <a href="https://jwt1399.top/baidusitemap.xml" class="tooltipped" target="_blank" data-tooltip="访问我的sitemap" data-position="top" data-delay="50">
        <i class="fas fa-sitemap"></i>
    </a>


    <a href="https://pl.jwt1399.top" class="tooltipped" target="_blank" data-tooltip="valine评论: https://pl.jwt1399.top" data-position="top" data-delay="50">
        <i class="fab fa-optin-monster"></i>
    </a>


    <a href="mailto:1019084218@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope"></i>
    </a>













    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1019084218" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1019084218" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.json", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.staticfile.org/aos/3.0.0-beta.6/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
	<!--valine_人机验证-->
	<button id="TencentCaptcha"data-appid="2046265119"data-cbfn="callback"type="button" hidden></button>
	
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-160042502-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-160042502-1');
</script>


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0e306ce3426983ae6367d094d39f1190";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

        
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>

</html>
