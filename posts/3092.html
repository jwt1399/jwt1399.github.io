<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java-JUC, 简简,简简博客,网络安全,计算机,Java开发">
    <meta name="description" content="JUC是java.util.concurrent包的简称，在Java5添加，目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html;charset=gb2312" />
    <meta name="sogou_site_verification" content="VTcD33rrfd" />
    <meta name="google-site-verification" content="mHsYpjV9Rl0e0UzjioJFLg8RMtOhxw8HB3D21dIWvmc" />
	<meta name="referrer" content="unsafe-url">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Java-JUC | 简言之</title>
    <link rel="icon" type="image/png" href="/favicon.png">
	<!--变灰-->
	<!-- <link href="http://static.isenyu.cn/file/css/MemorialDay.css"; rel="stylesheet" type="text/css" /> -->
    <!-- <style type="text/css">
     html{ filter: grayscale(100%); /* 标准写法 just for IE6-9 */ 
        -webkit-filter: grayscale(100%); /* webkit 内核支持程度较好 */ 
        -moz-filter: grayscale(100%); /* 其他内核现在并不支持，为了将来兼容性书写 */ 
        -ms-filter: grayscale(100%); 
        -o-filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);
        filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); /* Firefox 3.5+ */ }
     </style> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/aos/0.1.0/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js"></script>
	<!--valine_人机验证-->
	<script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
	<script src="/js/Valine-RJyanzheng.js"></script>

    
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="简言之" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img no-lazy src="/medias/logo.png" class="logo-img" alt="">
                    
                    <span class="logo-span">简言之</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Home</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-user-secret" style="zoom: 0.6;"></i>
      
      <span>Sec</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Web/">
          
          <i class="fab fa-internet-explorer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Web</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/CTF/">
          
          <i class="fas fa-flag" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CTF</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Crypto/">
          
          <i class="fa-solid fa-shield" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Data</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fab fa-java" style="zoom: 0.6;"></i>
      
      <span>Java</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/JavaSE/">
          
          <i class="fa-solid fa-mug-saucer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaSE</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/JavaWeb/">
          
          <i class="fa-solid fa-earth-americas" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaWeb</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Spring/">
          
          <i class="fa-solid fa-leaf" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Spring</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Q-A/">
          
          <i class="fa-solid fa-bell" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Q&A</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-desktop" style="zoom: 0.6;"></i>
      
      <span>CS</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/CS%E5%9F%BA%E7%A1%80/">
          
          <i class="fa-solid fa-server" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CS基础</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/SQL/">
          
          <i class="fas fa-database" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>数据库</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">
          
          <i class="fa-solid fa-bezier-curve" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>结构-算法</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-layer-group" style="zoom: 0.6;"></i>
      
      <span>Others</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Python/">
          
          <i class="fab fa-python" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Python</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Course/">
          
          <i class="fa-solid fa-graduation-cap" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Course</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Share/">
          
          <i class="fa-solid fa-crown" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Share~</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Tools/">
          
          <i class="fas fa-tools" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Tools~</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>整理</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/tags/">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归类</span>
        </a>
      </li>
      
      <li>
        <a href="/archives/">
          
          <i class="fas fa-file-contract" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归档</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-paper-plane" style="zoom: 0.6;"></i>
      
      <span>交流</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/friends/">
          
          <i class="fas fa-venus-mars" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>友链</span>
        </a>
      </li>
      
      <li>
        <a href="/artitalk/">
          
          <i class="fa-solid fa-message" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>说说</span>
        </a>
      </li>
      
      <li>
        <a href="/contact/">
          
          <i class="fas fa-envelope" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>留言</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-id-card-alt" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img no-lazy src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">简言之</div>
        <div class="logo-desc">
            
            悄无声息地变坚强，安静地变优秀！
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Home
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-secret"></i>
			
			Sec
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Web/ " style="margin-left:50px";>
				  
				   <i class="fab fa-internet-explorer" style="position: absolute;left:28px" ></i>
			      
		          <span>Web</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/CTF/ " style="margin-left:50px";>
				  
				   <i class="fas fa-flag" style="position: absolute;left:28px" ></i>
			      
		          <span>CTF</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Crypto/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-shield" style="position: absolute;left:28px" ></i>
			      
		          <span>Data</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fab fa-java"></i>
			
			Java
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/JavaSE/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-mug-saucer" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaSE</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/JavaWeb/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-earth-americas" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaWeb</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Spring/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-leaf" style="position: absolute;left:28px" ></i>
			      
		          <span>Spring</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Q-A/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bell" style="position: absolute;left:28px" ></i>
			      
		          <span>Q&A</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-desktop"></i>
			
			CS
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/CS%E5%9F%BA%E7%A1%80/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-server" style="position: absolute;left:28px" ></i>
			      
		          <span>CS基础</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/SQL/ " style="margin-left:50px";>
				  
				   <i class="fas fa-database" style="position: absolute;left:28px" ></i>
			      
		          <span>数据库</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bezier-curve" style="position: absolute;left:28px" ></i>
			      
		          <span>结构-算法</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-layer-group"></i>
			
			Others
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Python/ " style="margin-left:50px";>
				  
				   <i class="fab fa-python" style="position: absolute;left:28px" ></i>
			      
		          <span>Python</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Course/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-graduation-cap" style="position: absolute;left:28px" ></i>
			      
		          <span>Course</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Share/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-crown" style="position: absolute;left:28px" ></i>
			      
		          <span>Share~</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Tools/ " style="margin-left:50px";>
				  
				   <i class="fas fa-tools" style="position: absolute;left:28px" ></i>
			      
		          <span>Tools~</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			整理
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/tags/ " style="margin-left:50px";>
				  
				   <i class="fas fa-bookmark" style="position: absolute;left:28px" ></i>
			      
		          <span>归类</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/archives/ " style="margin-left:50px";>
				  
				   <i class="fas fa-file-contract" style="position: absolute;left:28px" ></i>
			      
		          <span>归档</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-paper-plane"></i>
			
			交流
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/friends/ " style="margin-left:50px";>
				  
				   <i class="fas fa-venus-mars" style="position: absolute;left:28px" ></i>
			      
		          <span>友链</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/artitalk/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-message" style="position: absolute;left:28px" ></i>
			      
		          <span>说说</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact/ " style="margin-left:50px";>
				  
				   <i class="fas fa-envelope" style="position: absolute;left:28px" ></i>
			      
		          <span>留言</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-id-card-alt"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('猜猜密码是什么呢ヾﾉ≧∀≦)o')).toString(CryptoJS.enc.Hex)) {
                alert('哎呦！密码好像不对哟，将返回主页！');
                location.href = '/';	
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://img.jwt1399.top/img/202212062044543.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java-JUC</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    /*.toc-widget {
        width: 345px;
        padding-left: 20px;
    }*/
    .toc-widget {
        width: 345px;
        padding-left: 20px;
        /* 毛玻璃 */
        /*background-color: rgba(162,101,228, 0.08);*/
        /*backdrop-filter: saturate(180%) blur(20px);*/
        /*目录样式修改*/
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }
    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JUC/">
                                <span class="chip bg-color">JUC</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaSE/" class="post-category">
                                JavaSE
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-12-06
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-04-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    45.2k
                </div>
                

                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="⓪基础"><a href="#⓪基础" class="headerlink" title="⓪基础"></a>⓪基础</h1><h2 id="❶进程-amp-线程"><a href="#❶进程-amp-线程" class="headerlink" title="❶进程&amp;线程"></a>❶进程&amp;线程</h2><ul>
<li>进程：指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。</li>
<li>线程：比进程更小的执行单位，一个进程可以启动多个线程，每条线程并行执行不同的任务。</li>
</ul>
<h2 id="❷并行-amp-并发"><a href="#❷并行-amp-并发" class="headerlink" title="❷并行&amp;并发"></a>❷并行&amp;并发</h2><ul>
<li>并行（Parallel）：在同一时刻，有多个指令在多个 CPU 上同时执行。</li>
<li>并发（Concurrent）：在同一时刻，有多个指令在单个 CPU 上交替执行。微观串行，宏观并行</li>
</ul>
<h2 id="❸同步-amp-异步"><a href="#❸同步-amp-异步" class="headerlink" title="❸同步&amp;异步"></a>❸同步&amp;异步</h2><ul>
<li>同步（sync）：需要等待结果返回，才能继续运行</li>
<li>异步（Async）：不需要等待结果返回，就能继续运行</li>
</ul>
<h1 id="①线程"><a href="#①线程" class="headerlink" title="①线程"></a>①线程</h1><h2 id="❶线程创建"><a href="#❶线程创建" class="headerlink" title="❶线程创建"></a>❶线程创建</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Slf4j
public class ThreadCreate {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("hello");
            }
        };
        // 启动线程
        t1.start();
        log.debug("do other things ...");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Slf4j
public class ThreadCreate {
    public static void main(String[] args) {
        Runnable task2 = new Runnable() {
            @Override
            public void run(){
                log.debug("hello");
            }
        };
        Thread t2 = new Thread(task2, "t2");
        // 启动线程
        t2.start();
        log.debug("do other things ...");  
    }
}

//写法2
Thread t4 = new Thread(new Runnable() {
    @Override
    public void run() {
        log.debug("hello");
    }
    },"t4");
t4.start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Java 8 以后可以使用 lambda 精简代码</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Runnable task2 = () -> log.debug("hello");
Thread t4 = new Thread(task2, "t4");
t4.start();


//写法2
Thread t4 = new Thread(() ->log.debug("hello"),"t4");
t4.start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">@Slf4j
public class ThreadCreate {
    public static void main(String[] args) {
        FutureTask<Integer> task3 = new FutureTask<>(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    log.debug("hello");
                    return 100;
                }
            });
        Thread t5 = new Thread(task3, "t5");
        t5.start();

        // 主线程阻塞，同步等待 task 执行完毕的结果
        // 获取call方法返回的结果（正常/异常结果）
        Integer result = task3.get(); 
        log.debug("结果是:{}", result);
    }
}



//简写
FutureTask<Integer> task3 = new FutureTask<>(() -> {
  log.debug("hello");
  return 100;
});
Thread t5 = new Thread(task3, "t5");
t5.start();

// 主线程阻塞，同步等待 task 执行完毕的结果
// 获取call方法返回的结果（正常/异常结果）
Integer result = task3.get();
log.debug("结果是:{}", result);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❷线程方法"><a href="#❷线程方法" class="headerlink" title="❷线程方法"></a>❷线程方法</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void start()</td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td>public void run()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字<br />线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前线程对象</td>
</tr>
<tr>
<td>public static void sleep(long time)</td>
<td>让当前线程休眠多少毫秒再继续执行<br /><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td>public static native void yield()</td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>public final void setPriority(int priority)</td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td>public final void join()</td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td>public final void join(long millis)</td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td>public final native boolean isAlive()</td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="run-amp-start"><a href="#run-amp-start" class="headerlink" title="run &amp; start"></a>run &amp; start</h3><ul>
<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">@Slf4j(topic = "test")
public class RunAndStart {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("测试！！！");
        }, "t1");
        t1.run();
        log.debug("do other things ...");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">16:09:05.495 [main] DEBUG test - 测试！！！
16:09:05.496 [main] DEBUG test - do other things ...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">@Slf4j(topic = "test")
public class RunAndStart {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("测试！！！");
        }, "t1");
        t1.start();
        log.debug("do other things ...");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">16:10:24.051 [main] DEBUG test - do other things ...
16:10:24.051 [t1] DEBUG test - 测试！！！
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="sleep-amp-yield"><a href="#sleep-amp-yield" class="headerlink" title="sleep &amp; yield"></a>sleep &amp; yield</h3><p>sleep：</p>
<ul>
<li><p>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p>
</li>
<li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p>
</li>
<li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p>
</li>
<li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">TimeUnit.SECONDS.sleep(10);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>yield：</p>
<ul>
<li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
<li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>等待这个线程结束</p>
</blockquote>
<p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final synchronized void join(long millis) throws InterruptedException {
    // 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束
    while (isAlive()) {
        wait(0);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p>
</li>
<li><p>当调用某个线程的 join 方法后，该线程抢占到 CPU 资源，就不再释放，直到线程执行完毕</p>
</li>
</ul>
<p>线程同步：</p>
<ul>
<li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul>
<li>需要外部共享变量，不符合面向对象封装的思想</li>
<li>必须等待线程结束，不能配合线程池使用</li>
</ul>
</li>
<li>Future 实现同步：get() 方法阻塞等待执行结果<ul>
<li>main 线程接收结果</li>
<li>get 方法是让调用线程同步等待</li>
</ul>
</li>
</ul>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><h4 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h4><p><code>interrupt()</code>：打断当前线程，异常处理机制</p>
<p><code>interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong></p>
<p><code>isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p>
<ul>
<li>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(()->{
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "t1");
    t1.start();
    Thread.sleep(500);
    t1.interrupt();
    System.out.println(" 打断状态: " + t1.isInterrupted());// 打断状态: false
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>打断正常运行的线程：不会清空打断状态（true）</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws Exception {
    Thread t2 = new Thread(()->{
        while(true) {
            Thread current = Thread.currentThread();
            boolean interrupted = current.isInterrupted();
            if(interrupted) {
                System.out.println(" 打断状态: " + interrupted);//打断状态: true
                break;
            }
        }
    }, "t2");
    t2.start();
    Thread.sleep(500);
    t2.interrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws Exception {
    Thread t1 = new Thread(() -> {
        System.out.println("park...");
        LockSupport.park();
        System.out.println("unpark...");
        System.out.println("打断状态：" + Thread.currentThread().isInterrupted());//打断状态：true
    }, "t1");
    t1.start();
    Thread.sleep(2000);
    t1.interrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果打断标记已经是 true, 则 park 会失效</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">LockSupport.park();
System.out.println("unpark...");
LockSupport.park();//失效，不会阻塞
System.out.println("unpark...");//和上一个unpark同时执行
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p>
<h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：Two Phase Termination</p>
<p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p>
<p>错误思想：</p>
<ul>
<li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
<li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
<p>两阶段终止模式图示：</p>
<p><img src="https://img.jwt1399.top/img/202212282140792.png" style="zoom: 67%;" /></p>
<p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();
        tpt.start();
        Thread.sleep(3500);
        tpt.stop();
    }
}
class TwoPhaseTermination {
    private Thread monitor;
    // 启动监控线程
    public void start() {
        monitor = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    Thread thread = Thread.currentThread();
                    if (thread.isInterrupted()) {
                        System.out.println("后置处理");
                        break;
                    }
                    try {
                        Thread.sleep(1000);                    // 睡眠
                        System.out.println("执行监控记录");    // 在此被打断不会异常
                    } catch (InterruptedException e) {        // 在睡眠期间被打断，进入异常处理的逻辑
                        e.printStackTrace();
                        // 重新设置打断标记，打断 sleep 会清除打断状态
                        thread.interrupt();
                    }
                }
            }
        });
        monitor.start();
    }
    // 停止监控线程
    public void stop() {
        monitor.interrupt();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">Thread t = new Thread() {
    @Override
    public void run() {
        System.out.println("running");
    }
};
// 设置该线程为守护线程
t.setDaemon(true);
t.start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用户线程：平常创建的普通线程</p>
<p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。</p>
<p>常见的守护线程：</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="❸线程原理"><a href="#❸线程原理" class="headerlink" title="❸线程原理"></a>❸线程原理</h2><p>Java 虚拟机栈（Java Virtual Machine Stacks）：每个线程启动后，虚拟机就会为其分配一块栈内存</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park 等方法</li>
</ul>
<p>程序计数器（Program Counter Register）：记录正在执行的字节码指令地址，是线程私有的</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<h2 id="❹线程状态"><a href="#❹线程状态" class="headerlink" title="❹线程状态"></a>❹线程状态</h2><p>操作系统进程的状态（5种）：创建态（new）、就绪态（ready）、运行态（running）、阻塞态（waiting）、终止态（terminated）</p>
<p><img src="https://img.jwt1399.top/img/202211251026928.png" alt=""></p>
<p>在 Java API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td>
</tr>
<tr>
<td>Timed Waiting （限期等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td>
</tr>
<tr>
<td>Teminated（结束）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody>
</table>
</div>
<h2 id="❺线程状态转换"><a href="#❺线程状态转换" class="headerlink" title="❺线程状态转换"></a>❺线程状态转换</h2><p><img src="https://img.jwt1399.top/img/202212191915210.png"  /></p>
<p>①NEW → RUNNABLE：</p>
<ul>
<li>当调用 <code>t.start()</code> 方法时，t 线程从 NEW → RUNNABLE</li>
</ul>
<p>②RUNNABLE <strong>⇆</strong>  WAITING</p>
<p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p>
<ul>
<li><p>调用 <code>obj.wait()</code> 方法时，t 线程从 RUNNABLE → WAITING</p>
</li>
<li><p>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时</p>
<ul>
<li><p>竞争锁成功，t 线程从 WAITING → RUNNABLE</p>
</li>
<li><p>竞争锁失败，t 线程从 WAITING → BLOCKED</p>
</li>
</ul>
</li>
</ul>
<p>③RUNNABLE <strong>⇆</strong>  WAITING</p>
<ul>
<li>当前线程调用 <code>t.join()</code> 方法时，当前线程从 RUNNABLE → WAITING <ul>
<li>注意是当前线程在 t 线程对象的监视器上等待</li>
</ul>
</li>
<li>t 线程运行结束或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING → RUNNABLE</li>
</ul>
<p>④RUNNABLE <strong>⇆</strong>  WAITING</p>
<ul>
<li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 RUNNABLE → WAITING</li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 WAITING →RUNNABLE</li>
</ul>
<p>⑤RUNNABLE <strong>⇆</strong> TIMED_WAITING</p>
<p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 RUNNABLE → TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING → RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING → BLOCKED</li>
</ul>
</li>
</ul>
<p>⑥RUNNABLE <strong>⇆</strong>  TIMED_WAITING</p>
<ul>
<li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 RUNNABLE → TIMED_WAITING<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了 n 毫秒或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从TIMED_WAITING → RUNNABLE</li>
</ul>
<p>⑦RUNNABLE <strong>⇆</strong> TIMED_WAITING</p>
<ul>
<li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 RUNNABLE → TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING → RUNNABLE</li>
</ul>
<p>⑧RUNNABLE <strong>⇆</strong>  TIMED_WAITING</p>
<ul>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线程从 RUNNABLE → TIMED_WAITING</li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从TIMED_WAITING → RUNNABLE</li>
</ul>
<p>⑨RUNNABLE <strong>⇆</strong>  BLOCKED</p>
<ul>
<li><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时，如果竞争失败，从 RUNNABLE → BLOCKED</p>
</li>
<li><p>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争</p>
<ul>
<li>如果其中 t 线程竞争成功，从 BLOCKED → RUNNABLE </li>
<li>其它失败的线程仍然 BLOCKED</li>
</ul>
</li>
</ul>
<p>⑩RUNNABLE <strong>⇆</strong>  TERMINATED</p>
<ul>
<li>当前线程所有代码运行完毕，进入 TERMINATED</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212281939521.png" alt="线程状态转移图"></p>
<p><strong>总结</strong></p>
<ul>
<li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p>
</li>
<li><p>RUNNABLE ⇆ WAITING：</p>
<ul>
<li><p>调用 obj.wait() 方法时，t 线程从 RUNNABLE → WAITING</p>
</li>
<li><p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p>
</li>
<li><p>竞争锁成功，线程从 WAITING → RUNNABLE</p>
<ul>
<li>竞争锁失败，线程从 WAITING → BLOCKED</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法，当前线程从 RUNNABLE → WAITING </p>
</li>
<li><p>当前线程调用 LockSupport.park() 方法，当前线程从 RUNNABLE → WAITING</p>
</li>
</ul>
</li>
<li><p>RUNNABLE ⇆ TIMED_WAITING：调用 obj.wait(long n) 方法、调用 t.join(long n) 方法、调用 Thread.sleep(long n)</p>
</li>
<li><p>RUNNABLE ⇆ BLOCKED：线程用 synchronized(obj) 获取了对象锁时竞争失败</p>
</li>
</ul>
<h2 id="❻线程查看命令"><a href="#❻线程查看命令" class="headerlink" title="❻线程查看命令"></a>❻线程查看命令</h2><p>windows</p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill</code> 杀死进程</li>
</ul>
<p>linux</p>
<ul>
<li><p><code>ps -ef</code> 查看所有进程</p>
</li>
<li><p><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</p>
</li>
<li><p><code>kill</code> 杀死进程</p>
</li>
<li><p><code>top</code> 按大写 H 切换是否显示线程</p>
</li>
<li><p><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</p>
</li>
</ul>
<p>Java</p>
<ul>
<li><p><code>jps</code> 命令查看所有 Java 进程</p>
</li>
<li><p><code>jstack &lt;PID&gt;</code> 查看某个 Java 进程（PID）的所有线程状态</p>
</li>
<li><p><code>jconsole</code> 查看某个 Java 进程中线程的运行情况（图形界面）</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># jconsole 远程监控配置
java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 java类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="②同步"><a href="#②同步" class="headerlink" title="②同步"></a>②同步</h1><h2 id="❶临界区-Critical-Section"><a href="#❶临界区-Critical-Section" class="headerlink" title="❶临界区-Critical Section"></a>❶临界区-Critical Section</h2><p>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static int counter = 0;
static void increment()
// 临界区
{
counter++;
}
static void decrement()
// 临界区
{
counter--;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❷竞态条件-Race-Condition"><a href="#❷竞态条件-Race-Condition" class="headerlink" title="❷竞态条件-Race Condition"></a>❷竞态条件-Race Condition</h2><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p>
<p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p>
<ul>
<li>阻塞式的解决方案：synchronized，lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h2 id="❸synchronized"><a href="#❸synchronized" class="headerlink" title="❸synchronized"></a>❸synchronized</h2><h3 id="锁使用"><a href="#锁使用" class="headerlink" title="锁使用"></a>锁使用</h3><blockquote>
<p>synchronized 是可重入、不公平的重量级锁</p>
</blockquote>
<p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">synchronized(锁对象){
    // 访问共享资源的核心代码
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实例：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class demo {
    static int counter = 0;
    //static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个
    static final Object obj = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (obj) {
                    counter++;
                }
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (obj) {
                    counter--;
                }
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(counter);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>解决线程安全问题的核心方法是使用锁，每次只能一个线程进入访问</p>
<p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的</p>
<p>如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p>
<p>用法：直接给方法加上一个修饰符 synchronized</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//同步方法
修饰符 synchronized 返回值类型 方法名(方法参数) { 
    方法体；
}
//同步静态方法
修饰符 static synchronized 返回值类型 方法名(方法参数) { 
    方法体；
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public synchronized void test() {} 

//等价于
public void test() {
    synchronized(this) {}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Test{
    public synchronized static void test() {}
}

//等价于
class Test{
    public void test() {
        synchronized(Test.class) {}
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h4><blockquote>
<p>线程八锁就是考察 synchronized 锁住的是哪个对象</p>
</blockquote>
<p>说明：主要关注锁住的对象是不是同一个</p>
<ul>
<li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li>
<li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li>
</ul>
<p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象和线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Number{
    public static synchronized void a(){
                Thread.sleep(1000);
        System.out.println("1");
    }
    public synchronized void b() {
        System.out.println("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Number{
    public static synchronized void a(){
                Thread.sleep(1000);
        System.out.println("1");
    }
    public static synchronized void b() {
        System.out.println("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h3><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor 被翻译为监视器或管程：每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 <code>Mark Word</code> 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p>
<p><code>Mark Word</code>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志（最后两位）、线程持有的锁、偏向线程ID、偏向时间戳等等。最后两位是<strong>锁标志位</strong></p>
<p>32 位虚拟机 Mark Word</p>
<pre class="line-numbers language-lang-ruby"><code class="language-lang-ruby">|-------------------------------------------------------|--------------------|
|                    Mark Word (32 bits)                |        State       |
|-------------------------------------------------------|--------------------|
|              hashcode:25 | age:4 | biased_lock:0 | 01 |        Normal      |
|-------------------------------------------------------|--------------------|
|      thread:23 | epoch:2 | age:4 | biased_lock:1 | 01 |        Biased      |
|-------------------------------------------------------|--------------------|
|                            ptr_to_lock_record:30 | 00 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|                    ptr_to_heavyweight_monitor:30 | 10 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                                  | 11 |    Marked for GC   |
|-------------------------------------------------------|--------------------|
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>64 位虚拟机 Mark Word</p>
<pre class="line-numbers language-lang-ruby"><code class="language-lang-ruby">|--------------------------------------------------------------------|--------------------|
|                      Mark Word (64 bits)                           |       State        |
|--------------------------------------------------------------------|--------------------|
|    unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 |       Normal       |
|--------------------------------------------------------------------|--------------------|
|        thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 |       Biased       |
|--------------------------------------------------------------------|--------------------|
|                                         ptr_to_lock_record:62 | 00 | Lightweight Locked |
|--------------------------------------------------------------------|--------------------|
|                                 ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked |
|--------------------------------------------------------------------|--------------------|
|                                                               | 11 |    Marked for GC   |
|--------------------------------------------------------------------|--------------------|
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>工作流程：</p>
<ul>
<li>开始时 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 <code>synchronized(obj)</code> 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<br><img src="../images/Java-JUC/JUC-Monitor工作原理1.png" style="zoom:67%;" /></li>
<li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 <code>synchronized(obj)</code>，就会进入 EntryList BLOCKED（双向链表）</li>
<li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li>
<li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li>
<li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271732344.png" alt=""></p>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    Object lock = new Object();
    synchronized (lock) {
        System.out.println("ok");
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">0:     new                #2        // new Object
3:     dup
4:     invokespecial     #1         // invokespecial <init>:()V，非虚方法
7:     astore_1                 // lock引用 -> lock
8:     aload_1                    // lock （synchronized开始）
9:     dup                        // 一份用来初始化，一份用来引用
10: astore_2                 // lock引用 -> slot 2
11: monitorenter             // 【将 lock对象 MarkWord 置为 Monitor 指针】
12: getstatic         #3        // System.out
15: ldc             #4        // "ok"
17: invokevirtual     #5         // invokevirtual println:(Ljava/lang/String;)V
20: aload_2                 // slot 2(lock引用)
21: monitorexit             // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】
22: goto 30
25: astore_3                 // any -> slot 3
26: aload_2                 // slot 2(lock引用)
27: monitorexit             // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】
28: aload_3
29: athrow
30: return
Exception table:
    from to target type
      12 22 25         any
      25 28 25         any
LineNumberTable: ...
LocalVariableTable:
    Start Length Slot Name Signature
        0     31         0 args [Ljava/lang/String;
        8     23         1 lock Ljava/lang/Object;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明：</p>
<ul>
<li>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</li>
<li>方法级别的 synchronized 不会在字节码指令中有所体现</li>
</ul>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><h4 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h4><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁    // 随着竞争的增加，只能锁升级，不能降级
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202212271733295.png" alt=""></p>
<p><img src="https://img.jwt1399.top/img/202212301531550.png" alt=""></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p>
<ul>
<li>当锁对象第一次被线程获得的时候进入偏向状态，标记为 <code>101</code>，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</li>
<li>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</li>
</ul>
<p><img src="../images/Java-JUC/image-20221227173941506.png" alt=""></p>
<pre class="line-numbers language-lang-ruby"><code class="language-lang-ruby">biased_lock: 偏向锁是否开启 默认开启，即为1
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个对象创建时：</p>
<ul>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</li>
<li>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li>
</ul>
<p><strong>偏向锁</strong>只在第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。<strong>轻量级锁</strong>在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p><strong>撤销偏向锁的状态</strong>：</p>
<ul>
<li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li>
<li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li>
<li>调用 wait/notify，需要申请 Monitor，进入 WaitSet</li>
</ul>
<p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<ul>
<li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p>
</li>
<li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p>
<p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p>
<p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p>
<p>CAS机制：Compare And Swap，表示比较并交换</p>
<p>锁重入实例：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}
public static void method2() {
    synchronized( obj ) {
        // 同步块 B
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>1.创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 <code>Mark Word</code>（Hashcode，Age，Bias 01（无锁））</p>
<p><img src="https://img.jwt1399.top/img/202212271752214.png" alt=""></p>
<p>2.让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word（loack record 地址 00（轻量级锁）），将 Mark Word 的值存入锁记录</p>
<p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁</p>
<p><img src="https://img.jwt1399.top/img/202212271856546.png" alt=""></p>
<p>如果 CAS 失败，有两种情况：</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入<strong>锁膨胀过程</strong></li>
<li>如果是线程自己执行了 synchronized 锁重入，就再添加一条 Lock Record 作为重入的计数，存储null</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271858706.png" alt=""></p>
<p>3.当退出 synchronized 代码块（解锁时）</p>
<ul>
<li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li>
<li>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong><ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀-重量级锁"><a href="#锁膨胀-重量级锁" class="headerlink" title="锁膨胀/重量级锁"></a>锁膨胀/重量级锁</h4><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271903673.png" alt=""></p>
<ul>
<li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271903923.png" alt=""></p>
<ul>
<li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p>
<ul>
<li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li>
<li>自旋失败的线程会进入阻塞状态</li>
</ul>
<p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p>
<p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p>
<p>自旋锁情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>自旋成功的情况</th>
<th>自旋失败的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img.jwt1399.top/img/202212271918731.png" style="zoom: 80%;" /></td>
<td><img src="https://img.jwt1399.top/img/202212271918251.png" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>自旋锁说明：</p>
<ul>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li>
<li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p>
<p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p>
<p><strong>同步消除 (Synchronization Elimination)</strong>：线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的<strong>同步锁</strong>，通过 <code>-XX:+EliminateLocks</code> 可以开启同步消除 ( - 号关闭)</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyBenchmark {
    static int x = 0;
    public void a() throws Exception {
        x++;
    }

      public void b() throws Exception {
      Object o = new Object();
      synchronized (o) {
          x++;
      }
      }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>a方法和b方法执行效率差不多，应为b方法中o对象不会逃逸出线程，不被其它线程访问到，那o对象的读写就不会存在竞争，则可以消除对o对象的<strong>同步锁</strong>，效果就跟a方法一样</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p>
<p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<ul>
<li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p>
<h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>将锁的粒度细分：</p>
<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 </li>
</ul>
<p>解决方法：准备多个对象锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    BigRoom bigRoom = new BigRoom();
    new Thread(() -> { bigRoom.study(); }).start();
    new Thread(() -> { bigRoom.sleep(); }).start();
}
class BigRoom {
    private final Object studyRoom = new Object();
    private final Object sleepRoom = new Object();

    public void sleep() throws InterruptedException {
        synchronized (sleepRoom) {
            System.out.println("sleeping 2 小时");
            Thread.sleep(2000);
        }
    }

    public void study() throws InterruptedException {
        synchronized (studyRoom) {
            System.out.println("study 1 小时");
            Thread.sleep(1000);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁形成"><a href="#死锁形成" class="headerlink" title="死锁形成"></a>死锁形成</h4><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p>
<p>Java 死锁产生的四个必要条件：</p>
<ol>
<li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li>
<li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li>
<li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li>
<li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li>
</ol>
<p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p>
<p>死锁代码：</p>
<p>一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<ul>
<li><p>t1 线程 获得 A对象 锁，接下来想获取 B对象的锁</p>
</li>
<li><p>t2 线程 获得 B对象 锁，接下来想获取 A对象的锁 </p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Dead {
    public static Object resources1 = new Object();
    public static Object resources2 = new Object();

    public static void main(String[] args)  {
        new Thread(() -> {
            // 线程1：占用资源1 ，请求资源2
            synchronized(resources1) {
                System.out.println("线程1已经占用了资源1，开始请求资源2");
                try {
                    sleep(2000);//保证线程2先获得资源2
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                //2秒内线程2肯定可以锁住资源2
                synchronized (resources2) {
                    System.out.println("线程1已经占用了资源2");
                }
            }
            },"t1").start();

            new Thread(() -> {
                // 线程2：占用资源2 ，请求资源1
                synchronized(resources2){
                    System.out.println("线程2已经占用了资源2，开始请求资源1");
                    try {
                        sleep(2000);//保证线程1先获得资源1
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    synchronized (resources1){
                        System.out.println("线程2已经占用了资源1");
                    }
                }
        },"t2").start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="死锁定位"><a href="#死锁定位" class="headerlink" title="死锁定位"></a>死锁定位</h4><p>定位死锁的方法：</p>
<ul>
<li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p>
<pre class="line-numbers language-lang-sh"><code class="language-lang-sh">Found one Java-level deadlock:
=============================
"t2":
  waiting to lock monitor 0x0000000126019ac0 (object 0x000000076ac25d88, a java.lang.Object),
  which is held by "t1"
"t1":
  waiting to lock monitor 0x000000012601c400 (object 0x000000076ac25d98, a java.lang.Object),
  which is held by "t2"

Java stack information for the threads listed above:
===================================================
"t2":
        at JJTest.Dead.lambda$main$1(Dead.java:43)
        - waiting to lock <0x000000076ac25d88> (a java.lang.Object)
        - locked <0x000000076ac25d98> (a java.lang.Object)
        at JJTest.Dead$$Lambda$2/1096979270.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)
"t1":
        at JJTest.Dead.lambda$main$0(Dead.java:28)
        - waiting to lock <0x000000076ac25d98> (a java.lang.Object)
        - locked <0x000000076ac25d88> (a java.lang.Object)
        at JJTest.Dead$$Lambda$1/2003749087.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 <code>jstack &lt;pid&gt;</code>的输出来看各个线程栈</p>
</li>
<li><p>可以使用可视化工具 jconsole 、Visual VM</p>
</li>
<li><p>避免死锁：避免死锁要注意加锁顺序</p>
</li>
</ul>
<h4 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h4><p>解决该问题最简单的方式就是两个线程按顺序获取资源，线程1和线程2都先获取资源1再获取资源2，无论哪个线程先获取到资源1，另一个线程都会因无法获取线程1产生阻塞，等到先获取到资源1的线程释放资源1，另一个线程获取资源1，这样两个线程可以轮流获取资源1和资源2。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Dead {
    public static Object resources1 = new Object();
    public static Object resources2 = new Object();

    public static void main(String[] args)  {
        new Thread(() -> {
            // 线程1：先请求资源1 ，再请求资源2
            synchronized(resources1) {
                System.out.println("线程1已经占用了资源1，开始请求资源2");
                try {
                    sleep(2000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (resources2) {
                    System.out.println("线程1已经占用了资源2");
                }
            }
            },"t1").start();

            new Thread(() -> {
                // 线程2：先请求资源1 ，再请求资源2
                synchronized(resources1){
                    System.out.println("线程2已经占用了资源2，开始请求资源1");
                    try {
                        sleep(2000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    synchronized (resources2){
                        System.out.println("线程2已经占用了资源1");
                    }
                }
        },"t2").start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p>
<p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestLiveLock {
    static volatile int count = 10;
    static final Object lock = new Object();
    public static void main(String[] args) {
        new Thread(() -> {
            // 期望减到 0 退出循环
            while (count > 0) {
                Thread.sleep(200);
                count--;
                System.out.println("线程一count:" + count);
            }
        }, "t1").start();
        new Thread(() -> {
            // 期望超过 20 退出循环
            while (count < 20) {
                Thread.sleep(200);
                count++;
                System.out.println("线程二count:"+ count);
            }
        }, "t2").start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。</p>
<p>以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生的饥饿，忙式等待就是不进入等待状态的等待。</p>
<p>产生饥饿的原因：</p>
<ul>
<li>高优先级的线程占用了低优先级线程的CPU时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的<code>wait()</code>方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<p>死锁、饥饿的区别：饥饿可自行解开，死锁不行。</p>
<h2 id="❹wait-notify"><a href="#❹wait-notify" class="headerlink" title="❹wait notify"></a>❹wait notify</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Object 类 API：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final void wait():导致当前线程等待，直到另一个线程调用该对象的notify()方法或 notifyAll()方法。
public final native void wait(long timeout):有时限的等待, 到n毫秒后结束等待，或是被唤醒
public final void notify():唤醒正在等待对象监视器的单个线程。
public final void notifyAll():唤醒正在等待对象监视器的所有线程。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p>
<p>对比 sleep()：</p>
<ul>
<li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li>
<li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，但是都会释放 CPU</li>
<li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（即必须先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li>
</ul>
<p>底层原理：</p>
<ul>
<li>Owner 发现该线程条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271941505.png" alt=""></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p>
<p>解决方法：采用 notifyAll</p>
<p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p>
<p>解决方法：用 while + wait，当条件不成立，再次 wait</p>
<p>wait notify正确使用代码模版：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//挂起线程
synchronized(lock){
      while(条件成立){
          lock.wait();
    }
      // 工作代码
}

//唤醒线程
synchronized(lock){
  lock.notifyAll();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❺park-unpark"><a href="#❺park-unpark" class="headerlink" title="❺park unpark"></a>❺park unpark</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>park</code> 和 <code>unpark</code> 是 LockSupport 类中的方法，LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 暂停当前线程，挂起原语
LockSupport.park();
//暂停当前线程，并指定等待时间
LockSupport.parkNanos(Object blocker, long nanos)
//暂停当前线程，并指定截止时间
LockSupport.parkUntil(Object blocker, long deadline)  

// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>结论：先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行</strong></p>
<ul>
<li>先 park 再 unpark</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
},"t1");

t1.start();
sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>18:42:52.585 c.TestParkUnpark [t1] - start...
18:42:53.589 c.TestParkUnpark [t1] - park...
18:42:54.583 c.TestParkUnpark [main] - unpark...
18:42:54.583 c.TestParkUnpark [t1] - resume...
</code></pre><ul>
<li>先 unpark 再 park</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");

t1.start();
sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>18:43:50.765 c.TestParkUnpark [t1] - start...
18:43:51.764 c.TestParkUnpark [main] - unpark...
18:43:52.769 c.TestParkUnpark [t1] - park...
18:43:52.769 c.TestParkUnpark [t1] - resume...
</code></pre><p>与 Object 类 的 wait &amp; notify 相比</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li>
<li>park ，unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li>
<li>park ，unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。</li>
<li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成 <code>_counter</code> ， <code>_cond</code> 和 <code>_mutex</code> </p>
<p>打个比喻<code>线程</code>就像一个旅人，<code>Parker</code> 就像他随身携带的背包，<code>_cond</code> 就好比背包中的帐篷，<code>_counter</code> 就好比背包中的备用干粮（0 为耗尽，1 为充足）</p>
<ul>
<li><p>调用 <code>park</code> 就是要看需不需要停下来歇息。</p>
<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li><p>调用 <code>unpark</code>，就好比令干粮充足</p>
<ul>
<li><p>如果这时线程还在帐篷，就唤醒让他继续前进</p>
</li>
<li><p>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进</p>
</li>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
<p><strong>先 park 再 unpark</strong></p>
<ol>
<li>当前线程调用 <code>Unsafe.park()</code> 方法</li>
<li>检查 <code>_counter</code> ，本情况为 0，这时获得 <code>_mutex</code> 互斥锁</li>
<li>线程进入 <code>_cond</code> 条件变量挂起</li>
<li>调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 1</li>
<li>唤醒 <code>_cond</code> 条件变量中的 <code>Thread_0</code>，<code>Thread_0</code> 恢复运行，设置 <code>_counter</code> 为 0</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">park</th>
<th style="text-align:center">unpark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://img.jwt1399.top/img/202212272238066.png" alt=""></td>
<td style="text-align:center"><img src="https://img.jwt1399.top/img/202212272238925.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p><strong>先 unpark 再 park</strong></p>
<ol>
<li>调用 <code>Unsafe.unpark(Thread_0)</code> 方法，设置 <code>_counter</code> 为 1</li>
<li>当前线程调用 <code>Unsafe.park()</code> 方法</li>
<li>检查 <code>_counter</code> ，本情况为 1，这时线程无需挂起，继续运行，设置 <code>_counter</code> 为 0</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202212272238449.png" alt=""></p>
<h2 id="❻ReentrantLock"><a href="#❻ReentrantLock" class="headerlink" title="❻ReentrantLock"></a>❻ReentrantLock</h2><h3 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h3><p>ReentrantLock 相对于 synchronized 具备如下特点：</p>
<ol>
<li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</li>
<li>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</li>
<li>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</li>
<li><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</li>
<li><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<ul>
<li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li>
<li>不公平锁的含义是阻塞队列内公平，队列外非公平</li>
</ul>
</li>
<li>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列<ul>
<li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li>
</ul>
</li>
<li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</li>
<li>两者都是可重入锁</li>
</ol>
<h3 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h3><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p>
<p>ReentrantLock 类 API：</p>
<ul>
<li><p><code>public void lock()</code>：获得锁</p>
<ul>
<li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p>
</li>
<li><p>如果当前线程已经保持锁定，则保持计数增加 1 </p>
</li>
<li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p>
</li>
</ul>
</li>
<li><p><code>public void unlock()</code>：尝试释放锁</p>
<ul>
<li>如果当前线程是该锁的持有者，则保持计数递减</li>
<li>如果保持计数现在为零，则锁定被释放</li>
<li>如果当前线程不是该锁的持有者，则抛出异常</li>
</ul>
</li>
</ul>
<p>基本语法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取锁
reentrantLock.lock();
try {
    // 临界区
} finally {
    // 释放锁
    reentrantLock.unlock();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>ReentrantLock 默认是不公平的：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantLock() {
    sync = new NonfairSync();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明：公平锁一般没有必要，会降低并发度</p>
<h4 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h4><p>参考下方同步器章节中ReentrantLock部分</p>
<h4 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h4><p>参考下方同步器章节中ReentrantLock部分</p>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static ReentrantLock lock = new ReentrantLock();
public static void main(String[] args) {
    method1();
}
public static void method1() {
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " execute method1");
        method2();
    } finally {
        lock.unlock();
    }
}
public static void method2() {
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " execute method2");
    } finally {
        lock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>源码解析参考：<code>nonfairTryAcquire(int acquires))</code> 和 <code>tryRelease(int releases)</code></p>
<p><code>ReentrantLock</code>内部自定义了同步器sync，在加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，检查当前维护的那个线程ID和当前请求的线程ID是否 一致，如果一致，同步状态加1，表示锁被当前线程获取了多次。</p>
<p>源码如下：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Lock 方法加两把锁会是什么情况呢？</p>
<ul>
<li>加锁两次解锁两次：正常执行</li>
<li>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></li>
<li>加锁一次解锁两次：运行程序会直接报错</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void getLock() {
    lock.lock();
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + "\t get Lock");
    } finally {
        lock.unlock();
        //lock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p>
<ul>
<li>如果没有竞争此方法就会获取 lock 对象锁</li>
<li>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</li>
</ul>
<p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {    
    ReentrantLock lock = new ReentrantLock();    
    Thread t1 = new Thread(() -> {        
        try {            
            System.out.println("尝试获取锁");            
            lock.lockInterruptibly();        
        } catch (InterruptedException e) {            
            System.out.println("没有获取到锁，被打断，直接返回");            
            return;        
        }        
        try {            
            System.out.println("获取到锁");        
        } finally {            
            lock.unlock();        
        }    
    }, "t1");    
    lock.lock();    
    t1.start();    
    Thread.sleep(2000);    
    System.out.println("主线程进行打断锁");    
    t1.interrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>参考下方同步器章节中ReentrantLock部分</p>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p>
<p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p>
<p>注意：tryLock 期间也可以被打断</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    ReentrantLock lock = new ReentrantLock();
    Thread t1 = new Thread(() -> {
        try {
            if (!lock.tryLock(2, TimeUnit.SECONDS)) {
                System.out.println("获取不到锁");
                return;
            }
        } catch (InterruptedException e) {
            System.out.println("被打断，获取不到锁");
            return;
        }
        try {
            log.debug("获取到锁");
        } finally {
            lock.unlock();
        }
    }, "t1");
    lock.lock();
    System.out.println("主线程获取到锁");
    t1.start();

    Thread.sleep(1000);
    try {
        System.out.println("主线程释放了锁");
    } finally {
        lock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    Chopstick c1 = new Chopstick("1");//...
    Chopstick c5 = new Chopstick("5");
    new Philosopher("苏格拉底", c1, c2).start();
    new Philosopher("柏拉图", c2, c3).start();
    new Philosopher("亚里士多德", c3, c4).start();
    new Philosopher("赫拉克利特", c4, c5).start();    
    new Philosopher("阿基米德", c5, c1).start();
}
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public void run() {
        while (true) {
            // 尝试获得左手筷子
            if (left.tryLock()) {
                try {
                    // 尝试获得右手筷子
                    if (right.tryLock()) {
                        try {
                            System.out.println("eating...");
                            Thread.sleep(1000);
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock();
                }
            }
        }
    }
}
class Chopstick extends ReentrantLock {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>参考下方同步器章节中ReentrantLock部分</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h4 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量</p>
<p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p>
<p>Condition 类 API：</p>
<ul>
<li><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</li>
<li><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</li>
</ul>
<p>使用流程：</p>
<ul>
<li><strong>await / signal 前需要获得锁</strong></li>
<li>await 执行后，会释放锁进入 ConditionObject 等待</li>
<li><p>await 的线程被唤醒去重新竞争 lock 锁</p>
</li>
<li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p>
</li>
<li><p>竞争 lock 锁成功后，从 await 后继续执行</p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {
         static ReentrantLock lock = new ReentrantLock();
    static Condition waitCigaretteQueue = lock.newCondition();
    static Condition waitbreakfastQueue = lock.newCondition();
    static volatile boolean hasCigrette = false;
    static volatile boolean hasBreakfast = false;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                lock.lock();
                while (!hasCigrette) {
                    try {
                        waitCigaretteQueue.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                 System.out.println("等到了它的烟");
            } finally {
                lock.unlock();
            }
        }).start();
        new Thread(() -> {
            try {
                lock.lock();
                while (!hasBreakfast) {
                    try {
                        waitbreakfastQueue.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                 System.out.println("等到了它的早餐");
            } finally {
                lock.unlock();
            }
        }).start();
        sleep(1);
        sendBreakfast();
        sleep(1);
        sendCigarette();
    }
    private static void sendCigarette() {
        lock.lock();
        try {
             System.out.println("送烟来了");
            hasCigrette = true;
            waitCigaretteQueue.signal();
        } finally {
            lock.unlock();
        }
    }
    private static void sendBreakfast() {
        lock.lock();
        try {
             System.out.println("送早餐来了");
            hasBreakfast = true;
            waitbreakfastQueue.signal();
        } finally {
            lock.unlock();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>参考下方同步器章节中ReentrantLock部分</p>
<h2 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h2><ol>
<li>成员变量和静态变量：</li>
</ol>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<ol>
<li>局部变量：</li>
</ol>
<ul>
<li>局部变量是线程安全的</li>
<li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的（每一个方法有一个栈帧）</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li>
</ul>
</li>
</ul>
<ol>
<li><p>线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p>
</li>
<li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Hashtable table = new Hashtable();
// 线程1，线程2
if(table.get("key") == null) {
    table.put("key", value);
}
// get、put 两个方法分别是线程安全的，一起使用就是不安全的
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202212201746213.png" style="zoom:50%;" /></p>
<ol>
<li><p>无状态类（就是没有成员变量的类）是线程安全的</p>
</li>
<li><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，方法是线程安全</p>
</li>
</ol>
<ul>
<li><p>String 的 replace 等方法底层是新建一个对象，复制过去</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Map<String,Object> map = new HashMap<>();    // 线程不安全
String S1 = "...";                              // 线程安全
final String S2 = "...";                    // 线程安全
Date D1 = new Date();                          // 线程不安全
final Date D2 = new Date();    // 线程不安全，final让D2引用的对象不能变，但对象的内容可以变
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ol>
<li>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></li>
</ol>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h3><h4 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h4><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212271954511.png" alt=""></p>
<p>实现代码：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class GuardedObject {
    private Object response; //结果

    //获取结果
    public Object get(long millis) {
        synchronized (this) {
            // 没有结果
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    //产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}

//测试
public static void main(String[] args) {

    // 创建 GuardedObject 对象
    GuardedObject guardedObject = new GuardedObject();

    //线程1 等待 线程2 的下载结果
    new Thread(() -> {
        log.debug("等待结果中");
        Object data = guardedObject.get(); // 获取结果
        log.debug("结果为：{}",data);
    }，"t1").start();

    //线程2 下载数据返回给 线程1 
      new Thread(() -> {
        log.debug("执行下载");
        Object data = download();// 下载方法
        guardedObject.complete(data);

    },"t2").start();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h4 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h4><h3 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h3><p>固定运行顺序，先输出 2 后 输出 1</p>
<h4 id="wait-notify-版"><a href="#wait-notify-版" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {        
        // 用来同步的对象
    static Object obj = new Object();
    // t2 运行标记， 代表 t2 是否执行过
    static boolean t2runned = false;
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (obj) {
                // 如果 t2 没有执行过
                while (!t2runned) {
                    try {
                        // t1 先等一会
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
              System.out.println("1");
            } 
        }, "t1");

        Thread t2 = new Thread(() -> {
            System.out.println(2);
            synchronized (obj) {
                System.out.println("2");
                // 修改运行标记
                t2runned = true;
                // 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）
                obj.notifyAll();
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Park-Unpark-版"><a href="#Park-Unpark-版" class="headerlink" title="Park Unpark 版"></a>Park Unpark 版</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
            LockSupport.park();
            System.out.println("1");
    }, "t1");

    Thread t2 = new Thread(() -> {
            System.out.println("2");
            LockSupport.unpark(t1);
    }, "t2");

    t1.start();
    t2.start();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><blockquote>
<p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>
</blockquote>
<h4 id="wait-notify-版-1"><a href="#wait-notify-版-1" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/*
输出内容  等待标记  下一个标记
   a       1        2
   b       2        3
   c       3        1
*/

class SyncWaitNotify {
    // 等待标记
    private int flag;
    // 循环次数
    private int loopNumber;
    public SyncWaitNotify(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }
    public void print(int waitFlag, int nextFlag, String str) {
        for (int i = 0; i < loopNumber; i++) {
            synchronized (this) {
                while (this.flag != waitFlag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }

    public static void main(String[] args) {
        SyncWaitNotify syncWaitNotify = new SyncWaitNotify(1, 5);
        new Thread(() -> {
            syncWaitNotify.print(1, 2, "a");
        }).start();
        new Thread(() -> {
            syncWaitNotify.print(2, 3, "b");
        }).start();
        new Thread(() -> {
            syncWaitNotify.print(3, 1, "c");
        }).start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ReentrantLock-版"><a href="#ReentrantLock-版" class="headerlink" title="ReentrantLock 版"></a>ReentrantLock 版</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class AwaitSignal extends ReentrantLock {
    // 循环次数
    private int loopNumber;
    public AwaitSignal(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    // 参数1：打印内容 参数2：进入哪一间休息室 参数3：下一间休息室
    public void print(String str, Condition current, Condition next) {
        for (int i = 0; i < loopNumber; i++) {
            this.lock();
            try {
                current.await();
                System.out.print(str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                this.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        AwaitSignal as = new AwaitSignal(5);
        // a,b,c分别的休息室
        Condition aWaitSet = as.newCondition();
        Condition bWaitSet = as.newCondition();
        Condition cWaitSet = as.newCondition();
        new Thread(() -> {
            as.print("a", aWaitSet, bWaitSet);
        }).start();
        new Thread(() -> {
            as.print("b", bWaitSet, cWaitSet);
        }).start();
        new Thread(() -> {
            as.print("c", cWaitSet, aWaitSet);
        }).start();

        Thread.sleep(1000);
        as.lock();
        try {
            //唤醒a休息室
            aWaitSet.signal();
        } finally {
            as.unlock();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Park-Unpark-版-1"><a href="#Park-Unpark-版-1" class="headerlink" title="Park Unpark 版"></a>Park Unpark 版</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class SyncPark {
    private int loopNumber;
    public SyncPark(int loopNumber) {
        this.loopNumber = loopNumber;
    }
    public void print(String str, Thread next) {
        for (int i = 0; i < loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }

    static  Thread t1, t2, t3;

    public static void main(String[] args) {
        SyncPark syncPark = new SyncPark(5);

        t1 = new Thread(() -> {
            syncPark.print("a", t2);
        });
        t2 = new Thread(() -> {
            syncPark.print("b", t3);
        });
        t3 = new Thread(() -> {
            syncPark.print("c\n", t1);
        });
        t1.start();
        t2.start();
        t3.start();
        LockSupport.unpark(t1);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="③内存"><a href="#③内存" class="headerlink" title="③内存"></a>③内存</h1><h2 id="❶JMM"><a href="#❶JMM" class="headerlink" title="❶JMM"></a>❶JMM</h2><h3 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h3><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM 作用：</p>
<ul>
<li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li>
<li>规定了线程和内存之间的一些关系</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212291444042.png" alt=""></p>
<p>根据 JMM 的设计，系统存在一个<code>主内存（Main Memory）</code>，Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的<code>工作内存（Working Memory）</code>，工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，工作内存存储在高速缓存或者寄存器中，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p>
<p>主内存和工作内存：</p>
<ul>
<li>主内存：计算机的内存，Java 中所有变量都存储在主内存中，对于所有线程都是共享的。</li>
<li>工作内存：存储的是主内存中某些<strong>变量的拷贝</strong>，工作内存存储在高速缓存或者寄存器中</li>
</ul>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。加入高速缓存带来了一个新的问题：缓存一致性【当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样】，需要一些协议来解决这个问题。</p>
<p><img src="https://img.jwt1399.top/img/202212291454203.png" style="zoom:80%;" /></p>
<p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p>
<ul>
<li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li>
<li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li>
</ul>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p>
<p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p>
<p><img src="../images/Java-JUC/JMM-CPU缓存结构.png" style="zoom: 50%;" /></p>
<p><strong>缓存使用</strong></p>
<p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在，则不用访问内存直接返回该数据；如果不存在，则要先把内存中的相应数据载入缓存，再将其返回处理器</p>
<p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p>
<p><strong>处理机制</strong></p>
<p>单核 CPU 处理器会自动保证基本内存操作的原子性</p>
<p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：总线锁定和缓存锁定来解决</p>
<h3 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h3><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p>
<p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p>
<p><img src="https://img.jwt1399.top/img/202212291445582.png" style="zoom: 67%;" /></p>
<ul>
<li>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</li>
<li>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</li>
<li>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</li>
<li>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</li>
<li><p>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</p>
</li>
<li><p>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</p>
</li>
<li>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</li>
</ul>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p>
<p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p>
<p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static boolean run = true;    //添加volatile即可解决不可见的问题
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(()->{
        while(run){
        // ....
        }
    });
    t.start();
    sleep(1);
    run = false;  //线程t按理应该停下来
}

// 线程t不会如预想的停下来
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原因：</p>
<ul>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212282148547.png" style="zoom:50%;" /></p>
<ul>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212282148347.png"  /></p>
<ul>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212282149428.png" alt=""></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响 </p>
<p>定义原子操作的使用规则：</p>
<ol>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</li>
<li>不允许一个线程丢弃 assign 操作，必须同步回主存</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li>
<li>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</li>
<li>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li>
<li>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</li>
</ol>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p>
<p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行指令
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p>
<p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p>
<ul>
<li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li>
<li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li>
</ul>
<p>补充知识：</p>
<ul>
<li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li>
<li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li>
<li>振荡周期指周期性信号作周期性重复变化的时间间隔</li>
</ul>
<h2 id="❷volatile"><a href="#❷volatile" class="headerlink" title="❷volatile"></a>❷volatile</h2><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>保证有序性（禁止指令重排）</li>
</ul>
<p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小（因此适合一写多读的场景）</p>
<p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p>
<ul>
<li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li>
<li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中</li>
</ul>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>volatile 修饰的变量，可以禁用指令重排</p>
<p>指令重排实例：</p>
<ul>
<li><p>example 1：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void mySort() {
    int x = 11;    //语句1
    int y = 12;    //语句2  谁先执行效果一样
    x = x + 5;    //语句3
    y = x * x;    //语句4
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</p>
<p>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</p>
</li>
<li><p>example 2：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">int num = 0;
boolean ready = false;
// 线程1 执行此方法
public void actor1(I_Result r) {
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
// 线程2 执行此方法
public void actor2(I_Result r) {
    num = 2;
    ready = true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>情况一：线程 1 先执行，ready = false，结果为 r.r1 = 1</p>
<p>情况二：线程 2 先执行 num = 2，但还没执行 ready = true，线程 1 执行，结果为 r.r1 = 1</p>
<p>情况三：线程 2 先执行 ready = true，线程 1 执行，进入 if 分支结果为 r.r1 = 4</p>
<p>情况四：线程 2 执行 ready = true，切换到线程 1，进入 if 分支为 r.r1 = 0，再切回线程 2 执行 num = 2，发生指令重排</p>
</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>使用 volatile 修饰的共享变量，总线会开启 <strong>CPU 总线嗅探机制</strong>来解决 JMM 缓存一致性问题，也就是共享变量在多线程中可见性的问题，实现 MESI 缓存一致性协议</p>
<p>底层是通过汇编 lock 前缀指令，共享变量加了 lock 前缀指令就会进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程根据总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p>
<p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<p>内存屏障有三个作用：</p>
<ul>
<li>确保对内存的读-改-写操作原子执行</li>
<li>阻止屏障两侧的指令重排序</li>
<li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li>
</ul>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>保证<strong>可见性</strong>：</p>
<ul>
<li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void actor1(I_Result r) {
    // 读屏障
    // ready 是 volatile 读取值带读屏障
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202212291520278.png" style="zoom:67%;" /></p>
</li>
<li><p>全能屏障：mfence（modify/mix Barrier），兼具 写屏障 和 读屏障 的功能</p>
</li>
</ul>
<p>保证<strong>有序性</strong>：</p>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p>不能解决指令交错：</p>
<ul>
<li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p>
</li>
<li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">volatile i = 0;
new Thread(() -> {i++});
new Thread(() -> {i--});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>i++ 反编译后的指令：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">0: iconst_1            // 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中
1: istore_1            // 将操作数栈顶数据弹出，存入局部变量表的 slot 1
2: iinc        1, 1
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="../images/Java-JUC/JMM-volatile不能保证原子性.png" style="zoom:67%;" /></p>
</li>
</ul>
<h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p>
<ul>
<li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li>
<li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li>
<li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li>
</ul>
<h3 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h3><h4 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h4><p>Double-Checked Locking：双端检锁机制</p>
<p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2，这里的判断不是线程安全的
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化
                if (INSTANCE == null) { 
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不锁 INSTANCE 的原因：</p>
<ul>
<li>INSTANCE 要重新赋值</li>
<li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li>
</ul>
<p>实现特点： </p>
<ul>
<li>懒惰初始化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li>
</ul>
<h4 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h4><p>getInstance 方法对应的字节码为：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">0:     getstatic         #2         // Field INSTANCE:Ltest/Singleton;
3:     ifnonnull         37
6:     ldc             #3         // class test/Singleton
8:     dup
9:     astore_0
10: monitorenter
11: getstatic         #2         // Field INSTANCE:Ltest/Singleton;
14: ifnonnull 27
17: new             #3         // class test/Singleton
20: dup
21: invokespecial     #4         // Method "<init>":()V
24: putstatic         #2         // Field INSTANCE:Ltest/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic         #2         // Field INSTANCE:Ltest/Singleton;
40: areturn
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>17 表示创建对象，将对象引用入栈 </li>
<li>20 表示复制一份对象引用，引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法初始化对象</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p>
<ul>
<li>关键在于 0:  getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li>
<li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212291533213.png" alt=""></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p>
<p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static volatile SingletonDemo INSTANCE = null;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before【先行发生】 原则，它是可见性与有序性的一套规则总结</p>
<p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p>
<ol>
<li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p>
</li>
<li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作。线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">  static int x;
  static Object m = new Object();
  new Thread(()->{
      synchronized(m) {
              x = 10;
      }
  },"t1").start();

  new Thread(()->{
      synchronized(m) {
              System.out.println(x);
          }
  },"t2").start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>volatile 变量规则  (Volatile Variable Rule)：线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">volatile static int x;

new Thread(()->{
        x = 10;
},"t1").start();

new Thread(()->{
        System.out.println(x);
},"t2").start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">volatile static int x;
static int y;
new Thread(()->{
  y = 10;
  x = 20;
},"t1").start();
new Thread(()->{
  // x=20 对 t2 可见, 同时 y=10 也对 t2 可见
  System.out.println(x);
},"t2").start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>线程启动规则 (Thread Start Rule)：线程 start 方法前对变量的写，对该线程开始后对该变量的读可见</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static int x = 10;//线程 start 前对变量的写，对该线程开始后对该变量的读可见
new Thread(()->{    
  System.out.println(x);
},"t1").start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static int x;
public static void main(String[] args) {
        Thread t2 = new Thread(()->{
        while(true) {
          if(Thread.currentThread().isInterrupted()) {
          System.out.println(x);
          break;
        }
            }
        },"t2");
    t2.start();
    new Thread(()->{
            sleep(1);
            x = 10;
            t2.interrupt();
    },"t1").start();
    while(!t2.isInterrupted()) {
            Thread.yield();
    }
    System.out.println(x);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>线程终止规则 (Thread Termination Rule)：线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static int x;
Thread t1 = new Thread(()->{
        x = 10;
},"t1");
t1.start();
t1.join();
System.out.println(x);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
</li>
</ol>
<h1 id="④无锁"><a href="#④无锁" class="headerlink" title="④无锁"></a>④无锁</h1><h2 id="❶CAS"><a href="#❶CAS" class="headerlink" title="❶CAS"></a>❶CAS</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>无锁编程：Lock Free</p>
<p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p>
<ul>
<li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li>
<li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li>
<li><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></li>
</ul>
<p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p>
<ul>
<li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p>
</li>
<li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p>
</li>
</ul>
<p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p>
<p>CAS 特点：</p>
<ul>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li>
<li>CAS 是基于乐观锁的思想</li>
</ul>
<p>CAS 缺点：</p>
<ul>
<li>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li>
<li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li>
</ul>
</li>
<li>引出来 ABA 问题<ul>
<li>当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值。即其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题。</li>
</ul>
</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>CAS 与 synchronized 总结：</p>
<ul>
<li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li>
<li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>如何 保证 <code>account.withdraw</code> 取款方法的线程安全</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Account {
  // 获取余额
  Integer getBalance();
  // 取款
  void withdraw(Integer amount);
}


class AccountUnsafe implements Account{
    private Integer balance;
    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }
    @Override
    public Integer getBalance() {
        return balance;
    }
    @Override
    public void withdraw(Integer amount) {
        balance -= amount;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="解决方法1：加锁"><a href="#解决方法1：加锁" class="headerlink" title="解决方法1：加锁"></a>解决方法1：加锁</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class AccountUnsafe implements Account {
    private Integer balance;

    public AccountUnsafe(Integer balance) {
            this.balance = balance;
    }

    @Override
    public synchronized Integer getBalance() {
            return balance;
    }

    @Override
    public synchronized void withdraw(Integer amount) {
            balance -= amount;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="解决方法2：无锁"><a href="#解决方法2：无锁" class="headerlink" title="解决方法2：无锁"></a>解决方法2：无锁</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class AccountSafe implements Account {
        private AtomicInteger balance;

        public AccountSafe(Integer balance) {
                this.balance = new AtomicInteger(balance);
        }

    @Override
    public Integer getBalance() {
            return balance.get();
    }

    @Override
    public void withdraw(Integer amount) {
        // 需要不断尝试，直到成功为止
        while (true) {
            //获取余额最新值
            int prev = balance.get();// 比如拿到了旧值 1000
            //要修改的余额
            int next = prev - amount;// 在这个基础上 1000-10 = 990
            //真正修改
            if (balance.compareAndSet(prev, next)) {
                    break;
            }
             }
        // 可以简化为下面的方法
        // balance.addAndGet(-1 * amount);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<p>compareAndSet：在 set 前，先比较 prev 与当前值(balance)</p>
<ul>
<li><p>不一致了，next 作废，返回 false 表示失败</p>
<ul>
<li><p>比如别的线程已经做了减法，当前值已经被减成了 990，那么本线程的这次 990 就作废了，进入 while 下次循环重试</p>
<ul>
<li>一致，以 next 设置为新值，返回 true 表示成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202212302049142.png" alt=""></p>
<h2 id="❷Atomic"><a href="#❷Atomic" class="headerlink" title="❷Atomic"></a>❷Atomic</h2><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p>
<p>构造方法：</p>
<ul>
<li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li>
<li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li>
</ul>
<p>常用API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>public final int get()</td>
<td>获取 AtomicInteger 的值</td>
</tr>
<tr>
<td>public final int getAndIncrement()</td>
<td>以原子方式将当前值加 1，返回的是自增前的值（i++）</td>
</tr>
<tr>
<td>public final int incrementAndGet()</td>
<td>以原子方式将当前值加 1，返回的是自增后的值（++i）</td>
</tr>
<tr>
<td>public final int getAndSet(int value)</td>
<td>以原子方式设置为 newValue 的值，返回旧值</td>
</tr>
<tr>
<td>public final int addAndGet(int data)</td>
<td>以原子方式将输入的数值与实例中的值相加并返回</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">AtomicInteger i = new AtomicInteger(0);

// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());
// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());
// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());
// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());
// 获取并加值（i = 0, 结果 i = 5, 返回 0）
System.out.println(i.getAndAdd(5));
// 加值并获取（i = 5, 结果 i = 0, 返回 0）
System.out.println(i.addAndGet(-5));
// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.getAndUpdate(p -> p - 2));
// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.updateAndGet(p -> p + 2));
// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));
// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><strong>AtomicInteger 原理</strong>：自旋锁  + CAS 算法</p>
<p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p>
<ul>
<li>当旧的预期值 A == 内存值 V   此时可以修改，将 V 改为 B</li>
<li>当旧的预期值 A !=  内存值 V   此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋 </li>
</ul>
<p>分析 getAndSet 方法：</p>
<ul>
<li><p>AtomicInteger：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final int getAndSet(int newValue) {
    /**
    * this:         当前对象
    * valueOffset:    内存偏移量，内存地址
    */
    return unsafe.getAndSetInt(this, valueOffset, newValue);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
//调用本地方法   -->
public native long objectFieldOffset(Field var1);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>unsafe 类：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数
public final int getAndSetInt(Object var1, long var2, int var4) {
    int var5;
    do {
        // var5: 用 var1 和 var2 找到的内存中的真实值
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var4));

    return var5;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p>
</li>
<li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile int value
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p>
</li>
</ul>
<p>分析 getAndUpdate 方法：</p>
<ul>
<li><p>getAndUpdate：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final int getAndUpdate(IntUnaryOperator updateFunction) {
    int prev, next;
    do {
        prev = get();    //当前值，cas的期望值
        next = updateFunction.applyAsInt(prev);//期望值更新到该值
    } while (!compareAndSet(prev, next));//自旋
    return prev;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数式接口：可以自定义操作逻辑</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">AtomicInteger a = new AtomicInteger();
a.getAndUpdate(i -> i + 10);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>compareAndSet：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final boolean compareAndSet(int expect, int update) {
    /**
    * this:         当前对象
    * valueOffset:    内存偏移量，内存地址
    * expect:        期望的值
    * update:         更新的值
    */
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p>
<p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
<p>AtomicReference 类：</p>
<ul>
<li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li>
<li><code>public final void set(V newValue)</code>：将值设置为 newValue </li>
<li><code>public final V get()</code>：返回当前值</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class AtomicReferenceDemo {
    public static void main(String[] args) {
        Student s1 = new Student(33, "z3");

        // 创建原子引用包装类
        AtomicReference<Student> atomicReference = new AtomicReference<>();
        // 设置主内存共享变量为s1
        atomicReference.set(s1);

        // 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4
        while (true) {
            Student s2 = new Student(44, "l4");
            if (atomicReference.compareAndSet(s1, s2)) {
                break;
            }
        }
        System.out.println(atomicReference.get());
    }
}

class Student {
    private int id;
    private String name;
    //。。。。
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p>AtomicIntegerArray 类方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/**
*   i        the index
* expect     the expected value
* update     the new value
*/
public final boolean compareAndSet(int i, int expect, int update) {
    return compareAndSetRaw(checkedByteOffset(i), expect, update);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h3><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p>
<p>常用 API：</p>
<ul>
<li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li>
<li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class UpdateDemo {
    private volatile int field;

    public static void main(String[] args) {
        AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater
                    .newUpdater(UpdateDemo.class, "field");
        UpdateDemo updateDemo = new UpdateDemo();
        fieldUpdater.compareAndSet(updateDemo, 0, 10);
        System.out.println(updateDemo.field);//10
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator </p>
<p>LongAdder 和 LongAccumulator 区别：</p>
<p>相同点：</p>
<ul>
<li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li>
<li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li>
</ul>
<p>不同点：</p>
<ul>
<li>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b = base, x) 来计算，LongAddr 使用 casBase(b = base, b + x) </li>
<li><p>LongAccumulator 类功能更加强大，构造方法参数中</p>
<ul>
<li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li>
<li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li>
</ul>
</li>
</ul>
<h2 id="❸Adder"><a href="#❸Adder" class="headerlink" title="❸Adder"></a>❸Adder</h2><p>LongAdder  是 Java8 提供的类， 跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用<strong>分段 CAS</strong> 以及<strong>自动分段迁移</strong>的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p>
<p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p>
<p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p>
<p><strong>分段 CAS 机制</strong>：</p>
<ul>
<li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li>
<li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li>
<li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li>
</ul>
<p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p>
<h2 id="❹Unsafe"><a href="#❹Unsafe" class="headerlink" title="❹Unsafe"></a>❹Unsafe</h2><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p>
<p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p>
<h2 id="❺final"><a href="#❺final" class="headerlink" title="❺final"></a>❺final</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestFinal {
    final int a = 20;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>字节码：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">0: aload_0
1: invokespecial #1 // Method java/lang/Object."<init>":()V
4: aload_0
5: bipush 20        // 将值直接放入栈中
7: putfield #2         // Field a:I
<-- 写屏障
10: return
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p>
<p>其他线程访问 final 修饰的变量<strong>会复制一份放入栈中</strong>，效率更高</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p>
<p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p>
<p>String 类也是不可变的，该类和类中所有属性都是 final 的</p>
<ul>
<li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p>
</li>
<li><p>无写入方法（set）确保外部不能对内部属性进行修改</p>
</li>
<li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    //....
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p>
</li>
</ul>
<h2 id="❻ThreadLocal"><a href="#❻ThreadLocal" class="headerlink" title="❻ThreadLocal"></a>❻ThreadLocal</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p>
<p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p>
<p>ThreadLocal 作用：</p>
<ul>
<li><p>线程并发：应用在多线程并发的场景下</p>
</li>
<li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p>
</li>
<li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p>
</li>
</ul>
<p>对比 synchronized：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ThreadLocal</th>
</tr>
</thead>
<tbody>
<tr>
<td>原理</td>
<td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td>
<td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td>
</tr>
<tr>
<td>侧重点</td>
<td>多个线程之间访问资源的同步</td>
<td>多线程中让每个线程之间的数据相互隔离</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadLocal&lt;&gt;()</td>
<td>创建 ThreadLocal 对象</td>
</tr>
<tr>
<td>protected T initialValue()</td>
<td>返回当前线程局部变量的初始值</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public void remove()</td>
<td>移除当前线程绑定的局部变量</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyDemo {

    private static ThreadLocal<String> tl = new ThreadLocal<>();

    private String content;

    private String getContent() {
        // 获取当前线程绑定的变量
        return tl.get();
    }

    private void setContent(String content) {
        // 变量content绑定到当前线程
        tl.set(content);
    }

    public static void main(String[] args) {
        MyDemo demo = new MyDemo();
        for (int i = 0; i < 5; i++) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    // 设置数据
                    demo.setContent(Thread.currentThread().getName() + "的数据");
                    System.out.println("-----------------------");
                    System.out.println(Thread.currentThread().getName() + "--->" + demo.getContent());
                }
            });
            thread.setName("线程" + i);
            thread.start();
        }
    }
}

/**
-----------------------
线程0--->线程0的数据
-----------------------
线程1--->线程1的数据
-----------------------
线程2--->线程2的数据
-----------------------
线程3--->线程3的数据
-----------------------
线程4--->线程4的数据
**/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>ThreadLocal 适用于下面两种场景：</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>ThreadLocal 方案有两个突出的优势： </p>
<ol>
<li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</li>
<li>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li>
</ol>
<p>ThreadLocal 用于数据连接的事务管理：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class JdbcUtils {
    // ThreadLocal对象，将connection绑定在当前线程中
    private static final ThreadLocal<Connection> tl = new ThreadLocal();
    // c3p0 数据库连接池对象属性
    private static final ComboPooledDataSource ds = new ComboPooledDataSource();
    // 获取连接
    public static Connection getConnection() throws SQLException {
        //取出当前线程绑定的connection对象
        Connection conn = tl.get();
        if (conn == null) {
            //如果没有，则从连接池中取出
            conn = ds.getConnection();
            //再将connection对象绑定到当前线程中，非常重要的操作
            tl.set(conn);
        }
        return conn;
    }
    // ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ThreadLocalDateUtil {
    private static ThreadLocal<DateFormat> threadLocal = new ThreadLocal<DateFormat>() {
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        }
    };

    public static Date parse(String dateStr) throws ParseException {
        return threadLocal.get().parse(dateStr);
    }

    public static String format(Date date) {
        return threadLocal.get().format(date);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p>
<p><img src="https://img.jwt1399.top/img/202301032103166.png" alt=""></p>
<p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p>
<ul>
<li><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></li>
<li>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</li>
<li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</li>
<li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301032103152.png" alt=""></p>
<p>JDK8 前后对比：</p>
<ul>
<li>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</li>
<li>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></li>
</ul>
<hr>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ThreadLocal.ThreadLocalMap threadLocals = null
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301032111440.png" alt=""></p>
</li>
<li><p>计算 ThreadLocal 对象的哈希值：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final int threadLocalHashCode = nextHashCode()
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p>
</li>
<li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static AtomicInteger nextHashCode = new AtomicInteger()
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final int HASH_INCREMENT = 0x61c88647
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p>
<ul>
<li><p><code>initialValue()</code>：返回该线程局部变量的初始值</p>
<ul>
<li>延迟调用的方法，在执行 get 方法时才执行</li>
<li>该方法缺省（默认）实现直接返回一个 null</li>
<li>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected T initialValue() {
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>nextHashCode()</code>：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static int nextHashCode() {
    // 哈希值自增一个 HASH_INCREMENT 数值
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>set()</code>：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void set(T value) {
    // 获取当前线程对象
    Thread t = Thread.currentThread();
    // 获取此线程对象中维护的 ThreadLocalMap 对象
    ThreadLocalMap map = getMap(t);
    // 判断 map 是否存在
    if (map != null)
        // 调用 threadLocalMap.set 方法进行重写或者添加
        map.set(this, value);
    else
        // map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量
        createMap(t, value);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取当前线程 Thread 对应维护的 ThreadLocalMap 
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
// 创建当前线程Thread对应维护的ThreadLocalMap 
void createMap(Thread t, T firstValue) {
    // 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>get()</code>：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    // 如果此map存在
    if (map != null) {
        // 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e
        ThreadLocalMap.Entry e = map.getEntry(this);
        // 对 e 进行判空 
        if (e != null) {
            // 获取存储实体 e 对应的 value值
            T result = (T)e.value;
            return result;
        }
    }
    /*有两种情况有执行当前代码
      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象
      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */
    // 初始化当前线程与当前 threadLocal 对象相关联的 value
    return setInitialValue();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private T setInitialValue() {
    // 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    // 判断 map 是否初始化过
    if (map != null)
        // 存在则调用 map.set 设置此实体 entry，value 是默认的值
        map.set(this, value);
    else
        // 调用 createMap 进行 ThreadLocalMap 对象的初始化中
        createMap(t, value);
    // 返回线程与当前 threadLocal 关联的局部变量
    return value;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>remove()</code>：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void remove() {
    // 获取当前线程对象中维护的 ThreadLocalMap 对象
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        // map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体
        m.remove(this);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h3><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 初始化当前 map 内部散列表数组的初始长度 16
private static final int INITIAL_CAPACITY = 16;

// 存放数据的table，数组长度必须是2的整次幂。
private Entry[] table;

// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值
private int size = 0;

// 进行扩容的阈值，表使用量大于它的时候进行扩容。
private int threshold;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>存储结构 Entry：</p>
<ul>
<li>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</li>
<li>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() == null) 意味着 key 不再被引用，entry 也可以从 table 中清除</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
        // this.referent = referent = key;
        super(k);
        value = v;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    // 初始化table，创建一个长度为16的Entry数组
    table = new Entry[INITIAL_CAPACITY];
    // 【寻址算法】计算索引
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    // 创建 entry 对象，存放到指定位置的 slot 中
    table[i] = new Entry(firstKey, firstValue);
    // 数据总量是 1
    size = 1;
    // 将阈值设置为 （当前数组长度 * 2）/ 3。
    setThreshold(INITIAL_CAPACITY);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><p><code>set()</code>：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p>
<ul>
<li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p>
<p>假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[]  table 看成一个<strong>环形数组</strong></p>
</li>
<li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p>
</li>
<li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void set(ThreadLocal<?> key, Object value) {
    // 获取散列表
    ThreadLocal.ThreadLocalMap.Entry[] tab = table;
    int len = tab.length;
    // 哈希寻址
    int i = key.threadLocalHashCode & (len-1);
    // 使用线性探测法向后查找元素，碰到 entry 为空时停止探测
    for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        // 获取当前元素 key
        ThreadLocal<?> k = e.get();
        // ThreadLocal 对应的 key 存在，【直接覆盖之前的值】
        if (k == key) {
            e.value = value;
            return;
        }
        // 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】

        // key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】
        if (k == null) {
            // 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】
            // 这个方法还进行了垃圾清理动作，防止内存泄漏
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    // 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry
    tab[i] = new Entry(key, value);
    // 数量 + 1
    int sz = ++size;

    // 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        // 扩容
        rehash();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取【环形数组】的下一个索引
private static int nextIndex(int i, int len) {
    // 索引越界后从 0 开始继续获取
    return ((i + 1 < len) ? i + 1 : 0);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在指定位置插入指定的数据
private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {
    // 获取散列表
    Entry[] tab = table;
    int len = tab.length;
    Entry e;
    // 探测式清理的开始下标，默认从当前 staleSlot 开始
    int slotToExpunge = staleSlot;
    // 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值
    // 【保证在一个区间段内，从最前面的过期数据开始清理】
    for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))
        if (e.get() == null)
            slotToExpunge = i;

    // 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测
    for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
        // 获取当前节点的 key
        ThreadLocal<?> k = e.get();
        // 条件成立说明是【替换逻辑】
        if (k == key) {
            e.value = value;
            // 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致
            // 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry
            // 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，
            tab[i] = tab[staleSlot];
            tab[staleSlot] = e;

            // 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是
            if (slotToExpunge == staleSlot)
                slotToExpunge = i;

            // 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }
        // 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据
        if (k == null && slotToExpunge == staleSlot)
            // 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据
            slotToExpunge = i;
    }
    // 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】
    // 删除原有的数据引用，防止内存泄露
    tab[staleSlot].value = null;
    // staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】
    tab[staleSlot] = new Entry(key, value);

    // 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】
    if (slotToExpunge != staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301032135926.png" alt=""></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static int prevIndex(int i, int len) {
    // 形成一个环绕式的访问，头索引越界后置为尾索引
    return ((i - 1 >= 0) ? i - 1 : len - 1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>getEntry()</code>：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private Entry getEntry(ThreadLocal<?> key) {
    // 哈希寻址
    int i = key.threadLocalHashCode & (table.length - 1);
    // 访问散列表中指定指定位置的 slot 
    Entry e = table[i];
    // 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回
    if (e != null && e.get() == key)
        return e;
    else
        // 进行线性探测
        return getEntryAfterMiss(key, i, e);
}
// 线性探测寻址
private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
    // 获取散列表
    Entry[] tab = table;
    int len = tab.length;

    // 开始遍历，碰到 slot == null 的情况，搜索结束
    while (e != null) {
        // 获取当前 slot 中 entry 对象的 key
        ThreadLocal<?> k = e.get();
        // 条件成立说明找到了，直接返回
        if (k == key)
            return e;
        if (k == null)
             // 过期数据，【探测式过期数据回收】
            expungeStaleEntry(i);
        else
            // 更新 index 继续向后走
            i = nextIndex(i, len);
        // 获取下一个槽位中的 entry
        e = tab[i];
    }
    // 说明当前区段没有找到相应数据
    // 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>rehash()</code>：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void rehash() {
    // 清楚当前散列表内的【所有】过期的数据
    expungeStaleEntries();

    // threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)
    if (size >= threshold - threshold / 4)
        resize();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    // 【遍历所有的槽位，清理过期数据】
    for (int j = 0; j < len; j++) {
        Entry e = tab[j];
        if (e != null && e.get() == null)
            expungeStaleEntry(j);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Entry <strong>数组扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    // 新数组的长度是老数组的二倍
    int newLen = oldLen * 2;
    Entry[] newTab = new Entry[newLen];
    // 统计新table中的entry数量
    int count = 0;
    // 遍历老表，进行【数据迁移】
    for (int j = 0; j < oldLen; ++j) {
        // 访问老表的指定位置的 entry
        Entry e = oldTab[j];
        // 条件成立说明老表中该位置有数据，可能是过期数据也可能不是
        if (e != null) {
            ThreadLocal<?> k = e.get();
            // 过期数据
            if (k == null) {
                e.value = null; // Help the GC
            } else {
                // 非过期数据，在新表中进行哈希寻址
                int h = k.threadLocalHashCode & (newLen - 1);
                // 【线程探测】
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                // 将数据存放到新表合适的 slot 中
                newTab[h] = e;
                count++;
            }
        }
    }
    // 设置下一次触发扩容的指标：threshold = len * 2 / 3;
    setThreshold(newLen);
    size = count;
    // 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用
    table = newTab;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>remove()</code>：删除 Entry</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    // 哈希寻址
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        // 找到了对应的 key
        if (e.get() == key) {
            // 设置 key 为 null
            e.clear();
            // 探测式清理
            expungeStaleEntry(i);
            return;
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h4><ul>
<li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据
private int expungeStaleEntry(int staleSlot) {
    // 获取散列表和数组长度
    Entry[] tab = table;
    int len = tab.length;

    // help gc，先把当前过期的 entry 置空，在取消对 entry 的引用
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    // 数量-1
    size--;

    Entry e;
    int i;
    // 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】
    for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
        ThreadLocal<?> k = e.get();
        // 当前 entry 是过期数据
        if (k == null) {
            // help gc
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            // 当前 entry 不是过期数据的逻辑，【rehash】
            // 重新计算当前 entry 对应的 index
            int h = k.threadLocalHashCode & (len - 1);
            // 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了
            if (h != i) {
                // 当前位置置空
                tab[i] = null;
                // 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置
                while (tab[h] != null)
                    h = nextIndex(h, len);
                // 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】
                tab[h] = e;
            }
        }
    }
    // 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】
    return i;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301040014250.png" style="zoom:67%;" /></p>
<p><img src="https://img.jwt1399.top/img/202301040014047.png" style="zoom:67%;" /></p>
</li>
<li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length 
private boolean cleanSomeSlots(int i, int n) {
    // 表示启发式清理工作是否清除了过期数据
    boolean removed = false;
    // 获取当前 map 的散列表引用
    Entry[] tab = table;
    int len = tab.length;
    do {
        // 获取下一个索引，因为探测式返回的 slot 为 null
        i = nextIndex(i, len);
        Entry e = tab[i];
        // 条件成立说明是过期的数据，key 被 gc 了
        if (e != null && e.get() == null) {
            // 【发现过期数据重置 n 为数组的长度】
            n = len;
            // 表示清理过过期数据
            removed = true;
            // 以当前过期的 slot 为开始节点 做一次探测式清理工作
            i = expungeStaleEntry(i);
        }
        // 假设 table 长度为 16
        // 16 >>> 1 ==> 8，8 >>> 1 ==> 4，4 >>> 1 ==> 2，2 >>> 1 ==> 1，1 >>> 1 ==> 0
        // 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据
    } while ((n >>>= 1) != 0);

    // 返回清除标记
    return removed;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="⑤线程池"><a href="#⑤线程池" class="headerlink" title="⑤线程池"></a>⑤线程池</h1><h2 id="❶基本概述"><a href="#❶基本概述" class="headerlink" title="❶基本概述"></a>❶基本概述</h2><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p>
<p>线程池作用：</p>
<ol>
<li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li>
<li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p>
<p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p>
<h2 id="❷阻塞队列-BlockingQueue"><a href="#❷阻塞队列-BlockingQueue" class="headerlink" title="❷阻塞队列-BlockingQueue"></a>❷阻塞队列-BlockingQueue</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>有界队列和无界队列：</p>
<ul>
<li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p>
</li>
<li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p>
</li>
</ul>
<p><code>java.util.concurrent.BlockingQueue</code> 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong> </p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</li>
<li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li>
</ul>
<p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p>
<ul>
<li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li>
<li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li>
</ul>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入（尾）</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（头）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查（队首元素）</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>抛出异常组：<ul>
<li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IllegalStateException: Queue full</li>
<li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li>
</ul>
</li>
<li>特殊值组：<ul>
<li>插入方法：成功 true，失败 false</li>
<li>移除方法：成功返回出队列元素，队列没有就返回 null</li>
</ul>
</li>
<li>阻塞组：<ul>
<li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li>
</ul>
</li>
<li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<h2 id="❸操作Pool"><a href="#❸操作Pool" class="headerlink" title="❸操作Pool"></a>❸操作Pool</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>存放线程的容器：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final HashSet<Worker> workers = new HashSet<Worker>();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数介绍：</p>
<ul>
<li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p>
</li>
<li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p>
</li>
<li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p>
</li>
<li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p>
</li>
<li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p>
</li>
<li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p>
</li>
<li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p>
<p>RejectedExecutionHandler 下有 4 个实现类：</p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</li>
<li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<p>补充：其他框架拒绝策略</p>
<ul>
<li>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty：创建一个新线程来执行任务</li>
<li>ActiveMQ：带超时等待（60s）尝试放入队列</li>
<li>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
</ul>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p>
<ul>
<li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</li>
<li>适用于任务量已知，相对耗时的长期任务</li>
</ul>
</li>
<li><p>newCachedThreadPool：创建一个可扩容的线程池</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></li>
<li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p>
</li>
<li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
</ul>
</li>
<li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li><p>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p>
<p>原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301031741667.png" alt=""></p>
<h4 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h4><p>阿里巴巴 Java 开发手册要求：</p>
<ul>
<li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p>
<ul>
<li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</li>
<li>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</li>
</ul>
</li>
<li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p>Executors 返回的线程池对象弊端如下：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li>
<li>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</li>
</ul>
</li>
</ul>
<p>创建多大容量的线程池合适？</p>
<ul>
<li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p>
</li>
<li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p>
</li>
<li><p>过大会导致更多的线程上下文切换，占用更多内存</p>
<p>上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p>
</li>
</ul>
<p>核心线程数常用公式：</p>
<ul>
<li><p><strong>CPU 密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p>
</li>
<li><p><strong>I/O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数/ (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p>
<p>IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p>
</li>
</ul>
<h3 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h3><p>ExecutorService 类 API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void execute(Runnable command)</td>
<td>执行任务（Executor 类 API）</td>
</tr>
<tr>
<td>Future&lt;?&gt; submit(Runnable task)</td>
<td>提交任务 task()</td>
</tr>
<tr>
<td>Future submit(Callable\<T> task)</td>
<td>提交任务 task，用返回值 Future 获得任务执行结果</td>
</tr>
<tr>
<td>List<Future\<T>&gt; invokeAll(Collection&lt;? extends Callable\<T>&gt; tasks)</td>
<td>提交 tasks 中所有任务</td>
</tr>
<tr>
<td>List<Future\<T>&gt; invokeAll(Collection&lt;? extends Callable\<T>&gt; tasks, long timeout, TimeUnit unit)</td>
<td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td>
</tr>
<tr>
<td>T invokeAny(Collection&lt;? extends Callable\<T>&gt; tasks)</td>
<td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td>
</tr>
</tbody>
</table>
</div>
<p>execute 和 submit 都属于线程池的方法，对比：</p>
<ul>
<li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。</p>
<ul>
<li>底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></li>
</ul>
</li>
<li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301031757459.png" alt=""></p>
<h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><p>ExecutorService 类 API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void shutdown()</td>
<td>线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</td>
</tr>
<tr>
<td>List\<Runnable> shutdownNow()</td>
<td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td>
</tr>
<tr>
<td>boolean isShutdown()</td>
<td>不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</td>
</tr>
<tr>
<td>boolean isTerminated()</td>
<td>线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</td>
</tr>
<tr>
<td>boolean awaitTermination(long timeout, TimeUnit unit)</td>
<td>调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td>
</tr>
</tbody>
</table>
</div>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p>
<p>方法 1：主动捉异常</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ExecutorService executorService = Executors.newFixedThreadPool(1);
pool.submit(() -> {
    try {
        System.out.println("task1");
        int i = 1 / 0;
    } catch (Exception e) {
        e.printStackTrace();
    }
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法 2：使用 Future 对象</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ExecutorService executorService = Executors.newFixedThreadPool(1);
Future<?> future = pool.submit(() -> {
    System.out.println("task1");
    int i = 1 / 0;
    return true;
});
System.out.println(future.get());
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❹工作原理"><a href="#❹工作原理" class="headerlink" title="❹工作原理"></a>❹工作原理</h2><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="https://img.jwt1399.top/img/202301031724574.png" alt=""></p>
<ol>
<li><p>创建线程池，等待提交过来的任务请求（<strong>懒惰</strong>），调用 execute 方法才会创建线程【①】</p>
</li>
<li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务【②】</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列【③】</li>
<li>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行【④】</li>
<li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行【⑤】</li>
</ul>
</li>
<li><p>当一个线程完成任务时，会从队列中取下一个任务来执行【take/poll】</p>
</li>
<li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p>
</li>
</ol>
<h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个<code>原子变量 ctl</code> 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p>
<ul>
<li><p>状态表示：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位
private static final int COUNT_BITS = Integer.SIZE - 3;
// 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 => 5亿多
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301031912289.png" alt=""></p>
</li>
<li><p>四种状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 111 000000000000000000，转换成整数后其实就是一个【负数】
private static final int RUNNING    = -1 << COUNT_BITS;
// 000 000000000000000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
// 001 000000000000000000
private static final int STOP       =  1 << COUNT_BITS;
// 010 000000000000000000
private static final int TIDYING    =  2 << COUNT_BITS;
// 011 000000000000000000
private static final int TERMINATED =  3 << COUNT_BITS;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>| 状态       | 高3位 | 接收新任务 | 处理阻塞任务队列 | 说明                                      |<br>| ————— | ——- | ————— | ———————— | ————————————————————- |<br>| RUNNING    | 111   | Y          | Y                |                                           |<br>| SHUTDOWN   | 000   | N          | Y                | 不接收新任务，但处理阻塞队列剩余任务      |<br>| STOP       | 001   | N          | N                | 中断正在执行的任务，并抛弃阻塞队列任务    |<br>| TIDYING    | 010   | -          | -                | 任务全执行完毕，活动线程为 0 即将进入终结 |<br>| TERMINATED | 011   | -          | -                | 终止状态                                  |</p>
</li>
<li><p>获取当前线程池运行状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static int runStateOf(int c)     { return c & ~CAPACITY; }
// ~CAPACITY = ~000 11111111111111111111 = 111 000000000000000000000（取反）
// c == ctl = 111 000000000000000000111
// 111 000000000000000000111
// 111 000000000000000000000
// 111 000000000000000000000    获取到了运行状态
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获取当前线程池线程数量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static int workerCountOf(int c)  { return c & CAPACITY; }
//        c = 111 000000000000000000111
// CAPACITY = 000 111111111111111111111
//            000 000000000000000000111 => 7
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>重置当前线程池状态 ctl：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态
private static int ctlOf(int rs, int wc) { return rs | wc; }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>比较当前线程池 ctl 所表示的状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s
// 状态对比：RUNNING < SHUTDOWN < STOP < TIDYING < TERMINATED
private static boolean runStateLessThan(int c, int s) { return c < s; }
// 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s
private static boolean runStateAtLeast(int c, int s) { return c >= s; }
// 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN == 0
private static boolean isRunning(int c) { return c < SHUTDOWN; }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>设置线程池 ctl：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false
private boolean compareAndIncrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect + 1);
}
// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false
private boolean compareAndDecrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect - 1);
}
// 将 ctl 值减一，do while 循环会一直重试，直到成功为止
private void decrementWorkerCount() {
    do {} while (!compareAndDecrementWorkerCount(ctl.get()));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h3><p>成员变量</p>
<ul>
<li><p><strong>线程池中存放 Worker 的容器</strong>：线程池没有初始化，直接往池中加线程即可</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final HashSet<Worker> workers = new HashSet<Worker>();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>线程全局锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock
private final ReentrantLock mainLock = new ReentrantLock();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>可重入锁的条件变量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止
private final Condition termination = mainLock.newCondition()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>线程池相关参数：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile int corePoolSize;                // 核心线程数量
private volatile int maximumPoolSize;            // 线程池最大线程数量
private volatile long keepAliveTime;            // 空闲线程存活时间
private volatile ThreadFactory threadFactory;    // 创建线程时使用的线程工厂，默认是 DefaultThreadFactory
private final BlockingQueue<Runnable> workQueue;// 【超过核心线程提交任务就放入 阻塞队列】
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile RejectedExecutionHandler handler;    // 拒绝策略，juc包提供了4中方式
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();// 默认策略
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>记录线程池相关属性的数值：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private int largestPoolSize;        // 记录线程池生命周期内线程数最大值
private long completedTaskCount;    // 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收
// allowCoreThreadTimeOut(boolean value) 方法可以设置该值
private volatile boolean allowCoreThreadTimeOut;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>内部类：</p>
<ul>
<li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state = 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    final Thread thread;            // worker 内部封装的工作线程
    Runnable firstTask;                // worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask
    volatile long completedTasks;    // 记录当前 worker 所完成任务数量

    // 构造方法
    Worker(Runnable firstTask) {
        // 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁
           setState(-1);
        // firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务
        this.firstTask = firstTask;
        // 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()
        this.thread = getThreadFactory().newThread(this);
    }
    // 【不可重入锁】
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public Thread newThread(Runnable r) {
    // 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()
    Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
    if (t.isDaemon())
        t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
        t.setPriority(Thread.NORM_PRIORITY);
    return t;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>拒绝策略相关的内部类</p>
</li>
</ul>
<h3 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h4><ul>
<li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public Future<?> submit(Runnable task) {
    // 空指针异常
    if (task == null) throw new NullPointerException();
    // 把 Runnable 封装成未来任务对象，执行结果是 null，也可以通过参数指定 FutureTask#get 返回数据
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    // 执行方法
    execute(ftask);
    return ftask;
}

public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    // 把 Callable 封装成未来任务对象
    RunnableFuture<T> ftask = newTaskFor(task);
    // 执行方法
    execute(ftask);    
    // 返回未来任务对象，用来获取返回值
    return ftask;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    // Runnable 封装成 FutureTask，【指定返回值】
    return new FutureTask<T>(runnable, value);
}
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    // Callable 直接封装成 FutureTask
    return new FutureTask<T>(callable);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable
public void execute(Runnable command) {
    // 非空判断
    if (command == null)
        throw new NullPointerException();
      // 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。
    int c = ctl.get();
    // 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程
    if (workerCountOf(c) < corePoolSize) {
        // addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行
        if (addWorker(command, true))
            return;

        // 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态
        // SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）
        c = ctl.get();
    }
    // 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败
    //     判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务
        // 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务
        if (!isRunning(recheck) && remove(command))
            // 任务出队成功，走拒绝策略
            reject(command);
        // 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0
        // 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 【3】offer失败说明queue满了
    // 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】
    // 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h4><ul>
<li><p>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public int prestartAllCoreThreads() {
    int n = 0;
    while (addWorker(null, true))
        ++n;
    return n;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p>
<p>注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize
private boolean addWorker(Runnable firstTask, boolean core) {
    // 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1
    retry:
    for (;;) {
        // 获取 ctl 的值
        int c = ctl.get();
        // 获取当前线程池运行状态
        int rs = runStateOf(c);    

        // 判断当前线程池状态【是否允许添加线程】

        // 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务
        // 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】
        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;
        for (;;) {
            // 获取线程池中线程数量
            int wc = workerCountOf(c);
            // 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false
            if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量
            if (compareAndIncrementWorkerCount(c))
                // 申请成功，跳出了 retry 这个 for 自旋
                break retry;
            // CAS 失败，没有成功的申请到令牌
            c = ctl.get();
            // 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法
            if (runStateOf(c) != rs)
                // 返回外层循环检查是否能创建线程，在 if 语句中返回 false
                continue retry;

        }
    }

    //【令牌申请成功，开始创建线程】

    // 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动
    boolean workerStarted = false;
    // 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】
        w = new Worker(firstTask);
        // 将新创建的 worker 节点中的线程赋值给 t
        final Thread t = w.thread;
        // 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // 加互斥锁，要添加 worker 了
            mainLock.lock();
            try {
                // 获取最新线程池运行状态保存到 rs
                int rs = runStateOf(ctl.get());
                // 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】
                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                    // 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错
                    if (t.isAlive())
                        throw new IllegalThreadStateException();

                    //【将新建的 Worker 添加到线程池中】
                    workers.add(w);
                    int s = workers.size();
                    // 当前池中的线程数量是一个新高，更新 largestPoolSize
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 添加标记置为 true
                    workerAdded = true;
                }
            } finally {
                // 解锁啊
                mainLock.unlock();
            }
            // 添加成功就【启动线程执行任务】
            if (workerAdded) {
                // Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask
                t.start();
                // 运行标记置为 true
                workerStarted = true;
            }
        }
    } finally {
        // 如果启动线程失败，做清理工作
        if (! workerStarted)
            addWorkerFailed(w);
    }
    // 返回新创建的线程是否启动
    return workerStarted;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>addWorkerFailed()：清理任务</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void addWorkerFailed(Worker w) {
    final ReentrantLock mainLock = this.mainLock;
    // 持有线程池全局锁，因为操作的是线程池相关的东西
    mainLock.lock();
    try {
        //条件成立需要将 worker 在 workers 中清理出去。
        if (w != null)
            workers.remove(w);
        // 将线程池计数 -1，相当于归还令牌。
        decrementWorkerCount();
        // 尝试停止线程池
        tryTerminate();
    } finally {
        //释放线程池全局锁。
        mainLock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><ul>
<li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void run() {
    // ThreadPoolExecutor#runWorker()
    runWorker(this);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();    
    // 获取 worker 的 firstTask
    Runnable task = w.firstTask;
    // 引用置空，【防止复用该线程时重复执行该任务】
    w.firstTask = null;
    // 初始化 worker 时设置 state = -1，表示不允许抢占锁
    // 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁
    w.unlock();
    // true 表示发生异常退出，false 表示正常退出。
    boolean completedAbruptly = true;
    try {
        // firstTask 不是 null 就直接运行，否则去 queue 中获取任务
        // 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】
        while (task != null || (task = getTask()) != null) {
            // worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】
            w.lock();

            // 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 // 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记
                 (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())
                // 中断线程，设置线程的中断标志位为 true
                wt.interrupt();
            try {
                // 钩子方法，【任务执行的前置处理】
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 【执行任务】
                    task.run();
                } catch (Exception x) {
                     //.....
                } finally {
                    // 钩子方法，【任务执行的后置处理】
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;        // 将局部变量task置为null，代表任务执行完成
                w.completedTasks++;    // 更新worker完成任务数量
                w.unlock();            // 解锁
            }
        }
        // getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】
        completedAbruptly = false;    
    } finally {
        // 正常退出 completedAbruptly = false
           // 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行
        processWorkerExit(w, completedAbruptly);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>unlock()：重置锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void unlock() { release(1); }
// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法
protected boolean tryRelease(int unused) {
    setExclusiveOwnerThread(null);        // 设置持有者为 null
    setState(0);                        // 设置 state = 0
    return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private Runnable getTask() {
    // 超时标记，表示当前线程获取任务是否超时，true 表示已超时
    boolean timedOut = false; 
    for (;;) {
        int c = ctl.get();
        // 获取线程池当前运行状态
        int rs = runStateOf(c);

        // 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空
        // 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            // 使用 CAS 自旋的方式让 ctl 值 -1
            decrementWorkerCount();
            return null;
        }

        // 获取线程池中的线程数量
        int wc = workerCountOf(c);

        // 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断

        // timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取
        // timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取
        // 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收
        // 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        // 如果线程数量是否超过最大线程数，直接回收
        // 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：
        //       wc > 1 说明线程池还用其他线程，当前线程可以直接回收
        //    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】
        if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {
            // 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();
            // 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null
            if (r != null)
                return r;
            // 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null
            timedOut = true;
        } catch (InterruptedException retry) {
            // 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务
            // 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null
            timedOut = false;
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 正常退出 completedAbruptly = false，异常退出为 true
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    // 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了
    if (completedAbruptly) 
        // 从异常时到这里 ctl 一直没有 -1，需要在这里 -1
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    // 加锁
    mainLock.lock();
    try {
        // 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount
        completedTaskCount += w.completedTasks;
        // 将 worker 从线程池中移除
        workers.remove(w);
    } finally {
        mainLock.unlock();    // 解锁
    }
    // 尝试停止线程池，唤醒下一个线程
    tryTerminate();

    int c = ctl.get();
    // 线程池不是停止状态就应该有线程运行【担保机制】
    if (runStateLessThan(c, STOP)) {
        // 正常退出的逻辑，是对空闲线程回收，不是执行出错
        if (!completedAbruptly) {
            // 根据是否回收核心线程确定【线程池中的线程数量最小值】
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            // 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制
            if (min == 0 && !workQueue.isEmpty())
                min = 1;
            // 线程池中的线程数量大于最小值可以直接返回
            if (workerCountOf(c) >= min)
                return;
        }
        // 执行 task 时发生异常，有个线程因为异常终止了，需要添加
        // 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池
        addWorker(null, false);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h4><ul>
<li><p>shutdown()：停止线程池</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    // 获取线程池全局锁
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        // 空方法，子类可以扩展
        onShutdown(); 
    } finally {
        // 释放线程池全局锁
        mainLock.unlock();
    }
    tryTerminate();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    / /持有全局锁
    mainLock.lock();
    try {
        // 遍历所有 worker
        for (Worker w : workers) {
            // 获取当前 worker 的线程
            Thread t = w.thread;
            // 条件一成立：说明当前迭代的这个线程尚未中断
            // 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的
            //           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    // 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    // 释放worker的独占锁
                    w.unlock();
                }
            }
            // false，代表中断所有的线程
            if (onlyOne)
                break;
        }

    } finally {
        // 释放全局锁
        mainLock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public List<Runnable> shutdownNow() {
    // 返回值引用
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    // 获取线程池全局锁
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 设置线程池状态为STOP
        advanceRunState(STOP);
        // 中断线程池中【所有线程】
        interruptWorkers();
        // 从阻塞队列中导出未处理的task
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }

    tryTerminate();
    // 返回当前任务队列中 未处理的任务。
    return tasks;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final void tryTerminate() {
    for (;;) {
        // 获取 ctl 的值
        int c = ctl.get();
        // 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回
        if (isRunning(c) || runStateAtLeast(c, TIDYING) ||
            // 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;

        // 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空
        // 判断线程池中线程的数量
        if (workerCountOf(c) != 0) {
            // 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲
            // 唤醒后的线程会在getTask()方法返回null，
            // 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程
            interruptIdleWorkers(ONLY_ONE);
            return;
        }
        // 池中的线程数量为 0 来到这里
        final ReentrantLock mainLock = this.mainLock;
        // 加全局锁
        mainLock.lock();
        try {
            // 设置线程池状态为 TIDYING 状态，线程数量为 0
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // 结束线程池
                    terminated();
                } finally {
                    // 设置线程池状态为TERMINATED状态。
                    ctl.set(ctlOf(TERMINATED, 0));
                    // 【唤醒所有调用 awaitTermination() 方法的线程】
                    termination.signalAll();
                }
                return;
            }
        } finally {
            // 释放线程池全局锁
            mainLock.unlock();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h4 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h4><p><img src="https://img.jwt1399.top/img/202301031939074.png" alt="img"></p>
<p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws ExecutionException, InterruptedException {
    FutureTask<String> task = new FutureTask<>(new Callable<String>() {
        @Override
        public String call() throws Exception {
            return "Hello World";
        }
    });
    new Thread(task).start();    //启动线程
    String msg = task.get();    //获取返回任务数据
    System.out.println(msg);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public FutureTask(Callable<V> callable){
    this.callable = callable;    // 属性注入
    this.state = NEW;             // 任务状态设置为 new
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public FutureTask(Runnable runnable, V result) {
    // 适配器模式
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       
}
public static <T> Callable<T> callable(Runnable task, T result) {
    if (task == null) throw new NullPointerException();
    // 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取
    // 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】
    return new RunnableAdapter<T>(task, result);
}
static final class RunnableAdapter<T> implements Callable<T> {
    final Runnable task;
    final T result;
    // 构造方法
    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;
    }
    public T call() {
        // 实则调用 Runnable#run 方法
        task.run();
        // 返回值为构造 FutureTask 对象时传入的返回值或者是 null
        return result;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>FutureTask 类的成员属性：</p>
<ul>
<li><p>任务状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示当前task状态
private volatile int state;
// 当前任务尚未执行
private static final int NEW          = 0;
// 当前任务正在结束，尚未完全结束，一种临界状态
private static final int COMPLETING   = 1;
// 当前任务正常结束
private static final int NORMAL       = 2;
// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了
private static final int EXCEPTIONAL  = 3;
// 当前任务被取消
private static final int CANCELLED    = 4;
// 当前任务中断中
private static final int INTERRUPTING = 5;
// 当前任务已中断
private static final int INTERRUPTED  = 6;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>任务对象：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private Callable<V> callable;    // Runnable 使用装饰者模式伪装成 Callable
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值
// 非正常情况：callable 向上抛出异常，outcome 保存异常
private Object outcome;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>执行当前任务的线程对象：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile Thread runner;    // 当前任务被线程执行期间，保存当前执行任务的线程对象引用
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>线程阻塞队列的头节点</strong>：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程
private volatile WaitNode waiters;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>内部类：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final class WaitNode {
    // 单向链表
    volatile Thread thread;
    volatile WaitNode next;
    WaitNode() { thread = Thread.currentThread(); }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
<h4 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h4><p>FutureTask 类的成员方法：</p>
<ul>
<li><p><strong>FutureTask#run</strong>：任务执行入口</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void run() {
    //条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了
    //条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))
        return;
    try {
        // 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】
        Callable<V> c = callable;
        // 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务
        // 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】
        if (c != null && state == NEW) {
            V result;
            // true 表示 callable.run 代码块执行成功 未抛出异常
            // false 表示 callable.run 代码块执行失败 抛出异常
            boolean ran;
            try {
                // 【调用自定义的方法，执行结果赋值给 result】
                result = c.call();
                // 没有出现异常
                ran = true;
            } catch (Throwable ex) {
                // 出现异常，返回值置空，ran 置为 false
                result = null;
                ran = false;
                // 设置返回的异常
                setException(ex);
            }
            // 代码块执行正常
            if (ran)
                // 设置返回的结果
                set(result);
        }
    } finally {
        // 任务执行完成，取消线程的引用，help GC
        runner = null;
        int s = state;
        // 判断任务是不是被中断
        if (s >= INTERRUPTING)
            // 执行中断处理方法
            handlePossibleCancellationInterrupt(s);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected void set(V v) {
    // CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        // 【将结果赋值给 outcome】
        outcome = v;
        // 将当前任务状态修改为 NORMAL 正常结束状态。
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL);
        finishCompletion();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#setException：设置异常返回值</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected void setException(Throwable t) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        // 赋值给返回结果，用来向上层抛出来的异常
        outcome = t;
        // 将当前任务的状态 修改为 EXCEPTIONAL
        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL);
        finishCompletion();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void finishCompletion() {
    // 遍历所有的等待的节点，q 指向头节点
    for (WaitNode q; (q = waiters) != null;) {
        // 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行
        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
            // 自旋
            for (;;) {
                // 获取当前 WaitNode 节点封装的 thread
                Thread t = q.thread;
                // 当前线程不为 null，唤醒当前 get() 等待获取数据的线程
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                // 获取当前节点的下一个节点
                WaitNode next = q.next;
                // 当前节点是最后一个节点了
                if (next == null)
                    break;
                // 断开链表
                q.next = null; // help gc
                q = next;
            }
            break;
        }
    }
    done();
    callable = null;    // help GC
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void handlePossibleCancellationInterrupt(int s) {
    if (s == INTERRUPTING)
        // 中断状态中
        while (state == INTERRUPTING)
            // 等待中断完成
            Thread.yield();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public V get() throws InterruptedException, ExecutionException {
    // 获取当前任务状态
    int s = state;
    // 条件成立说明任务还没执行完成
    if (s <= COMPLETING)
        // 返回 task 当前状态，可能当前线程在里面已经睡了一会
        s = awaitDone(false, 0L);
    return report(s);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private int awaitDone(boolean timed, long nanos) throws InterruptedException {
    // 0 不带超时
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    // 引用当前线程，封装成 WaitNode 对象
    WaitNode q = null;
    // 表示当前线程 waitNode 对象，是否进入阻塞队列
    boolean queued = false;
    // 【三次自旋开始休眠】
    for (;;) {
        // 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记
        if (Thread.interrupted()) {
            // 当前线程对应的等待 node 出队，
            removeWaiter(q);
            throw new InterruptedException();
        }
        // 获取任务状态
        int s = state;
        // 条件成立说明当前任务执行完成已经有结果了
        if (s > COMPLETING) {
            // 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC
            if (q != null)
                q.thread = null;
            // 返回当前的状态
            return s;
        }
        // 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu
        else if (s == COMPLETING) 
            Thread.yield();
        // 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象
        else if (q == null)
            q = new WaitNode();
        // 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队
        else if (!queued)
            // waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q);
        // 【第三次自旋】，会到这里，或者 else 内
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos <= 0L) {
                removeWaiter(q);
                return state;
            }
            // 阻塞指定的时间
            LockSupport.parkNanos(this, nanos);
        }
        // 条件成立：说明需要阻塞
        else
            // 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断
            LockSupport.park(this);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private V report(int s) throws ExecutionException {
    // 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取
    Object x = outcome;
    // 当前任务状态正常结束
    if (s == NORMAL)
        return (V)x;    // 直接返回 callable 的逻辑结果
    // 当前任务被取消或者中断
    if (s >= CANCELLED)
        throw new CancellationException();        // 抛出异常
    // 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常
    throw new ExecutionException((Throwable)x);    
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean cancel(boolean mayInterruptIfRunning) {
    // 条件一：表示当前任务处于运行中或者处于线程池任务队列中
    // 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败
    if (!(state == NEW &&
          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
        return false;
    try {
        // 如果任务已经被执行，是否允许打断
        if (mayInterruptIfRunning) {
            try {
                // 获取执行当前 FutureTask 的线程
                Thread t = runner;
                if (t != null)
                    // 打断执行的线程
                    t.interrupt();
            } finally {
                // 设置任务状态为【中断完成】
                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
            }
        }
    } finally {
        // 唤醒所有 get() 阻塞的线程
        finishCompletion();
    }
    return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="❺任务调度"><a href="#❺任务调度" class="headerlink" title="❺任务调度"></a>❺任务调度</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static void method1() {
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() {
        @Override
        public void run() {
            System.out.println("task 1");
            //int i = 1 / 0;//任务一的出错会导致任务二无法执行
            Thread.sleep(2000);
        }
    };
    TimerTask task2 = new TimerTask() {
        @Override
        public void run() {
            System.out.println("task 2");
        }
    };
    // 使用 timer 添加两个任务，希望它们都在 1s 后执行
    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行
    timer.schedule(task1, 1000);//17:45:56 c.ThreadPool [Timer-0] - task 1
    timer.schedule(task2, 1000);//17:45:58 c.ThreadPool [Timer-0] - task 2
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p>
<ul>
<li>使用内部类 ScheduledFutureTask 封装任务</li>
<li>使用内部类 DelayedWorkQueue 作为线程池队列</li>
<li>重写 onShutdown 方法去处理 shutdown 后的任务</li>
<li>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</li>
</ul>
<p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ScheduledThreadPoolExecutor(int corePoolSize) {
    // 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          // 阻塞队列是 DelayedWorkQueue
          new DelayedWorkQueue());
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用 API：</p>
<ul>
<li><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li>
</ul>
<p>基本使用：</p>
<ul>
<li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args){
    // 线程池大小为1时也是串行执行
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
    // 添加两个任务，都在 1s 后同时执行
    executor.schedule(() -> {
        System.out.println("任务1，执行时间：" + new Date());
        //int i = 1 / 0;
        try { Thread.sleep(2000); } catch (InterruptedException e) { }
    }, 1000, TimeUnit.MILLISECONDS);

    executor.schedule(() -> {
        System.out.println("任务2，执行时间：" + new Date());
    }, 1000, TimeUnit.MILLISECONDS);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>定时任务 <code>scheduleAtFixedRate</code>：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
    System.out.println("start..." + new Date());

    pool.scheduleAtFixedRate(() -> {
        System.out.println("running..." + new Date());
        Thread.sleep(2000);
    }, 1, 1, TimeUnit.SECONDS);
}

/*start...Sat Apr 24 18:08:12 CST 2021
running...Sat Apr 24 18:08:13 CST 2021
running...Sat Apr 24 18:08:15 CST 2021
running...Sat Apr 24 18:08:17 CST 2021
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>定时任务 <code>scheduleWithFixedDelay</code>：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args){
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);
    System.out.println("start..." + new Date());

    pool.scheduleWithFixedDelay(() -> {
        System.out.println("running..." + new Date());
        Thread.sleep(2000);
    }, 1, 1, TimeUnit.SECONDS);
}
/*start...Sat Apr 24 18:11:41 CST 2021
running...Sat Apr 24 18:11:42 CST 2021
running...Sat Apr 24 18:11:45 CST 2021
running...Sat Apr 24 18:11:48 CST 2021
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="❻ForkJoin"><a href="#❻ForkJoin" class="headerlink" title="❻ForkJoin"></a>❻ForkJoin</h2><p>Fork/Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p>
<p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p>
<ul>
<li><p>Fork/Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p>
</li>
<li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p>
</li>
<li>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(4);
    System.out.println(pool.invoke(new MyTask(5)));
    //拆分  5 + MyTask(4) --> 4 + MyTask(3) -->
}

// 1~ n 之间整数的和
class MyTask extends RecursiveTask<Integer> {
    private int n;

    public MyTask(int n) {
        this.n = n;
    }

    @Override
    public String toString() {
        return "MyTask{" + "n=" + n + '}';
    }

    @Override
    protected Integer compute() {
        // 如果 n 已经为 1，可以求得结果了
        if (n == 1) {
            return n;
        }
        // 将任务进行拆分(fork)
        MyTask t1 = new MyTask(n - 1);
        t1.fork();
        // 合并(join)结果
        int result = n + t1.join();
        return result;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>继续拆分优化：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class AddTask extends RecursiveTask<Integer> {
    int begin;
    int end;
    public AddTask(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    public String toString() {
        return "{" + begin + "," + end + '}';
    }

    @Override
    protected Integer compute() {
        // 5, 5
        if (begin == end) {
            return begin;
        }
        // 4, 5  防止多余的拆分  提高效率
        if (end - begin == 1) {
            return end + begin;
        }
        // 1 5
        int mid = (end + begin) / 2; // 3
        AddTask t1 = new AddTask(begin, mid); // 1,3
        t1.fork();
        AddTask t2 = new AddTask(mid + 1, end); // 4,5
        t2.fork();
        int result = t1.join() + t2.join();
        return result;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p>
<ul>
<li>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</li>
<li>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</li>
<li>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</li>
</ul>
<h1 id="⑥JUC锁"><a href="#⑥JUC锁" class="headerlink" title="⑥JUC锁"></a>⑥JUC锁</h1><h2 id="❶AQS"><a href="#❶AQS" class="headerlink" title="❶AQS"></a>❶AQS</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p>
<p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p>
<ul>
<li>独占模式是只有一个线程能够访问资源，如 ReentrantLock</li>
<li>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</li>
</ul>
<p>AQS 核心思想：</p>
<ul>
<li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</li>
<li>如果请求的共享资源被占用，AQS 用CLH 队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</li>
</ul>
<p><strong>CLH 队列</strong>是一个<strong>虚拟的双向队列</strong>（即不存在队列实例，仅存在结点之间的关联关系）。</p>
<p><img src="https://img.jwt1399.top/img/202301041734514.png" alt=""></p>
<p>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。同时 AQS 还维护两个指针 Head 和 Tail，分别指向队列的头部和尾部。</p>
<p><img src="https://img.jwt1399.top/img/202301041734275.png" alt="AQS原理图"></p>
<h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>设计原理：</p>
<ul>
<li><p>获取锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">while(state 状态不允许获取) {    // tryAcquire(arg)
    if(队列中还没有此线程) {
        入队并阻塞 park
    }
}
当前线程出队
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>释放锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">if(state 状态允许了) {    // tryRelease(arg)
    恢复阻塞的线程(s) unpark
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>AbstractQueuedSynchronizer 中 state 设计：</p>
<ul>
<li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile int state;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p>
</li>
<li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p>
</li>
<li><p>state API：</p>
<ul>
<li><code>protected final int getState()</code>：获取 state 状态</li>
<li><code>protected final void setState(int newState)</code>：设置 state 状态</li>
<li><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</li>
</ul>
</li>
</ul>
<p>封装线程的 Node 节点中 waitstate 设计：</p>
<ul>
<li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p>
</li>
<li><p>表示 Node 节点的状态，有以下几种状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 默认为 0
volatile int waitStatus;
// 由于超时或中断，此节点被取消，不会再改变状态
static final int CANCELLED =  1;
// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】
static final int SIGNAL    = -1;
// 此节点当前在条件队列中
static final int CONDITION = -2;
// 将releaseShared传播到其他节点
static final int PROPAGATE = -3;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>阻塞恢复设计：</p>
<ul>
<li>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</li>
<li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li>
<li>park 线程可以通过 interrupt 打断</li>
</ul>
<p>队列设计：</p>
<ul>
<li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 头结点，指向哑元节点
private transient volatile Node head;
// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列
private transient volatile Node tail;

static final class Node {
    // 枚举：共享模式
    static final Node SHARED = new Node();
    // 枚举：独占模式
    static final Node EXCLUSIVE = null;
    // node 需要构建成 FIFO 队列，prev 指向前继节点
    volatile Node prev;
    // next 指向后继节点
    volatile Node next;
    // 当前 node 封装的线程
    volatile Thread thread;
    // 条件队列是单向链表，只有后继指针，条件队列使用该属性
    Node nextWaiter;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301041747575.png" alt=""></p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java"> public class ConditionObject implements Condition, java.io.Serializable {
     // 指向条件队列的第一个 node 节点
     private transient Node firstWaiter;
     // 指向条件队列的最后一个 node 节点
     private transient Node lastWaiter;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p>
<ul>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</li>
</ul>
<p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">isHeldExclusively()        //该线程是否正在独占资源。只有用到condition才需要去实现它
tryAcquire(int)            //独占方式。尝试获取资源，成功则返回true，失败则返回false
tryRelease(int)            //独占方式。尝试释放资源，成功则返回true，失败则返回false
tryAcquireShared(int)    //共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源
tryReleaseShared(int)    //共享方式。尝试释放资源，成功则返回true，失败则返回false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></li>
<li>这些方法的实现必须是内部线程安全的</li>
<li>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</li>
</ul>
<h3 id="自定义不可重入锁"><a href="#自定义不可重入锁" class="headerlink" title="自定义不可重入锁"></a>自定义不可重入锁</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">class MyLock implements Lock {
    //独占锁 不可重入
    class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                // 加上锁 设置 owner 为当前线程
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        @Override   //解锁
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            setState(0);//volatile 修饰的变量放在后面，防止指令重排
            return true;
        }
        @Override   //是否持有独占锁
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
        public Condition newCondition() {
            return new ConditionObject();
        }
    }

    private MySync sync = new MySync();

    @Override   //加锁（不成功进入等待队列等待）
    public void lock() {
        sync.acquire(1);
    }

    @Override   //加锁 可打断
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override   //尝试加锁，尝试一次
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override   //尝试加锁，带超时
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override   //解锁
    public void unlock() {
        sync.release(1);
    }

    @Override   //条件变量
    public Condition newCondition() {
        return sync.newCondition();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❷ReentrantLock"><a href="#❷ReentrantLock" class="headerlink" title="❷ReentrantLock"></a>❷ReentrantLock</h2><h3 id="⓿基本使用"><a href="#⓿基本使用" class="headerlink" title="⓿基本使用"></a>⓿基本使用</h3><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>ReentrantLock 默认是不公平的：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantLock() {
    sync = new NonfairSync();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明：公平锁一般没有必要，会降低并发度</p>
<h3 id="❶非公平锁原理"><a href="#❶非公平锁原理" class="headerlink" title="❶非公平锁原理"></a>❶非公平锁原理</h3><h4 id="加解锁流程"><a href="#加解锁流程" class="headerlink" title="加解锁流程"></a>加解锁流程</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Thread-0执行，没有竞争时</th>
<th>Thread-1执行，第一个竞争出现</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://img.jwt1399.top/img/202301042023014.png" alt=""></td>
<td><img src="https://img.jwt1399.top/img/202301042023877.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>Thread-1 执行时</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败（第一次）</li>
<li>进入 <code>tryAcquire</code> 逻辑，这时 state 已经是 1，结果仍然失败（第二次）</li>
<li>进入 <code>addWaiter</code> 逻辑，构造 Node 队列<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202301042023669.png" alt=""></p>
<p>线程节点加入阻塞队列成功，当前线程进入 <code>acquireQueued</code> 逻辑，阻塞线程</p>
<ol>
<li><code>acquireQueued</code> 会在一个死循环（自旋）中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果当前线程是在 head 节点后，再次 <code>tryAcquire</code> 尝试获取锁，当然这时 state 仍为 1，失败（第三次）</li>
<li>进入 <code>shouldParkAfterFailedAcquire</code> 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false，waitStatus 为 -1 的节点用来唤醒下一个节点</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202301042024786.png" alt=""></p>
<ol>
<li><code>shouldParkAfterFailedAcquire</code> 执行完毕回到 <code>acquireQueued</code> ，再次 <code>tryAcquire</code> 尝试获取锁，当然这时 state 仍为 1，失败（第四次）</li>
<li>当再次进入 <code>shouldParkAfterFailedAcquire</code> 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202301042024607.png" alt=""></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="https://img.jwt1399.top/img/202301042024307.png" alt=""></p>
<p>Thread-0 释放锁，进入 <code>tryRelease</code> 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state = 0</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301042024640.png" alt=""></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 <code>unparkSuccessor</code> 流程</p>
<p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
<p>回到 Thread-1 的 <code>acquireQueued</code> 流程</p>
<p><img src="https://img.jwt1399.top/img/202301042024310.png" alt=""></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<p><img src="https://img.jwt1399.top/img/202301042024253.png" alt=""></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h4 id="加锁源码"><a href="#加锁源码" class="headerlink" title="加锁源码"></a>加锁源码</h4><p>ReentrantLock 默认是不公平的：NonfairSync 继承自 AQS</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantLock() {
    sync = new NonfairSync();
}

public void lock() {
    sync.lock();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// ReentrantLock.NonfairSync#lock
final void lock() {
    // 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】
    if (compareAndSetState(0, 1))
        // 设置当前线程为独占线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);//失败进入
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// AbstractQueuedSynchronizer#acquire
public final void acquire(int arg) {
    // tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程
    // acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        // 如果线程被中断了逻辑来到这，完成一次真正的打断效果
        selfInterrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301042023877.png" style="zoom:50%;" /></p>
<ul>
<li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p>
<ul>
<li>当前 AQS 处于无锁状态</li>
<li>加锁线程就是当前线程，说明发生了锁重入</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// ReentrantLock.NonfairSync#tryAcquire
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
// 抢占成功返回 true，抢占失败返回 false
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    // state 值
    int c = getState();
    // 条件成立说明当前处于【无锁状态】
    if (c == 0) {
        //如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁        
        if (compareAndSetState(0, acquires)) {
            // 获取锁成功设置当前线程为独占锁线程。
            setExclusiveOwnerThread(current);
            return true;
         }    
    }    
       // 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】
    else if (current == getExclusiveOwnerThread()) {
        // 更新锁重入的值
        int nextc = c + acquires;
        // 越界判断，当重入的深度很深时，会导致 nextc < 0，int值达到最大之后再 + 1 变负数
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内
        setState(nextc);
        return true;
    }
    // 获取失败
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>接下来进入 addWaiter 逻辑，构造 Node 队列，前置条件是当前线程获取锁失败，说明有线程占用了锁</p>
<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></li>
<li>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点
private Node addWaiter(Node mode) {
    // 将当前线程关联到一个 Node 对象上, 模式为独占模式   
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    // 快速入队，如果 tail 不为 null，说明存在阻塞队列
    if (pred != null) {
        // 将当前节点的前驱节点指向 尾节点
        node.prev = pred;
        // 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】
        if (compareAndSetTail(pred, node)) {
            pred.next = node;// 双向链表
            return node;
        }
    }
    // 初始时队列为空，或者 CAS 失败进入这里
    enq(node);
    return node;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// AbstractQueuedSynchronizer#enq
private Node enq(final Node node) {
    // 自旋入队，必须入队成功才结束循环
    for (;;) {
        Node t = tail;
        // 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】
        if (t == null) {
            // 设置一个【哑元节点】，头尾指针都指向该节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】
            node.prev = t;
            // 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】
            if (compareAndSetTail(t, node)) {
                //【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】
                t.next = node;
                return t;    // 返回当前 node 的前驱节点
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301042023669.png" alt=""></p>
</li>
<li><p>线程节点加入阻塞队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p>
<ul>
<li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p>
</li>
<li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final boolean acquireQueued(final Node node, int arg) {
    // true 表示当前线程抢占锁失败，false 表示成功
    boolean failed = true;
    try {
        // 中断标记，表示当前线程是否被中断
        boolean interrupted = false;
        for (;;) {
            // 获得当前线程节点的前驱节点
            final Node p = node.predecessor();
            // 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁
            if (p == head && tryAcquire(arg)) {
                // 获取成功, 设置当前线程自己的 node 为 head
                setHead(node);
                p.next = null; // help GC
                // 表示抢占锁成功
                failed = false;
                // 返回当前线程是否被中断
                return interrupted;
            }
            // 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                // 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑
                // 【就算被打断了，也会继续循环，并不会返回】
                interrupted = true;
        }
    } finally {
        // 【可打断模式下才会进入该逻辑】
        if (failed)
            cancelAcquire(node);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    // 表示前置节点是个可以唤醒当前节点的节点，返回 true
    if (ws == Node.SIGNAL)
        return true;
    // 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试
    if (ws > 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        // 获取到非取消的节点，连接上当前节点
        pred.next = node;
    // 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑
    } else {
        // 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    // 返回不应该 park，再次尝试一次
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final boolean parkAndCheckInterrupt() {
    // 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效
    LockSupport.park(this);
    // 判断当前线程是否被打断，清除打断标记
    return Thread.interrupted();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>再有多个线程经历竞争失败后：</p>
<p><img src="https://img.jwt1399.top/img/202301042024307.png" alt=""></p>
</li>
</ul>
<h4 id="解锁源码"><a href="#解锁源码" class="headerlink" title="解锁源码"></a>解锁源码</h4><p>ReentrantLock#unlock：释放锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void unlock() {
    sync.release(1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Thread-0 释放锁，进入 release 流程</p>
<ul>
<li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state = 0</p>
</li>
<li><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// AbstractQueuedSynchronizer#release
public final boolean release(int arg) {
    // 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】
    if (tryRelease(arg)) {
        // 队列头节点
        Node h = head;
        // 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点
        // 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }    
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// ReentrantLock.Sync#tryRelease
protected final boolean tryRelease(int releases) {
    // 减去释放的值，可能重入
    int c = getState() - releases;
    // 如果当前线程不是持有锁的线程直接报错
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    // 是否已经完全释放锁
    boolean free = false;
    // 支持锁重入, 只有 state 减为 0, 才完全释放锁成功
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    // 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS
    setState(c);
    return free;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p>
<ul>
<li>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void unparkSuccessor(Node node) {
    // 当前节点的状态
    int ws = node.waitStatus;    
    if (ws < 0)        
        // 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了
        compareAndSetWaitStatus(node, ws, 0);    
    // 找到需要 unpark 的节点，当前节点的下一个    
    Node s = node.next;    
    // 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点
    if (s == null || s.waitStatus > 0) {
        s = null;
        // AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了
        for (Node t = tail; t != null && t != node; t = t.prev)
            // 说明当前线程状态需要被唤醒
            if (t.waitStatus <= 0)
                // 置换引用
                s = t;
    }
    // 【找到合适的可以被唤醒的 node，则唤醒线程】
    if (s != null)
        LockSupport.unpark(s.thread);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点</p>
</li>
<li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301042024310.png" alt=""></p>
</li>
<li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301042024253.png" alt=""></p>
<h3 id="❷公平锁原理"><a href="#❷公平锁原理" class="headerlink" title="❷公平锁原理"></a>❷公平锁原理</h3><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;
    final void lock() {
        acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 锁重入
        return false;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final boolean hasQueuedPredecessors() {    
    Node t = tail;
    Node h = head;
    Node s;    
    // 头尾指向一个节点，链表为空，返回false
    return h != t &&
        // 头尾之间有节点，判断头节点的下一个是不是空
        // 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❸可重入原理"><a href="#❸可重入原理" class="headerlink" title="❸可重入原理"></a>❸可重入原理</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">static final class NonfairSync extends Sync {
    // ...
        // Sync 继承过来的方法, 方便阅读, 放在此处
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❹可打断原理"><a href="#❹可打断原理" class="headerlink" title="❹可打断原理"></a>❹可打断原理</h3><p>1.不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final void acquire(int arg) {    
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))//阻塞等待        
        // 如果acquireQueued返回true，打断状态 interrupted = true        
        selfInterrupt();
}
static void selfInterrupt() {
    // 知道自己被打断了，需要重新产生一次中断完成中断效果
    Thread.currentThread().interrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final boolean acquireQueued(final Node node, int arg) {    
    try {        
        boolean interrupted = false;        
        for (;;) {            
            final Node p = node.predecessor();            
            if (p == head && tryAcquire(arg)) {                
                setHead(node);                
                p.next = null; // help GC                
                failed = false;                
                // 还是需要获得锁后, 才能返回打断状态
                return interrupted;            
            }            
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()){
                // 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】
                interrupted = true;  
            }                  
        } 
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
 private final boolean parkAndCheckInterrupt() {    
     // 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效
     LockSupport.park(this);    
     // 判断当前线程是否被打断，清除打断标记，被打断返回true
     return Thread.interrupted();
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2.可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void lockInterruptibly() throws InterruptedException {    
    sync.acquireInterruptibly(1);
}
public final void acquireInterruptibly(int arg) {
    // 被其他线程打断了直接返回 false
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        // 没获取到锁，进入这里
        doAcquireInterruptibly(arg);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doAcquireInterruptibly(int arg) throws InterruptedException {
    // 返回封装当前线程的节点
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            //...
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                // 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果
                throw new InterruptedException();
        }    
    } finally {
        // 抛出异常前会进入这里
        if (failed)
            // 取消当前线程的节点
            cancelAcquire(node);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 取消节点出队的逻辑
private void cancelAcquire(Node node) {
    // 判空
    if (node == null)
        return;
    // 把当前节点封装的 Thread 置为空
    node.thread = null;
    // 获取当前取消的 node 的前驱节点
    Node pred = node.prev;
    // 前驱节点也被取消了，循环找到前面最近的没被取消的节点
    while (pred.waitStatus > 0)
        node.prev = pred = pred.prev;

    // 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus > 0 的节点
    Node predNext = pred.next;

    // 把当前节点的状态设置为 【取消状态 1】
    node.waitStatus = Node.CANCELLED;

    // 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点
    if (node == tail && compareAndSetTail(node, pred)) {
        // 把前驱节点的后继节点置空，这里直接把所有的取消节点出队
        compareAndSetNext(pred, predNext, null);
    } else {
        // 说明当前节点不是 tail 节点
        int ws;
        // 条件一成立说明当前节点不是 head.next 节点
        if (pred != head &&
            // 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             // 如果状态不是 -1，设置前驱节点的状态为 -1
             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
            // 前驱节点的线程不为null
            pred.thread != null) {

            Node next = node.next;
            // 当前节点的后继节点是正常节点
            if (next != null && next.waitStatus <= 0)
                // 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】
                compareAndSetNext(pred, predNext, next);
        } else {
            // 当前节点是 head.next 节点，唤醒当前节点的后继节点
            unparkSuccessor(node);
        }
        node.next = node; // help GC
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="❺锁超时原理"><a href="#❺锁超时原理" class="headerlink" title="❺锁超时原理"></a>❺锁超时原理</h3><ul>
<li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final long spinForTimeoutThreshold = 1000L;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p>
</li>
<li><p>tryLock()</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean tryLock() {   
    // 只尝试一次
    return sync.nonfairTryAcquire(1);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>tryLock(long timeout, TimeUnit unit)</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final boolean tryAcquireNanos(int arg, long nanosTimeout) {
    if (Thread.interrupted())        
        throw new InterruptedException();    
    // tryAcquire 尝试一次
    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
}
protected final boolean tryAcquire(int acquires) {    
    return nonfairTryAcquire(acquires);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private boolean doAcquireNanos(int arg, long nanosTimeout) {    
    if (nanosTimeout <= 0L)
        return false;
    // 获取最后期限的时间戳
    final long deadline = System.nanoTime() + nanosTimeout;
    //...
    try {
        for (;;) {
            //...
            // 计算还需等待的时间
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout <= 0L)    //时间已到     
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &&
                // 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点
                nanosTimeout > spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            // 【被打断会报异常】
            if (Thread.interrupted())
                throw new InterruptedException();
        }    
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="❻条件变量原理"><a href="#❻条件变量原理" class="headerlink" title="❻条件变量原理"></a>❻条件变量原理</h3><h4 id="await-singal流程"><a href="#await-singal流程" class="headerlink" title="await/singal流程"></a>await/singal流程</h4><p><strong>await流程</strong></p>
<p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<p><img src="https://img.jwt1399.top/img/202301042053395.png" alt=""></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="https://img.jwt1399.top/img/202301042053463.png" alt=""></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="https://img.jwt1399.top/img/202301042053665.png" alt=""></p>
<p>park 阻塞 Thread-0</p>
<p><img src="https://img.jwt1399.top/img/202301042053656.png" alt=""></p>
<p><strong>singal流程</strong></p>
<p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="https://img.jwt1399.top/img/202301042053253.png" alt=""></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="https://img.jwt1399.top/img/202301042053575.png" alt=""></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p>
<p><img src="https://img.jwt1399.top/img/202301042053188.png" alt=""></p>
<p>Thread-1 释放锁，进入 unlock 流程</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p>
<ul>
<li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final void await() throws InterruptedException {
     // 判断当前线程是否是中断状态，是就直接给个中断异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 将调用 await 的线程包装成 Node，添加到条件队列并返回
    Node node = addConditionWaiter();
    // 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】
    int savedState = fullyRelease(node);

    // 设置打断模式为没有被打断，状态码为 0
    int interruptMode = 0;

    // 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        // 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】

    // 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;

    // node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null
    if (node.nextWaiter != null)
        // 清理条件队列内所有已取消的 Node
        unlinkCancelledWaiters();
    // 条件成立说明挂起期间发生过中断
    if (interruptMode != 0)
        // 应用打断模式
        reportInterruptAfterWait(interruptMode);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 打断模式 - 在退出等待时重新设置打断状态
private static final int REINTERRUPT = 1;
// 打断模式 - 在退出等待时抛出异常
private static final int THROW_IE = -1;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301042053463.png" alt=""></p>
</li>
<li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private Node addConditionWaiter() {
    // 获取当前条件队列的尾节点的引用，保存到局部变量 t 中
    Node t = lastWaiter;
    // 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断
    if (t != null && t.waitStatus != Node.CONDITION) {
        // 清理条件队列内所有已取消的 Node
        unlinkCancelledWaiters();
        // 清理完成重新获取 尾节点 的引用
        t = lastWaiter;
    }
    // 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;        // 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】
    else
        t.nextWaiter = node;    // 非空队列队尾追加
    lastWaiter = node;            // 更新队尾的引用
    return node;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】
private void unlinkCancelledWaiters() {
    // 从头节点开始遍历【FIFO】
    Node t = firstWaiter;
    // 指向正常的 CONDITION 节点
    Node trail = null;
    // 等待队列不空
    while (t != null) {
        // 获取当前节点的后继节点
        Node next = t.nextWaiter;
        // 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的
        if (t.waitStatus != Node.CONDITION) { 
            // 不是正常节点，需要 t 与下一个节点断开
            t.nextWaiter = null;
            // 条件成立说明遍历到的节点还未碰到过正常节点
            if (trail == null)
                // 更新 firstWaiter 指针为下个节点
                firstWaiter = next;
            else
                // 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】
                trail.nextWaiter = next;
            // t 是尾节点了，更新 lastWaiter 指向最后一个正常节点
            if (next == null)
                lastWaiter = trail;
        } else {
            // trail 指向的是正常节点 
            trail = t;
        }
        // 把 t.next 赋值给 t，循环遍历
        t = next; 
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 线程可能重入，需要将 state 全部释放
final int fullyRelease(Node node) {
    // 完全释放锁是否成功，false 代表成功
    boolean failed = true;
    try {
        // 获取当前线程所持有的 state 值总数
        int savedState = getState();
        // release -> tryRelease 解锁重入锁
        if (release(savedState)) {
            // 释放成功
            failed = false;
            // 返回解锁的深度
            return savedState;
        } else {
            // 解锁失败抛出异常
            throw new IllegalMonitorStateException();
        }
    } finally {
        // 没有释放成功，将当前 node 设置为取消状态
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p>
<p><img src="https://img.jwt1399.top/img/202301042053656.png" alt=""></p>
</li>
<li><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final boolean isOnSyncQueue(Node node) {
    // node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    // 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null
    if (node.next != null)
        return true;
    // 说明【可能在阻塞队列，但是是尾节点】
    // 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false
    return findNodeFromTail(node);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private int checkInterruptWhileWaiting(Node node) {
    // Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false
    // 如果被中断了，根据是否在条件队列被中断的，设置中断状态码
    return Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 这个方法只有在线程是被打断唤醒时才会调用
final boolean transferAfterCancelledWait(Node node) {
    // 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        // 把【中断唤醒的 node 加入到阻塞队列中】
        enq(node);
        // 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1
        return true;
    }

    //执行到这里的情况：
    //1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了
    //2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态

    // 如果当前线程还没到阻塞队列，一直释放 CPU
    while (!isOnSyncQueue(node))
        Thread.yield();

    // 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>最后开始处理中断状态：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void reportInterruptAfterWait(int interruptMode) throws InterruptedException {
    // 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】
    if (interruptMode == THROW_IE)
        throw new InterruptedException();

    // 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】
    else if (interruptMode == REINTERRUPT)
        // 进行一次自己打断，产生中断的效果
        selfInterrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><ul>
<li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public final void signal() {
    // 判断调用 signal 方法的线程是否是独占锁持有线程
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    // 获取条件队列中第一个 Node
    Node first = firstWaiter;
    // 不为空就将第该节点【迁移到阻塞队列】
    if (first != null)
        doSignal(first);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】
private void doSignal(Node first) {
    do {
        // 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    // 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环
    } while (!transferForSignal(first) && (first = firstWaiter) != null);
}

// signalAll() 会调用这个函数，唤醒所有的节点
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    // 唤醒所有的节点，都放到阻塞队列中
    } while (first != null);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功
final boolean transferForSignal(Node node) {
    // CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了
    // 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        // 返回函数调用处继续寻找下一个节点
        return false;

    // 【先改状态，再进行迁移】
    // 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】
    Node p = enq(node);
    int ws = p.waitStatus;

    // 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态, 
    // 让 thread-0 线程竞争锁，重新同步状态
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301042053188.png" alt=""></p>
</li>
<li><p>Thread-1 释放锁，进入 unlock 流程</p>
</li>
</ul>
<h2 id="❸ReentrantReadWriteLock"><a href="#❸ReentrantReadWriteLock" class="headerlink" title="❸ReentrantReadWriteLock"></a>❸ReentrantReadWriteLock</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p>
<p>共享锁：指该锁可以被多个线程锁持有</p>
<p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p>
<p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p>
<p>使用规则：</p>
<ul>
<li><p>加锁解锁格式：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">r.lock();
try {
    // 临界区
} finally {
    r.unlock();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>读-读能共存、读-写不能共存、写-写不能共存</p>
</li>
<li><p>读锁不支持条件变量</p>
</li>
<li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p>
</li>
<li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">w.lock();
try {
    r.lock();// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存
    try {
        // ...
    } finally{
        w.unlock();// 要在写锁释放之前获取读锁
    }
} finally{
    r.unlock();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>构造方法：</p>
<ul>
<li><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</li>
<li><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</li>
<li><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</li>
<li><code>public void lock()</code>：加锁</li>
<li><code>public void unlock()</code>：解锁</li>
<li><code>public boolean tryLock()</code>：尝试获取锁</li>
</ul>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class DataContainer {
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();
    public Object read() {
        log.debug("获取读锁...");
        r.lock();
        try {
            log.debug("读取");
            sleep(1);
            return data;
        } finally {
            log.debug("释放读锁...");
            r.unlock();
        }
    }
    public void write() {
        log.debug("获取写锁...");
        w.lock();
        try {
            log.debug("写入");
            sleep(1);
        } finally {
            log.debug("释放写锁...");
            w.unlock();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试读读并发：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">    DataContainer dataContainer = new DataContainer();
    new Thread(()->{
        dataContainer.read();
    },"t1").start();

    new Thread(()->{
        dataContainer.read();
    },"t2").start();

14:05:14.341 c.DataContainer [t2] - 获取读锁...
14:05:14.341 c.DataContainer [t1] - 获取读锁...
14:05:14.345 c.DataContainer [t1] - 读取
14:05:14.345 c.DataContainer [t2] - 读取
14:05:15.365 c.DataContainer [t2] - 释放读锁...
14:05:15.386 c.DataContainer [t1] - 释放读锁...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试读写互斥</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">    DataContainer dataContainer = new DataContainer();
    new Thread(() -> {
        dataContainer.read();
    }, "t1").start();
    Thread.sleep(100);
    new Thread(() -> {
        dataContainer.write();
    }, "t2").start();

14:04:21.838 c.DataContainer [t1] - 获取读锁...
14:04:21.838 c.DataContainer [t2] - 获取写锁...
14:04:21.841 c.DataContainer [t2] - 写入
14:04:22.843 c.DataContainer [t2] - 释放写锁...
14:04:22.843 c.DataContainer [t1] - 读取
14:04:23.843 c.DataContainer [t1] - 释放读锁...
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写锁-写锁 也是相互阻塞的，这里就不测试了</p>
<h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h4><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p>
<ul>
<li><p>读写锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final ReentrantReadWriteLock.ReadLock readerLock;        
private final ReentrantReadWriteLock.WriteLock writerLock;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ReentrantReadWriteLock(boolean fair) {
    // true 为公平锁
    sync = fair ? new FairSync() : new NonfairSync();
    // 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>Sync 类的属性：</p>
<ul>
<li><p>统计变量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 用来移位
static final int SHARED_SHIFT   = 16;
// 高16位的1
static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
// 65535，16个1，代表写锁的最大重入次数
static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获取读写锁的次数：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取读写锁的读锁分配的总次数
static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
// 写锁（独占）锁的重入次数
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>内部类：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量
static final class HoldCounter {
    int count = 0;
    // Use id, not reference, to avoid garbage retention
    final long tid = getThreadId(Thread.currentThread());
}
// 线程安全的存放线程各自的 HoldCounter 对象
static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {
    public HoldCounter initialValue() {
        return new HoldCounter();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>内部类实例：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 当前线程持有的可重入读锁的数量，计数为 0 时删除
private transient ThreadLocalHoldCounter readHolds;
// 记录最后一个获取【读锁】线程的 HoldCounter 对象
private transient HoldCounter cachedHoldCounter;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>首次获取锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 第一个获取读锁的线程
private transient Thread firstReader = null;
// 记录该线程持有的读锁次数（读锁重入次数）
private transient int firstReaderHoldCount;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Sync 构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Sync() {
    readHolds = new ThreadLocalHoldCounter();
    // 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】
    setState(getState()); 
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
<h4 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h4><ul>
<li><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state = 0_1</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// lock()  -> sync.acquire(1);
public void lock() {
    sync.acquire(1);
}
public final void acquire(int arg) {
    // 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式 
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    // 获得低 16 位, 代表写锁的 state 计数
    int w = exclusiveCount(c);
    // 说明有读锁或者写锁
    if (c != 0) {
        // c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false
        // w != 0 说明有写锁，写锁的拥有者不是自己，获取失败
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;

        // 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // 写锁重入, 获得锁成功，没有并发，所以不使用 CAS
        setState(c + acquires);
        return true;
    }

    // c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false
    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))
        return false;
    // 获得锁成功，设置锁的持有线程为当前线程
    setExclusiveOwnerThread(current);
    return true;
}
// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞
final boolean writerShouldBlock() {
    return false; 
}
// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争
final boolean writerShouldBlock() {
    return hasQueuedPredecessors();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p>
<ul>
<li>返回 -1 表示失败</li>
<li>如果返回 0 表示成功</li>
<li>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void lock() {
    sync.acquireShared(1);
}
public final void acquireShared(int arg) {
    // tryAcquireShared 返回负数, 表示获取读锁失败
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 尝试以共享模式获取
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    // exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁
    // 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】
    if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current)
        return -1;

    // 高 16 位，代表读锁的 state，共享锁分配出去的总次数
    int r = sharedCount(c);
    // 读锁是否应该阻塞
    if (!readerShouldBlock() &&    r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {    // 尝试增加读锁计数
        // 加锁成功
        // 加锁之前读锁为 0，说明当前线程是第一个读锁线程
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        // 第一个读锁线程是自己就发生了读锁重入
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            // cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程
            HoldCounter rh = cachedHoldCounter;
            // 说明还没设置 rh
            if (rh == null || rh.tid != getThreadId(current))
                // 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter
                cachedHoldCounter = rh = readHolds.get();
            // 还没重入
            else if (rh.count == 0)
                readHolds.set(rh);
            // 重入 + 1
            rh.count++;
        }
        // 读锁加锁成功
        return 1;
    }
    // 逻辑到这 应该阻塞，或者 cas 加锁失败
    // 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞
    return fullTryAcquireShared(current);
}
// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞
// 防止一直有读锁线程，导致写锁线程饥饿
// true 则该阻塞, false 则不阻塞
final boolean readerShouldBlock() {
    return apparentlyFirstQueuedIsExclusive();
}
final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final int fullTryAcquireShared(Thread current) {
    // 当前读锁线程持有的读锁次数对象
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        // 说明有线程持有写锁
        if (exclusiveCount(c) != 0) {
            // 写锁不是自己则获取锁失败
            if (getExclusiveOwnerThread() != current)
                return -1;
        } else if (readerShouldBlock()) {
            // 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
            } else {
                if (rh == null) {
                    // 最后一个读锁的 HoldCounter
                    rh = cachedHoldCounter;
                    // 说明当前线程也不是最后一个读锁
                    if (rh == null || rh.tid != getThreadId(current)) {
                        // 获取当前线程的 HoldCounter
                        rh = readHolds.get();
                        // 条件成立说明 HoldCounter 对象是上一步代码新建的
                        // 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队
                        if (rh.count == 0)
                            // 防止内存泄漏
                            readHolds.remove();
                    }
                }
                if (rh.count == 0)
                    return -1;
            }
        }
        // 越界判断
        if (sharedCount(c) == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // 读锁加锁，条件内的逻辑与 tryAcquireShared 相同
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1;
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doAcquireShared(int arg) {
    // 将当前线程关联到一个 Node 对象上, 模式为共享模式
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // 获取前驱节点
            final Node p = node.predecessor();
            // 如果前驱节点就头节点就去尝试获取锁
            if (p == head) {
                // 再一次尝试获取读锁
                int r = tryAcquireShared(arg);
                // r >= 0 表示获取成功
                if (r >= 0) {
                    //【这里会设置自己为头节点，唤醒相连的后序的共享节点】
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 是否在获取读锁失败时阻塞                           park 当前线程
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p>
<p><img src="https://img.jwt1399.top/img/202301051627804.png" style="zoom: 80%;" /></p>
</li>
<li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p>
<p><img src="https://img.jwt1399.top/img/202301051627027.png" alt=""></p>
</li>
</ul>
<h4 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h4><ul>
<li><p>t1 w.unlock， 写锁解锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void unlock() {
    // 释放锁
    sync.release(1);
}
public final boolean release(int arg) {
    // 尝试释放锁
    if (tryRelease(arg)) {
        Node h = head;
        // 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
protected final boolean tryRelease(int releases) {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    int nextc = getState() - releases;
    // 因为可重入的原因, 写锁计数为 0, 才算释放成功
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    setState(nextc);
    return free;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p>
</li>
<li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; 
    // 设置自己为 head 节点
    setHead(node);
    // propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        // 获取下一个节点
        Node s = node.next;
        // 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】
        if (s == null || s.isShared())
            // 唤醒后继节点
            doReleaseShared();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doReleaseShared() {
    // 如果 head.waitStatus == Node.SIGNAL ==> 0 成功, 下一个节点 unpark
    // 如果 head.waitStatus == 0 ==> Node.PROPAGATE
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            // SIGNAL 唤醒后继
            if (ws == Node.SIGNAL) {
                // 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0
                // 防止 unparkSuccessor 被多次执行
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;  
                // 唤醒后继节点
                unparkSuccessor(h);
            }
            // 如果已经是 0 了，改为 -3，用来解决传播性
            else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                
        }
        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，
        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点
        if (h == head)                   
            break;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301051627915.png" style="zoom: 67%;" /></p>
</li>
<li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
</li>
<li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void unlock() {
    sync.releaseShared(1);
}
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected final boolean tryReleaseShared(int unused) {

    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放
        if (compareAndSetState(c, nextc))
            // 返回是否已经完全释放了 
            return nextc == 0;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<p><img src="https://img.jwt1399.top/img/202301051627580.png" style="zoom: 67%;" /></p>
</li>
</ul>
<h2 id="❹StampedLock"><a href="#❹StampedLock" class="headerlink" title="❹StampedLock"></a>❹StampedLock</h2><p>读写锁，该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<p>特点：</p>
<ul>
<li><p>在使用读锁、写锁时都必须配合戳使用</p>
</li>
<li><p>StampedLock 不支持条件变量</p>
</li>
<li>StampedLock <strong>不支持重入</strong></li>
</ul>
<p>基本用法</p>
<ul>
<li><p>加解读锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">long stamp = lock.readLock();
lock.unlockRead(stamp);            // 类似于 unpark，解指定的锁
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>加解写锁：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">long stamp = lock.writeLock();
lock.unlockWrite(stamp);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">long stamp = lock.tryOptimisticRead();
// 验戳
if(!lock.validate(stamp)){
    // 锁升级
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p>
<ul>
<li>读-读可以优化</li>
<li>读-写优化读，补加读锁</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) throws InterruptedException {
    DataContainerStamped dataContainer = new DataContainerStamped(1);
    new Thread(() -> {
        dataContainer.read(1000);
    },"t1").start();
    Thread.sleep(500);

    new Thread(() -> {
        dataContainer.write(1000);
    },"t2").start();
}

class DataContainerStamped {
    private int data;
    private final StampedLock lock = new StampedLock();

    public int read(int readTime) throws InterruptedException {
        long stamp = lock.tryOptimisticRead();
        System.out.println(new Date() + " optimistic read locking" + stamp);
        Thread.sleep(readTime);
        // 戳有效，直接返回数据
        if (lock.validate(stamp)) {
            Sout(new Date() + " optimistic read finish..." + stamp);
            return data;
        }

        // 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁
        System.out.println(new Date() + " updating to read lock" + stamp);
        try {
            stamp = lock.readLock();
            System.out.println(new Date() + " read lock" + stamp);
            Thread.sleep(readTime);
            System.out.println(new Date() + " read finish..." + stamp);
            return data;
        } finally {
            System.out.println(new Date() + " read unlock " +  stamp);
            lock.unlockRead(stamp);
        }
    }

    public void write(int newData) {
        long stamp = lock.writeLock();
        System.out.println(new Date() + " write lock " + stamp);
        try {
            Thread.sleep(2000);
            this.data = newData;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println(new Date() + " write unlock " + stamp);
            lock.unlockWrite(stamp);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="⑦并发工具类"><a href="#⑦并发工具类" class="headerlink" title="⑦并发工具类"></a>⑦并发工具类</h1><h2 id="❶Semaphore"><a href="#❶Semaphore" class="headerlink" title="❶Semaphore"></a>❶Semaphore</h2><h3 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h3><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p>
<p>构造方法：</p>
<ul>
<li><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</li>
<li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void acquire()</code>：表示获取许可</li>
<li><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    // 1.创建Semaphore对象
    Semaphore semaphore = new Semaphore(3);

    // 2. 10个线程同时运行
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            try {
                // 3. 获取许可
                semaphore.acquire();
                sout(Thread.currentThread().getName() + " running...");
                Thread.sleep(1000);
                sout(Thread.currentThread().getName() + " end...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 4. 释放许可
                semaphore.release();
            }
        }).start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h3><p>加锁流程：</p>
<ul>
<li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Sync(int permits) {
    setState(permits);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// acquire() -> sync.acquireSharedInterruptibly(1)，可中断
public final void acquireSharedInterruptibly(int arg) {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 尝试获取通行证，获取成功返回 >= 0的值
    if (tryAcquireShared(arg) < 0)
        // 获取许可证失败，进入阻塞
        doAcquireSharedInterruptibly(arg);
}

// tryAcquireShared() -> nonfairTryAcquireShared()
// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)
final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        // 获取 state ，state 这里【表示通行证】
        int available = getState();
        // 计算当前线程获取通行证完成之后，通行证还剩余数量
        int remaining = available - acquires;
        // 如果许可已经用完, 返回负数, 表示获取失败,
        if (remaining < 0 ||
            // 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功
            compareAndSetState(available, remaining))
            return remaining;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doAcquireSharedInterruptibly(int arg) {
    // 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中
    final Node node = addWaiter(Node.SHARED);
    // 获取标记
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            // 前驱节点是头节点可以再次获取许可
            if (p == head) {
                // 再次尝试获取许可，【返回剩余的许可证数量】
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 成功后本线程出队（AQS）, 所在 Node设置为 head
                    // r 表示【可用资源数】, 为 0 则不会继续传播
                    setHeadAndPropagate(node, r); 
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        // 被打断后进入该逻辑
        if (failed)
            cancelAcquire(node);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void setHeadAndPropagate(Node node, int propagate) {    
    Node h = head;
    // 设置自己为 head 节点
    setHead(node);
    // propagate 表示有【共享资源】（例如共享读锁或信号量）
    // head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        // 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301051627469.png" alt=""></p>
</li>
<li><p>这时 Thread-4 释放了 permits，状态如下</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// release() -> releaseShared()
public final boolean releaseShared(int arg) {
    // 尝试释放锁
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }    
    return false;
}
protected final boolean tryReleaseShared(int releases) {    
    for (;;) {
        // 获取当前锁资源的可用许可证数量
        int current = getState();
        int next = current + releases;
        // 索引越界判断
        if (next < current)            
            throw new Error("Maximum permit count exceeded");        
        // 释放锁
        if (compareAndSetState(current, next))            
            return true;    
    }
}
private void doReleaseShared() {    
    // PROPAGATE 详解    
    // 如果 head.waitStatus == Node.SIGNAL ==> 0 成功, 下一个节点 unpark    
    // 如果 head.waitStatus == 0 ==> Node.PROPAGATE
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202301051627529.png" alt=""></p>
</li>
<li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
</li>
</ul>
<h2 id="❷CountDownLatch"><a href="#❷CountDownLatch" class="headerlink" title="❷CountDownLatch"></a>❷CountDownLatch</h2><h3 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h3><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p>
<p>构造器：</p>
<ul>
<li><code>public CountDownLatch(int count)</code>：初始化，唤醒需要 down 几步</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void await()</code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</li>
<li><code>public void countDown()</code>：计数器进行减 1（down 1）</li>
</ul>
<p>应用：同步等待多个 Rest 远程调用结束</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// LOL 10人进入游戏倒计时
public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(10);
    ExecutorService service = Executors.newFixedThreadPool(10);
    String[] all = new String[10];
    Random random = new Random();

    for (int j = 0; j < 10; j++) {
        int k = j;//常量
        service.submit(() -> {
            for (int i = 0; i <= 100; i++) {
                Thread.sleep(random.nextInt(100));    //随机休眠
                all[k] = i + "%";
                System.out.print("\r" + Arrays.toString(all));    // \r代表覆盖
            }
            latch.countDown();
        });
    }
    latch.await();
    System.out.println("\n游戏开始");
    service.shutdown();
}
/*
[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]
游戏开始
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h3><p>阻塞等待：</p>
<ul>
<li><p>线程调用 await() 等待其他线程完成任务：支持打断</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
// AbstractQueuedSynchronizer#acquireSharedInterruptibly
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
    // 判断线程是否被打断，抛出打断异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 尝试获取共享锁，条件成立说明 state > 0，此时线程入队阻塞等待，等待其他线程获取共享资源
    // 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
// CountDownLatch.Sync#tryAcquireShared
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
    // 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            // 获取当前节点的前驱节点
            final Node p = node.predecessor();
            // 前驱节点时头节点就可以尝试获取锁
            if (p == head) {
                // 再次尝试获取锁，获取成功返回 1
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 获取锁成功，设置当前节点为 head 节点，并且向后传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            // 阻塞在这里
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        // 阻塞线程被中断后抛出异常，进入取消节点的逻辑
        if (failed)
            cancelAcquire(node);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    // 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null
    setHead(node);
    // propagate = 1，条件一成立
    if (propagate > 0 || h == null || h.waitStatus < 0 || (h = head) == null || h.waitStatus < 0) {
        // 获取当前节点的后继节点
        Node s = node.next;
        // 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式
        if (s == null || s.isShared())
            // 唤醒所有的等待共享锁的节点
            doReleaseShared();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>计数减一：</p>
<ul>
<li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public void countDown() {
    sync.releaseShared(1);
}
public final boolean releaseShared(int arg) {
    // 尝试释放共享锁
    if (tryReleaseShared(arg)) {
        // 释放锁成功开始唤醒阻塞节点
        doReleaseShared();
        return true;
    }
    return false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">protected boolean tryReleaseShared(int releases) {
    for (;;) {
        int c = getState();
        // 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false
        if (c == 0)
            return false;
        // 计数器减一
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            // 计数器为 0 时返回 true
            return nextc == 0;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>state = 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void doReleaseShared() {
    for (;;) {
        Node h = head;
        // 判断队列是否是空队列
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            // 头节点的状态为 signal，说明后继节点没有被唤醒过
            if (ws == Node.SIGNAL) {
                // cas 设置头节点的状态为 0，设置失败继续自旋
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                // 唤醒后继节点
                unparkSuccessor(h);
            }
            // 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性
            else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，
        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点
        if (h == head)
            break;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="❸CyclicBarrier"><a href="#❸CyclicBarrier" class="headerlink" title="❸CyclicBarrier"></a>❸CyclicBarrier</h2><h3 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h3><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p>
<p>常用方法：</p>
<ul>
<li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction<ul>
<li>parties：代表多少个线程到达屏障开始触发线程任务</li>
<li>barrierAction：线程任务</li>
</ul>
</li>
<li><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</li>
</ul>
<p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p>
<p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void main(String[] args) {
    ExecutorService service = Executors.newFixedThreadPool(2);
    CyclicBarrier barrier = new CyclicBarrier(2, () -> {
        System.out.println("task1 task2 finish...");
    });

    for (int i = 0; i < 3; i++) { // 循环重用
        service.submit(() -> {
            System.out.println("task1 begin...");
            try {
                Thread.sleep(1000);
                barrier.await();    // 2 - 1 = 1
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        });

        service.submit(() -> {
            System.out.println("task2 begin...");
            try {
                Thread.sleep(2000);
                barrier.await();    // 1 - 1 = 0
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        });
    }
    service.shutdown();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><ul>
<li><p>全局锁：利用可重入锁实现的工具类</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用
private final ReentrantLock lock = new ReentrantLock();
// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒
private final Condition trip = lock.newCondition();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>线程数量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final int parties;    // 代表多少个线程到达屏障开始触发线程任务
private int count;            // 表示当前“代”还有多少个线程未到位，初始值为 parties
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>当前代中最后一个线程到位后要执行的事件：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final Runnable barrierCommand;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>代：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示 barrier 对象当前 代
private Generation generation = new Generation();
private static class Generation {
    // 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常
    // 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。
    boolean broken = false;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public CyclicBarrie(int parties, Runnable barrierAction) {
    // 因为小于等于 0 的 barrier 没有任何意义
    if (parties <= 0) throw new IllegalArgumentException();

    this.parties = parties;
    this.count = parties;
    // 可以为 null
    this.barrierCommand = barrierAction;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301061955546.png" style="zoom: 80%;" /></p>
<h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><p>await()：阻塞等待所有线程到位</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的
// nanos：线程等待超时时长，单位是纳秒
private int dowait(boolean timed, long nanos) {
    final ReentrantLock lock = this.lock;
    // 加锁
    lock.lock();
    try {
        // 获取当前代
        final Generation g = generation;

        // 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】
        if (g.broken)
            throw new BrokenBarrierException();
        // 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常
        if (Thread.interrupted()) {
            // 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程
            breakBarrier();
            throw new InterruptedException();
        }

        // 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）

        // 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0
        int index = --count;
        // 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】
        if (index == 0) {
            // 栅栏任务启动标记
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    // 启动触发的任务
                    command.run();
                // run()未抛出异常的话，启动标记设置为 true
                ranAction = true;
                // 开启新的一代，这里会【唤醒所有的阻塞队列】
                nextGeneration();
                // 返回 0 因为当前线程是此代最后一个到达的线程，index == 0
                return 0;
            } finally {
                // 如果 command.run() 执行抛出异常的话，会进入到这里
                if (!ranAction)
                    breakBarrier();
            }
        }

        // 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时
        for (;;) {
            try {
                // 根据是否需要超时等待选择阻塞方法
                if (!timed)
                    // 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒
                    trip.await();
                else if (nanos > 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                // 被中断后来到这里的逻辑

                // 当前代没有变化并且没有被打破
                if (g == generation && !g.broken) {
                    // 打破屏障
                    breakBarrier();
                    // node 节点在【条件队列】内收到中断信号时 会抛出中断异常
                    throw ie;
                } else {
                    // 等待过程中代变化了，完成一次自我打断
                    Thread.currentThread().interrupt();
                }
            }
            // 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】
            if (g.broken)
                throw new BrokenBarrierException();

            // 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑
            if (g != generation)
                return index;
            // 当前线程 trip 中等待超时，然后主动转移到阻塞队列
            if (timed && nanos <= 0L) {
                breakBarrier();
                // 抛出超时异常
                throw new TimeoutException();
            }
        }
    } finally {
        // 解锁
        lock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>breakBarrier()：打破 Barrier 屏障</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void breakBarrier() {
    // 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常
    generation.broken = true;
    // 重置 count 为 parties
    count = parties;
    // 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常
    trip.signalAll();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>nextGeneration()：开启新的下一代 </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void nextGeneration() {
    // 将在 trip 条件队列内挂起的线程全部唤醒
    trip.signalAll();
    // 重置 count 为 parties
    count = parties;

    // 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】
    generation = new Generation();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="❹Exchanger"><a href="#❹Exchanger" class="headerlink" title="❹Exchanger"></a>❹Exchanger</h2><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p>
<p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p>
<p>常用方法：</p>
<ul>
<li><code>public Exchanger()</code>：创建一个新的交换器</li>
<li><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</li>
<li><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ExchangerDemo {
    public static void main(String[] args) {
        // 创建交换对象（信使）
        Exchanger<String> exchanger = new Exchanger<>();
        new ThreadA(exchanger).start();
        new ThreadB(exchanger).start();
    } 
}
class ThreadA extends Thread{
    private Exchanger<String> exchanger();

    public ThreadA(Exchanger<String> exchanger){
        this.exchanger = exchanger;
    }

    @Override
    public void run() {
        try{
            sout("线程A，做好了礼物A，等待线程B送来的礼物B");
            //如果等待了5s还没有交换就死亡（抛出异常）！
            String s = exchanger.exchange("礼物A",5,TimeUnit.SECONDS);
            sout("线程A收到线程B的礼物：" + s);
        } catch (Exception e) {
            System.out.println("线程A等待了5s，没有收到礼物,最终就执行结束了!");
        }
    }
}
class ThreadB extends Thread{
    private Exchanger<String> exchanger;

    public ThreadB(Exchanger<String> exchanger) {
        this.exchanger = exchanger;
    }

    @Override
    public void run() {
        try {
            sout("线程B,做好了礼物B,等待线程A送来的礼物A.....");
            // 开始交换礼物。参数是送给其他线程的礼物!
            sout("线程B收到线程A的礼物：" + exchanger.exchange("礼物B"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="⑧并发容器"><a href="#⑧并发容器" class="headerlink" title="⑧并发容器"></a>⑧并发容器</h1><h2 id="❶ConcurrentHashMap"><a href="#❶ConcurrentHashMap" class="headerlink" title="❶ConcurrentHashMap"></a>❶ConcurrentHashMap</h2><h3 id="集合对比"><a href="#集合对比" class="headerlink" title="集合对比"></a>集合对比</h3><p>三种集合：</p>
<ul>
<li>HashMap 是线程不安全的，性能好</li>
<li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li>
<li>ConcurrentHashMap 保证了线程安全，综合性能较好</li>
</ul>
<p>集合对比：</p>
<ol>
<li>Hashtable 继承 Dictionary 类，HashMap、ConcurrentHashMap 继承 AbstractMap，均实现 Map 接口</li>
<li>Hashtable 底层是数组 + 链表，JDK8 以后 HashMap 和 ConcurrentHashMap 底层是数组 + 链表 + 红黑树</li>
<li>HashMap 线程不安全，Hashtable 线程安全，Hashtable 的方法都加了 synchronized 关来确保线程同步</li>
<li>ConcurrentHashMap、Hashtable <strong>不允许 null 值</strong>，HashMap 允许 null 值</li>
<li>ConcurrentHashMap、HashMap 的初始容量为 16，Hashtable 初始容量为11，填充因子默认都是 0.75，两种 Map 扩容是当前容量翻倍：capacity <em> 2，Hashtable 扩容时是容量翻倍 + 1：capacity</em>2 + 1</li>
</ol>
<p><img src="https://img.jwt1399.top/img/202301062156037.png" alt="ConcurrentHashMap数据结构"></p>
<h3 id="工作步骤："><a href="#工作步骤：" class="headerlink" title="工作步骤："></a>工作步骤：</h3><ol>
<li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table</p>
</li>
<li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 链表节点数 &gt; 8 时，会将<strong>链表树化</strong>，树化过程会用 synchronized 锁住链表头</p>
<p>说明：锁住某个槽位的对象头，是一种很好的<strong>细粒度的加锁</strong>方式，类似 MySQL 中的行锁</p>
</li>
<li><p>put，如果该 节点 尚未创建，只需要使用 cas 创建 节点；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 节点 的尾部</p>
</li>
<li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 会让 get 操作在新 table 进行搜索</p>
</li>
<li><p>扩容，扩容时以 bin节点 为单位进行，需要对 bin节点 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin节点 进行扩容</p>
</li>
<li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中，最后统计数量时累加</p>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">//需求：多个线程同时往HashMap容器中存入数据会出现安全问题
public class ConcurrentHashMapDemo{
    public static Map<String,String> map = new ConcurrentHashMap();

    public static void main(String[] args){
        new AddMapDataThread().start();
        new AddMapDataThread().start();

        Thread.sleep(1000 * 5);//休息5秒，确保两个线程执行完毕
        System.out.println("Map大小：" + map.size());//20万
    }
}

public class AddMapDataThread extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 1000000 ; i++ ){
            ConcurrentHashMapDemo.map.put("键："+i , "值"+i);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a><strong>并发死链</strong></h3><p>JDK1.7 的 HashMap 采用的头插法（拉链法）进行节点的添加，HashMap 的扩容长度为原来的 2 倍</p>
<p>resize() 中节点（Entry）转移的源代码：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;//得到新数组的长度   
    // 遍历整个数组对应下标下的链表，e代表一个节点
    for (Entry<K,V> e : table) {   
        // 当e == null时，则该链表遍历完了，继续遍历下一数组下标的链表 
        while(null != e) { 
            // 先把e节点的下一节点存起来
            Entry<K,V> next = e.next; 
            if (rehash) {              //得到新的hash值
                e.hash = null == e.key ? 0 : hash(e.key);  
            }
            // 在新数组下得到新的数组下标
            int i = indexFor(e.hash, newCapacity);  
             // 将e的next指针指向新数组下标的位置
            e.next = newTable[i];   
            // 将该数组下标的节点变为e节点
            newTable[i] = e; 
            // 遍历链表的下一节点
            e = next;                                   
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JDK 7 HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，因为一个线程先期完成了扩容，将原的链表重新散列到自己的表中，并且链表变成了倒序（头插法），后一个线程再扩容时，又进行自己的散列，再次将倒序链表变为正序链表。于是形成了一个环形链表，当表中不存在的元素时，造成死循环。</p>
<p>JDK 8 虽然将扩容算法做了调整，改用了尾插法，但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p>
<h3 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>存储数组：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">transient volatile Node<K,V>[] table;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>散列表的长度：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final int MAXIMUM_CAPACITY = 1 << 30;    // 最大长度
private static final int DEFAULT_CAPACITY = 16;            // 默认长度
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>并发级别，JDK7 遗留下来，1.8 中不代表并发级别：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>负载因子，JDK1.8 的 ConcurrentHashMap 中是固定值：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final float LOAD_FACTOR = 0.75f;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>阈值：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final int TREEIFY_THRESHOLD = 8;        // 链表树化的阈值
static final int UNTREEIFY_THRESHOLD = 6;    // 红黑树转化为链表的阈值
static final int MIN_TREEIFY_CAPACITY = 64;    // 当数组长度达到64且某个桶位中的链表长度超过8，才会真正树化
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>扩容相关：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final int MIN_TRANSFER_STRIDE = 16;    // 线程迁移数据【最小步长】，控制线程迁移任务的最小区间
private static int RESIZE_STAMP_BITS = 16;            // 用来计算扩容时生成的【标识戳】
private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;// 65535-1并发扩容最多线程数
private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;        // 扩容时使用
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>节点哈希值：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final int MOVED     = -1;             // 表示当前节点是 FWD 节点
static final int TREEBIN   = -2;             // 表示当前节点已经树化，且当前节点为 TreeBin 对象
static final int RESERVED  = -3;             // 表示节点时临时节点
static final int HASH_BITS = 0x7fffffff;     // 正常节点的哈希值的可用的位数
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>扩容过程：volatile 修饰保证多线程的可见性</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 扩容过程中，会将扩容中的新 table 赋值给 nextTable 保持引用，扩容结束之后，这里会被设置为 null
private transient volatile Node<K,V>[] nextTable;
// 记录扩容进度，所有线程都要从 0 - transferIndex 中分配区间任务，简单说就是老表转移到哪了，索引从高到低转移
private transient volatile int transferIndex;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>累加统计：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// LongAdder 中的 baseCount 未发生竞争时或者当前LongAdder处于加锁状态时，增量累到到 baseCount 中
private transient volatile long baseCount;
// LongAdder 中的 cellsBuzy，0 表示当前 LongAdder 对象无锁状态，1 表示当前 LongAdder 对象加锁状态
private transient volatile int cellsBusy;
// LongAdder 中的 cells 数组，
private transient volatile CounterCell[] counterCells;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>控制变量：</p>
<p><strong>sizeCtl</strong> &lt; 0：</p>
<ul>
<li><p>-1 表示当前 table 正在初始化（有线程在创建 table 数组），当前线程需要自旋等待</p>
</li>
<li><p>其他负数表示当前 map 的 table 数组正在进行扩容，高 16 位表示扩容的标识戳；低 16 位表示 (1 + nThread) 当前参与并发扩容的线程数量 + 1</p>
</li>
</ul>
<p>sizeCtl = 0，表示创建 table 数组时使用 DEFAULT_CAPACITY 为数组大小</p>
<p>sizeCtl &gt; 0：</p>
<ul>
<li>如果 table 未初始化，表示初始化大小</li>
<li>如果 table 已经初始化，表示下次扩容时的触发条件（阈值，元素个数，不是数组的长度）</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private transient volatile int sizeCtl;        // volatile 保持可见性
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li><p>Node 节点：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static class Node<K,V> implements Entry<K,V> {
    // 节点哈希值
    final int hash;
    final K key;
    volatile V val;
    // 单向链表
    volatile Node<K,V> next;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>TreeBin 节点：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java"> static final class TreeBin<K,V> extends Node<K,V> {
     // 红黑树根节点
     TreeNode<K,V> root;
     // 链表的头节点
     volatile TreeNode<K,V> first;
     // 等待者线程
     volatile Thread waiter;

     volatile int lockState;
     // 写锁状态 写锁是独占状态，以散列表来看，真正进入到 TreeBin 中的写线程同一时刻只有一个线程
     static final int WRITER = 1;
     // 等待者状态（写线程在等待），当 TreeBin 中有读线程目前正在读取数据时，写线程无法修改数据
     static final int WAITER = 2;
     // 读锁状态是共享，同一时刻可以有多个线程 同时进入到 TreeBi 对象中获取数据，每一个线程都给 lockState + 4
     static final int READER = 4;
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>TreeNode 节点：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final class TreeNode<K,V> extends Node<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;   //双向链表
    boolean red;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>ForwardingNode 节点：转移节点</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java"> static final class ForwardingNode<K,V> extends Node<K,V> {
     // 持有扩容后新的哈希表的引用
     final Node<K,V>[] nextTable;
     ForwardingNode(Node<K,V>[] tab) {
         // ForwardingNode 节点的 hash 值设为 -1
         super(MOVED, null, null, null);
         this.nextTable = tab;
     }
 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul>
<li><p>变量：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示sizeCtl属性在 ConcurrentHashMap 中内存偏移地址
private static final long SIZECTL;
// 表示transferIndex属性在 ConcurrentHashMap 中内存偏移地址
private static final long TRANSFERINDEX;
// 表示baseCount属性在 ConcurrentHashMap 中内存偏移地址
private static final long BASECOUNT;
// 表示cellsBusy属性在 ConcurrentHashMap 中内存偏移地址
private static final long CELLSBUSY;
// 表示cellValue属性在 CounterCell 中内存偏移地址
private static final long CELLVALUE;
// 表示数组第一个元素的偏移地址
private static final long ABASE;
// 用位移运算替代乘法
private static final int ASHIFT;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>赋值方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 表示数组单元所占用空间大小，scale 表示 Node[] 数组中每一个单元所占用空间大小，int 是 4 字节
int scale = U.arrayIndexScale(ak);
// 判断一个数是不是 2 的 n 次幂，比如 8：1000 & 0111 = 0000
if ((scale & (scale - 1)) != 0)
    throw new Error("data type scale not a power of two");

// numberOfLeadingZeros(n)：返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一起
// 8 → 1000 numberOfLeadingZeros(8) = 28
// 4 → 100 numberOfLeadingZeros(4) = 29   int 值就是占4个字节
ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);

// ASHIFT = 31 - 29 = 2 ，int 的大小就是 2 的 2 次方，获取次方数
// ABASE + （5 << ASHIFT） 用位移运算替代了乘法，获取 arr[5] 的值
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><p>无参构造， 散列表结构延迟初始化，默认的数组大小是 16：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ConcurrentHashMap() {
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>有参构造：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ConcurrentHashMap(int initialCapacity) {
    // 指定容量初始化
    if (initialCapacity < 0) throw new IllegalArgumentException();
    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
               MAXIMUM_CAPACITY :
               // 假如传入的参数是 16，16 + 8 + 1 ，最后得到 32
               // 传入 12， 12 + 6 + 1 = 19，最后得到 32，尽可能的大，与 HashMap不一样
               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    // sizeCtl > 0，当目前 table 未初始化时，sizeCtl 表示初始化容量
    this.sizeCtl = cap;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private static final int tableSizeFor(int c) {
    int n = c - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>核心思想就是<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是 2 的 n 次幂</p>
</li>
<li><p>多个参数构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    // 初始容量小于并发级别
    if (initialCapacity < concurrencyLevel)  
        // 把并发级别赋值给初始容量
        initialCapacity = concurrencyLevel; 
    // loadFactor 默认是 0.75
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    int cap = (size >= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    // sizeCtl > 0，当目前 table 未初始化时，sizeCtl 表示初始化容量
    this.sizeCtl = cap;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>集合构造方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public ConcurrentHashMap(Map<? extends K, ? extends V> m) {
    this.sizeCtl = DEFAULT_CAPACITY;    // 默认16
    putAll(m);
}
public void putAll(Map<? extends K, ? extends V> m) {
    // 尝试触发扩容
    tryPresize(m.size());
    for (Entry<? extends K, ? extends V> e : m.entrySet())
        putVal(e.getKey(), e.getValue(), false);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final void tryPresize(int size) {
    // 扩容为大于 2 倍的最小的 2 的 n 次幂
    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
        tableSizeFor(size + (size >>> 1) + 1);
    int sc;
    while ((sc = sizeCtl) >= 0) {
        Node<K,V>[] tab = table; int n;
        // 数组还未初始化，【一般是调用集合构造方法才会成立，put 后调用该方法都是不成立的】
        if (tab == null || (n = tab.length) == 0) {
            n = (sc > c) ? sc : c;
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if (table == tab) {
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = nt;
                        sc = n - (n >>> 2);// 扩容阈值：n - 1/4 n
                    }
                } finally {
                    sizeCtl = sc;    // 扩容阈值赋值给sizeCtl
                }
            }
        }
        // 未达到扩容阈值或者数组长度已经大于最大长度
        else if (c <= sc || n >= MAXIMUM_CAPACITY)
            break;
        // 与 addCount 逻辑相同
        else if (tab == table) {

        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="数据访存"><a href="#数据访存" class="headerlink" title="数据访存"></a>数据访存</h4><ul>
<li><p>tabAt()：获取数组某个槽位的<strong>头节点</strong>，类似于数组中的直接寻址 arr[i]</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// i 是数组索引
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
    // (i << ASHIFT) + ABASE == ABASE + i * 4 （一个 int 占 4 个字节），这就相当于寻址，替代了乘法
    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>casTabAt()：指定数组索引位置修改原值为指定的值</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) {
    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>setTabAt()：指定数组索引位置设置值</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {
    U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="添加方法：put"><a href="#添加方法：put" class="headerlink" title="添加方法：put"></a>添加方法：put</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public V put(K key, V value) {
    // 第三个参数 onlyIfAbsent 为 false 表示哈希表中存在相同的 key 时【用当前数据覆盖旧数据】
    return putVal(key, value, false);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>putVal()</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final V putVal(K key, V value, boolean onlyIfAbsent) {
    // 【ConcurrentHashMap 不能存放 null 值】
    if (key == null || value == null) throw new NullPointerException();
    // 扰动运算，高低位都参与寻址运算
    int hash = spread(key.hashCode());
    // 表示当前 k-v 封装成 node 后插入到指定桶位后，在桶位中的所属链表的下标位置
    int binCount = 0;
    // tab 引用当前 map 的数组 table，开始自旋
    for (Node<K,V>[] tab = table;;) {
        // f 表示桶位的头节点，n 表示哈希表数组的长度
        // i 表示 key 通过寻址计算后得到的桶位下标，fh 表示桶位头结点的 hash 值
        Node<K,V> f; int n, i, fh;

        // 【CASE1】：表示当前 map 中的 table 尚未初始化
        if (tab == null || (n = tab.length) == 0)
            //【延迟初始化】
            tab = initTable();

        // 【CASE2】：i 表示 key 使用【寻址算法】得到 key 对应数组的下标位置，tabAt 获取指定桶位的头结点f
        // i = (n - 1) & hash 等价于 i = hash % n  
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // 对应的数组为 null 说明没有哈希冲突，直接新建节点添加到表中
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }
        // 【CASE3】：逻辑说明数组已经被初始化，并且当前 key 对应的位置不为 null
        // 条件成立表示当前桶位的头结点为 FWD 结点，表示目前 map 正处于扩容过程中
        else if ((fh = f.hash) == MOVED)
            // 当前线程【需要去帮助哈希表完成扩容】
            tab = helpTransfer(tab, f);

        // 【CASE4】：哈希表没有在扩容，当前桶位可能是链表也可能是红黑树
        else {
            // 当插入 key 存在时，会将旧值赋值给 oldVal 返回
            V oldVal = null;
            // 【锁住当前 key 寻址的桶位的头节点】
            synchronized (f) {
                // 这里重新获取一下桶的头节点有没有被修改，因为可能被其他线程修改过，这里是线程安全的获取
                if (tabAt(tab, i) == f) {
                    // 【头节点的哈希值大于 0 说明当前桶位是普通的链表节点】
                    if (fh >= 0) {
                        // 当前的插入操作没出现重复的 key，追加到链表的末尾，binCount表示链表长度 -1
                        // 插入的key与链表中的某个元素的 key 一致，变成替换操作，binCount 表示第几个节点冲突
                        binCount = 1;
                        // 迭代循环当前桶位的链表，e 是每次循环处理节点，e 初始是头节点
                        for (Node<K,V> e = f;; ++binCount) {
                            // 当前循环节点 key
                            K ek;
                            // key 的哈希值与当前节点的哈希一致，并且 key 的值也相同
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                // 把当前节点的 value 赋值给 oldVal
                                oldVal = e.val;
                                // 允许覆盖
                                if (!onlyIfAbsent)
                                    // 新数据覆盖旧数据
                                    e.val = value;
                                // 跳出循环
                                break;
                            }
                            Node<K,V> pred = e;
                            // 如果下一个节点为空，把数据封装成节点插入链表尾部，【binCount 代表长度 - 1】
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // 当前桶位头节点是红黑树
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                              value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }

            // 条件成立说明当前是链表或者红黑树
            if (binCount != 0) {
                // 如果 binCount >= 8 表示处理的桶位一定是链表，说明长度是 9
                if (binCount >= TREEIFY_THRESHOLD)
                    // 树化
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    // 统计当前 table 一共有多少数据，判断是否达到扩容阈值标准，触发扩容
    // binCount = 0 表示当前桶位为 null，node 可以直接放入，2 表示当前桶位已经是红黑树
    addCount(1L, binCount);
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>spread()：扰动函数</p>
<p>将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，最后与 HASH_BITS 相与变成正数，<strong>与树化节点和转移节点区分</strong>，把高低位都利用起来减少哈希冲突，保证散列的均匀性</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">static final int spread(int h) {
    return (h ^ (h >>> 16)) & HASH_BITS; // 0111 1111 1111 1111 1111 1111 1111 1111
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<p>initTable()：初始化数组，延迟初始化</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final Node<K,V>[] initTable() {
    // tab 引用 map.table，sc 引用 sizeCtl
    Node<K,V>[] tab; int sc;
    // table 尚未初始化，开始自旋
    while ((tab = table) == null || tab.length == 0) {
        // sc < 0 说明 table 正在初始化或者正在扩容，当前线程可以释放 CPU 资源
        if ((sc = sizeCtl) < 0)
            Thread.yield();
        // sizeCtl 设置为 -1，相当于加锁，【设置的是 SIZECTL 位置的数据】，
        // 因为是 sizeCtl 是基本类型，不是引用类型，所以 sc 保存的是数据的副本
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                // 线程安全的逻辑，再进行一次判断
                if ((tab = table) == null || tab.length == 0) {
                    // sc > 0 创建 table 时使用 sc 为指定大小，否则使用 16 默认值
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    // 创建哈希表数组
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    // 扩容阈值，n >>> 2  => 等于 1/4 n ，n - (1/4)n = 3/4 n => 0.75 * n
                    sc = n - (n >>> 2);
                }
            } finally {
                // 解锁，把下一次扩容的阈值赋值给 sizeCtl
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="链表转树-treeifyBin"><a href="#链表转树-treeifyBin" class="headerlink" title="链表转树: treeifyBin"></a>链表转树: treeifyBin</h4><p>treeifyBin()：树化方法，链表转红黑树</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final void treeifyBin(Node<K,V>[] tab, int index) {
    Node<K,V> b; int n, sc;
    if (tab != null) {
        // 条件成立：【说明当前 table 数组长度未达到 64，此时不进行树化操作，进行扩容操作】
        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
            // 当前容量的 2 倍
            tryPresize(n << 1);

        // 条件成立：说明当前桶位有数据，且是普通 node 数据。
        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
            // 【树化加锁】
            synchronized (b) {
                // 条件成立：表示加锁没问题。
                if (tabAt(tab, index) == b) {
                    TreeNode<K,V> hd = null, tl = null;
                    for (Node<K,V> e = b; e != null; e = e.next) {
                        TreeNode<K,V> p = new TreeNode<K,V>(e.hash, e.key, e.val,null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin<K,V>(hd));
                }
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩容方法：tryPresize"><a href="#扩容方法：tryPresize" class="headerlink" title="扩容方法：tryPresize"></a>扩容方法：tryPresize</h4><p>扩容机制：</p>
<ul>
<li>当链表中元素个数超过 8 个，数组的大小还未超过 64 时，此时进行数组的扩容，如果超过则将链表转化成红黑树</li>
<li>put 数据后调用 addCount() 方法，判断当前哈希表的容量超过阈值 sizeCtl，超过进行扩容</li>
<li>增删改线程发现其他线程正在扩容，帮其扩容</li>
</ul>
<p>addCount()：添加计数，<strong>代表哈希表中的数据总量</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final void addCount(long x, int check) {
    // 【上面这部分的逻辑就是 LongAdder 的累加逻辑】
    CounterCell[] as; long b, s;
    // 判断累加数组 cells 是否初始化，没有就去累加 base 域，累加失败进入条件内逻辑
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        // true 未竞争，false 发生竞争
        boolean uncontended = true;
        // 判断 cells 是否被其他线程初始化
        if (as == null || (m = as.length - 1) < 0 ||
            // 前面的条件为 fasle 说明 cells 被其他线程初始化，通过 hash 寻址对应的槽位
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            // 尝试去对应的槽位累加，累加失败进入 fullAddCount 进行重试或者扩容
            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // 与 Striped64#longAccumulate 方法相同
            fullAddCount(x, uncontended);
            return;
        }
        // 表示当前桶位是 null，或者一个链表节点
        if (check <= 1)    
            return;
        // 【获取当前散列表元素个数】，这是一个期望值
        s = sumCount();
    }

    // 表示一定 【是一个 put 操作调用的 addCount】
    if (check >= 0) {
        Node<K,V>[] tab, nt; int n, sc;

        // 条件一：true 说明当前 sizeCtl 可能为一个负数表示正在扩容中，或者 sizeCtl 是一个正数，表示扩容阈值
        //        false 表示哈希表的数据的数量没达到扩容条件
        // 然后判断当前 table 数组是否初始化了，当前 table 长度是否小于最大值限制，就可以进行扩容
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) {
            // 16 -> 32 扩容 标识为：1000 0000 0001 1011，【负数，扩容批次唯一标识戳】
            int rs = resizeStamp(n);

            // 表示当前 table，【正在扩容】，sc 高 16 位是扩容标识戳，低 16 位是线程数 + 1
            if (sc < 0) {
                // 条件一：判断扩容标识戳是否一样，fasle 代表一样
                // 勘误两个条件：
                // 条件二是：sc == (rs << 16 ) + 1，true 代表扩容完成，因为低16位是1代表没有线程扩容了
                // 条件三是：sc == (rs << 16) + MAX_RESIZERS，判断是否已经超过最大允许的并发扩容线程数
                // 条件四：判断新表的引用是否是 null，代表扩容完成
                // 条件五：【扩容是从高位到低位转移】，transferIndex < 0 说明没有区间需要扩容了
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;

                // 设置当前线程参与到扩容任务中，将 sc 低 16 位值加 1，表示多一个线程参与扩容
                // 设置失败其他线程或者 transfer 内部修改了 sizeCtl 值
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    //【协助扩容线程】，持有nextTable参数
                    transfer(tab, nt);
            }
            // 逻辑到这说明当前线程是触发扩容的第一个线程，线程数量 + 2
            // 1000 0000 0001 1011 0000 0000 0000 0000 +2 => 1000 0000 0001 1011 0000 0000 0000 0010
            else if (U.compareAndSwapInt(this, SIZECTL, sc,(rs << RESIZE_STAMP_SHIFT) + 2))
                //【触发扩容条件的线程】，不持有 nextTable，初始线程会新建 nextTable
                transfer(tab, null);
            s = sumCount();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tryPresize方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了
private final void tryPresize(int size) {
    // c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。
    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
        tableSizeFor(size + (size >>> 1) + 1);
    int sc;
    while ((sc = sizeCtl) >= 0) {
        Node<K,V>[] tab = table; int n;

        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码
        if (tab == null || (n = tab.length) == 0) {
            n = (sc > c) ? sc : c;
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if (table == tab) {
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = nt;
                        sc = n - (n >>> 2); // 0.75 * n
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
        else if (c <= sc || n >= MAXIMUM_CAPACITY)
            break;
        else if (tab == table) {
            // 扩容标识符
            int rs = resizeStamp(n);

            if (sc < 0) {
                Node<K,V>[] nt;
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法
                //    此时 nextTab 不为 null
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            // 1. 将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)
            //     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数
            //  调用 transfer 方法，此时 nextTab 参数为 null
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>resizeStamp()：扩容标识符，<strong>每次扩容都会产生一个，不是每个线程都产生</strong>，16 扩容到 32 产生一个，32 扩容到 64 产生一个</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/**
 * 扩容的标识符
 * 16 -> 32 从16扩容到32
 * numberOfLeadingZeros(16) => 1 0000 => 32 - 5 = 27 => 0000 0000 0001 1011
 * (1 << (RESIZE_STAMP_BITS - 1)) => 1000 0000 0000 0000 => 32768
 * ---------------------------------------------------------------
 * 0000 0000 0001 1011
 * 1000 0000 0000 0000
 * 1000 0000 0001 1011
 * 永远是负数
 */
static final int resizeStamp(int n) {
    // 或运算
    return Integer.numberOfLeadingZeros(n) | (1 << (RESIZE_STAMP_BITS - 1)); // (16 -1 = 15)
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="数据迁移-transfer"><a href="#数据迁移-transfer" class="headerlink" title="数据迁移: transfer"></a>数据迁移: transfer</h4><p>transfer()：将数据转移到新表中，完成扩容</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    // n 表示扩容之前 table 数组的长度
    int n = tab.length, stride;
    // stride 表示分配给线程任务的步长，默认就是 16 
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE;
    // 如果当前线程为触发本次扩容的线程，需要做一些扩容准备工作，【协助线程不做这一步】
    if (nextTab == null) {
        try {
            // 创建一个容量是之前【二倍的 table 数组】
            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
            nextTab = nt;
        } catch (Throwable ex) {
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        // 把新表赋值给对象属性 nextTable，方便其他线程获取新表
        nextTable = nextTab;
        // 记录迁移数据整体位置的一个标记，transferIndex 计数从1开始不是 0，所以这里是长度，不是长度-1
        transferIndex = n;
    }
    // 新数组的长度
    int nextn = nextTab.length;
    // 当某个桶位数据处理完毕后，将此桶位设置为 fwd 节点，其它写线程或读线程看到后，可以从中获取到新表
    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
    // 推进标记
    boolean advance = true;
    // 完成标记
    boolean finishing = false;

    // i 表示分配给当前线程任务，执行到的桶位
    // bound 表示分配给当前线程任务的下界限制，因为是倒序迁移，16 迁移完 迁移 15，15完成去迁移14
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;

        // 给当前线程【分配任务区间】
        while (advance) {
            // 分配任务的开始下标，分配任务的结束下标
            int nextIndex, nextBound;

            // --i 让当前线程处理下一个索引，true说明当前的迁移任务尚未完成，false说明线程已经完成或者还未分配
            if (--i >= bound || finishing)
                advance = false;
            // 迁移的开始下标，小于0说明没有区间需要迁移了，设置当前线程的 i 变量为 -1 跳出循环
            else if ((nextIndex = transferIndex) <= 0) {
                i = -1;
                advance = false;
            }
            // 逻辑到这说明还有区间需要分配，然后给当前线程分配任务，
            else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,
                      // 判断区间是否还够一个步长，不够就全部分配
                      nextBound = (nextIndex > stride ? nextIndex - stride : 0))) {
                // 当前线程的结束下标
                bound = nextBound;
                // 当前线程的开始下标，上一个线程结束的下标的下一个索引就是这个线程开始的下标
                i = nextIndex - 1;
                // 任务分配结束，跳出循环执行迁移操作
                advance = false;
            }
        }

        // 【分配完成，开始数据迁移操作】
        // 【CASE1】：i < 0 成立表示当前线程未分配到任务，或者任务执行完了
        if (i < 0 || i >= n || i + n >= nextn) {
            int sc;
            // 如果迁移完成
            if (finishing) {
                nextTable = null;    // help GC
                table = nextTab;    // 新表赋值给当前对象
                sizeCtl = (n << 1) - (n >>> 1);// 扩容阈值为 2n - n/2 = 3n/2 = 0.75*(2n)
                return;
            }
            // 当前线程完成了分配的任务区间，可以退出，先把 sizeCtl 赋值给 sc 保留
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                // 判断当前线程是不是最后一个线程，不是的话直接 return，
                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                    return;
                // 所以最后一个线程退出的时候，sizeCtl 的低 16 位为 1
                finishing = advance = true;
                // 【这里表示最后一个线程需要重新检查一遍是否有漏掉的区间】
                i = n;
            }
        }

        // 【CASE2】：当前桶位未存放数据，只需要将此处设置为 fwd 节点即可。
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        // 【CASE3】：说明当前桶位已经迁移过了，当前线程不用再处理了，直接处理下一个桶位即可
        else if ((fh = f.hash) == MOVED)
            advance = true; 
        // 【CASE4】：当前桶位有数据，而且 node 节点不是 fwd 节点，说明这些数据需要迁移
        else {
            // 【锁住头节点】
            synchronized (f) {
                // 二次检查，防止头节点已经被修改了，因为这里才是线程安全的访问
                if (tabAt(tab, i) == f) {
                    // 【迁移数据的逻辑，和 HashMap 相似】

                    // ln 表示低位链表引用
                    // hn 表示高位链表引用
                    Node<K,V> ln, hn;
                    // 哈希 > 0 表示当前桶位是链表桶位
                    if (fh >= 0) {
                        // 和 HashMap 的处理方式一致，与老数组长度相与，16 是 10000
                        // 判断对应的 1 的位置上是 0 或 1 分成高低位链表
                        int runBit = fh & n;
                        Node<K,V> lastRun = f;
                        // 遍历链表，寻找【逆序看】最长的对应位相同的链表，看下面的图更好的理解
                        for (Node<K,V> p = f.next; p != null; p = p.next) {
                            // 将当前节点的哈希 与 n
                            int b = p.hash & n;
                            // 如果当前值与前面节点的值 对应位 不同，则修改 runBit，把 lastRun 指向当前节点
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        // 判断筛选出的链表是低位的还是高位的
                        if (runBit == 0) {
                            ln = lastRun;    // ln 指向该链表
                            hn = null;        // hn 为 null
                        }
                        // 说明 lastRun 引用的链表为高位链表，就让 hn 指向高位链表头节点
                        else {
                            hn = lastRun;
                            ln = null;
                        }
                        // 从头开始遍历所有的链表节点，迭代到 p == lastRun 节点跳出循环
                        for (Node<K,V> p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph & n) == 0)
                                // 【头插法】，从右往左看，首先 ln 指向的是上一个节点，
                                // 所以这次新建的节点的 next 指向上一个节点，然后更新 ln 的引用
                                ln = new Node<K,V>(ph, pk, pv, ln);
                            else
                                hn = new Node<K,V>(ph, pk, pv, hn);
                        }
                        // 高低位链设置到新表中的指定位置
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        // 老表中的该桶位设置为 fwd 节点
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                    // 条件成立：表示当前桶位是 红黑树结点
                    else if (f instanceof TreeBin) {
                        TreeBin<K,V> t = (TreeBin<K,V>)f;
                        TreeNode<K,V> lo = null, loTail = null;
                        TreeNode<K,V> hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        // 迭代 TreeBin 中的双向链表，从头结点至尾节点
                        for (Node<K,V> e = t.first; e != null; e = e.next) {
                            // 迭代的当前元素的 hash
                            int h = e.hash;
                            TreeNode<K,V> p = new TreeNode<K,V>
                                (h, e.key, e.val, null, null);
                            // 条件成立表示当前循环节点属于低位链节点
                            if ((h & n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    //【尾插法】
                                    loTail.next = p;
                                // loTail 指向尾节点
                                loTail = p;
                                ++lc;
                            }
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                        // 拆成的高位低位两个链，【判断是否需要需要转化为链表】，反之保持树化
                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                        (hc != 0) ? new TreeBin<K,V>(lo) : t;
                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                        (lc != 0) ? new TreeBin<K,V>(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                }
            }
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>helpTransfer()：帮助扩容机制</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    // 数组不为空，节点是转发节点，获取转发节点指向的新表开始协助主线程扩容
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        // 扩容标识戳
        int rs = resizeStamp(tab.length);
        // 判断数据迁移是否完成，迁移完成会把 新表赋值给 nextTable 属性
        while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) {
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex <= 0)
                break;
            // 设置扩容线程数量 + 1
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                // 协助扩容
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="获取方法：get"><a href="#获取方法：get" class="headerlink" title="获取方法：get"></a>获取方法：get</h4><ul>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置: (n - 1) &amp; h  等价于 h % n</li>
<li>根据该位置处结点性质进行相应查找 <ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // 判断头节点是否就是我们需要的节点
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树
        else if (eh < 0)
            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)
            return (p = e.find(h, key)) != null ? p.val : null;

        // 遍历链表
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="删除方法：remove"><a href="#删除方法：remove" class="headerlink" title="删除方法：remove"></a>删除方法：remove</h4><ul>
<li><p>remove()：删除指定元素</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public V remove(Object key) {
    return replaceNode(key, null, null);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>replaceNode()：替代指定的元素，会协助扩容，<strong>增删改（写）都会协助扩容，查询（读）操作不会</strong>，因为读操作不涉及加锁</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final V replaceNode(Object key, V value, Object cv) {
    // 计算 key 扰动运算后的 hash
    int hash = spread(key.hashCode());
    // 开始自旋
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;

        // 【CASE1】：table 还未初始化或者哈希寻址的数组索引处为 null，直接结束自旋，返回 null
        if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) & hash)) == null)
            break;
        // 【CASE2】：条件成立说明当前 table 正在扩容，【当前是个写操作，所以当前线程需要协助 table 完成扩容】
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        // 【CASE3】：当前桶位可能是 链表 也可能是 红黑树 
        else {
            // 保留替换之前数据引用
            V oldVal = null;
            // 校验标记
            boolean validated = false;
            // 【加锁当前桶位头结点】，加锁成功之后会进入代码块
            synchronized (f) {
                // 双重检查
                if (tabAt(tab, i) == f) {
                    // 说明当前节点是链表节点
                    if (fh >= 0) {
                        validated = true;
                        //遍历所有的节点
                        for (Node<K,V> e = f, pred = null;;) {
                            K ek;
                            // hash 和值都相同，定位到了具体的节点
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                // 当前节点的value
                                V ev = e.val;
                                if (cv == null || cv == ev ||
                                    (ev != null && cv.equals(ev))) {
                                    // 将当前节点的值 赋值给 oldVal 后续返回会用到
                                    oldVal = ev;
                                    if (value != null)        // 条件成立说明是替换操作
                                        e.val = value;    
                                    else if (pred != null)    // 非头节点删除操作，断开链表
                                        pred.next = e.next;    
                                    else
                                        // 说明当前节点即为头结点，将桶位头节点设置为以前头节点的下一个节点
                                        setTabAt(tab, i, e.next);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                    // 说明是红黑树节点
                    else if (f instanceof TreeBin) {
                        validated = true;
                        TreeBin<K,V> t = (TreeBin<K,V>)f;
                        TreeNode<K,V> r, p;
                        if ((r = t.root) != null &&
                            (p = r.findTreeNode(hash, key, null)) != null) {
                            V pv = p.val;
                            if (cv == null || cv == pv ||
                                (pv != null && cv.equals(pv))) {
                                oldVal = pv;
                                // 条件成立说明替换操作
                                if (value != null)
                                    p.val = value;
                                // 删除操作
                                else if (t.removeTreeNode(p))
                                    setTabAt(tab, i, untreeify(t.first));
                            }
                        }
                    }
                }
            }
            // 其他线程修改过桶位头结点时，当前线程 sync 头结点锁错对象，validated 为 false，会进入下次 for 自旋
            if (validated) {
                if (oldVal != null) {
                    // 替换的值为 null，【说明当前是一次删除操作，更新当前元素个数计数器】
                    if (value == null)
                        addCount(-1L, -1);
                    return oldVal;
                }
                break;
            }
        }
    }
    return null;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="JDK7原理"><a href="#JDK7原理" class="headerlink" title="JDK7原理"></a>JDK7原理</h3><p>ConcurrentHashMap 对锁粒度进行了优化，<strong>分段锁技术</strong>，将整张表分成了多个数组（Segment），每个数组又是一个类似 HashMap 数组的结构。允许多个修改操作并发进行，Segment 是一种可重入锁，继承 ReentrantLock，并发时锁住的是每个 Segment，其他 Segment 还是可以操作的，这样不同 Segment 之间就可以实现并发，大大提高效率。</p>
<p>底层结构： <strong>Segment 数组 + HashEntry 数组 + 链表</strong>（数组 + 链表是 HashMap 的结构）</p>
<ul>
<li><p>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 JDK8 中是类似的</p>
</li>
<li><p>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301071534470.png" alt=""></p>
<h2 id="❷CopyOnWriteArrayList"><a href="#❷CopyOnWriteArrayList" class="headerlink" title="❷CopyOnWriteArrayList"></a>❷CopyOnWriteArrayList</h2><h3 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h3><p>CopyOnWriteArrayList 采用了<strong>写入时拷贝</strong>的思想，增删改操作会将底层数组拷贝一份，在新数组上执行操作，不影响其它线程的<strong>并发读，读写分离</strong></p>
<p>CopyOnWriteArraySet 底层对 CopyOnWriteArrayList 进行了包装，装饰器模式</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public CopyOnWriteArraySet() {
    al = new CopyOnWriteArrayList<E>();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>存储结构：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private transient volatile Object[] array;    // volatile 保证了读写线程之间的可见性
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>全局锁：保证线程的执行安全</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final transient ReentrantLock lock = new ReentrantLock();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>新增数据：需要加锁，<strong>创建新的数组操作</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 加锁，保证线程安全
    lock.lock();
    try {
        // 获取旧的数组
        Object[] elements = getArray();
        int len = elements.length;
        // 【拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）】
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 添加新元素
        newElements[len] = e;
        // 替换旧的数组，【这个操作以后，其他线程获取数组就是获取的新数组了】
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>读操作：不加锁，<strong>在原数组上操作</strong></p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public E get(int index) {
    return get(getArray(), index);
}
private E get(Object[] a, int index) {
    return (E) a[index];
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>适合读多写少的应用场景</p>
</li>
<li><p>迭代器：CopyOnWriteArrayList 在返回迭代器时，<strong>创建一个内部数组当前的快照（引用）</strong>，即使其他线程替换了原始数组，迭代器遍历的快照依然引用的是创建快照时的数组，所以这种实现方式也存在一定的数据延迟性，对其他线程并行添加的数据不可见</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public Iterator<E> iterator() {
    // 获取到数组引用，整个遍历的过程该数组都不会变，一直引用的都是老数组，
    return new COWIterator<E>(getArray(), 0);
}

// 迭代器会创建一个底层array的快照，故主类的修改不影响该快照
static final class COWIterator<E> implements ListIterator<E> {
    // 内部数组快照
    private final Object[] snapshot;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        // 数组的引用在迭代过程不会改变
        snapshot = elements;
    }
    // 【不支持写操作】，因为是在快照上操作，无法同步回去
    public void remove() {
        throw new UnsupportedOperationException();
    } 
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>数据一致性就是读到最新更新的数据：</p>
<ul>
<li><p>强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值</p>
</li>
<li><p>弱一致性：系统并不保证进程或者线程的访问都会返回最新的更新过的值，也不会承诺多久之后可以读到</p>
</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202301071536087.png" style="zoom:80%;" /></p>
<p>Thread-0 读到了脏数据</p>
<p>不一定弱一致性就不好</p>
<ul>
<li>数据库的<strong>事务隔离级别</strong>就是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>
<h2 id="❸ConcurrentLinkedQueue"><a href="#❸ConcurrentLinkedQueue" class="headerlink" title="❸ConcurrentLinkedQueue"></a>❸ConcurrentLinkedQueue</h2><p>并发编程中，需要用到安全的队列，实现安全队列可以使用 2 种方式：</p>
<ul>
<li>加锁，这种实现方式是阻塞队列</li>
<li>使用循环 CAS 算法实现，这种方式是非阻塞队列</li>
</ul>
<p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部，当获取一个元素时，会返回队列头部的元素</p>
<p>补充：ConcurrentLinkedDeque 是双向链表结构的无界并发队列</p>
<p>ConcurrentLinkedQueue 使用约定：</p>
<ol>
<li>不允许 null 入列</li>
<li>队列中所有未删除的节点的 item 都不能为 null 且都能从 head 节点遍历到</li>
<li>删除节点是将 item 设置为 null，队列迭代时跳过 item 为 null 节点</li>
<li>head 节点跟 tail 不一定指向头节点或尾节点，可能<strong>存在滞后性</strong></li>
</ol>
<p>ConcurrentLinkedQueue 由 head 节点和 tail 节点组成，每个节点由节点元素和指向下一个节点的引用组成，组成一张链表结构的队列</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private transient volatile Node<E> head;
private transient volatile Node<E> tail;

private static class Node<E> {
    volatile E item;
    volatile Node<E> next;
    //.....
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="❹ConcurrentSkipListMap"><a href="#❹ConcurrentSkipListMap" class="headerlink" title="❹ConcurrentSkipListMap"></a>❹ConcurrentSkipListMap</h2><p>。。。</p>
<h1 id="Sponsor❤️"><a href="#Sponsor❤️" class="headerlink" title="Sponsor❤️"></a>Sponsor❤️</h1><p>您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰</p>
<table>
  <tbody>
     <tr>
         <td style="text-align:center;">支付宝</td>
         <td style="text-align:center;">微信</td>
     </tr>
   <tr>
    <td style="text-align:center;" ><img width="200" src="https://jwt1399.top/medias/reward/alipay.png"></td>    
      <td style="text-align:center;"><img width="200" src="https://jwt1399.top/medias/reward/sponor_wechat.png"></td>     
  </tr>
</tbody></table>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top" rel="external nofollow noreferrer">简简</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top/posts/3092.html">https://jwt1399.top/posts/3092.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jwt1399.top" target="_blank">简简</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JUC/">
                                    <span class="chip bg-color">JUC</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,linkedin,facebook,twitter,google,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">打</a>
	<a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>
    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        /*max-width: 100%;*/
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    .v[data-class=v] .vinput {
     padding: 0px 0px;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论<center>填上邮箱会收到评论回复提醒哦!!!</center></span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/valine/1.4.18/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Awf92dhT3VWqTfENqbCDoqbA-gzGzoHsz',
        appKey: '9uN7ODvigK9GAp8CYBz0fOrX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: '',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '[填上邮箱，会给你发送评论提醒]，ヾﾉ≧∀≦)o 请畅所欲言~',
        enableQQ: true,
        boolean: true,
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/49068.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top/img/20220118195531.png" class="responsive-img" alt="可搜索加密：DVSSE方案">
                        
                        <span class="card-title">可搜索加密：DVSSE方案</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            论文名称：《Dynamic Verifiable Encrypted Keyword Search Using Bitmap Index and Homomorphic MAC》


作者：Rajkumar Ramasamy; S. Sre
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-12-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Crypto/" class="post-category">
                                    Crypto
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%8F%AF%E6%90%9C%E7%B4%A2%E5%8A%A0%E5%AF%86/">
                        <span class="chip bg-color">可搜索加密</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/14485.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top/img/202212022124200.jpg" class="responsive-img" alt="Java-JVM">
                        
                        <span class="card-title">Java-JVM</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-12-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaSE/" class="post-category">
                                    JavaSE
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM/">
                        <span class="chip bg-color">JVM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 简言之<br />'
            + '文章作者: 简简<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://jwt1399.top" target="_blank">简简</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;|

			<!-- <span>为♥️️发电</span> -->
            <a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img no-lazy src="https://img.jwt1399.top/img/20200824181422.png" style="width: 47px; vertical-align: middle;" ></a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">712.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "7";
                    var startDate = "2";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            <a href="https://search.google.com/search-console?resource_id=http%3A%2F%2Fjwt1399.top%2F" target="_blank"
                rel="nofollow noopener">谷歌统计</a>&nbsp;|
            
            <span id="icp"><img no-lazy src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://www.beian.miit.gov.cn/" target="_blank">蜀ICP备19020450号</a>
            </span>
            |
            
            <a href="https://tongji.baidu.com/web/10000159136/overview/index?siteId=14519996" target="_blank"
                rel="nofollow noopener">百度统计</a>

        </div>
        <div class="col s12 m4 l4 social-link social-statis">

    <a href="https://jwt1399.top/baidusitemap.xml" class="tooltipped" target="_blank" data-tooltip="访问我的sitemap" data-position="top" data-delay="50">
        <i class="fas fa-sitemap"></i>
    </a>


    <a href="https://pl.jwt1399.top" class="tooltipped" target="_blank" data-tooltip="valine评论: https://pl.jwt1399.top" data-position="top" data-delay="50">
        <i class="fab fa-optin-monster"></i>
    </a>


    <a href="mailto:1019084218@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope"></i>
    </a>













    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1019084218" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1019084218" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.json", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.staticfile.org/aos/3.0.0-beta.6/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
	<!--valine_人机验证-->
	<button id="TencentCaptcha"data-appid="2046265119"data-cbfn="callback"type="button" hidden></button>
	
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-160042502-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-160042502-1');
</script>


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0e306ce3426983ae6367d094d39f1190";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

        
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>

</html>
