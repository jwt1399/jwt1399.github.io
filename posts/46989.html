<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="高级算法设计与分析, 简简,简简博客,网络安全,计算机,Java开发">
    <meta name="description" content="⓪前言本科的时候上过《数据结构与算法》课，但彼时天真的以为搞安全不需要懂太多算法，算法部分也就没有深入去学习，没想到读研还是没能逃过，此时也已经意识到算法的重要性，初学算法时真的觉得这东西晦涩难懂，貌似毫无用处，但渐渐明白搞懂算法背后的核心">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html;charset=gb2312" />
    <meta name="sogou_site_verification" content="VTcD33rrfd" />
    <meta name="google-site-verification" content="mHsYpjV9Rl0e0UzjioJFLg8RMtOhxw8HB3D21dIWvmc" />
	<meta name="referrer" content="unsafe-url">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>高级算法设计与分析 | 简言之</title>
    <link rel="icon" type="image/png" href="/favicon.png">
	<!--变灰-->
	<!-- <link href="http://static.isenyu.cn/file/css/MemorialDay.css"; rel="stylesheet" type="text/css" /> -->
    <!-- <style type="text/css">
     html{ filter: grayscale(100%); /* 标准写法 just for IE6-9 */ 
        -webkit-filter: grayscale(100%); /* webkit 内核支持程度较好 */ 
        -moz-filter: grayscale(100%); /* 其他内核现在并不支持，为了将来兼容性书写 */ 
        -ms-filter: grayscale(100%); 
        -o-filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);
        filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); /* Firefox 3.5+ */ }
     </style> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/font-awesome/6.0.0/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/aos/0.1.0/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js"></script>
	<!--valine_人机验证-->
	<script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
	<script src="/js/Valine-RJyanzheng.js"></script>

    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="alternate" href="/atom.xml" title="简言之" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img no-lazy src="/medias/logo.png" class="logo-img" alt="">
                    
                    <span class="logo-span">简言之</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Home</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-user-secret" style="zoom: 0.6;"></i>
      
      <span>Sec</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Web/">
          
          <i class="fab fa-internet-explorer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Web</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/CTF/">
          
          <i class="fas fa-flag" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CTF</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Crypto/">
          
          <i class="fa-solid fa-shield" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Data</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fab fa-java" style="zoom: 0.6;"></i>
      
      <span>Java</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/JavaSE/">
          
          <i class="fa-solid fa-mug-saucer" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaSE</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/JavaWeb/">
          
          <i class="fa-solid fa-earth-americas" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>JavaWeb</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Spring/">
          
          <i class="fa-solid fa-leaf" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Spring</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Q-A/">
          
          <i class="fa-solid fa-bell" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Q&A</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-desktop" style="zoom: 0.6;"></i>
      
      <span>CS</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/CS%E5%9F%BA%E7%A1%80/">
          
          <i class="fa-solid fa-server" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>CS基础</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/SQL/">
          
          <i class="fas fa-database" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>数据库</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/">
          
          <i class="fa-solid fa-bezier-curve" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>结构-算法</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-layer-group" style="zoom: 0.6;"></i>
      
      <span>Others</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/Python/">
          
          <i class="fab fa-python" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Python</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Course/">
          
          <i class="fa-solid fa-graduation-cap" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Course</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Share/">
          
          <i class="fa-solid fa-crown" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Share~</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/Tools/">
          
          <i class="fas fa-tools" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Tools~</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>整理</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/tags/">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归类</span>
        </a>
      </li>
      
      <li>
        <a href="/archives/">
          
          <i class="fas fa-file-contract" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归档</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fa-solid fa-paper-plane" style="zoom: 0.6;"></i>
      
      <span>交流</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/friends/">
          
          <i class="fas fa-venus-mars" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>友链</span>
        </a>
      </li>
      
      <li>
        <a href="/contact/">
          
          <i class="fas fa-envelope" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>留言</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-id-card-alt" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img no-lazy src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">简言之</div>
        <div class="logo-desc">
            
            悄无声息地变坚强，安静地变优秀！
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Home
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-secret"></i>
			
			Sec
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Web/ " style="margin-left:50px";>
				  
				   <i class="fab fa-internet-explorer" style="position: absolute;left:28px" ></i>
			      
		          <span>Web</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/CTF/ " style="margin-left:50px";>
				  
				   <i class="fas fa-flag" style="position: absolute;left:28px" ></i>
			      
		          <span>CTF</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Crypto/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-shield" style="position: absolute;left:28px" ></i>
			      
		          <span>Data</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fab fa-java"></i>
			
			Java
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/JavaSE/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-mug-saucer" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaSE</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/JavaWeb/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-earth-americas" style="position: absolute;left:28px" ></i>
			      
		          <span>JavaWeb</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Spring/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-leaf" style="position: absolute;left:28px" ></i>
			      
		          <span>Spring</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Q-A/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bell" style="position: absolute;left:28px" ></i>
			      
		          <span>Q&A</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-desktop"></i>
			
			CS
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/CS%E5%9F%BA%E7%A1%80/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-server" style="position: absolute;left:28px" ></i>
			      
		          <span>CS基础</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/SQL/ " style="margin-left:50px";>
				  
				   <i class="fas fa-database" style="position: absolute;left:28px" ></i>
			      
		          <span>数据库</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-bezier-curve" style="position: absolute;left:28px" ></i>
			      
		          <span>结构-算法</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-layer-group"></i>
			
			Others
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/categories/Python/ " style="margin-left:50px";>
				  
				   <i class="fab fa-python" style="position: absolute;left:28px" ></i>
			      
		          <span>Python</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Course/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-graduation-cap" style="position: absolute;left:28px" ></i>
			      
		          <span>Course</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Share/ " style="margin-left:50px";>
				  
				   <i class="fa-solid fa-crown" style="position: absolute;left:28px" ></i>
			      
		          <span>Share~</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/categories/Tools/ " style="margin-left:50px";>
				  
				   <i class="fas fa-tools" style="position: absolute;left:28px" ></i>
			      
		          <span>Tools~</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			整理
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/tags/ " style="margin-left:50px";>
				  
				   <i class="fas fa-bookmark" style="position: absolute;left:28px" ></i>
			      
		          <span>归类</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/archives/ " style="margin-left:50px";>
				  
				   <i class="fas fa-file-contract" style="position: absolute;left:28px" ></i>
			      
		          <span>归档</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fa-solid fa-paper-plane"></i>
			
			交流
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/friends/ " style="margin-left:50px";>
				  
				   <i class="fas fa-venus-mars" style="position: absolute;left:28px" ></i>
			      
		          <span>友链</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact/ " style="margin-left:50px";>
				  
				   <i class="fas fa-envelope" style="position: absolute;left:28px" ></i>
			      
		          <span>留言</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-id-card-alt"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('猜猜密码是什么呢ヾﾉ≧∀≦)o')).toString(CryptoJS.enc.Hex)) {
                alert('哎呦！密码好像不对哟，将返回主页！');
                location.href = '/';	
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://img.jwt1399.top//img/20211007114153.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">高级算法设计与分析</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    /*.toc-widget {
        width: 345px;
        padding-left: 20px;
    }*/
    .toc-widget {
        width: 345px;
        padding-left: 20px;
        /* 毛玻璃 */
        /*background-color: rgba(162,101,228, 0.08);*/
        /*backdrop-filter: saturate(180%) blur(20px);*/
        /*目录样式修改*/
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }
    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" class="post-category">
                                结构-算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-05-14
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.4k
                </div>
                

                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="⓪前言"><a href="#⓪前言" class="headerlink" title="⓪前言"></a>⓪前言</h2><p>本科的时候上过《数据结构与算法》课，但彼时天真的以为搞安全不需要懂太多算法，算法部分也就没有深入去学习，没想到读研还是没能逃过，此时也已经意识到算法的重要性，初学算法时真的觉得这东西晦涩难懂，貌似毫无用处，但渐渐明白搞懂算法背后的核心思想能让你写出更加优雅的代码。作此文的目的有四，一来是复习本科阶段学了但又遗忘的知识；二来感到近日记忆力下降明显，学过的东西不一会就忘了，记下来以便日后复习吧，再者好记性不如烂笔头；三来是以此做为 UESTC 研一《高级算法设计与分析》课程的期末复习笔记；四来是希望能给此时正在看此文的你一点点帮助吧。小简的水平和精力有限，文章中难免存在一些错误和不足，恳请读者批评指正，如发现错误，请及时与简简联系进行更正，我们共同使文章更加完善，大家可以在评论区留下自己想法，一起交流，谢谢🙏</p>
<ul>
<li><p><code>课件下载：</code><a target="_blank" rel="noopener" href="https://jwt1399.lanzouo.com/b01cy151a">https://jwt1399.lanzouo.com/b01cy151a</a> 密码:1399</p>
</li>
<li><p>配合 <a href="https://jwt1399.top/posts/40445.html">数据结构与算法 | 简言之 (jwt1399.top)</a> 食用效果更佳</p>
</li>
</ul>
<h2 id="①算法引论"><a href="#①算法引论" class="headerlink" title="①算法引论"></a>①算法引论</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li>理解什么是算法，算法的特征，算法和程序的差别；</li>
<li>理解什么是判断问题和优化问题。</li>
</ul>
</blockquote>
<h3 id="❶什么是算法"><a href="#❶什么是算法" class="headerlink" title="❶什么是算法"></a>❶什么是算法</h3><ul>
<li><strong>算法</strong>是求解问题的一系列计算步骤，用来将输入数据转换成输出结果    <code>从蛮力到策略</code></li>
<li><strong>数据结构</strong>是数据的组织与存储：<code>从杂乱无章到井然有序</code></li>
<li><strong>算法 + 数据结构 &#x3D; 程序</strong></li>
</ul>
<h3 id="❷算法的特征"><a href="#❷算法的特征" class="headerlink" title="❷算法的特征"></a>❷算法的特征</h3><ul>
<li><p>输入性：必须有0个或多个输入（待处理信息） </p>
</li>
<li><p>输出性：应有一个或多个输出（已处理信息） </p>
</li>
<li><p>确定性：组成算法的每条指令是清晰的、无歧义</p>
</li>
<li><p>有穷性：算法必须总能在执行有限步之后终止</p>
</li>
</ul>
<h3 id="❸什么是好算法"><a href="#❸什么是好算法" class="headerlink" title="❸什么是好算法"></a>❸什么是好算法</h3><ul>
<li><p>正确性：符合语法、编译通过；</p>
</li>
<li><p>健壮性：能辨别不合法的输入并做适当的处理，不至于异常退出（崩溃） </p>
</li>
<li><p>可读性：结构化 + 准确的命名 + 注释 </p>
</li>
<li><p>效率性：速度尽可能快；存储空间尽可能少</p>
</li>
</ul>
<h3 id="❹算法和程序的差别"><a href="#❹算法和程序的差别" class="headerlink" title="❹算法和程序的差别"></a>❹算法和程序的差别</h3><ul>
<li>程序是算法用某种程序语言的一个具体实现</li>
<li>程序是用来给计算机读的，算法是给人来读的</li>
<li>程序可以不满足算法的有穷性。</li>
</ul>
<h3 id="❺判断问题和优化问题"><a href="#❺判断问题和优化问题" class="headerlink" title="❺判断问题和优化问题"></a>❺判断问题和优化问题</h3><ul>
<li><strong>判断问题</strong>：是否存在一个…(如小于k的点覆盖)</li>
<li><strong>优化问题</strong>：找出最大&#x2F;最小的…(最小点覆盖)</li>
</ul>
<p>很多经典的难问题都是优化问题，而一个优化问题往往可以转换成对应的判断问题。</p>
<h3 id="❻经典算法分析"><a href="#❻经典算法分析" class="headerlink" title="❻经典算法分析"></a>❻经典算法分析</h3><p>贪心算法：逐步建立一个解决方案，具体地优化一些局部准则。 自顶向下。</p>
<p>分治算法：将一个问题分解成独立的子问题，求解每个子问题，并将子问题的解组合起来形成原问题的解。  自顶向下。</p>
<p>动态规划：把一个问题分解成一系列相互重叠的子问题，并为越来越大的子问题建立解决方案。自底向上。</p>
<h2 id="②算法复杂度"><a href="#②算法复杂度" class="headerlink" title="②算法复杂度"></a>②算法复杂度</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li><p>理解指数增长的恐怖；理解算法分析里为什么常数倍的差别可以被忽略</p>
</li>
<li><p>掌握渐近符号O、W、Q的含义，能判断一个函数属于哪个渐近增长阶；</p>
</li>
<li><p>能对给定函数按照渐进增长率进行排序，典型考题：</p>
</li>
</ul>
</blockquote>
<h3 id="❶渐近符号"><a href="#❶渐近符号" class="headerlink" title="❶渐近符号"></a>❶渐近符号</h3><p><img src="https://img.jwt1399.top//img/20211016202335.jpeg" alt="Θ,O,Ω的图像表示"></p>
<p><strong>Θ(渐近紧确界)：</strong></p>
<ul>
<li><p>存在正常数 c<sub>1</sub> , c<sub>2</sub>和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：c<sub>1</sub>g(n) ≤ f(n) ≤ c<sub>2</sub>g(n)，记为f(n) ∈ Θ(g(n))</p>
</li>
<li><p>例如：n<sup>2</sup>+3n+2∈Θ(n<sup>2</sup>)、n(n-1)&#x2F;2∈Θ (n<sup>2</sup>)、4n<sup>2</sup>+5 ∈Θ (n<sup>2</sup>)</p>
</li>
</ul>
<p><strong>O(渐近上界)：</strong></p>
<ul>
<li><p>存在正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：f(n) ≤  cg(n)，记为f(n) ∈ O(g(n))</p>
</li>
<li><p>例如：n ∈O(n<sup>2</sup>)、100n+5 ∈O(n<sup>2</sup>)、n(n-1)&#x2F;2 ∈O(n<sup>2</sup>)</p>
</li>
</ul>
<p><strong>Ω(渐近下界)：</strong></p>
<ul>
<li>存在正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：f(n) ≥ cg(n)，记为f(n) ∈ Ω(g(n))</li>
<li>例如：n<sup>3</sup>∈Ω (n<sup>2</sup>)、n(n+1)∈Ω (n<sup>2</sup>)、4n<sup>2</sup>+5 ∈Ω (n<sup>2</sup>)</li>
</ul>
<p><img src="https://img.jwt1399.top//img/20211016205620.png"></p>
<h3 id="❷复杂度"><a href="#❷复杂度" class="headerlink" title="❷复杂度"></a>❷复杂度</h3><blockquote>
<p> 时间复杂度具有「最差」、「平均」、「最佳」三种情况，分别使用 O , Θ , Ω 三种符号表示。</p>
</blockquote>
<p>根据从小到大排列，常见的算法时间复杂度主要有：</p>
<p>O(1) &lt; O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(2<sup>n</sup>)&lt;O(n!)&lt;O(n<sup>n</sup>)</p>
<p><img src="https://img.jwt1399.top//img/20211016203924.png"></p>
<h3 id="❸渐进增长率比较"><a href="#❸渐进增长率比较" class="headerlink" title="❸渐进增长率比较"></a>❸渐进增长率比较</h3><p>方法1：<strong>定义法</strong></p>
<p>找到正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub> 有 f(n) ≤ cg(n)，则f(n) &#x3D; O(g(n))</p>
<p>方法2：<strong>极限法</strong></p>
<p>比较两个函数f(n)和g(n)的渐近增长率时，可以对两个函数相除，然后令变量 n 趋向于无穷，看这个极限值是无穷大还是一个大于零的常数还是趋向于0。</p>
<p><img src="https://img.jwt1399.top/img/image-20211016205209274.png"></p>
<ul>
<li>前两种情况意味着f(n) ∈ O(g(n))</li>
<li>后两种情况意味着f(n) ∈ Ω(g(n))</li>
<li>第二种情况意味着f(n) ∈ Θ(g(n))</li>
</ul>
<p>方法3：<strong>取对数法</strong></p>
<p>对于比较难的比较的两个函数，我们可以对它们同时取对数后再进行比较</p>
<p><code>常见对数公式：</code></p>
<ul>
<li><p>log<sub>a</sub>m*n &#x3D; log<sub>a</sub>m + log<sub>a</sub>n</p>
</li>
<li><p>log<sub>a</sub>(m&#x2F;n) &#x3D; log<sub>a</sub>m - log<sub>a</sub>n</p>
</li>
<li><p>log<sub>a</sub>m<sup>n</sup> &#x3D; nlog<sub>a</sub>m</p>
</li>
<li><p>log<sub>a</sub><sup>n</sup>√m &#x3D; (1&#x2F;n)log<sub>a</sub>m</p>
</li>
<li><p>log<sub>a</sub>b &#x3D; log<sub>c</sub>b &#x2F; log<sub>c</sub>a </p>
</li>
<li><p>a<sup>log<sub>a</sub>b</sup> &#x3D; b</p>
</li>
</ul>
<h3 id="❹真题练习"><a href="#❹真题练习" class="headerlink" title="❹真题练习"></a>❹真题练习</h3><h4 id="➀题目1"><a href="#➀题目1" class="headerlink" title="➀题目1"></a>➀题目1</h4><p>判断 f(n) &#x3D; 32n<sup>2</sup> + 17n + 32 属于哪些渐近增长阶<br>O(n), Ω(n), Θ(n), O(n<sup>2</sup>), Θ(n<sup>2</sup>), Ω(n<sup>2</sup>),O(n<sup>3</sup>), Ω(n<sup>3</sup>), Θ(n<sup>3</sup>). </p>
<p>f(n) 属于 Ω(n),O(n<sup>2</sup>), Ω(n<sup>2</sup>), Θ(n<sup>2</sup>) ,O(n<sup>3</sup>)<br>f(n) 不属于 O(n), Θ(n), Ω(n<sup>3</sup>), Θ(n<sup>3</sup>)</p>
<h4 id="➁题目2"><a href="#➁题目2" class="headerlink" title="➁题目2"></a>➁题目2</h4><p><img src="https://img.jwt1399.top//img/20211016213402.png"></p>
<p>f<sub>1</sub>(n) &#x3D; √n + log<sup>100</sup>n &#x3D; O(√n)</p>
<p>f<sub>2</sub>(n) &#x3D; 2<sup>logn</sup> * 2<sup>loglogn</sup> &#x3D; nlogn</p>
<p>f<sub>3</sub>(n) &#x3D; 100logn + nlog3 &#x3D; O(n)</p>
<p>f<sub>4</sub>(n) &#x3D; O(3<sup>n</sup>)、f<sub>5</sub>(n) &#x3D; 100log<sup>2</sup>n、f<sub>6</sub>(n) &#x3D;  O(n!)</p>
<p>(1)显然 f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) </p>
<p>(2)f<sub>5</sub>(n) 是对数的幂，f<sub>1</sub>(n) 是幂函数，因此 f<sub>5</sub>(n)＜ f<sub>1</sub>(n)</p>
<p>综上所述： f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)＜ f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) </p>
<h4 id="➂题目3"><a href="#➂题目3" class="headerlink" title="➂题目3"></a>➂题目3</h4><p><img src="https://img.jwt1399.top//img/20211016213526.png"></p>
<p>f<sub>1</sub>(n) &#x3D; nlog<sup>n</sup>n 、f<sub>2</sub>(n) &#x3D; logn、f<sub>3</sub>(n) &#x3D; log<sup>5</sup>n </p>
<p>f<sub>4</sub>(n) &#x3D; n<sup>1&#x2F;5</sup>、f<sub>5</sub>(n) &#x3D; n<sup>1&#x2F;10</sup>log<sup>50</sup>n</p>
<p>(1)f<sub>2</sub>(n)＜ f<sub>3</sub>(n)</p>
<p>(2)f<sub>3</sub>(n)是对数的幂，f<sub>4</sub>(n) 是幂函数，因此 f<sub>3</sub>(n)＜ f<sub>4</sub>(n)</p>
<p>(3) lim f<sub>1</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; lim (n<sup>4&#x2F;5</sup>log<sup>n</sup>n) &#x3D; ∞ ，因此 f<sub>4</sub>(n) &lt; f<sub>1</sub>(n) </p>
<p>​		lim f<sub>5</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; lim (n<sup>-1&#x2F;10</sup>log<sup>50</sup>n) &#x3D; 0 ，因此 f<sub>5</sub>(n) &lt; f<sub>4</sub>(n) </p>
<p>(4)对f<sub>1</sub>(n)、f<sub>3</sub>(n)、f<sub>5</sub>(n)取对数</p>
<p>​	logf<sub>1</sub>(n) &#x3D; logn + nloglogn &#x3D; Θ(nloglogn) &#x3D; O(n)</p>
<p>​	logf<sub>3</sub>(n) &#x3D; 5loglogn &#x3D; O(loglogn)</p>
<p>​	logf<sub>5</sub>(n) &#x3D; (1&#x2F;10)logn + 50loglogn &#x3D; O(logn)</p>
<p>因此 f<sub>3</sub>(n) ＜ f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)</p>
<p>综上所述： f<sub>2</sub>(n)＜ f<sub>3</sub>(n)＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n)＜ f<sub>1</sub>(n)</p>
<h4 id="➃题目4"><a href="#➃题目4" class="headerlink" title="➃题目4"></a>➃题目4</h4><p><img src="https://img.jwt1399.top/img/202111161254116.png"></p>
<p>对f<sub>1</sub>(n)、f<sub>2</sub>(n)、f<sub>3</sub>(n)、f<sub>3</sub>(n)、f<sub>5</sub>(n)取对数</p>
<p>​	logf<sub>1</sub>(n) &#x3D; nlog10 &#x3D; O(n)</p>
<p>​	logf<sub>2</sub>(n) &#x3D; 1&#x2F;3logn &#x3D; O(logn)</p>
<p>​	logf<sub>3</sub>(n) &#x3D; nlogn &#x3D; O(nlogn)</p>
<p>​	logf<sub>4</sub>(n) &#x3D; loglogn &#x3D; O(loglogn)</p>
<p>​	logf<sub>5</sub>(n) &#x3D; √logn &#x3D; O(√logn)</p>
<p>因此 f<sub>4</sub>(n)＜f<sub>5</sub>(n)＜ f<sub>2</sub>(n)＜ f<sub>1</sub>(n) ＜ f<sub>3</sub>(n) </p>
<h4 id="➄题目5"><a href="#➄题目5" class="headerlink" title="➄题目5"></a>➄题目5</h4><p><img src="https://img.jwt1399.top//img/20211021120457.png"></p>
<p>f<sub>2</sub>(n) &#x3D; 2<sup>logn</sup>*2<sup>loglogn</sup> &#x3D; nlogn</p>
<p>lim f<sub>1</sub>(n)&#x2F; f<sub>2</sub>(n) &#x3D; lim (log<sup>99</sup>n) &#x3D; ∞ ，因此 f<sub>2</sub>(n) &lt; f<sub>1</sub>(n) </p>
<p>lim f<sub>1</sub>(n)&#x2F; f<sub>3</sub>(n) &#x3D; lim (log<sup>99.5</sup>n&#x2F;n<sup>0.25</sup>) &#x3D; 0 ，因此 f<sub>1</sub>(n) &lt; f<sub>3</sub>(n) </p>
<p>lim f<sub>5</sub>(n)&#x2F; f<sub>3</sub>(n) &#x3D; L &#x3D; ∞ ，因此 f<sub>3</sub>(n) &lt; f<sub>5</sub>(n) </p>
<p>lim f<sub>5</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; L &#x3D; 0 ，因此 f<sub>5</sub>(n) &lt; f<sub>4</sub>(n) </p>
<p>综上所述： f<sub>2</sub>(n)＜f<sub>1</sub>(n)＜ f<sub>3</sub>(n)＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n) </p>
<h4 id="➅题目6"><a href="#➅题目6" class="headerlink" title="➅题目6"></a>➅题目6</h4><p><img src="https://img.jwt1399.top//img/20211021120454.png"></p>
<p>f<sub>1</sub>(n) &#x3D; nlog<sup>n</sup>n、f<sub>2</sub>(n) &#x3D; 100log<sup>2</sup>n、f<sub>3</sub>(n) &#x3D; n<sup>2</sup>logn、f<sub>4</sub>(n) &#x3D; nlogn、f<sub>5</sub>(n) &#x3D; n<sup>1&#x2F;10</sup></p>
<p>(1)显然 f<sub>4</sub>(n)＜f<sub>1</sub>(n)</p>
<p>(2)f<sub>2</sub>(n)是对数的幂，f<sub>5</sub>(n) 是幂函数，因此 f<sub>2</sub>(n)＜ f<sub>5</sub>(n)</p>
<p>(3)lim f<sub>3</sub>(n)&#x2F; f<sub>5</sub>(n) &#x3D; lim (n<sup>19&#x2F;10</sup>logn) &#x3D; ∞ ，因此 f<sub>5</sub>(n) &lt; f<sub>3</sub>(n) </p>
<p>lim f<sub>1</sub>(n)&#x2F; f<sub>2</sub>(n) &#x3D; lim (nlog<sup>n-2</sup>n&#x2F;100) &#x3D; ∞ ，因此 f<sub>2</sub>(n) &lt; f<sub>1</sub>(n) </p>
<p>lim f<sub>2</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; lim (100logn&#x2F;n) &#x3D; 0 ，因此 f<sub>2</sub>(n) &lt; f<sub>4</sub>(n) </p>
<p>lim f<sub>5</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; lim (100logn&#x2F;n) &#x3D; 0 ，因此 f<sub>5</sub>(n) &lt; f<sub>4</sub>(n) </p>
<p>lim f<sub>3</sub>(n)&#x2F; f<sub>4</sub>(n) &#x3D; lim (100logn&#x2F;n) &#x3D; ∞ ，因此 f<sub>4</sub>(n) &lt; f<sub>3</sub>(n) </p>
<p>lim f<sub>1</sub>(n)&#x2F; f<sub>3</sub>(n) &#x3D; lim ((log<sup>n-1</sup>n)&#x2F;n) &#x3D; ∞ ，因此 f<sub>3</sub>(n) &lt; f<sub>1</sub>(n) </p>
<p>综上所述：  f<sub>2</sub>(n) ＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n)＜ f<sub>3</sub>(n)＜f<sub>1</sub>(n)</p>
<h2 id="③贪心算法"><a href="#③贪心算法" class="headerlink" title="③贪心算法"></a>③贪心算法</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li>理解贪心算法的思想；</li>
<li>能判断一个算法是否为贪心算法；</li>
<li>掌握工作安排问题Interval scheduling的贪心算法及其正确性证明。</li>
</ul>
</blockquote>
<h3 id="❶算法分析"><a href="#❶算法分析" class="headerlink" title="❶算法分析"></a>❶算法分析</h3><p>贪心算法就是用计算机模拟一个「贪心的人」来做出决策。这个贪心的人是目光短浅的，他每次总是：</p>
<ul>
<li>只做出<strong>当前看来最好的选择</strong></li>
<li><strong>只看眼前的利益，而不考虑做出选择后对未来造成的影响</strong></li>
<li>并且他一旦做出了选择，就<strong>没有办法反悔</strong>（不可回溯）</li>
</ul>
<p><code>总结：</code>在对问题求解时，总是做出在<strong>当前最好的选择</strong>。也就是说并<strong>不从整体最优考虑</strong>，他所做出的是在某种意义上的<strong>局部最优解</strong>。 因此贪心算法不是对<strong>所有问题</strong>都能得到整体最优解。</p>
<p><strong>应用场景</strong></p>
<p>解决一个问题需要多个步骤，每一个步骤有多种选择。<strong>想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心</strong>。</p>
<p> <strong>解题步骤</strong></p>
<p>贪心算法一般分为如下三步：</p>
<ul>
<li><strong>1.分解：</strong>将问题分解为若干个子问题</li>
<li><strong>2.解决：</strong>找出适合的贪心策略，求解每一个子问题的最优解</li>
<li><strong>3.合并：</strong>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="❷正确性证明"><a href="#❷正确性证明" class="headerlink" title="❷正确性证明"></a>❷正确性证明</h3><blockquote>
<p><strong>贪心算法最难的部分不在于问题的求解，而在于正确性的证明</strong>，常用的证明方法有<strong>归纳法</strong>和<strong>反证法</strong>。</p>
</blockquote>
<h4 id="➀证明方法"><a href="#➀证明方法" class="headerlink" title="➀证明方法"></a>➀证明方法</h4><ul>
<li>先假设贪心算法得到的解不是最优解，假设 S1 是贪心算法得到的解，S2 是所有最优解中和 S1 具有最多相同元素的解；</li>
<li>然后比较 S1 和 S2，观察 S1 和 S2 中第一个（最前面一个）不一样的元素；</li>
<li>然后在解 S2 中将不一样的元素换成 S1 中的那个元素得到另一个最优解 S3，这样 S3 和 S1 比 S2 和 S1有更多相同元素，和假设 S2 是与 S1 有最多相同元素的最优解矛盾，这样来推导 S1 是最优解。</li>
</ul>
<h4 id="➁真题练习"><a href="#➁真题练习" class="headerlink" title="➁真题练习"></a>➁真题练习</h4><p>有一堆货物需要被运走，现在有四种运货车：推车的容量最小，小货车的容量是推车容量的2倍，中货车的容量是两辆小货车的容量加上一辆推车的容量，大货车的容量是一辆中货车的容量加上一辆小货车的容量再加上两辆推车的容量。假设以上四种车的数量都非常多。现在要求你设计一种方案派出最少辆车将货物全搬走，其中除了推车以外其它三种车都必须装满才能发车。为这个问题设计一个算法，并证明该算法的正确性。  （8分）</p>
<hr>
<p> 参考答案：</p>
<p> 贪心算法：</p>
<p>将车型按容量由大至小排列，能装满容量大的车就先装满发车，不行就考虑容量小一级的车。</p>
<p> 证明：</p>
<p>设我们算法给出的结果为S1，即推车、小货车、中货车、大货车各a1，a2，a3，a4辆；S2 是所有最优解中和 S1 具有最多相同元素的解，即推车、小货车、中货车、大货车各b1，b2，b3，b4辆。假设 S1 和 S2 不一样，即 ai 和 bi 不一样。</p>
<p>如果i&#x3D;4，则将 S2 中两个中货车（或者4个小货车）换成一个大货车和一个推车，或者一个中货车和两个小货车（或者。。。。）换成一个大货车。</p>
<p>如果i&#x3D;3，则将 S2 中两个小货车和一个推车换成一个中货车；。。。</p>
<p>如果i&#x3D;2，两个推车换成一个小货车。</p>
<p>通过如上变换得到另一个最优解 S3，这样 S3 和 S1 比 S2 和 S1有更多相同元素，和假设 S2 是与 S1 有最多相同元素的最优解矛盾，这样来推导 S1 是最优解。</p>
<h3 id="❸区间调度-活动安排"><a href="#❸区间调度-活动安排" class="headerlink" title="❸区间调度(活动安排)"></a>❸区间调度(活动安排)</h3><blockquote>
<p><strong>问题描述：</strong>设有 n 个活动的集合 E&#x3D;{1, 2, …, n}，其中任意活动 i 都有一个起始时间 s<sub>i</sub> 和一个结束时间 f<sub>i</sub> 。如果选择了活动 i，则它在半开时间区间 [s<sub>i</sub> , f<sub>i</sub>) 内占用资源。若区间 [s<sub>i</sub> , f<sub>i</sub>) 与区间 [s<sub>j</sub> , f<sub>j</sub>) 不相交，则称<strong>活动 i 与活动 j 是相容</strong>的。每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。</p>
</blockquote>
<h4 id="➀理论分析"><a href="#➀理论分析" class="headerlink" title="➀理论分析"></a>➀理论分析</h4><p>例如有如下 11 个活动，s[i] 代表第 i 个活动开始时间，f[i] 代表第 i 个活动的结束时间，选出最大的相容活动子集合</p>
<p><img src="https://img.jwt1399.top//img/20211017214614.jpg"></p>
<p><strong>1、分析问题</strong></p>
<p>本问题为选择尽可能多的相容活动</p>
<p>约束条件是下一个活动开始时间大于或等于上一个活动结束时间 s[i] &gt;&#x3D; f[j]</p>
<p><strong>2、选择适合的贪心策略</strong></p>
<p>可能的贪心选择策略：</p>
<ul>
<li>①每次选择<strong>开始时间最早</strong>的活动</li>
<li>②每次选择<strong>持续时间最短</strong>的活动</li>
<li>③每次选择<strong>结束时间最早</strong>的活动</li>
</ul>
<p>依次证明上面哪种思路可以应用于本题，为了方便，我们用不同颜色的线条代表每个活动，线条的长度就是活动所占据的时间段，蓝色的线条表示我们已经选择的活动；红色的线条表示我们没有选择的活动。</p>
<p><strong>①</strong>每次选择<strong>开始时间最早</strong>的活动（<code>不是最优解</code>）</p>
<p><img src="https://img.jwt1399.top/img/WWEMNdAZPFyV9CATDQaG.png"></p>
<ul>
<li>证明（反证法）：<ul>
<li>先来看开始最早，很容易找到反例，如图贪开始最早，那么选择蓝色的活动，显然不是最优解，因为选择红色的活动，可以参加2次，而蓝色活动只能参加一次</li>
<li>例如我们选择了10号活动（开始时间2点，结束时间13点）；2号活动待选择（开始时间3点，结束时间5点）；<br>则会出现上图所示的情况，这显然违背了约束条件。</li>
</ul>
</li>
</ul>
<p><strong>②</strong>每次选择<strong>持续时间最短</strong>的活动（<code>不是最优解</code>）</p>
<p><img src="https://img.jwt1399.top/img/dMryDIJiFbVKQR0HXw3M.png"></p>
<ul>
<li>证明（反证法）：<ul>
<li>贪持续时间最短，显然也不对，特殊情况发生在最短时间的活动，位置刚好和其他活动冲突，如果选择时间最短的活动，也不是最优解。</li>
<li>例如我们选择了2号活动（开始时间3点，结束时间5点）；1号活动待选择（开始时间1点，结束时间4点）；<br>则会出现上图所示的情况，这显然也违背了约束条件。</li>
</ul>
</li>
</ul>
<p><strong>③</strong>每次选择<strong>结束时间最早</strong>的活动（<code>最优解</code>）</p>
<p>要证明一个算法是错的非常简单，要证明是对的却非常难。对于贪心算法的证明，一是使用归纳法，二是采用反证法。像上面两种策略，我们实际上就用到了反证法。那么怎么证明贪心算法是对的呢？</p>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>


<p><strong>3、计算最优解</strong></p>
<p><code>求解思路：</code>将活动按照结束时间进行从小到大排序。挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。首先检查活动 i 是否与当前已选择的所有活动相容。若相容，活动 i 加入已选择活动的集合中，否则不选择活动 i，而继续检查下一活动与集合中活动的相容性。若活动 i 与之相容，则 i 成为最近加入集合 的活动，并取代活动 j 的位置。</p>
<p>图中每行相应于算法的一次迭代。阴影长条表示的活动是已选入集合A的活动，而空白长条表示的活动是当前正在检查相容性的活动。</p>
<p><img src="https://img.jwt1399.top/img/image-20211126114040642.png"></p>
<p><strong>因此最大的相容活动子集合为{1,4,8,11}</strong></p>
<h4 id="➁代码实现"><a href="#➁代码实现" class="headerlink" title="➁代码实现"></a>➁代码实现</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">GreedyChoose</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>f<span class="token punctuation">,</span>bool <span class="token operator">*</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
      j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  bool mark<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">GreedyChoose</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span>s<span class="token punctuation">,</span>f<span class="token punctuation">,</span>mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
      cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//system("pause");</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><del>其他经典贪心算法如下，等有空了再详细写吧！</del></p>
<p><del>找零钱的问题、单源最短路径中的Dijkstra算法、最小生成树的Prim算法、最小生成树的Kruskal算法、Huffman编码</del></p>
<h3 id="❹真题练习-1"><a href="#❹真题练习-1" class="headerlink" title="❹真题练习"></a>❹真题练习</h3><h4 id="LC5-分发饼干"><a href="#LC5-分发饼干" class="headerlink" title="LC5.分发饼干"></a>LC5.分发饼干</h4><p><strong>题目</strong></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">输入</span><span class="token punctuation">:</span> <span class="token attr-value">g = [1,2,3], s = [1,1]</span>
<span class="token attr-name">输出</span><span class="token punctuation">:</span> <span class="token attr-value">1</span>
<span class="token attr-name">解释</span><span class="token punctuation">:</span><span class="token attr-value"> </span>
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例 2:</p>
<pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">输入</span><span class="token punctuation">:</span> <span class="token attr-value">g = [1,2], s = [1,2,3]</span>
<span class="token attr-name">输出</span><span class="token punctuation">:</span> <span class="token attr-value">2</span>
<span class="token attr-name">解释</span><span class="token punctuation">:</span><span class="token attr-value"> </span>
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.	
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; g.length &lt;&#x3D; 3 * 104</li>
<li>0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 104</li>
<li>1 &lt;&#x3D; g[i], s[j] &lt;&#x3D; 231 - 1</li>
</ul>
<p><strong>思路</strong></p>
<p>为了了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p><strong>这里的局部最优就是小饼干喂给胃口小的或者大饼干喂给胃口大的，充分利用饼干尺寸喂饱小孩，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从前向后或者从后向前遍历小孩数组，用小饼干满足胃口小的或者大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<p><strong>解答</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 优先考虑饼干，小饼干先喂饱小胃口</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 优先考虑胃口，先喂饱大胃口</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 遍历胃口</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> g<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="④分治算法"><a href="#④分治算法" class="headerlink" title="④分治算法"></a>④分治算法</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li>理解分治算法的思想；</li>
<li>掌握Counting inversions问题的分治算法；</li>
<li>能用Master Theorem求解递归关系式</li>
</ul>
</blockquote>
<h3 id="❶算法分析-1"><a href="#❶算法分析-1" class="headerlink" title="❶算法分析"></a>❶算法分析</h3><p>分治算法的核心是<strong>分而治之</strong>，就是把一个复杂的问题<strong>分成</strong>多个相同&#x2F;相似的子问题，递归地解决这些子问题然后进行<strong>合并</strong>，原问题的解即子问题解的合并。</p>
<p><strong>分治法适用的情况</strong></p>
<ul>
<li>问题的规模缩小到一定的程度就可以容易地解决；</li>
<li>问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；</li>
<li>问题分解出的子问题的解可以合并为问题的解；</li>
<li>问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ul>
<p><strong>解题步骤</strong></p>
<ul>
<li>1.分解：将原问题分解为若干规模较小，相互独立，与原问题相同的子问题。</li>
<li>2.解决：若干子问题较小而容易被解决则直接解决，否则再继续分解为更小的子问题，直到容易解决。</li>
<li>3.合并：将已求解的各个子问题的解，逐步合并为原问题的解。</li>
</ul>
<h3 id="❷主定理"><a href="#❷主定理" class="headerlink" title="❷主定理"></a>❷主定理</h3><p>主定理适用于求解右边递归式算法的时间复杂度：<strong>T(n) &#x3D; aT(n&#x2F;b) + f(n)</strong></p>
<p>其中：</p>
<ul>
<li>n：问题的规模大小</li>
<li>a：原问题的子问题个数</li>
<li>n&#x2F;b：每个子问题的大小</li>
<li>f(n)：将原问题分解成子问题和将子问题的解合并成原问题的解的时间。</li>
</ul>
<p><strong>定理：</strong>设 a &gt;&#x3D; 1，b &gt;&#x3D;1 为常数，设 f(n) 为一函数，T(n) 由以下递归式给出 T(n) &#x3D; aT(n&#x2F;b) + f(n)，则T(n)可能有如下渐近界：</p>
<ul>
<li><p>①若 f(n) &lt; n<sup>log<sub>b</sub>a</sup> 时，存在 ε &gt; 0，有 f(n) &#x3D; O(n<sup>log<sub>b</sub>a-ε</sup>)，则 <strong>T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>)</strong></p>
</li>
<li><p>②若 f(n) &#x3D; n<sup>log<sub>b</sub>a</sup> 时，有 f(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>)，则 <strong>T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn)</strong></p>
</li>
<li><p>③若 f(n) &gt; n<sup>log<sub>b</sub>a</sup> 时，存在 ε &gt; 0，有 f(n) &#x3D; Ω(n<sup>log<sub>b</sub>a+ε</sup>)，且满足 af(n&#x2F;b) ≤ cf(n), c&lt;1，则 <strong>T(n) &#x3D; Θ(f(n))</strong></p>
</li>
</ul>
<p><strong>来几道例题，利用主定理求渐近表达式：</strong></p>
<p>例一：求解递推方程 T(n) &#x3D; 9T(n&#x2F;3) + n</p>
<p>​	a &#x3D; 9，b &#x3D; 3 ，f(n) &#x3D; n，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>3</sub>9</sup> &#x3D; n<sup>2</sup> &gt; f(n)</p>
<p>   存在 f(n) &#x3D; O(n<sup>log<sub>b</sub>a-ε</sup>) &#x3D; O(n<sup>log<sub>3</sub>9-6</sup>)，ε &#x3D; 6</p>
<p>​	满足主定理的条件1，因此 T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>) &#x3D; Θ(n<sup>2</sup>)</p>
<p> 例二：求解递推方程 T(n) &#x3D; T(2n&#x2F;3) + 1</p>
<p>​	a &#x3D; 1，b &#x3D; 3&#x2F;2，f(n)&#x3D;1，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>3&#x2F;2</sub>1</sup> &#x3D;  n<sup>0</sup> &#x3D; 1 &#x3D; f(n)</p>
<p>​	满足主定理的条件2，所以T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn) &#x3D; Θ(logn)</p>
<p> 例三：求解递推方程 T(n) &#x3D; 3T(n&#x2F;4) + nlogn</p>
<p>​	a &#x3D; 3，b &#x3D; 4，f(n) &#x3D; nlogn，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>4</sub>3 </sup>&lt; f(n)</p>
<p>​	再判断是否满足不等式：af(n&#x2F;b) ≤ cf(n)，代入f(n) &#x3D; nlogn</p>
<p>​	(3n&#x2F;4)log(n&#x2F;4)和cnlogn，当 c ≥ 3&#x2F;4 即可满足 af(n&#x2F;b) ≤ cf(n) 的关系</p>
<p>​	即满足主定理的条件3，所以T(n) &#x3D; Θ(f(n)) &#x3D; Θ(nlogn)</p>
<h3 id="❸计数逆序"><a href="#❸计数逆序" class="headerlink" title="❸计数逆序"></a>❸计数逆序</h3><blockquote>
<p><strong>问题描述：</strong>设 S 为一个有 n 个数字的有序集 ( n &gt; 1 )，其中所有数字各不相同。如果存在正整数 i , j 使得 1 ≤ i &lt; j ≤ n 并且 S [ i ] &gt; S [ j ] ，则 （S [ i ] , S [ j ] ） 这个有序对称为 S 的一个逆序对，也称作逆序数。</p>
</blockquote>
<p>分解：将 S 分为 A 和 B 两部分。</p>
<p>解决：递归计算A 、B、AB中的逆序数。</p>
<p>合并：返回三个计数的总和。</p>
<p><img src="https://img.jwt1399.top/img/202111242033582.png"></p>
<h3 id="❹真题练习-2"><a href="#❹真题练习-2" class="headerlink" title="❹真题练习"></a>❹真题练习</h3><h4 id="➀题目1-1"><a href="#➀题目1-1" class="headerlink" title="➀题目1"></a>➀题目1</h4><p><img src="https://img.jwt1399.top//img/20211017212545.png"></p>
<p>(1) f(n) &#x3D; 9f(n&#x2F;6) + Θ(nlogn)</p>
<p>a &#x3D; 9 ， b &#x3D; 6 ， f(n) &#x3D; Θ(nlogn)， n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>6</sub>9</sup> ，Θ(nlogn) &lt; Θ(n<sup>log<sub>6</sub>9</sup>)，</p>
<p>f(n) &lt; Θ( n<sup>log<sub>b</sub>a</sup>)，因此 f(n) &#x3D;  Θ(n<sup>log<sub>b</sub>a</sup>) &#x3D; Θ(n<sup>log<sub>6</sub>9</sup> )</p>
<p>(2) f(n) &#x3D; 2f(n-3) + Θ(n)</p>
<hr>
<p>f(n) - 2f(n -3) &#x3D; n                                         ①</p>
<p>2f(n -3) - 2<sup>2</sup>f(n-6) &#x3D; 2(n-3)                           ②</p>
<p>2<sup>2</sup>f(n-6)- 2<sup>3</sup>f(n-9) &#x3D; 2<sup>2</sup>(n-3)                          ③</p>
<p>……</p>
<p>2<sup>k-1</sup>f(n-3(k-1)) - 2<sup>k</sup>f(n-3k) &#x3D; 2<sup>k-1</sup>(n-3(k-1))   第k项</p>
<hr>
<p>① + ② + ③ + … + 第k项 得：</p>
<p>f(n) - 2<sup>k</sup>f(n-3k) &#x3D; n(2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+…+2<sup>k-1</sup>) - 3(2+2*2<sup>2</sup>+3*2<sup>3</sup>+…+(k-1)*2<sup>k-1</sup>)</p>
<p>​							 &#x3D; -n*(1-2<sup>k</sup>) - 3*(2<sup>k</sup>(k-2)+2)</p>
<p>​							&#x3D; (2<sup>k</sup>-1)*n -3*2<sup>k</sup>(k-2) - 6</p>
<p><strong>⇒</strong> f(n) &#x3D;  (2<sup>k</sup>-1)*n  -3*2<sup>k</sup>(k-2) - 6 + 2<sup>k</sup>f(n-3k) </p>
<p>令 k &#x3D; n&#x2F;3 则：<strong>⇒</strong> f(n) &#x3D; n*2<sup>n&#x2F;3</sup> - n - n*2<sup>n&#x2F;3</sup>  + 6*2<sup>n&#x2F;3</sup> - 6 + 2<sup>n&#x2F;3</sup></p>
<p><strong>⇒</strong> f(n) &#x3D; 7*2<sup>n&#x2F;3</sup> - n - 6 </p>
<p>因此 f(n) &#x3D;Θ(2<sup>n&#x2F;3</sup>)</p>
<p>(3) f(n) &#x3D; 4f(n&#x2F;2) + Θ(n<sup>2</sup>)</p>
<p>a &#x3D; 4 ，b &#x3D; 2 ，f(n) &#x3D; Θ(n<sup>2</sup>)，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>2</sub>4</sup>  &#x3D; 2 </p>
<p>f(n) &#x3D; Θ( n<sup>log<sub>b</sub>a</sup> )，因此 f(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn) &#x3D; Θ(n<sup>2</sup>logn)</p>
<h4 id="➁题目2-1"><a href="#➁题目2-1" class="headerlink" title="➁题目2"></a>➁题目2</h4><p>一个数的序列中排在前面的数比排在后面的数要大的话则称为一对逆序。问下面这个序列中存在多少对逆序：5，10，7，9，13，1，8，4，12，2，6，3，11，14。（4分）</p>
<p>答：4+8+5+6+8+0+4+2+4+0+1+0+0&#x3D;42</p>
<h2 id="⑤动态规划"><a href="#⑤动态规划" class="headerlink" title="⑤动态规划"></a>⑤动态规划</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li>理解动态规划算法的思想。</li>
<li>对相应问题能建立基本的递归关系式并用从底至上的方法来求解，在求解过程中知道如何建立数据储存的表格。</li>
<li>重点掌握的问题：带权重的活动安排问题、0-1背包问题、最长公共子序列问题、矩阵连乘的最优计算次序问题。</li>
<li>理解0-1背包问题的动态规划算法不是多项式时间算法。</li>
</ul>
</blockquote>
<h3 id="❶算法分析-2"><a href="#❶算法分析-2" class="headerlink" title="❶算法分析"></a>❶算法分析</h3><p>动态规划问题分析是自顶而下的思路，但是算法实现却是自底而上的策略。</p>
<p>动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。</p>
<p>但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</p>
<h3 id="❷带权区间调度"><a href="#❷带权区间调度" class="headerlink" title="❷带权区间调度"></a>❷带权区间调度</h3><blockquote>
<p><strong>问题描述：</strong>给定若干个工作 job 的开始时间 **s<sub>j</sub>**、结束时间 <strong>f<sub>j</sub></strong> 和权重 <strong>v<sub>j</sub><strong>（可以理解成重要程度），求出能完成的最大的工作权重（尽可能地完成更重要的工作），且必须满足各个</strong>工作相容</strong>(<strong>工作安排的时间没有重叠</strong>)。</p>
<p>例如有如下三个工作：</p>
<table>
<thead>
<tr>
<th>job</th>
<th>s</th>
<th>f</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>工作1</td>
<td>0</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>工作2</td>
<td>5</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>工作3</td>
<td>2</td>
<td>8</td>
<td>10</td>
</tr>
</tbody></table>
<p>由不带权重的区间调度方法(贪心)，按<strong>最早结束时间</strong>且相容选择工作，这里就选出{工作1, 工作2}，能实现的最大权重是4+5&#x3D;9。但是，选择{工作3}权重可达到10，因此<strong>最早结束时间的贪心策略在带权区间调度问题里已不适用</strong>。那么如何求相互兼容工作的最大权值子集呢？</p>
</blockquote>
<h4 id="➀理论分析-1"><a href="#➀理论分析-1" class="headerlink" title="➀理论分析"></a>➀理论分析</h4><p><strong>1、分析最优子结构</strong></p>
<ul>
<li>工作 job 按照完成时间升序排列：f<sub>1</sub>≤f<sub>2</sub>≤…≤ f<sub>n</sub></li>
<li>定义两个参数：<code>p(j)</code>、<code>OPT(j)</code></li>
</ul>
<p><code>p(j)</code> &#x3D; 与工作 j 相容的最大的工作 i 且 i &lt; j，也就是说 i 是 j 左边的在 j 开始之前结束的区间。</p>
<p>如下图：</p>
<p>p(1) &#x3D; 0，p(2) &#x3D; 0，p(3) &#x3D; 0，p(4) &#x3D; 1</p>
<p>p(5) &#x3D; 0，p(6) &#x3D; 2，p(7) &#x3D; 3，p(8) &#x3D; 1</p>
<p><img src="https://img.jwt1399.top//img/20211012234008.png"></p>
<p><code>OPT(j)</code>表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。</p>
<p>OPT(j) 显然有两种方案：</p>
<ul>
<li>①选择 j 工作<ul>
<li>如果选择工作 j，原问题退化成 **v<sub>j</sub>+OPT(P(j))**，选择了 j 活动，则下一个活动为不能和 j 活动冲突的最大活动 P(j)</li>
</ul>
</li>
<li>②不选择 j 工作<ul>
<li>如果不选择工作 j，原问题退化成 **OPT(j-1)**，即从(1,2,3…j-1)中找最优解</li>
</ul>
</li>
</ul>
<p><strong>2、建立递推公式</strong></p>
<p>递推公式如下：<br><img src="https://img.jwt1399.top//img/20211012234021.png"></p>
<p><strong>3、计算<code>最优值</code>、构造<code>最优解</code></strong></p>
<p>例如：给定如下8个候选活动的开始时间、结束时间和权重</p>
<p><img src="https://img.jwt1399.top//img/20211013182102.png"></p>
<p>依据递推公式，计算出  <code>p(j)</code>、<code>OPT(j)</code></p>
<table>
<thead>
<tr>
<th>j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>p(j)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>OPT(j)</td>
<td>12</td>
<td>20</td>
<td>23</td>
<td>25</td>
<td>26</td>
<td>40</td>
<td>40</td>
<td>42</td>
</tr>
</tbody></table>
<p>p(8) &#x3D; 5，与 活动8 相容的最大活动为 5</p>
<p>p(5) &#x3D; 0，与 活动5 相容最大活动没有</p>
<p><strong>因此选择活动 8 和 5</strong></p>
<p>OPT(2) &#x3D; max{ OPT(1) ,v<sub>2</sub> + OPT(p(2)) } &#x3D; max{12,20} &#x3D; 20</p>
<p>OPT(4) &#x3D; max{ OPT(3) ,v<sub>4 </sub>+ OPT(p(4)) } &#x3D; v<sub>4</sub> + OPT(1) &#x3D; 13 + 12 &#x3D; 25</p>
<p>OPT(7) &#x3D; max{ OPT(6) ,v<sub>7</sub> + OPT(p(7)) } &#x3D; max{40,34} &#x3D; 40</p>
<p>OPT(8) &#x3D; max{ OPT(7) ,v<sub>8</sub> + OPT(p(8)) } &#x3D; max{40,42} &#x3D; 42</p>
<p><strong>因此最大权重之和为42</strong></p>
<h4 id="➁代码实现-1"><a href="#➁代码实现-1" class="headerlink" title="➁代码实现"></a>➁代码实现</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> iStartT<span class="token punctuation">;</span>
    <span class="token keyword">int</span> iFinshT<span class="token punctuation">;</span>
    <span class="token keyword">int</span> iWight<span class="token punctuation">;</span>
<span class="token punctuation">}</span>TASK_INFO<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">CreatWeightedScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment" spellcheck="true">//创建每个任务</span>
<span class="token keyword">void</span> <span class="token function">PrintWeightedScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">DynamicScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment" spellcheck="true">//用动态算法求解最大权重问题</span>
<span class="token keyword">void</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment" spellcheck="true">//寻求最大权重任务的集合	</span>

<span class="token keyword">void</span> <span class="token function">CreatWeightedScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span>schedule<span class="token punctuation">,</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请逐个输入任务的开始时间s、结束时间f、权重v\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Task "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" information: "</span><span class="token punctuation">;</span>
        cin <span class="token operator">>></span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iStartT <span class="token operator">>></span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iFinshT <span class="token operator">>></span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iWight<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PrintWeightedScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span>schedule<span class="token punctuation">,</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Task"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":\t"</span> <span class="token operator">&lt;&lt;</span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iStartT <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iFinshT <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> schedule<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iWight <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
** key: j号task的开始时间，即startArray[j]
** finsh[] &amp;&amp; currentIndex: 查找“j号task的开始时间”在j-1号之前的任务的结束时间finishArray[1...j-1]
**/</span>
<span class="token keyword">int</span> <span class="token function">binarySereach</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> finsh<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> currentIndex<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> currentIndex<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> finsh<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>									<span class="token comment" spellcheck="true">//找到即返回Index</span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> finsh<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>							<span class="token comment" spellcheck="true">//key小于所有的finshTime，即没有一个任务相容</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">&lt;</span> low<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>													<span class="token comment" spellcheck="true">//key大于所有的finshTime，最大的相容的，即high</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">></span> high<span class="token punctuation">)</span>
                <span class="token keyword">return</span> high<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">DynamicScheduling</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span>schedule<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>compute<span class="token punctuation">,</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> startArray <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>												<span class="token comment" spellcheck="true">//将每个任务的开始、结束时间转存下，方便计算P(j)</span>
    <span class="token keyword">int</span><span class="token operator">*</span> finishArray <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        startArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> schedule<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iStartT<span class="token punctuation">;</span>
        finishArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> schedule<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iFinshT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//compute P(j) &amp; OPT(j)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//P(j)</span>
        compute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">binarySereach</span><span class="token punctuation">(</span>startArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> finishArray<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//OPT(j)：OPT(j) ? Wj+OPT(P(j))</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> schedule<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iWight <span class="token operator">+</span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>compute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>			<span class="token comment" spellcheck="true">//第一个任务信息在0号内存单元的，所以是j-1</span>
            compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> schedule<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iWight <span class="token operator">+</span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>compute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> startArray<span class="token punctuation">;</span>						<span class="token comment" spellcheck="true">//从理论上讲，new的内存必需要delete才能释放，不知道编译器有优化没？，还是显示的释放下</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> finishArray<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> g_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>TASK_INFO <span class="token operator">*</span>schedule<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>compute<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> path<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>schedule<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iWight <span class="token operator">+</span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>compute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//后面值大于前面的，则加入；否则j-1</span>
    <span class="token punctuation">{</span>
        path<span class="token punctuation">[</span>g_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> compute<span class="token punctuation">,</span> compute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> compute<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入你要分配总任务数： "</span><span class="token punctuation">;</span>
    cin <span class="token operator">>></span> taskNum<span class="token punctuation">;</span>

    TASK_INFO <span class="token operator">*</span>schedule <span class="token operator">=</span> new TASK_INFO<span class="token punctuation">[</span>taskNum<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">CreatWeightedScheduling</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//用动态算法求解最大权重问题</span>
    <span class="token comment" spellcheck="true">//compute[2][]:first clow means P(j); second clow means OPT(j)</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>compute <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">[</span>taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>											<span class="token comment" spellcheck="true">//分配内存及置0</span>
        compute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            compute<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">DynamicScheduling</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> compute<span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>											<span class="token comment" spellcheck="true">//输出P(j)、OPT(j)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"  P(j):  "</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"OPT(j):  "</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> taskNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> compute<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n最大权重之和："</span> <span class="token operator">&lt;&lt;</span> compute<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>taskNum<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//输出任务</span>
    <span class="token keyword">int</span><span class="token operator">*</span> path <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>taskNum<span class="token punctuation">]</span><span class="token punctuation">;</span>													<span class="token comment" spellcheck="true">//存储任务的数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">FindSolution</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> compute<span class="token punctuation">,</span> taskNum<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最优活动子集："</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskNum <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//PrintWeightedScheduling(schedule, taskNum);</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        delete<span class="token punctuation">[</span><span class="token punctuation">]</span> compute<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> compute<span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> schedule<span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> path<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/image-20211013191721686.png"></p>
<h4 id="➂真题练习"><a href="#➂真题练习" class="headerlink" title="➂真题练习"></a>➂真题练习</h4><h5 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h5><p><img src="https://img.jwt1399.top//img/20211013180909.png"></p>
<p>设 <code>p(j)</code> 为与工作 j 相容的最大的工作 i 且 i &lt; j 。<code>OPT(j)</code>表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。则递归关系式为：</p>
<p><img src="https://img.jwt1399.top//img/20211013181235.png"></p>
<p>依据递推公式，计算出  <code>p(j)</code>、<code>OPT(j)</code></p>
<p><img src="https://img.jwt1399.top//img/20211013181844.png"></p>
<p>因为 OPT(17) &#x3D; 50 ，因此<strong>最大权重之和为 50</strong></p>
<p>OPT(17) &#x3D; OPT(16) &#x3D; OPT(15) &#x3D; 50 ，选择活动 15，p(15) &#x3D;13；</p>
<p>OPT(13) &#x3D; OPT(12) &#x3D; 45 ，选择活动 12，p(12) &#x3D; 7；</p>
<p>OPT(7) &#x3D; OPT(6) &#x3D; 25 ，选择活动 6，p(6) &#x3D; 3；</p>
<p>OPT(3) &#x3D; 18 ，p(3) &#x3D; 0，选择活动 3，且选择完毕。</p>
<p>因此<strong>最优活动子集为 3、6、12、15</strong></p>
<h3 id="❸0-1背包问题"><a href="#❸0-1背包问题" class="headerlink" title="❸0-1背包问题"></a>❸0-1背包问题</h3><blockquote>
<p><strong>问题描述：</strong>有n个物品，它们有各自的重量 w<sub>i</sub> 和价值 v<sub>i</sub> ，现有给定容量为 C 的背包，如何让背包里装入的物品具有最大的价值总和？</p>
</blockquote>
<h4 id="➀理论分析-2"><a href="#➀理论分析-2" class="headerlink" title="➀理论分析"></a>➀理论分析</h4><p><strong>1、分析最优子结构</strong></p>
<p>定义一个参数：<code>OPT(i,w)</code></p>
<p><code>OPT(i,w)</code>表示表示前 i 个物品 ( 1,2,3,…,i )的最大价值，i（当前背包存放物品的数量）、w（当前背包容量）</p>
<p>OPT(i,w) 显然有两种方案：</p>
<ul>
<li>①不选择 i 物品<ul>
<li>如果不选择 i 物品，原问题退化成 **OPT(i-1，w)**，即包的剩余容量比 i 物品重量小，装不下，此时的价值与前 i-1 个的价值是一样的，从(1,2,3…i-1)中找最优解</li>
</ul>
</li>
<li>②选择 i 物品<ul>
<li>如果选择 i 物品，原问题退化成 **v<sub>i</sub> + OPT(i-1，w-w<sub>i</sub>)**，即既然选择了 i 物品，能装的重量减少 w<sub>i</sub>，并尝试 i-1 是否装入</li>
</ul>
</li>
</ul>
<p><strong>2、建立递推公式</strong></p>
<p>递推公式如下：</p>
<p><img src="https://img.jwt1399.top/img/202111111714615.png"></p>
<p><strong>3、计算<code>最优值</code>、构造<code>最优解</code></strong></p>
<p>例如：给定如下 5 个物品的价值 v<sub>i</sub> 和重量 w<sub>i</sub>，限制包的容量 C 为11</p>
<p><img src="https://img.jwt1399.top/img/202111111714596.png"></p>
<p>依据递推公式，计算出<code>OPT(i,w)</code></p>
<p><img src="https://img.jwt1399.top/img/202111111714543.png"></p>
<p>OPT(2,2) &#x3D; max{ v<sub>2</sub> + OPT(1,2-w<sub>2</sub>)，OPT(1,2)}  &#x3D; max{6，1} &#x3D; 6</p>
<p>…</p>
<p>OPT(3,5) &#x3D; max{ v<sub>3</sub> + OPT(2,5-w<sub>3</sub>)，OPT(2,5)} &#x3D;  max{18，7} &#x3D; 18</p>
<p>OPT(4,11) &#x3D; max{ v<sub>4</sub> + OPT(3,11-w<sub>4</sub>)，OPT(3,11)} &#x3D;  max{40，25} &#x3D; 40</p>
<p>OPT(5,11) &#x3D; max{ v<sub>5</sub> + OPT(4,11-w<sub>5</sub>)，OPT(4,11)} &#x3D;  max{35，40} &#x3D; 40</p>
<p><strong>因此最大价值为 40，由图中红线回溯可知，背包装了物品 3 和 4</strong></p>
<h4 id="➁代码实现-2"><a href="#➁代码实现-2" class="headerlink" title="➁代码实现"></a>➁代码实现</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip></span>															</span><span class="token comment" spellcheck="true">//setw()函数</span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> ITEM <span class="token punctuation">{</span>
    <span class="token keyword">int</span> wight<span class="token punctuation">;</span>													<span class="token comment" spellcheck="true">//单个物品的重量</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>													<span class="token comment" spellcheck="true">//单个物品的价值</span>
<span class="token punctuation">}</span>ITEM_INFO<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">creatItemInfo</span><span class="token punctuation">(</span>ITEM_INFO <span class="token operator">*</span>items<span class="token punctuation">,</span> <span class="token keyword">int</span> itemNum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//创建背包物品基本信息</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入(value weigh),例如(1 1)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter item "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" information: "</span><span class="token punctuation">;</span>
        cin <span class="token operator">>></span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">>></span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>wight<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PrintItemInfo</span><span class="token punctuation">(</span>ITEM_INFO <span class="token operator">*</span>items<span class="token punctuation">,</span> <span class="token keyword">int</span> itemNum<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Item"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":\t"</span> <span class="token operator">&lt;&lt;</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>wight <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">DynamicKnapsack</span><span class="token punctuation">(</span>ITEM_INFO <span class="token operator">*</span>items<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> maxWeight<span class="token punctuation">,</span> <span class="token keyword">int</span> itemNum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//用动态规划解决0/1背包问题</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//其实首先是将m[0, ],第一行清零，由于之前全清零了，所以就没做这步了</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> itemNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>											<span class="token comment" spellcheck="true">//i:物品的数量，从1到itemNum</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> maxWeight<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span>									<span class="token comment" spellcheck="true">//w:背包的当前重量，最开始没有物品为0，慢慢增加到maxWeight</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//分两种情况，(1)i号物品不放入背包；(2 else)i号物品放入背包</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wight <span class="token operator">></span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//OPT(i,w) &lt;== OPT(i-1, w) ? Vi+OPT(i-1, w-wi)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">+</span> m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w <span class="token operator">-</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wight<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">+</span> m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w <span class="token operator">-</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wight<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> g_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment" spellcheck="true">//返回活动j存在path中</span>
<span class="token keyword">void</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>ITEM_INFO <span class="token operator">*</span>items<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//回溯求解问题的解</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> w <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">+</span> m<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w <span class="token operator">-</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wight<span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//当w=0,不能执行这里了，重量已经0，还减少？越界，所以不加m==0判断，下面执行出错误</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//i物品选中，迭代时候数量i减一，背包能容量的重量减wi</span>
        path<span class="token punctuation">[</span>g_i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> m<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> w <span class="token operator">-</span> items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>wight<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment" spellcheck="true">//这里是items[i - 1]，因为第一个物品信息存放在0号内存单元的</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
        <span class="token comment" spellcheck="true">//i物品没选中，迭代时候数量i减一即可</span>
        <span class="token keyword">return</span> <span class="token function">FindSolution</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> m<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> itemNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>														<span class="token comment" spellcheck="true">//物品的数量</span>
    <span class="token keyword">int</span> maxWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>														<span class="token comment" spellcheck="true">//背包最大能放的重量</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"物品个数:"</span><span class="token punctuation">;</span>
    cin <span class="token operator">>></span> itemNum<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"背包容量："</span><span class="token punctuation">;</span>
    cin <span class="token operator">>></span> maxWeight<span class="token punctuation">;</span>

    ITEM_INFO <span class="token operator">*</span>items <span class="token operator">=</span> new ITEM_INFO<span class="token punctuation">[</span>itemNum<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">creatItemInfo</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> itemNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//PrintItemInfo(items, itemNum);</span>
    
    <span class="token comment" spellcheck="true">//其实m[][]是(itemNum+1)*(maxWeight+1),要多一行一列</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>m <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">[</span>maxWeight<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>maxWeight <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> maxWeight <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">DynamicKnapsack</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> m<span class="token punctuation">,</span> maxWeight<span class="token punctuation">,</span> itemNum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nm[][]:\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> itemNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> maxWeight<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token operator">*</span> path <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>itemNum<span class="token punctuation">]</span><span class="token punctuation">;</span>													<span class="token comment" spellcheck="true">//存储任务的数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">FindSolution</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> m<span class="token punctuation">,</span> itemNum<span class="token punctuation">,</span> maxWeight<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n最大权重物品："</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//释放内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        delete<span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> path<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top/img/202111111713603.png"></p>
<h4 id="➂01背包是NP"><a href="#➂01背包是NP" class="headerlink" title="➂01背包是NP"></a>➂01背包是NP</h4><blockquote>
<p>理解0-1背包问题的动态规划算法不是多项式时间算法。</p>
</blockquote>
<p>P 是否等于 NP 是计算复杂度理论里面最著名的未解决的问题之一，一个 NP 完全问题，如果能找到解决它的多项式时间算法，那么就说明了 P &#x3D; NP。</p>
<p>如今 0-1 背包问题已经被证明是 NP 完全问题，而它却有着一个动态规划解法，该解法有着 O(n*W) 的时间复杂度，其中 n 是物品的个数，W 是背包限制的最大负重。所以时间复杂度对输入 n，W 来说是多项式时间的，所以说明了 NP &#x3D; P 是不是哪里出错了呢？</p>
<p>其实多项式时间是相对于输入规模来说的，输入规模最直观的理解就是输入到该算法的数据占了多少比特内存。0-1 背包的输入有 n 个物品的价值，n 个物品的重量，还有背包的最大负重 W。如今假设 W 占用的比特数为 L（也就是说背包的最大负重的输入规模是 L），那么 log(W) &#x3D; L，所以 O(n*W) &#x3D; O(n*2<sup>L</sup>)，由此看到，该算法的时间复杂度对于输入规模 L 来说是指数级别的，随着输入规模 L 的增加，运算时间会迅速增长。</p>
<p>实际上，人们把这种动态规划的算法称为伪多项式时间算法（pseudo-polynomial time algorithm），这种算法不能真正意义上实现多项式时间内解决问题。</p>
<h4 id="➃真题练习"><a href="#➃真题练习" class="headerlink" title="➃真题练习"></a>➃真题练习</h4><h5 id="题目1-1"><a href="#题目1-1" class="headerlink" title="题目1"></a>题目1</h5><p><img src="https://img.jwt1399.top/img/image-20211104201447553.png"></p>
<p><img src="https://img.jwt1399.top/img/image-20211210165447955.png"></p>
<h5 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h5><p><img src="https://img.jwt1399.top/img/image-20211104223426667.png"></p>
<h3 id="❹最长公共子序列"><a href="#❹最长公共子序列" class="headerlink" title="❹最长公共子序列"></a>❹最长公共子序列</h3><blockquote>
<p><strong>问题描述︰</strong>给定两个字符串，求解这两个字符串的最长公共子序列(LCS)。如: X&#x3D;{1,5,2,8,9,3,6},Y&#x3D;{5,6,8,9,3,7}，其最长公共子序列为{5,8,9,3}，最长公共子序列长度为4。那么如何求解呢？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&id=top-100-liked">1143. 最长公共子序列 - 力扣（Leetcode）</a></p>
</blockquote>
<h4 id="➀理论分析-3"><a href="#➀理论分析-3" class="headerlink" title="➀理论分析"></a>➀理论分析</h4><p><strong>1、分析最优子结构</strong></p>
<p>设序列 <strong>X&#x3D;{x<sub>1</sub>, x<sub>2</sub>, …, x<sub>i</sub>}</strong> 和 <strong>Y&#x3D;{y<sub>1</sub>, y<sub>2</sub>, …, y<sub>j</sub>}</strong> 的最长公共子序列为 **Z&#x3D;{z<sub>1</sub>, z<sub>2</sub>, …, z<sub>k</sub>}**，则</p>
<ul>
<li><p>①若 <strong>x<sub>i</sub>&#x3D;y<sub>j</sub></strong> ，则 z<sub>k</sub>&#x3D;x<sub>i</sub>&#x3D;y<sub>j</sub> 且 <strong>Z<sub>k-1</sub></strong> 是 X<sub>i-1</sub> 和 Y<sub>j-1 </sub>的最长公共子序列;</p>
</li>
<li><p>②若 <strong>x<sub>i</sub>≠y<sub>j</sub></strong> 且 <strong>z<sub>k</sub>≠x<sub>i</sub></strong> ，则 <strong>Z<sub>k</sub></strong> 是 X<sub>i-1 </sub>和 Y<sub>j</sub> 的最长公共子序列;.</p>
</li>
<li><p>③若 <strong>x<sub>i</sub>≠y<sub>j</sub></strong> 且 <strong>z<sub>k</sub>≠y<sub>j</sub></strong> ，则 **Z<sub>k </sub>**是 X<sub>i</sub> 和 Y<sub>j-1 </sub>的最长公共子序列。</p>
</li>
</ul>
<p><strong>2、建立递推公式</strong></p>
<p>用**<code>c[i][j]</code>**表示 <strong>X<sub>i</sub>&#x3D;{x<sub>1</sub>, x<sub>2</sub>, …, x<sub>i</sub>}</strong> 和 <strong>Y<sub>j</sub>&#x3D;{y<sub>1</sub>, y<sub>2</sub>, …, y<sub>j</sub>}</strong> 的最长公共子序列的长度，那么得到以下的递推公式：</p>
<p><img src="https://img.jwt1399.top//img/20211010182558.png"></p>
<p><strong>递推公式代码版</strong>：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> Y<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 	
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3、计算<code>最优值</code></strong></p>
<blockquote>
<p>假设 X&#x3D;{A,B,C,E} 和 Y&#x3D;{B,D,C,E}</p>
</blockquote>
<p>根据上方递推公式得到下表：</p>
<table>
<thead>
<tr>
<th><code>c[i][j]</code></th>
<th>0</th>
<th>1B</th>
<th>2D</th>
<th>3C</th>
<th>4E</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1A</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>2B</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>3C</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><strong>4E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td><code>3</code></td>
</tr>
</tbody></table>
<p>在 <code>C[2][0]</code> 处，j &#x3D; 0 ，此时根据公式<code>C[2][0]= 0</code></p>
<p>在 <code>C[2][1]</code> 处，B &#x3D; B，即 <strong>x<sub>i</sub>&#x3D;y<sub>j</sub></strong> ，此时根据公式<code>C[2][1]=C[1][0]+1=0+1=1</code></p>
<p>在 <code>C[2][2]</code> 处，B ≠ C，即 <strong>x<sub>i</sub>≠y<sub>j</sub></strong> ，此时根据公式<code>C[2][2]=max&#123;C[2][1],C[1][2]&#125;=1</code></p>
<p>根据最<strong>右下角的值(c[][])<strong>，我们可以知道</strong>最长公共子序列长度为3</strong>。</p>
<p><strong>最优值代码版：</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">int LCSLength(char *X,char *Y){
    for(int i = 0; i <= n; i++){
      for(int j = 0; j <= m; j++){
        c[i][0] = 0;
        c[0][j] = 0;
      }
   }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            if(X[i] == Y[j]){
                c[i][j] = c[i-1][j-1] + 1;
            }
            else{
                c[i][j] = max(c[i - 1][j], c[i][j - 1]);
            } 	
        }
     return c[n][m];
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>4、构造<code>最优解</code></strong></p>
<p><code>b[i][j]</code>记录<code>c[i][j]</code>的值是由哪个子问题的解得到的</p>
<ul>
<li><p><code>if(X[i]==Y[j])</code> 用b&#x3D;1代表</p>
</li>
<li><p><code>if(X[i]!=Y[j])</code> 用b&#x3D;2代表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><code>b[i][j]</code></th>
<th>0</th>
<th>1B</th>
<th>2D</th>
<th>3C</th>
<th>4E</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1A</strong></td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><strong>2B</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><strong>3C</strong></td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td><strong>4E</strong></td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>c[i][j]</code></th>
<th>0</th>
<th>1B</th>
<th>2D</th>
<th>3C</th>
<th>4E</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1A</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>2B</strong></td>
<td>0</td>
<td>1<code>↖</code></td>
<td>1<code>←</code></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>3C</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2<code>↖</code></td>
<td>2</td>
</tr>
<tr>
<td><strong>4E</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3<code>↖</code></td>
</tr>
</tbody></table>
<p><code>↖</code>处则为最长公共子序列{B,C,E}</p>
<h4 id="➁代码实现-3"><a href="#➁代码实现-3" class="headerlink" title="➁代码实现"></a>➁代码实现</h4><pre class="line-numbers language-c++"><code class="language-c++">//自底向上计算最优值，并记录相关信息
void LCSLength(){
    int i,j;
    for(i=1; i<=m; i++){
        c[i][0] = 0;
    }
    for(i=1; i<=n;i++){
        c[0][i] = 0;
    }
    for(i=1; i<=m; i++){
        for(j=1; j<=n; j++){
            if(x[i] == y[j]){
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = 1;
            }else if(){
                c[i][j] = c[i-1][j];
                b[i][j] = 3;
            }else{
                c[i][j] = c[i][j-1];
                b[i][j] = 2;
            }
        }
    }
}
void LCS(int i,int j,char *x,int **b){
    if(i == 0 || j == 0){
        return;
    }
    if(b[i][j] == 1){
        LCS(i-1,j-1,x,b);
        cout<<x[i];
    }else if(b[][] == 2){
        LCS(i,j-1,x,b);
    }else{
        LCS(i-1,j,x,b);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="➂真题练习-1"><a href="#➂真题练习-1" class="headerlink" title="➂真题练习"></a>➂真题练习</h4><h5 id="题目1-2"><a href="#题目1-2" class="headerlink" title="题目1"></a>题目1</h5><p>给定两个字符串A和B，长度分别为m和n，设计动态规划算法找出它们最长公共子序列长度，并给出最长公共子序列。例如：A &#x3D; “HelloWorld”，B &#x3D; “loopbird”，则A与B的最长公共子序列为”loord”，返回的长度为5。</p>
<h5 id="题目2-1"><a href="#题目2-1" class="headerlink" title="题目2"></a>题目2</h5><p>设计一个 O(n<sup>2</sup>) 时间的算法，找出由 n 个数组成的序列的最长单调递增子序列(LIS)。</p>
<p>解法一：转化成 LCS 问题求解，时间复杂度为 O(n*n).</p>
<p>思路：原序列为 A，把 A 按升序排序得到序列 B，求出 A，B 序列的最长公共子序列，即为 A 的最长单调递增子序列。</p>
<p>解法二：设 d[i] 为以第 i 个元素结尾的最长递增子序列的长度，</p>
<p>则 d(i) &#x3D; max(d(j)) + 1; ( j&lt;i &amp;&amp; a[j] &lt; a[i] ) ,  时间复杂度O(n*n)</p>
<h3 id="❺矩阵连乘"><a href="#❺矩阵连乘" class="headerlink" title="❺矩阵连乘"></a>❺矩阵连乘</h3><h5 id="➀理论分析-4"><a href="#➀理论分析-4" class="headerlink" title="➀理论分析"></a>➀理论分析</h5><blockquote>
<p><strong>问题描述：</strong>给定 n 个矩阵 {A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub>} ，其中 A<sub>i</sub> 与 A<sub>i+1</sub> 是可乘的，用加括号的方法表示矩阵连乘的次序，不同加括号的方法所对应的计算次序是不同的，求矩阵连乘的最佳计算次序。</p>
<p>例如，矩阵连乘积 A<sub>1</sub>A<sub>2</sub>A<sub>3</sub> 有以下 2 种加括号方式：A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>)，(A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>，所以那种加括号方式是最优的呢？</p>
<p>说明：</p>
<ul>
<li>1.矩阵 A 和矩阵 B 可乘的条件：<code>矩阵 A 的列数 = 矩阵 B 的行数</code></li>
<li>2.设矩阵 A 是 p × q 的矩阵，B 是 q × r 的矩阵，<code>乘积结果 C 是 p × r的矩阵，计算量是 p * q * r</code></li>
</ul>
</blockquote>
<p><strong>1、分析最优子结构</strong></p>
<p>将矩阵连乘的积 <strong>A<sub>i</sub> A<sub>i+1</sub> … A<sub>j</sub></strong> 简记为<code>A[i][j]</code> ，<strong>A<sub>i</sub></strong> 的维度记为 **p<sub>i-1 </sub>× p<sub>i</sub>**，那么上述问题变为求解 <code>A[1][n]</code>的最佳计算次序。</p>
<p><code>A[1][n]的最佳计算次序：</code>设这个计算次序在矩阵  A<sub>K </sub> (1≤k&lt;n) 和 A<sub>K+1</sub> 之间将矩阵链断开，则相应的加括号方式：( <strong>A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub></strong> )( <strong>A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub></strong> )，依此计算顺序，总计算量为 <strong>A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub></strong> 的计算量加上 <strong>A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub></strong> 的计算量，再加上 ( <strong>A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub></strong> ) 和  ( <strong>A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub></strong> )相乘的计算量。即 <strong>A[1][n] &#x3D; A[1][k] + A[k+1][n] + p<sub>i-1</sub>p<sub>k</sub>p<sub>n</sub></strong> </p>
<p><strong>2、建立递推公式</strong></p>
<p>设计算 <code>A[i][j]</code> (i≤j) 所需的最少乘法次数为 <code>m[i][j]</code>，那么得到以下的递推公式：</p>
<p><img src="https://img.jwt1399.top//img/20211011125331.png"></p>
<p><strong>3、计算<code>最优值</code></strong></p>
<p>例如，要计算矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，其中各矩阵的维数分别为:</p>
<table>
<thead>
<tr>
<th>A1</th>
<th>A2</th>
<th>A3</th>
<th>A4</th>
<th>A5</th>
<th>A6</th>
</tr>
</thead>
<tbody><tr>
<td>30x35</td>
<td>35x15</td>
<td>15x5</td>
<td>5x10</td>
<td>10x20</td>
<td>20x25</td>
</tr>
</tbody></table>
<p>依据递推公式，按照图 a 的次序，计算出  <code>m[i][j]</code></p>
<p><img src="https://img.jwt1399.top/img/image-20211011130742451.png"></p>
<p><img src="https://img.jwt1399.top//img/20211011131609.png"></p>
<p>★最优值：本题是求解 <code>A[1][6]</code> 的最佳计算次序，即求<code>m[1][6]</code> 。由图 b 可知， <code>m[1][6] =15125</code>，因此矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> 的最优值为 <strong>15125</strong></p>
<p><strong>4、构造<code>最优解</code></strong></p>
<p>若将对应<code>m[i][j]</code>的断开位置<code>k</code>记为<code>s[i][j]</code>，计算出最优值<code>m[i][j]</code>后，可递归地由<code>s[i][j]</code>[][]构造出相应的最优解。</p>
<p><img src="https://img.jwt1399.top//img/20211011131648.png"></p>
<p>例如，<strong>m[2][5] &#x3D; m[2][3] + m[4][5] + p<sub>1</sub>p<sub>3</sub>p<sub>5</sub></strong> ，则 k &#x3D; 3，因此 <strong>s[2][5] &#x3D; 3</strong></p>
<p>★最优解：</p>
<p>s[1][6] &#x3D; 3 ,因此矩阵链在A<sub>3</sub>和A<sub>4</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>)(A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> )</strong></p>
<p>s[1][3] &#x3D; 1,因此矩阵链在A<sub>1</sub>和A<sub>2</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))(A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> )</strong></p>
<p>s[4][6] &#x3D; 5,因此矩阵链在A<sub>5</sub>和A<sub>6</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))((A<sub>4</sub>A<sub>5</sub>)A<sub>6</sub> )</strong></p>
<p>因此最优解为 <strong>(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))((A<sub>4</sub>A<sub>5</sub>)A<sub>6</sub> )</strong></p>
<h5 id="➁代码实现-4"><a href="#➁代码实现-4" class="headerlink" title="➁代码实现"></a>➁代码实现</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> N 100</span>
<span class="token keyword">int</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//s存储切割位置，m存储最优值 </span>

<span class="token keyword">void</span> <span class="token function">MatricChain</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//p矩阵维数数组，n为矩阵个数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//初始化，对角线上的计算量和加括号的位置为0</span>
        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//r为矩阵链的长度</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i为首矩阵的序号</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//j为尾矩阵的序号</span>
            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//首先尝试在矩阵 i 处分开</span>
            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                    <span class="token keyword">int</span> t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 然后尝试在矩阵 k 处分开 (i&lt;=k&lt;j)</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
                        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Traceback</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">Traceback</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">Traceback</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> k <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"×"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span><span class="token string">"["</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> <span class="token string">"]"</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//矩阵维数</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//矩阵个数</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"×"</span><span class="token operator">&lt;&lt;</span>p<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"这"</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"个矩阵连乘的最优值和最优解？"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token function">MatricChain</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m[i][j]:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s[i][j]:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最少连乘次数(最优值):"</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"次。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最佳计算次序(最优解):"</span> <span class="token punctuation">;</span>
    <span class="token function">Traceback</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://img.jwt1399.top//img/20211011231627.png"></p>
<h5 id="➂真题练习-2"><a href="#➂真题练习-2" class="headerlink" title="➂真题练习"></a>➂真题练习</h5><h6 id="题目1-3"><a href="#题目1-3" class="headerlink" title="题目1"></a>题目1</h6><p><img src="https://img.jwt1399.top//img/20211011201113.png"></p>
<p>（1）令计算**A<sub>1</sub> x A<sub>2</sub> x A<sub>3</sub> x … x A<sub>n</sub>*<em>所需要的最少乘法次数为</em>m*[<em>i</em>, <em>j</em>] （3分）</p>
<p>​			则递归关系式为<img src="https://img.jwt1399.top//img/20211011201529.png">  （5分，其中边界条件1分)</p>
<p> （2）</p>
<table>
<thead>
<tr>
<th>m(<em>i</em>, <em>j</em>)</th>
<th><em>j</em> &#x3D; 1</th>
<th><em>j</em> &#x3D; 2</th>
<th><em>j</em> &#x3D; 3</th>
<th><em>j</em> &#x3D; 4</th>
<th><em>j</em> &#x3D; 5</th>
</tr>
</thead>
<tbody><tr>
<td><em>i</em> &#x3D; 1</td>
<td>0</td>
<td>1440</td>
<td>3360</td>
<td>4000</td>
<td><code>5856</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 2</td>
<td>&#x2F;</td>
<td>0</td>
<td>2400</td>
<td>2800</td>
<td>4800</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 3</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
<td>1600</td>
<td>2880</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 4</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
<td>3200</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 5</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
</tr>
</tbody></table>
<p> 将对应<code>m(i,j)</code>的断开位置<code>k</code>记为<code>s(i,j)</code></p>
<table>
<thead>
<tr>
<th><em>s</em>(<em>i</em>, <em>j</em>)</th>
<th><em>j</em> &#x3D; 1</th>
<th><em>j</em> &#x3D; 2</th>
<th><em>j</em> &#x3D; 3</th>
<th><em>j</em> &#x3D; 4</th>
<th><em>j</em> &#x3D; 5</th>
</tr>
</thead>
<tbody><tr>
<td><em>i</em> &#x3D; 1</td>
<td>&#x2F;</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td><code>2</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 2</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 3</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>3</td>
<td><code>4</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 4</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>4</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 5</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<p> s(1,5) &#x3D; 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>)(A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>)</strong></p>
<p>s(3,5) &#x3D; 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)</strong></p>
<p>最优加括号方式为<img src="https://img.jwt1399.top//img/20211011202017.png"></p>
<h6 id="题目2-2"><a href="#题目2-2" class="headerlink" title="题目2"></a>题目2</h6><table>
<thead>
<tr>
<th><strong>A1</strong></th>
<th><strong>A2</strong></th>
<th><strong>A3</strong></th>
<th><strong>A4</strong></th>
<th><strong>A5</strong></th>
</tr>
</thead>
<tbody><tr>
<td>3x7</td>
<td>7x8</td>
<td>8x5</td>
<td>5x12</td>
<td>12x10</td>
</tr>
</tbody></table>
<p>计算矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>最优值和最优解？</p>
<table>
<thead>
<tr>
<th>m[i][j]</th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>0</td>
<td>168</td>
<td>288</td>
<td>468</td>
<td><code>828</code></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td>0</td>
<td>280</td>
<td>700</td>
<td>1230</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td></td>
<td>0</td>
<td>480</td>
<td>1000</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>600</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>s[i][j]</th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td></td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody></table>
<p>最少乘法次数为(最优值)：<strong>828</strong></p>
<p>s[1][5] &#x3D; 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub></strong></p>
<p>s[1][4] &#x3D; 3 因此矩阵链在A<sub>3</sub>和A<sub>4</sub>之间断开，则加括号方式为 <strong>((A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub></strong></p>
<p>s[1][3] &#x3D; 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 <strong>(((A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub></strong></p>
<p>最优加括号方式为(最优解)： <strong>(((A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub></strong></p>
<h3 id="❻真题练习"><a href="#❻真题练习" class="headerlink" title="❻真题练习"></a>❻真题练习</h3><h4 id="题目1-4"><a href="#题目1-4" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目：</strong>LC746. 使用最小花费爬楼梯</p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1：</p>
<pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">输入：cost</span> <span class="token punctuation">=</span> <span class="token attr-value">[10, 15, 20]</span>
输出：15
<span class="token attr-name">解释：最低花费是从</span> <span class="token attr-value">cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span>
<span class="token attr-name"> 示例</span> <span class="token attr-value">2：</span>

<span class="token attr-name">输入：cost</span> <span class="token punctuation">=</span> <span class="token attr-value">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span>
输出：6
<span class="token attr-name">解释：最低花费方式是从</span> <span class="token attr-value">cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>思路</strong></p>
<p>创建长度为 n + 1 的数组 dp，其中 dp[i] 表示达到下标 i 的最小花费。</p>
<p>由于可以选择下标 0 或 1 作为初始阶梯，因此有 dp[0] &#x3D; dp[1] &#x3D; 0</p>
<p>当 2 ≤ i ≤ n 时，可以从下标 i−1 使用 cost[i−1] 的花费达到下标 i，或者从下标 i−2 </p>
<p>使用 cost[i−2] 的花费达到下标 i。为了使总花费最小，dp[i] 应取上述两项的最小</p>
<p>值，因此状态转移方程如下：</p>
<p><strong>dp[i]&#x3D;min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])</strong></p>
<p>依次计算 dp 中的每一项的值，最终得到的 dp[n] 即为达到楼层顶部的最小花费。</p>
<p>解答</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCostClimbingStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> cost<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="题目2-3"><a href="#题目2-3" class="headerlink" title="题目2"></a>题目2</h4><p><img src="https://img.jwt1399.top/img/image-20211210154118892.png"></p>
<p><img src="https://img.jwt1399.top/img/image-20211210154157032.png"></p>
<p><img src="https://img.jwt1399.top/img/image-20211210154316100.png"></p>
<h2 id="⑥网络流"><a href="#⑥网络流" class="headerlink" title="⑥网络流"></a>⑥网络流</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li><p>理解最大流、任意流、最小割、任意割之间的关系；</p>
</li>
<li><p>掌握网络最大流问题和最小割问题及其求解算法，给出一个网络能求出它的最大流或者最小割。</p>
</li>
</ul>
</blockquote>
<h3 id="❶基础概念"><a href="#❶基础概念" class="headerlink" title="❶基础概念"></a>❶基础概念</h3><p>**网络流(Network-Flows)**是一种类比<code>水流</code>的解决问题方法，与线性规划密切相关。网络流是图论中的一种理论与方法，研究网络上的一类最优化问题。</p>
<p><strong>网络(NetWork)：</strong>是指一个有向图 G &#x3D;(V,E)，V 是图 G 中顶点的集合，E 是图 G 中边的集合。（<strong>运输水流的水管线路</strong>）</p>
<ul>
<li><p>每条<code>边 (u,v)</code> ∈ E 都有一个<code>权值 c(u,v)</code> ，称之为<code>容量(Capacity)</code>，当 (u,v) ∉ E 时 c(u,v) &#x3D; 0。</p>
</li>
<li><p>图 G 有两个特殊的点：<code>源点 s</code> ∈ V 和<code>汇点 t</code> ∈ V 。</p>
</li>
</ul>
<p><strong>弧</strong> (arc) <strong>：</strong> 图 G 的边 <code>(u,v)</code>（<strong>水管</strong>）</p>
<p><strong>源点</strong> (Sources)： 可以理解为<strong>起点</strong>。它会源源不断地放出流量，表示为 <code>s</code> 。（<strong>可无限出水的水厂</strong>）</p>
<p><strong>汇点</strong> (Sinks)：可以理解为<strong>终点</strong>。它会无限地接受流量，表示为 <code>t</code> 。（<strong>可无限接收水的小区</strong>）</p>
<p><strong>容量</strong> (Capacity) <strong>：</strong>每条弧 (u,v) 的权值 <code>c(u,v)</code> （<strong>水管规格。即可承受的最大水流量</strong>）</p>
<p><strong>容量网络：</strong> 拥有<strong>源点</strong>和<strong>汇点</strong>且每条弧都给出了<strong>容量</strong>的<strong>网络</strong>。（<strong>安排好了水厂、小区和水管规格的路线图</strong>）</p>
<p><img src="https://img.jwt1399.top//img/20211016110427.png" alt="容量网络"></p>
<p><strong>流量</strong> (Flow) <strong>：</strong>容量网络G中每条弧&lt; u,v&gt;上的实际流量 ，表示为 <code>f(u,v)</code> （<strong>运输的水流量</strong>）</p>
<p>​	设 <code>f(u,v)</code>定义在二元组 (u∈V, v∈V) 上的实数函数满足：</p>
<ul>
<li><p>容量限制：对于每条边，流经该边的流量不超过该边的容量，即 f(u,v)≤c(u,v) (<strong>水流量超过了水管规格就爆了</strong>）</p>
</li>
<li><p>斜对称性：每条边的流量与其相反边的流量之和为 0 ，即 f(u,v)+f(v,u)&#x3D;0 (<strong>可以暂且感性理解为矢量的正负</strong>)</p>
</li>
<li><p>流守恒性：从源点流出的流量等于汇点流入的流量。即 ∀x ∈ V - {s,t}，∑<sub>(u,x)∈E</sub>f(u,x) &#x3D; ∑<sub>(x,v)∈E</sub>f(x,v) (<strong>对于所有的水管交界处，有多少水流量过来，就应有多少水流量出去</strong>)</p>
</li>
</ul>
<p><img src="https://img.jwt1399.top//img/20211016110621.png" alt="流函数"></p>
<p><strong>流量网络：</strong> 拥有<strong>源点</strong>和<strong>汇点</strong>且每条弧都给出了<strong>流量</strong>的<strong>网络</strong>。(<strong>分配好了各个水管水流量的路线图</strong>)</p>
<p><img src="https://img.jwt1399.top//img/20211016110431.png" alt="流量网络"></p>
<p><strong>剩余容量</strong>(Residual)：对于每条边，<code>剩余容量(Residual) = 容量(Capacity) − 流量(Flow)</code>。(<strong>表示水管分配了水流量后还能继续承受的水流量</strong>）</p>
<p><strong>残量网络：</strong> 拥有<strong>源点</strong>和汇点且每条弧还有<strong>剩余容量</strong>的<strong>网络</strong>。<code>残量网络 = 容量网络 − 流量网络</code>。初始的残量网络即为容量网络。（<strong>表示了分配了一定的水流量后还能继续承受的水流量路线图</strong>）</p>
<p><img src="https://img.jwt1399.top//img/20211016111631.png" alt="剩余网络"></p>
<h3 id="❷最大流"><a href="#❷最大流" class="headerlink" title="❷最大流"></a>❷最大流</h3><blockquote>
<p><strong>问题描述：</strong>我们有一张有向图，要求从源点 s 流向汇点 t 的最大流量（可以有很多条路到达汇点），这就是我们的最大流问题。</p>
</blockquote>
<h4 id="➀基础概念"><a href="#➀基础概念" class="headerlink" title="➀基础概念"></a>➀基础概念</h4><p><strong>网络的流量：</strong> 在某种方案下形成的<strong>流量网络</strong>中<strong>汇点</strong>接收到的<strong>流量</strong>值。（<strong>小区最终接收到的总水流量</strong>）</p>
<p><strong>最大流(Maximum-Flow)</strong> ：<strong>网络的流量</strong>的最大值。（<strong>小区可接受到的最大水流量</strong>）</p>
<p><strong>最大流网络：</strong> 达到<strong>最大流</strong>的<strong>流量网络</strong>。（<strong>小区接收到最大水流量的分配方案路线图</strong>）</p>
<p><strong>增广路径(Augmenting Path)：</strong> 一条在<strong>残量网络</strong>中从 s 到 t 的路径，路径上所有边的<strong>残留容量</strong>都为正。<br>(<strong>可以成功从水厂将水送到小区的一条路线</strong>）</p>
<h4 id="➁增广路算法"><a href="#➁增广路算法" class="headerlink" title="➁增广路算法"></a>➁增广路算法</h4><blockquote>
<p>当残量网络不包含增广路径时能求得最大流</p>
</blockquote>
<p>例如如下网络：</p>
<table>
<thead>
<tr>
<th>初始容量网络</th>
<th>初始残量网络</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.jwt1399.top//img/20211016110427.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016132829.png"></td>
</tr>
</tbody></table>
<p><strong>寻找增广路径</strong>,增广路径上的流量为路径上最小容量</p>
<table>
<thead>
<tr>
<th>增广路径1（s→v<sub>2</sub>→v<sub>4</sub>→t）</th>
<th>残量网络1</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.jwt1399.top//img/20211016132837.png" alt="s→v2→v4→t"></td>
<td><img src="https://img.jwt1399.top//img/20211016132841.png"></td>
</tr>
<tr>
<td><strong>增广路径2（s→v<sub>1</sub>→v<sub>3</sub>→t）</strong></td>
<td><strong>残量网络2</strong></td>
</tr>
<tr>
<td><img src="https://img.jwt1399.top//img/20211016132845.png" alt="s→v1→v3→t"></td>
<td><img src="https://img.jwt1399.top//img/20211016132848.png"></td>
</tr>
<tr>
<td><strong>增广路径3（s→v<sub>1</sub>→v<sub>4</sub>→t）</strong></td>
<td><strong>最终残量网络</strong></td>
</tr>
<tr>
<td><img src="https://img.jwt1399.top//img/20211016132853.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016132856.png"></td>
</tr>
</tbody></table>
<p><strong>求流量网络</strong>，流量网络 &#x3D; 初始容量网络 - 最终残余网络</p>
<p><img src="https://img.jwt1399.top//img/20211016132910.png" alt="流量网络"></p>
<p><strong>因此最大流为从 s 流出的流量 3 + 2 &#x3D; 5 或者流入 t 的流量 2 +3 &#x3D;5</strong></p>
<p><strong>但是这种算法并不能保证一定能得到最大流</strong>，取决于你选择增广路径的顺序，我们同样以上方初始容量网络图为例，假设第一条增广路径选择 <strong>s→v<sub>1</sub>→v<sub>4</sub>→t</strong>，第二条增广路径选择 <strong>s→v<sub>1</sub>→v<sub>3</sub>→t</strong>，得到如下残量网络 和 流量网络</p>
<table>
<thead>
<tr>
<th>容量网络</th>
<th>残量网络</th>
<th>流量网络</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.jwt1399.top//img/20211016110427.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016133136.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016133139.png"></td>
</tr>
</tbody></table>
<p><strong>因此该种方法求得最大流为从 s 流出的流量 4 + 0 &#x3D; 4 或者流入 t 的流量 1 +3 &#x3D;4</strong>，显然比刚刚求得的最大流 5 要小</p>
<p><code>总结：</code>这种算法并不能保证一定能得到最大流，取决于你选择增广路径的顺序，那么如何保证无论怎么选择增广路径仍然能求得最大流呢？且听我娓娓道来。</p>
<h4 id="➂Ford-Fulkerson"><a href="#➂Ford-Fulkerson" class="headerlink" title="➂Ford-Fulkerson"></a>➂Ford-Fulkerson</h4><p>FF 算法核心是引入反向边，有了反向边，哪怕之前选择的增广路径顺序不好，也有了一个后悔和改正的机会</p>
<p>FF算法复杂度：O(f*m) (f 为最大流，m为原图边的数量)</p>
<p>我们来改造上方的错误求解方法</p>
<table>
<thead>
<tr>
<th>增广路径1(s→v<sub>1</sub>→v<sub>4</sub>→t)</th>
<th>残量网络1</th>
<th>加入路径1反向边</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.jwt1399.top//img/20211016141358.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141425.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141433.png"></td>
</tr>
<tr>
<td><strong>增广路径2(s→v<sub>1</sub>→v<sub>3</sub>→t)</strong></td>
<td><strong>残量网络2</strong></td>
<td><strong>加入路径2反向边</strong></td>
</tr>
<tr>
<td><img src="https://img.jwt1399.top//img/20211016141347.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141416.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141442.png"></td>
</tr>
<tr>
<td><strong>增广路径3(s→v<sub>2</sub>→v<sub>4</sub>→v<sub>1</sub>→v<sub>3</sub>→t)</strong></td>
<td><strong>残量网络3</strong></td>
<td><strong>加入路径3反向边</strong></td>
</tr>
<tr>
<td><img src="https://img.jwt1399.top//img/20211016141457.png" alt="相当于反悔v4→v1的3份流量"></td>
<td><img src="https://img.jwt1399.top//img/20211016141459.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141503.png" alt="已经没有s到t的增广路径"></td>
</tr>
<tr>
<td><strong>移除所有反向边得最终残量图</strong></td>
<td><strong>流量图</strong></td>
<td><strong>最大流</strong></td>
</tr>
<tr>
<td><img src="https://img.jwt1399.top//img/20211016141512.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016141517.png"></td>
<td><strong>因此最大流为从 s 流出的流量4 + 1 &#x3D; 5 或者流入 t 的流量 2 +3 &#x3D;5</strong></td>
</tr>
</tbody></table>
<h3 id="❸最小割"><a href="#❸最小割" class="headerlink" title="❸最小割"></a>❸最小割</h3><p><strong>割</strong>：对于一个网络流图 G &#x3D; (V,E)，其割的定义为一种 <strong>点的划分方式</strong>：将所有的点 V 划分为 S 和 T 两个集合，其中源点  s ∈ S ，汇点 t ∈ T。割并不唯一</p>
<p><img src="https://img.jwt1399.top/img/202211082244581.png"></p>
<p><code>上图就为一种割，S = &#123;s,v1,v2&#125;，V =&#123;t,v3,v4&#125;,s的水无法流到t了</code></p>
<p><strong>割的容量</strong>：我们的定义割 (S,T) 的容量 c(S,T) 表示所有从 S 到 T 的边的容量之和，即 c(S,T) &#x3D; ∑<sub>u∈S,v∈T</sub>c(u,v) 。</p>
<p><img src="https://img.jwt1399.top//img/20211021151950.png"></p>
<p><code>容量 c(S,T) = 2 + 2 + 2 = 6</code></p>
<p><img src="https://img.jwt1399.top//img/20211021151945.png"></p>
<p><code>容量 c(S,T) = 2 + 1 = 3</code></p>
<p><strong>最小割：</strong>求得一个割 (S,T) 使得割的容量 c(S,T) 最小，最小割并不一定唯一。</p>
<p><strong>最大流最小割定理</strong>：f(s,t)<sub>max</sub> &#x3D; c(S,T)<sub>min</sub> 最小割的容量等价于最大流的流量</p>
<p><strong>求解最小割：</strong> </p>
<ul>
<li><p><strong>求最小割的容量</strong>，那么只要跑一遍网络最大流即可得出答案。</p>
</li>
<li><p><strong>求 S 集合和 T 集合</strong>，那么先跑一遍网络最大流，然后在跑完网络最大流的残留网络中，从源点 s 开始进行 DFS，能遍历到的节点都属于 S 集合，剩下的节点都属于 T 集合。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>初始容量网络</th>
<th>最终残量网络</th>
<th>最小割</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://img.jwt1399.top//img/20211016110427.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016132856.png"></td>
<td><img src="https://img.jwt1399.top//img/20211016145010.png"></td>
</tr>
</tbody></table>
<p><strong>因此最小割为{ {s,v1,v2,v4}{t,v3}}，容量(最大流)为 5</strong></p>
<h3 id="❹流与割"><a href="#❹流与割" class="headerlink" title="❹流与割"></a>❹流与割</h3><p>对任意流 f，任意割 (A, B)，<strong>流的大小为流出A的流量与流入A的流量之差</strong>。</p>
<p><img src="https://img.jwt1399.top/img/image-20211021153436806.png"></p>
<p>例如如下 ，A集合为黑色小圆圈，B集合为白色小圆圈</p>
<p><img src="https://img.jwt1399.top/img/image-20211021152515576.png"></p>
<p>val(f) &#x3D; (10 + 10 + 5 +10 + 0 + 0) - (5 +5 + 0 +0 ) &#x3D; 25</p>
<p><img src="https://img.jwt1399.top/img/image-20211021152742760.png"></p>
<p>val(f) &#x3D; (20 + 22) - (8 + 4 + 4 ) &#x3D; 26</p>
<h3 id="❺真题练习"><a href="#❺真题练习" class="headerlink" title="❺真题练习"></a>❺真题练习</h3><h4 id="➀题目1-2"><a href="#➀题目1-2" class="headerlink" title="➀题目1"></a>➀题目1</h4><p>计算下图中从S到T的最大流和最小割.</p>
<p><img src="https://img.jwt1399.top//img/20211016201257.gif"></p>
<p>增广路径：(<em>S</em>, <em>A</em>, <em>B</em>, <em>T</em>)，网络流大小+6</p>
<p>增广路径：(<em>S</em>, <em>B</em>, <em>E</em>, <em>T</em>)，网络流大小+4      </p>
<p>增广路径：(<em>S</em>, <em>A</em>, <em>D</em>, <em>E</em>, <em>T</em>)，网络流大小+3</p>
<p>增广路径：(<em>S</em>, <em>C</em>, <em>E</em>, <em>T</em>)，网络流大小+3</p>
<p><img src="https://img.jwt1399.top//img/20211016201305.png"></p>
<p><strong>最大流 6 + 4 + 3 + 3 &#x3D; 16</strong></p>
<p><strong>最小割 [ {S，A，B，C，D，E}，{T} ]</strong></p>
<h4 id="➁题目2-2"><a href="#➁题目2-2" class="headerlink" title="➁题目2"></a>➁题目2</h4><p>求下图中S和T间的最大流，要求给出最少两个中间计算步骤。</p>
<p><img src="https://img.jwt1399.top//img/20211016201320.png"></p>
<p>增广路径：(S，C，F，T），流量值+1</p>
<p>增广路径：(S，C，B，F，T)，流量值+1</p>
<p>增广路径：(S，A，B，F，T)，流量值+1</p>
<p>增广路径：(S，A，D，T )，流量值+1</p>
<p>增广路径：(S，A，E，D，T )，流量值+1</p>
<p>增广路径：(S，A，E，T)，流量值+1</p>
<p>增广路径：(S，B，F，E，T)，流量值+3</p>
<p><img src="https://img.jwt1399.top/img/202112091215288.png" alt="闹闹友情提供"></p>
<p><strong>最大流 1 + 1 + 1 + 1 + 1 + 1 + 3  &#x3D; 9</strong></p>
<h2 id="⑦NP完备性理论"><a href="#⑦NP完备性理论" class="headerlink" title="⑦NP完备性理论"></a>⑦NP完备性理论</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li><p>理解什么是多项式归约（polynomial-time reduction）</p>
</li>
<li><p>从一个问题 A 多项式归约到另一个问题 B 时，掌握针对问题 A 的任意实例构造问题 B 的实例的方法。</p>
</li>
<li><p>自身归约</p>
</li>
<li><p>掌握如果P≠NP ，P、NP和NPC三个集合之间的关系， 以及NP问题定义的非对称性</p>
</li>
<li><p>记住证明一个问题属于NPC的基本步骤</p>
</li>
<li><p>能证明给定的问题是NP完全问题</p>
</li>
</ul>
</blockquote>
<h3 id="❶P-amp-NP-amp-NPC"><a href="#❶P-amp-NP-amp-NPC" class="headerlink" title="❶P&amp;NP&amp;NPC"></a>❶P&amp;NP&amp;NPC</h3><h4 id="➀基础概念-1"><a href="#➀基础概念-1" class="headerlink" title="➀基础概念"></a>➀基础概念</h4><ul>
<li><p><strong>P(Polynomial-time，多项式时间)：</strong>能在多项式时间内求解的问题。</p>
<ul>
<li>多项式时间算法，对于规模为 n 的输入，在最坏情况下的运行时间是O(n<sup>k</sup>)，其中 k 为某一确定常数。</li>
<li>伪多项式时间算法，典型的0-1背包问题算法复杂度为O(n*W)，其运行时间与输入的规模相关，是伪多项式的。</li>
</ul>
</li>
<li><p><strong>NP(Nondeterministic Polynomial-time，非确定性多项式时间)：</strong>能多项式时间内可以被验证的问题</p>
</li>
<li><p><strong>NPC(NP Completeness，NP完全)：</strong>NP中最难的问题，可能没有多项式时间算法的问题 ，满足两个条件①是一个NP问题②所有的NP问题都可以约化到它</p>
</li>
<li><p><strong>NP-Hard</strong>：比NP问题都要难的问题，满足NPC问题的第二条，但不一定要满足第一条</p>
</li>
</ul>
<h4 id="➁P-amp-NP-amp-NPC关系"><a href="#➁P-amp-NP-amp-NPC关系" class="headerlink" title="➁P&amp;NP&amp;NPC关系"></a>➁P&amp;NP&amp;NPC关系</h4><ul>
<li>当 P ≠ NP 时，NP 问题和 NP-hard 的交集就是 NPC 问题</li>
<li>当 P &#x3D; NP 时，P &#x3D; NP &#x3D; NPC</li>
</ul>
<p><img src="https://img.jwt1399.top/img/image-20211129115054549.png"></p>
<h4 id="➂NP问题定义的非对称性"><a href="#➂NP问题定义的非对称性" class="headerlink" title="➂NP问题定义的非对称性"></a>➂NP问题定义的非对称性</h4><p>这个问题小简也不太懂，不知道如何写，有知道的大佬可以给小简讲讲吗</p>
<h3 id="❷多项式时间归约"><a href="#❷多项式时间归约" class="headerlink" title="❷多项式时间归约"></a>❷多项式时间归约</h3><p><strong>归约</strong></p>
<p>描述：在研究不同问题的难度时，希望表达“问题 Y 至少像问题 X 一样的难”，这就是归约。</p>
<p>定义：设计一个函数 f(x)，把问题 A 的输入转换成问题 B 的一个输入，这样就能用问题 B 的解法来求解。这样就是归约技术，将这个问题转换为类似的其他问题。</p>
<p><strong>多项式时间归约</strong></p>
<p>描述：所谓多项式归约是指转换函数 f(x) 不能太复杂，需要在多项式时间内完成，如果是指数级或其他复杂度就没有意义了。</p>
<p>定义：如果问题 X 和问题 Y 满足以下两条性质，那么问题 X 可以在多项式时间归约到问题 Y 。记为：X ≤<sub>p </sub>Y </p>
<ul>
<li>问题 X 可以通过多项式时间的基本运算步骤转换为问题 Y；</li>
<li>问题 X 多项式次调用求解问题 Y 的算法，且问题 Y 可以在多项式时间内被求解。</li>
</ul>
<p>根据以上定义，可以得到三个<strong>定理</strong>：</p>
<ul>
<li>假设 X ≤<sub>p</sub> Y，如果 Y 能够在多项式时间内求解，那么 X 也能在多项式时间内求解。</li>
<li>假设 X ≤<sub>p</sub> Y，如果 X 不能在多项式时间内求解，那么 Y 也不能在多项式时间内求解。</li>
<li>如果 X ≤<sub>p</sub> Y 且 Y ≤<sub>p</sub> X，那么 X  ≡<sub>p</sub> Y， 即 X 和 Y 等价。</li>
</ul>
<p>例题：</p>
<table>
<thead>
<tr>
<th><img src="https://img.jwt1399.top//img/image-20211029191456394.png"></th>
<th><img src="https://img.jwt1399.top//img/image-20211029191959453.png"></th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>B</td>
</tr>
</tbody></table>
<p><strong>有多项式时间算法的问题和可能没有多项式时间算法的问题</strong></p>
<table>
<thead>
<tr>
<th>有多项式时间算法</th>
<th>可能没有多项式时间算法</th>
</tr>
</thead>
<tbody><tr>
<td>最短路问题</td>
<td>最长路问题</td>
</tr>
<tr>
<td>最小割问题</td>
<td>最大割问题</td>
</tr>
<tr>
<td>2元可满足性问题</td>
<td>3元可满足性问题</td>
</tr>
<tr>
<td>平面图4着色问题</td>
<td>平面图3着色问题</td>
</tr>
<tr>
<td>二部图顶点覆盖问题</td>
<td>一般图顶点覆盖问题</td>
</tr>
<tr>
<td>匹配问题</td>
<td>3D匹配问题</td>
</tr>
<tr>
<td>素性测试问题</td>
<td>质因子分解问题</td>
</tr>
<tr>
<td>线性规划问题</td>
<td>整数线性规划问题</td>
</tr>
</tbody></table>
<p>看到这里，小简觉得你已经对归约有了一个基本的认知，但是我们如何进行规约呢，莫慌莫慌，下面小简将对具体问题如何规约进行详细叙述，友情提示下方内容高能，请读者做好心理准备，耐心阅读，反复研读，加油！</p>
<h3 id="❸一般归约方法"><a href="#❸一般归约方法" class="headerlink" title="❸一般归约方法"></a>❸一般归约方法</h3><p>归约是指问题 A 的任何实例能用问题 B 的方法来解决（判断），并且 A 的解为“是”，当且仅当 B 的解也是“是”。因此，证明归约是<strong>双向的</strong>，目前遇到的大多归约问题（A ≤<sub>p</sub> B）都可以按以下步骤进行：</p>
<ol>
<li>构造图 G ，存在问题 A 的解集；</li>
<li>在图 G 基础上，构造图 G’（常添加边或点），使得问题 A 的解集能反应在 G’ 中问题 B 的解集（注意两个问题解集的规模 k 一定要有确定的联系）；</li>
<li>图 G 中存在问题 A 的解集 S，当且仅当图 G’ 中存在问题 B 的解集 S’ ；</li>
<li>规约的正确性，需双向证明。</li>
</ol>
<p>也有不用构造新图的，比如点覆盖到独立集的规约，这种方法叫直接规约。但大多有些难度的归约一般都需要构造。</p>
<h3 id="❹重点掌握的归约"><a href="#❹重点掌握的归约" class="headerlink" title="❹重点掌握的归约"></a>❹重点掌握的归约</h3><h4 id="①顶点覆盖≡p独立集"><a href="#①顶点覆盖≡p独立集" class="headerlink" title="①顶点覆盖≡p独立集"></a>①顶点覆盖≡<sub>p</sub>独立集</h4><blockquote>
<p><strong>Vertex-Cover ≡<sub>p </sub>Independent Set（顶点覆盖 ≡<sub>p </sub>独立集）</strong></p>
</blockquote>
<p><code>顶点覆盖问题：</code>给定一个图 G &#x3D; ( V , E )和一个整数 k ，是否存在一个大小为 k 的顶点子集，使图中每一条边至少有一个顶点在上述顶点子集中。</p>
<p>如图，黑色的点集合都是顶点覆盖集合，图的每一条边都至少有一个顶点在点集合中。</p>
<p><img src="https://img.jwt1399.top/img/202111111714918.webp" alt="顶点覆盖集(黑色)"></p>
<p><code>独立集问题：</code>给定一个图 G &#x3D; ( V，E )和一个整数 k ，是否存在一个大小为 k 的顶点子集，使子集中任意两个顶点不邻接。即顶点集合中的任意两个点之间没有边。</p>
<p>如图，红色s的点集合都是独立集，任意两个红色的顶点没有边。</p>
<p><img src="https://img.jwt1399.top/img/202111111714615.webp" alt="独立集(红色)"></p>
<p>例题：</p>
<img src="https://img.jwt1399.top//img/image-20211029192154553.png" alt="选C" style="zoom:80%;" />

<p><strong>两个问题可以归纳为：</strong></p>
<p>独立集问题：    给定图 G 和数 k ，问 G 是否包含大小为 k 的独立集？<br>顶点覆盖问题：给定图 G 和数 k ，问 G 是否包含大小为 k 的顶点覆盖？</p>
<blockquote>
<p><strong>（顶点覆盖 ≡<sub>p </sub>独立集）问题描述</strong>：设图 G &#x3D; ( V , E ) ，S ⊆ V，若 S 是一个大小为 k 的<code>独立集</code>当且仅当 V − S 是一个大小为 n − k 的<code>顶点覆盖</code></p>
</blockquote>
<p><code>证明:</code><br><strong>⇒</strong> </p>
<p>​	S 是图 G 的任一独立集<br>​	则任意边 (u,v) ∈ E，有u ∉ S 或 v ∉ S 或 u,v 都 ∉ S；那么 u∈V-S 或 v∈V-S 或 u,v 都 ∈ S<br>​	所以图的任意边 (u,v) 至少有一个顶点在集合 V-S 中，即集合 V-S 是一个顶点覆盖</p>
<p><strong>⇐</strong> </p>
<p>​	V-S 是图 G 的任一顶点覆盖<br>​	则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S 或 u,v 都 ∈ V-S ；那么 u ∉ S 或 v ∉ S 或 u,v 都 ∉ V-S<br>​	所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集</p>
<p>∴  Vertex-Cover ≡<sub>p</sub> Independent Set</p>
<h4 id="②顶点覆盖≤p集合覆盖"><a href="#②顶点覆盖≤p集合覆盖" class="headerlink" title="②顶点覆盖≤p集合覆盖"></a>②顶点覆盖≤<sub>p</sub>集合覆盖</h4><blockquote>
<p><strong>Vertex-Cover ≤<sub>p</sub> Set-Cover（顶点覆盖 ≤<sub>p </sub>集合覆盖）</strong></p>
</blockquote>
<p><code>集合覆盖问题：</code>给定 n 个元素的集合 U , S<sub>1</sub>，S<sub>2</sub>，… ，S<sub>m</sub> 是 U 的子集，给定数 k ， 问在这些子集中是否有几组子集，它们的并集等于整个 U 且至多含有 k 组子集？</p>
<p>如图，集合覆盖大小为 k &#x3D; 2 </p>
<p><img src="https://img.jwt1399.top//img/image-20211029184922160.png"></p>
<p>例题：</p>
<p><img src="https://img.jwt1399.top//img/image-20211029192302351.png" alt="选C"></p>
<blockquote>
<p><strong>（顶点覆盖 ≤<sub>p </sub>集合覆盖）问题描述：</strong>给任意一个顶点覆盖问题的实例 G&#x3D;（V，E）和 k，都能构造出对应的集合覆盖实例（U，S，k）。集合覆盖大小为 k 当且仅当顶点覆盖大小为 k 。</p>
</blockquote>
<p><code>证明：</code></p>
<p>构造思路：原顶点覆盖的顶点相当于集合覆盖中的子集合，原顶点覆盖的边相当于集合覆盖的子集合中元素。</p>
<p><img src="https://img.jwt1399.top//img/image-20211029193948736.png"></p>
<p><strong>⇒</strong></p>
<p>​	令 X ⊆ V 为 G 中大小为 k 的顶点覆盖，则 Y &#x3D; {S <sub>v</sub> | v ∈ X } 为大小为 k 的集合覆盖。<br><strong>⇐</strong> </p>
<p>​	令 Y ⊆ S 为 (U，S，k) 中大小为 k 的集合覆盖，则 X &#x3D; { v | S<sub>v</sub> ∈ Y } 为 G 中大小为 k 的顶点覆盖。<br>∴  Vertex-Cover ≤<sub>p</sub> Set-Cover</p>
<h4 id="③3-SAT≤p独立集"><a href="#③3-SAT≤p独立集" class="headerlink" title="③3-SAT≤p独立集"></a>③3-SAT≤<sub>p</sub>独立集</h4><blockquote>
<p><strong>3-SAT ≤<sub>p</sub> Independent Set（3-SAT ≤<sub>p </sub> 独立集）</strong></p>
</blockquote>
<p><code>SAT问题：</code>SAT 问题叫作布尔可满足性问题（Boolean satisfiability problem）</p>
<p>给定变量集 X &#x3D; {x<sub>1</sub>，x<sub>2</sub>，… ，x<sub>n</sub>} 上的一组子句 C<sub>1</sub>，C<sub>2</sub>，… ，C<sub>n</sub> ，子句为 X 中一些元素的并集，多个子句的交集构成一个合取范式，问是否存在使合取范式为真的分配方案？</p>
<p><code>3-SAT问题：</code>3-SAT 问题叫作三元可满足性问题。</p>
<p>若限定 SAT问题合取范式中的每个子句中元素的数量为 3 个，则为 3-SAT 问题。</p>
<blockquote>
<p><strong>（3-SAT ≤<sub>p </sub> 独立集）问题描述：</strong>给定一个 3-SAT 问题的实例 Ф ，我们都能构造出一个图 G &#x3D; ( V , E ) 独立集问题的实例。3-SAT问题有解，当且仅当 G 中 k &#x3D; ∣ Ф ∣，∣ Ф ∣ 大小为合取范式中子句的个数。</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：</p>
<ul>
<li><em>G</em>中三个顶点构成一个三角形表示一个子句，每个节点表示一个元素</li>
<li>每个顶点与其对立节点连线</li>
</ul>
<p><img src="https://img.jwt1399.top/img/202111111714726.png"></p>
<p>规约的正确性，需双向证明，即独立集存在，则 Ф 被满足；Ф 被满足，则独立集存在。<br><strong>⇒</strong></p>
<p>​	图 G 存在大小为 k 的独立集，那么各三角形中必然有一点在独立集中（三角形内的点均相邻，不独立）；<br>​	将这 k 个点（变量）的值设为 true，那么其余所有点的取值均可确定下来；<br>​	因为这 k 个点在 k 个不同的句子中，则 Ф 能被满足。<br><strong>⇐</strong></p>
<p>Ф 被满足，在 k 个句子中选取三个变量设为 true，它们对应图 G 中 k 个三角形中的 k 个点；<br>这 k 个点刚好构成图 G 大小为 k 的独立集（因为互反的变量不会同时为 true，即不会同时在 k 个点中）。</p>
<p>∴  3-SAT ≤<sub>p</sub> Independent Set</p>
<p><code>①②③总结：</code>3-SAT ≤<sub>p</sub> 独立集问题 ≡<sub>p</sub>  顶点覆盖 ≤<sub>p</sub> 集合覆盖</p>
<h4 id="④顶点覆盖≤p支配集"><a href="#④顶点覆盖≤p支配集" class="headerlink" title="④顶点覆盖≤p支配集"></a>④顶点覆盖≤<sub>p</sub>支配集</h4><blockquote>
<p><strong>Vertex-Cover ≤<sub>p</sub> Dominating-Set（顶点覆盖 ≤<sub>p </sub>支配集问题）</strong></p>
</blockquote>
<p><code>支配集问题：</code>给定无向图 G 和正整数 k，问图 G 中是否存在 k 个顶点的子集 s ，使得对于图 G 中的任意顶点 v ，要么 v∈s，要么 v 至少与 S 中的至少一个顶点相邻。</p>
<blockquote>
<p><strong>（顶点覆盖 ≤<sub>p </sub>支配集问题）问题描述：</strong>给任意一个顶点覆盖问题的实例 G&#x3D;（V，E）和 k，都能构造出对应的支配集实例 G’。支配集大小为 k 当且仅当顶点覆盖大小为 k 。</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：对给定的图G，作如下处理：对于图G的任意一边uv，添加一个点w，使得该边的两个顶点u、v分别与w相邻，得到新的一个无向图G’。</p>
<p><img src="https://img.jwt1399.top/img/202111101836405.png"></p>
<p><strong>⇒</strong></p>
<p>假设 s 是 G 的一个顶点覆盖，由于所有边都被 s 覆盖，因此图 G’ 所有顶点也都被 s 所支配。<br><strong>⇐</strong></p>
<p>假设 s 是 G’ 的一个支配集，如果 s 含有新顶点 w，它可以被 v 或者 u 替换并且仍旧是一个支配集（因为顶点 v 和 u都能覆盖 w 所覆盖的顶点），可以假定 s 仅包含 G 中的顶点。由于 s 支配了所有新顶点，它一定至少包含原图中每条边的两端顶点之一，因此它也是 G 的一个顶点覆盖。</p>
<p>∴  Vertex-Cover ≤<sub>p</sub> Dominating-Set</p>
<h4 id="⑤有向图Ham≤p无向图Ham"><a href="#⑤有向图Ham≤p无向图Ham" class="headerlink" title="⑤有向图Ham≤p无向图Ham"></a>⑤有向图Ham≤<sub>p</sub>无向图Ham</h4><blockquote>
<p><strong>Directed Ham-cycle ≤<sub>p</sub>  Ham-cycle（有向图哈密尔顿圈 ≤<sub>p</sub> 无向图的哈密尔顿圈）</strong></p>
</blockquote>
<p><code>哈密尔顿圈：</code>设有一个图 G&#x3D;(V,E)，若其上存在一个圈 C，这个圈包含该图上的每一节点，则称该圈 C 为哈密顿圈，图 G 称为哈密顿图。下图就是一个含有哈密顿圈的哈密顿图。</p>
<p><img src="https://img.jwt1399.top/img/image-20211108203843315.png"></p>
<blockquote>
<p><strong>（有向图哈密尔顿圈 ≤<sub>p</sub> 无向图的哈密尔顿圈）问题描述：</strong>给定一个 n 个节点的有向图 G &#x3D; ( V , E ) ，我们可以构造一个含 3n 个顶点的无向图 G ′。有向图 G 拥有哈密尔顿圈当且仅当无向图 G ′ 拥有哈密尔顿圈。</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：把有向图 G 中的一个顶点，拆分成三个顶点(蓝、黑、白)</p>
<p><img src="https://img.jwt1399.top/img/202111082108366.png"></p>
<p>⇒<br>假设 G 存在一个有向的哈密尔顿圈 Γ ，那么 G′ 也有一个跟上述顺序一致的无向哈密尔顿圈 Γ′<br>⇐<br>假设 G′ 有一个无向哈密尔顿圈 Γ′ ，Γ′ 访问 G′ 中的顶点必须选择以下两种顺序中的一个：</p>
<ul>
<li>黑，白，蓝</li>
<li>黑，蓝，白</li>
</ul>
<p>Γ′ 中的黑色节点对应 Γ 中的哈密尔顿圈或者逆序中的一个。</p>
<p>∴  Directed Ham-cycle  ≤<sub>p</sub> Ham-cycle</p>
<h4 id="⑥3−SAT≤p有向图Ham"><a href="#⑥3−SAT≤p有向图Ham" class="headerlink" title="⑥3−SAT≤p有向图Ham"></a>⑥<strong>3−SAT≤<sub>p</sub>有向图Ham</strong></h4><blockquote>
<p> <strong>(3−SAT ≤<sub>p </sub>有向图哈密尔顿圈)问题描述：</strong>给定一个 3−SAT 的实例，我们都能构造出一个图 G，3−SAT 实例有解当且仅当图 G 含有一个哈密尔顿圈。</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：</p>
<ul>
<li>图 G 中哈密尔顿圈的个数为 2<sup>n</sup> 个，每个元素有真假 2 种可能，一共有 n 个，从左到右赋值为真，从右到左赋值为假</li>
<li>对于每个子句，若存在 x<sub>i</sub> ，则增加一个节点，并从左到右增加边；若存在 ¬x<sub>i</sub>，则增加一个节点，并从右到左增加边</li>
</ul>
<p><img src="https://img.jwt1399.top/img/image-20211205231006836.png"></p>
<ul>
<li>对每个变量 xi(1≤i≤n)，创建 3m+3 个顶点，命名为v<sub>i,1</sub>，v<sub>i,2</sub>，⋯  v<sub>i,3m+3</sub> 并且对相邻序号的两个顶点添加互相之间的有向边。如果 x<sub>i</sub> &#x3D; 1，则形成从左向右的一个路径；如果 ¬x<sub>i</sub>&#x3D;1，则形成从右向左的一个路径。</li>
<li>对每个 1≤i≤n−1，添加四条有向边(v<sub>i,1</sub>,v<sub>i+1,1</sub>),(v<sub>i,3m+3</sub>,v<sub>i+1,3m+3</sub>),(v<sub>i,1</sub>,v<sub>i+1,3m+3</sub>),(v<sub>i,3m+3</sub>,v<sub>i+1,1</sub>)</li>
<li>添加两个节点 s,t，添加有向边(s,v<sub>1,1</sub>),(s,v<sub>1,3m+3</sub>),(v<sub>n,1</sub>,t),(v<sub>n,3m+3</sub>,t)。然后再添加有向边(t,s)。这时得到的图中有 hamiltonian cycle。</li>
<li>对于每一个 clause C<sub>j </sub>&#x3D; z<sub>1</sub>z<sub>2</sub>z<sub>3</sub>，创建对应的顶点 C<sub>j</sub>。<ul>
<li>如果 z &#x3D; x<sub>i</sub>，则添加有向边 (v<sub>i,3j</sub>,C<sub>j</sub>) 和 (C<sub>j</sub>,v<sub>i,3j+1</sub>) ; </li>
<li>如果z &#x3D; ¬xi，则添加有向边 (C<sub>j</sub>,v<sub>i,3j</sub>) 和 (v<sub>i,3j+1</sub>,C<sub>j</sub>)。</li>
<li>这里 1 ≤ j ≤ m,1 ≤ i ≤ n。</li>
</ul>
</li>
<li>如对子句C<sub>1</sub> &#x3D; x<sub>1</sub>∨¬x<sub>2</sub>∨x<sub>3</sub> 生成如下图中蓝色所示。<ul>
<li>如果选择子句中 x1 &#x3D; 1，则 x<sub>1</sub> 对应的路径为从左向右；</li>
<li>如果选择 ¬x<sub>2</sub>&#x3D;1，则 x<sub>2</sub> 对应的路径为从右到左；</li>
<li>如果选择 x<sub>3</sub>&#x3D;1，则 x<sub>4</sub> 对应的路径为从左到右。</li>
</ul>
</li>
<li>这样我们就得到了最终的图G。</li>
</ul>
<p><img src="https://img.jwt1399.top/img/image-20211205234535016.png"></p>
<p>⇒</p>
<ul>
<li><p>假设 3−SAT 实例 ϕ 有满足的真值指派 x<sup>∗</sup>，那么我们在 G 中找到一个哈密尔顿圈 Γ 如下：</p>
<ul>
<li><p>如果 x<sub>i</sub><sup>∗</sup> &#x3D; true 我们从左到右穿过第 i 行</p>
</li>
<li><p>如果 x<sub>i</sub><sup>∗</sup> &#x3D; false 我们从右到左穿过第 i 行</p>
</li>
</ul>
</li>
<li><p>对于每个字句 C<sub>j</sub> ，至少存在一行 i 按照我们上述的方向，把子句节点拼接进圈内(我们只把子句节点拼接进圈有且仅有一次)</p>
</li>
</ul>
<p>⇐ </p>
<ul>
<li><p>假设 G 中有一个哈密尔顿圈 Γ </p>
</li>
<li><p>如果 Γ 加入了子句节点 C<sub>j</sub>  ，</p>
<ul>
<li>并假设与 C<sub>j</sub>  前后邻接的节点通过边 e ∈ E 相连。</li>
<li>我们从圈中删除节点 C<sub>j</sub> 和其直连边，并用边 e 代替，得到 G − { C<sub>j</sub> } 的哈密尔顿圈。</li>
</ul>
</li>
<li><p>循环执行上述方法，我们得到在 G − { C<sub>1</sub>  , C<sub>2</sub>  , … , C<sub>k</sub> } 上的哈密尔顿圈 Γ′</p>
</li>
<li><p>如果 Γ′ 在第 i 行的遍历方向是从左到右的，那么置 x<sub>i</sub><sup>∗</sup>  &#x3D; true ，否则置  x<sub>i</sub><sup>∗</sup>&#x3D; false </p>
</li>
<li><p>按照上述正确方向遍历进行真值指派，每个子句都会被满足，即原实例 ϕ 可满足。</p>
</li>
</ul>
<h4 id="⑦哈密尔顿圈≤p旅行售货员"><a href="#⑦哈密尔顿圈≤p旅行售货员" class="headerlink" title="⑦哈密尔顿圈≤p旅行售货员"></a>⑦哈密尔顿圈≤<sub>p</sub>旅行售货员</h4><blockquote>
<p><strong>Ham-cycle ≤<sub>p</sub> TSP（哈密尔顿圈 ≤<sub>p</sub> 旅行售货员问题）</strong></p>
</blockquote>
<p><code>TSP：</code>给定 n 个城市以及两两城市之间的距离 d(u,v)，问是否存在一个旅游访问 n 个城市一次且长度 ≤ D。</p>
<blockquote>
<p><strong>问题描述：</strong>给定一个哈密尔顿圈的实例  G &#x3D; (V,E)，创建一个 TSP 问题的完全图实例 G’， n 个城市两两间的距离函数定义如下：<img src="https://img.jwt1399.top/img/image-20211201230052384.png"></p>
<p>TSP问题有一个长度 ≤ n 的旅游当且仅当 G 中含有一个哈密尔顿圈</p>
</blockquote>
<p>TSP实例满足三角形不等式：d(u,w) ≤ d(u,v)+d(v,w)</p>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>


<h4 id="⑧三着色-≤p-k着色"><a href="#⑧三着色-≤p-k着色" class="headerlink" title="⑧三着色 ≤p k着色"></a>⑧三着色 ≤<sub>p</sub> k着色</h4><blockquote>
<p><strong>3-Color ≤<sub>p</sub> K-Color (K &gt; 3)（三着色问题 ≤<sub>p</sub> k着色问题）</strong></p>
</blockquote>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>


<h4 id="⑨哈密尔顿圈≤p最长路径"><a href="#⑨哈密尔顿圈≤p最长路径" class="headerlink" title="⑨哈密尔顿圈≤p最长路径"></a>⑨哈密尔顿圈≤<sub>p</sub>最长路径</h4><blockquote>
<p><strong>Ham-Cycle ≤<sub>p</sub> Longest-Path（哈密尔顿圈 ≤<sub>p </sub>最长路径）</strong></p>
</blockquote>
<p><code>Longest-Path：</code>给定一个有向图 G &#x3D; (V,E)，是否存在至少由 k 条边组成的简单路径？</p>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>


<h4 id="⑪子集和≤p分区问题"><a href="#⑪子集和≤p分区问题" class="headerlink" title="⑪子集和≤p分区问题"></a>⑪子集和≤<sub>p</sub>分区问题</h4><blockquote>
<p><strong>Subset-Sum ≤<sub>p</sub> Partition（子集和问题 ≤<sub>p </sub>分区问题）</strong></p>
</blockquote>
<p><code>Subset-Sum：</code>给定 n 个数 w<sub>1</sub> , … , w<sub>n</sub> 和整数 W，是否存在一个子集，其中所有元素的和等于 W。</p>
<p><code>Partition：</code>给定元素个数为 m 的集合 V &#x3D;{v<sub>1</sub> , v<sub>2</sub> , … , v<sub>m</sub>} ，是否可以将集合 V 分割成两个子集，使每个子集各元素之和为 1&#x2F;2∑v<sub>i</sub>  。即集合 A 能划分成元素之和相等的两部分。</p>
<blockquote>
<p>(<strong>子集和问题 ≤<sub>p </sub>分区问题)问题描述：</strong>给定一个集合 S &#x3D; {w<sub>1</sub> , w<sub>2</sub> , … , w<sub>n</sub>}，子集和为 W，需构造集合 S’，使得集合 S 存在一个子集之和为 W，当且仅当集合 S’ 存在一个 Partition</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：构造分区问题集合 S’ &#x3D; {v<sub>1</sub> , v<sub>2</sub> , … , v<sub>n</sub>, v<sub>n+1</sub>, v<sub>n+2</sub>}，其中：</p>
<p>v<sub>1</sub> &#x3D; w<sub>1</sub>，v<sub>2</sub> &#x3D; w<sub>2</sub>, … , v<sub>n</sub> &#x3D; w<sub>n</sub>，v<sub>n+1</sub> &#x3D; 2∑w<sub>i</sub> - W，v<sub>n+2</sub> &#x3D; ∑w<sub>i</sub> + W</p>
<p>由于分割问题总和为 4∑w<sub>i</sub>  ，所以 v<sub>n+1 </sub> 和 v<sub>n+2</sub> 不能在同一子集，不然该子集和为3∑w<sub>i</sub>，最终不能均分。要使每部分和为 2∑w<sub>i</sub> ，只能是如下情况：</p>
<p><img src="https://img.jwt1399.top/img/image-20211129154202796.png"></p>
<p>⇒<br>S 存在一个子集 A &#x3D; {a<sub>1</sub> , a<sub>2</sub> , … , a<sub>k</sub>}，其中 a<sub>k</sub> ∈ S，k≤n 且 ∑a<sub>i</sub> &#x3D; W</p>
<p>那么集合 S’ 中，有 ∑<sub>i∈A</sub> a<sub>i</sub> + v<sub>n+1</sub> &#x3D; ∑<sub>i∈S-A</sub> a<sub>i</sub> + v<sub>n+2</sub> &#x3D; 2∑w<sub>i</sub></p>
<p>所以集合 S’ 存在一个划分 A ∪ {v<sub>n+1</sub>} 和 S-A ∪ {v<sub>n+2</sub>}<br>⇐<br>集合 S’ 能被划分为两个和相等的集合，可知 v<sub>n+1</sub> 和 v<sub>n+2</sub> 不在一个划分子集里</p>
<p>那么，存在一个集合 A，设其元素之和为 Y，有 Y + v<sub>n+1</sub> &#x3D; ∑<sub>i∈S</sub> w<sub>i</sub> - Y + v<sub>n+2</sub></p>
<p>解出 Y &#x3D; W。</p>
<p>∴  Subset-Sum ≤<sub>p</sub> Partition</p>
<h4 id="⑩子集和≤p背包问题"><a href="#⑩子集和≤p背包问题" class="headerlink" title="⑩子集和≤p背包问题"></a>⑩子集和≤<sub>p</sub>背包问题</h4><blockquote>
<p><strong>Subset-Sum ≤<sub>p</sub> Knapsack（子集和问题 ≤<sub>p</sub> 背包问题）</strong></p>
</blockquote>
<p><code>Knapsack：</code>给定一个物品集合 X ，重量为 u<sub>i</sub> ≥ 0 ，价值 v<sub>i</sub> ≥ 0 ，背包能承受的总重量不超过 U，给定一个目标价值 V，是否存在一个子集 S ⊆ X 使得 ∑<sub>i∈S</sub> u<sub>i</sub>≤<em>U</em>，∑<sub>i∈S</sub> v<sub>i</sub>≥V</p>
<blockquote>
<p><strong>(子集和问题 ≤<sub>p</sub> 背包问题)问题描述：</strong>给定一个集合 S &#x3D; {w<sub>1</sub> , w<sub>2</sub> , … , w<sub>n</sub>}，子集和为 W，需构造集合 S’，使得集合 S 存在一个子集之和为 W，当且仅当集合 S’ 存在一个背包实例</p>
</blockquote>
<p><code>证明：</code></p>
<p>构图思路：对于任意一个子集和实例，我们构造一个背包实例：u<sub>i</sub> &#x3D; v<sub>i</sub> &#x3D; w<sub>i</sub>，U &#x3D; V &#x3D; W</p>
<p> ⇒<br>S 存在一个子集 A &#x3D; {a<sub>1</sub> , a<sub>2</sub> , … , a<sub>k</sub>}，其中 a<sub>i</sub> ∈ S，k≤n 且 ∑a<sub>i</sub> &#x3D; W</p>
<p>那么集合 S’ 中，有 ∑a<sub>i</sub>  &#x3D; ∑u<sub>i</sub> &#x3D; ∑v<sub>i</sub> &#x3D; W，∴  ∑u<sub>i</sub> &#x3D; U，∑v<sub>i</sub> &#x3D; V</p>
<p>所以集合 S’ 存在一个背包实例<br>⇐<br>集合 S’ 中存在一个背包实例，可知 ∑<sub>i∈S</sub> u<sub>i</sub>≤<em>U</em>，∑<sub>i∈S</sub> v<sub>i</sub>≥V</p>
<p>那么，存在一个集合 A，设其元素之和为 Y，有 Y  &#x3D; W</p>
<p>∴  Subset-Sum ≤<sub>p</sub> Knapsack</p>
<h4 id="⑫分区问题-≤p-k负载均衡"><a href="#⑫分区问题-≤p-k负载均衡" class="headerlink" title="⑫分区问题 ≤p k负载均衡"></a>⑫分区问题 ≤<sub>p </sub>k负载均衡</h4><blockquote>
<p><strong>Partition ≤<sub>p</sub> k-Load-Balance（分区问题≤<sub>p </sub>k负载均衡）</strong></p>
</blockquote>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>



<h3 id="❺自归身约"><a href="#❺自归身约" class="headerlink" title="❺自归身约"></a>❺自归身约</h3><blockquote>
<p>掌握同一个问题的最优化问题如何多项时间归约到该问题的判断问题（自身归约），例如顶点覆盖问题，Hamilton Cycle问题，3-Color问题</p>
</blockquote>
<h4 id="➀基础概念-2"><a href="#➀基础概念-2" class="headerlink" title="➀基础概念"></a>➀基础概念</h4><p><strong>自身规约：</strong>将求解(最优化)问题多项时间归约到该问题的判断问题。</p>
<p>如果判断问题能够解决，那么就可以利用判断问题来解决求解问题。</p>
<p><strong>自归约步骤</strong></p>
<ol>
<li>设该判断算法为 A ，利用算法 A 判断出图中存在…(大小为k的…)；</li>
<li>删除一条边或点(看具体是边集还是点集的问题)，对删除边&#x2F;点后的图运行判断算法 A ；</li>
<li>若图中还存在…(大小为k的…)，则从图中彻底删除该边&#x2F;点；若不存在，则把该边&#x2F;点加入集合 S 中；</li>
<li>对所有的边&#x2F;点调用算法 A 执行上述操作，最终得到的集合 S 就是求解问题的解。</li>
</ol>
<p>看完以上解题步骤，小简觉得你应该还是有点点懵懵的，但别担心，看完下面的具体案例你再回来研读解题步骤，我相信你对自身规约会有不一样的认知，加油！</p>
<h4 id="➁Vertex-Cover问题"><a href="#➁Vertex-Cover问题" class="headerlink" title="➁Vertex-Cover问题"></a>➁Vertex-Cover问题</h4><p>假如我们能判断一个图中是否存在点数为 k 的最小点覆盖。请你设计构造最小点覆盖问题的多项式时间算法。</p>
<ul>
<li>设该判断算法为 A ，利用算法 A 判断图 G 是否存在点数为 k 的最小点覆盖<ul>
<li>若不存在，则结束；</li>
<li>若存在，则在图中删除一个点 v；</li>
</ul>
</li>
<li>再用算法 A 判断图 G &#x3D; (V-v, E) 中是否存在点数为 k 的最小点覆盖<ul>
<li>若存在，则将点 v 从图中彻底删除；</li>
<li>若不存在，则把点 v 加入到集合 S 中；</li>
</ul>
</li>
<li>不断重复上述操作，最终 S 中的所有点就是最小点覆盖。</li>
</ul>
<h4 id="➂Hamilton-Cycle问题"><a href="#➂Hamilton-Cycle问题" class="headerlink" title="➂Hamilton Cycle问题"></a>➂Hamilton Cycle问题</h4><p>(2020)如果存在判断任意简单无向图是否存在哈密尔顿圈的多项式时间算法，请你设计构造任意简单无向图的哈密尔顿圈（如果存在的话）的多项式时间算法。</p>
<p>算法：</p>
<p>&#x2F;&#x2F;设该判断算法为A<br>S 初始化为空集；<br>首先算法 A 判断图 G 中是否存在哈密尔顿圈，如果不存在则算法结束，如果存在则继续寻找哈密尔顿圈；<br>For every edge e in G {<br>    如果 G – {e} 中不存在哈密尔顿圈，则将 e 添加到集合 S 中；<br>    否则 G &#x3D; G – {e}；<br>}<br>最终所得集合 S 中的所有边构成图 G 的哈密尔顿圈。</p>
<h4 id="➃3-Color问题"><a href="#➃3-Color问题" class="headerlink" title="➃3-Color问题"></a>➃3-Color问题</h4><blockquote>
<p>3-Color问题：对一个图的顶点进行三种颜色着色使得相邻两个点的颜色不一样</p>
</blockquote>
<p>(2018&#x2F;2019)对于三着色问题，若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。</p>
<p>解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。  </p>
<p>解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。</p>
<h4 id="➄Longest-Path"><a href="#➄Longest-Path" class="headerlink" title="➄Longest-Path"></a>➄Longest-Path</h4><p>如果存在一个多项式时间算法判断一个图是否存在一个长度为 k 的路径，则存在一个多项式时间算法要么找到图中一个长度为 k 的路径要么证明此图不存在长度为 k 的路径。</p>
<ul>
<li><p>假设存在判断一个图 G 是否存在一个长度为 k 的路径的多项式时间算法 A </p>
</li>
<li><p>首先用算法 A 判断图 G 是否存在一个长度为 k 的路径</p>
<ul>
<li>若不存在，则结束；</li>
<li>若存在，则在图中删除一条边 e ；</li>
</ul>
</li>
<li><p>再用 A 判断图 G &#x3D; (V, E-e) 中是否存在长度为 k 的一条路径</p>
<ul>
<li>若存在，则将边 e 从图中彻底删除；</li>
<li>若不存在，则把边 e 加入到集合 S 中；</li>
</ul>
</li>
<li><p>重复上述操作，最终 S 中的所有边构成的边就是长度为 k 的一条路径。</p>
</li>
</ul>
<h4 id="➅Subset-Sum问题"><a href="#➅Subset-Sum问题" class="headerlink" title="➅Subset-Sum问题"></a>➅Subset-Sum问题</h4><p>如果存在一个多项式时间算法判断一个集合 V 存在一个子集且其中元素的和等于 W，则存在一个多项式时间算法要么找到图中一个和为 W 的子集要么证明此集合不存在和为W的子集。</p>
<ul>
<li><p>假设存在判断一个集合 V 是否存在一个和为 W 的子集的多项式时间算法 A </p>
</li>
<li><p>首先用算法 A 判断该集合 V 是否存在和为 W 的子集</p>
<ul>
<li>若不存在，则结束；</li>
<li>若存在，则在集合中删除一个元素 v ；</li>
</ul>
</li>
<li><p>再用 A 判断 V - v 中是否存在和为 W 的子集</p>
<ul>
<li>若存在，则将元素 v 从集合中彻底删除；</li>
<li>若不存在，则把元素 v 加入到集合 S 中；</li>
</ul>
</li>
<li><p>重复上述操作，最终 S 构成的集合就是和为 W 的子集。</p>
</li>
</ul>
<h3 id="❻真题练习-1"><a href="#❻真题练习-1" class="headerlink" title="❻真题练习"></a>❻真题练习</h3><h4 id="➀题目1-3"><a href="#➀题目1-3" class="headerlink" title="➀题目1"></a>➀题目1</h4><p>证明问题属于NPC的基本步骤</p>
<ul>
<li><p>Step 1. 证明该问题是NP问题.</p>
</li>
<li><p>Step 2. 找到一个已知的NP完全问题X.</p>
</li>
<li><p>Step 3. 证明问题X可以多项式归约到该问题.</p>
</li>
</ul>
<h4 id="➁题目2-3"><a href="#➁题目2-3" class="headerlink" title="➁题目2"></a>➁题目2</h4><p>(2018)给出一个图和一个整数k，问是否可以在这个图上删除k个点使得剩余图上没有三角形（含有3个顶点的圈）。证明这个问题是NP完全的。  （10分）</p>
<p>答：从点覆盖问题规约过来（2分）。</p>
<p>对于一个点覆盖实例 G，构造一个该问题实例 G’；（1分）<br>对 G 中每一条边 ab，都添加一个新的顶点 c 然后连成三角形 abc。（4分）<br>说明 G 存在大小为 k 的点覆盖当且仅当 G’ 存在一个大小为 k 的解。（3分）</p>
<h4 id="➂题目3-1"><a href="#➂题目3-1" class="headerlink" title="➂题目3"></a>➂题目3</h4><p>(2019)证明独立集问题（给定一个图，问图中是否存在k个顶点的子集，使得这个子集中任意两个顶点之间在原图中都不存在边）是NP完全的。</p>
<p>答：从点覆盖问题规约过来</p>
<p><strong>⇒</strong> </p>
<p>​	S 是图 G 的任一独立集<br>​	则任意边 (u,v)∈E，有u ∉ S 或 v ∉ S；那么 u∈V-S 或 v∈V-S<br>​	所以图的任意边至少有一个端点在集合 V-S 中，集合 V-S 是一个点覆盖</p>
<p><strong>⇐</strong> </p>
<p>​	V-S 是图 G 的任一点覆盖<br>​	则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S ；那么 u ∉ S 或 v ∉ S<br>​	所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集</p>
<p>∴  Vertex-Cover ≡<sub>p</sub> Independent Set，即独立集问题NP完全的</p>
<h4 id="➃题目4-1"><a href="#➃题目4-1" class="headerlink" title="➃题目4"></a>➃题目4</h4><p>最长路径问题：给定简单无向图中是否存在长度大于等于k的简单路径？请证明这个问题是NP完全问题。</p>
<table>
    <tbody>
        <tr>
            <td><input type="text" placeholder="🔔请输入文章查看码，看更多内容"></td>
            <td><button class="btn">Button</button></td>
        </tr>
</tbody></table>


<h2 id="⑧近似算法"><a href="#⑧近似算法" class="headerlink" title="⑧近似算法"></a>⑧近似算法</h2><blockquote>
<p><strong>本章重点：</strong></p>
<ul>
<li>理解为什么会有近似算法，什么是近似算法，如何评价近似算法的优劣。</li>
<li>掌握负载均衡问题的近似算法及其近似比证明。</li>
<li>掌握带权重的顶点覆盖问题的定价算法，证明该方法能得到一个2倍近似解。</li>
<li>理解带权重的顶点覆盖问题的整数规划模型如何建立的，理解松弛求解方法。</li>
<li>能够对一个图问题建立整数规划模型(如：带权重的顶点覆盖问题，广义负载均衡问题)。</li>
<li>理解求解0-1背包问题的基于取整法的近似算法。</li>
<li>能够设计简单的近似算法，并证明该算法是几倍近似算法。</li>
</ul>
</blockquote>
<h3 id="❶基础知识"><a href="#❶基础知识" class="headerlink" title="❶基础知识"></a>❶基础知识</h3><h4 id="➀概念"><a href="#➀概念" class="headerlink" title="➀概念"></a>➀概念</h4><p>近似的想法很简单，要解决一个问题，我们希望能够做到</p>
<ul>
<li>①求解结果是最优的 </li>
<li>②在多项式时间内解决 </li>
<li>③对于任意的实例都能够通过该算法解决。</li>
</ul>
<p>现在对于部分问题，无法完全满足以上要求，所以就牺牲了①，但是我们希望结果不是盲目的，所以就引入了近似的概念。近似算法其实是针对NP难问题的一种退让，对于许多 P 不等于 NP 的最优化问题，无法在多项式时间内找到最优解。因此，如果可以只求一个我们可以接受的解，而不是非要最优解，那么可能存在一个多项式时间的算法。</p>
<h4 id="➁思想"><a href="#➁思想" class="headerlink" title="➁思想"></a>➁思想</h4><p>放弃求解最优解，用近似最优解代替最优解，以此换取：</p>
<ul>
<li>算法设计上的简化</li>
<li>时间复杂性的降低</li>
</ul>
<h4 id="➂性能"><a href="#➂性能" class="headerlink" title="➂性能"></a>➂性能</h4><p>近似算法通常采用两个标准来衡量性能：</p>
<ul>
<li>算法的时间复杂度（必须为多项式级的）</li>
<li>解的近似程度（可能与算法设计、问题规模、输入实例等有关）</li>
</ul>
<h3 id="❷负载均衡问题"><a href="#❷负载均衡问题" class="headerlink" title="❷负载均衡问题"></a>❷负载均衡问题</h3><blockquote>
<p>掌握负载均衡问题的近似算法及其近似比证明</p>
</blockquote>
<p><code>问题描述：</code>有 m 台相同机器，n 个任务，任务 j 的处理时间为 t<sub>j</sub>，每个任务只能在一台机器上连续工作，一台机器同一时间只能处理一个任务。我们认为完成最后一个任务所需的时间为负载时间，希望能够让这个负载时间最短。</p>
<p>机器 i 的负载(机器 i 处理任务的时间之和)：L[i] &#x3D; ∑<sub>j∈S[i]</sub> t<sub>j</sub> ，S[i] 为分配给机器 i 的任务集合<br>最优工期(完成所有工作的最短时间跨度[makespan])：L<sup>∗</sup> &#x3D; max<sub>i</sub>L[i]</p>
<p>优化问题：寻找一个分配方案最优工期<br>决策问题：是否存在一个分配方案使工期为 L<sup>∗</sup></p>
<p><strong>两个引理：</strong></p>
<ul>
<li><strong>引理1：</strong>L<sup>∗</sup> ≥ max(t<sub>j</sub>)（最优工期大于等于完成最长的工作所需时间）</li>
<li><strong>引理2：</strong>L<sup>∗</sup> ≥ (1&#x2F;m)∑<sub>j</sub>t<sub>j</sub> （最优工期大于等于所有任务的平均时间)</li>
</ul>
<p>负载均衡问题是 NPH 问题，因为分割问题 ≤<sub>p</sub> 负载均衡问题</p>
<h4 id="➀2倍近似算法-List-Scheduling"><a href="#➀2倍近似算法-List-Scheduling" class="headerlink" title="➀2倍近似算法-List Scheduling"></a>➀2倍近似算法-List Scheduling</h4><p>List Scheduling 是一种贪心策略，它的核心思想是将各个工作依次安排到累计工作时长最短的机器中，下面的动图显示了这一过程。可以发现，这种贪心的初衷只考虑了眼前的最小值，而局部最优解并不一定是最终的最优解。</p>
<p><img src="https://img.jwt1399.top/img/202111122021025.webp"></p>
<p><code>2倍近似度证明：</code></p>
<p>设机器 i 是瓶颈机器(则 L[i] 为贪心解)，任务 j 是最后一个在机器 i 上调度的任务（在调度前，机器 i 的工期是最小的）我们在考虑放入最后一个任务前，根据我们放置的规则，该机器 i 是所有机器中耗时最短的(L[i] − t<sub>j </sub>≤ L[k])，该机器此时的用时(L[i] - t<sub>j</sub>)是低于除掉最后一个任务 j 后的平均时长(1&#x2F;m)∑<sub>k</sub> L[k]，更低于所有任务的平均时长(1&#x2F;m)∑<sub>j</sub>t<sub>j</sub>(引理2)；再根据引理1，最后一个任务应该是小于最优解的。</p>
<p>L[i] − t<sub>j </sub>≤ L[k]，对任意 1 ≤ k ≤ m</p>
<p>L[i] − t<sub>j</sub> ≤ (1&#x2F;m) ∑<sub>k</sub>L[k] </p>
<p>​				≤ (1&#x2F;m)∑<sub>j</sub>t<sub>j</sub> </p>
<p>​				≤ L<sup>∗</sup> </p>
<p>L<sup>∗</sup>  &#x3D; L[i] &#x3D; (L[i] − t<sub>j</sub>) + t<sub>j</sub> ≤ 2L<sup>∗</sup> </p>
<p>L[i] − t<sub>j</sub> ≤  L<sup>∗</sup> ，t<sub>j</sub> ≤ L<sup>∗</sup> </p>
<p>∴ L[i] ≤ 2L<sup>∗</sup> </p>
<h4 id="➁3-x2F-2倍近似算法-LPT-Rule"><a href="#➁3-x2F-2倍近似算法-LPT-Rule" class="headerlink" title="➁3&#x2F;2倍近似算法-LPT Rule"></a>➁3&#x2F;2倍近似算法-LPT Rule</h4><p>上述贪心策略存在一个很明显的漏洞，当最后加入的工作所花时间最长时，效果很差。因此我们希望先安排长工作，将所有工作<strong>按花费时间降序排列</strong>，再执行上述贪心算法，这就是 Longest Processing Time Rule 的核心思想。</p>
<p><code>3/2倍近似度证明：</code></p>
<p>当 n ≤ m 时，则每台机器最多安排一个工作，容易找到最优解。 当 n ≥ m 时，先将 m 个任务安排到 m 台机器，那么对第 m+1 个工作，有 2t<sub>m+1</sub> ≤ L<sup>∗</sup> （瓶颈机器至少要做两个任务，两个任务的时间总和 ≥ 2t<sub>m+1</sub>）</p>
<p>由上面证明可得：L[i] − t<sub>j</sub> ≤  L<sup>∗</sup> </p>
<p>又∵ 2t<sub>m+1</sub> ≤ L<sup>∗</sup> ⇒ t<sub>j</sub> ≤ (1&#x2F;2)L<sup>∗</sup> </p>
<p>L<sup>∗</sup>  &#x3D; L[i] &#x3D; (L[i] − t<sub>j</sub>) + t<sub>j</sub> ≤ (3&#x2F;2)L<sup>∗</sup> </p>
<p>∴ L[i] ≤ (3&#x2F;2)L<sup>∗</sup> </p>
<p>但其实 2&#x2F;3 倍近似并不是紧密的，Graham 在1969年，计算出 LPT Rule 是负载均衡问题的一个 4&#x2F;3 近似算法。因此 4&#x2F;3 倍近似才是紧密的。</p>
<h3 id="❸带权顶点覆盖问题"><a href="#❸带权顶点覆盖问题" class="headerlink" title="❸带权顶点覆盖问题"></a>❸带权顶点覆盖问题</h3><blockquote>
<p>掌握带权重的顶点覆盖问题的定价算法（Pricing method），证明该方法能得到一个2倍近似解；</p>
<p>理解带权重的顶点覆盖问题的整数线性规划(Integer linear programming)模型如何建立的，理解松弛求解方法；</p>
<p>要求会对一个图问题建立整数线性规划模型（以点覆盖问题为例）</p>
</blockquote>
<p><code>问题描述：</code>对于顶点覆盖问题（一个点的集合使得图中所有边至少有一个端点在集合内），带权点覆盖问题中，需要满足这个集合中所有点的权值之和最小。</p>
<p>如下图左边就是一个带权的最小顶点覆盖</p>
<p><img src="https://img.jwt1399.top/img/202111122306124.png"></p>
<h4 id="➀2倍近似算法-Pricing-method"><a href="#➀2倍近似算法-Pricing-method" class="headerlink" title="➀2倍近似算法-Pricing method"></a>➀2倍近似算法-Pricing method</h4><p>给每条边 e &#x3D; (i,j) 赋予一个价格 p<sub>e</sub> ≥ 0 ，任意顶点 i 的权重大于等于与其邻接的所有边价格总和：∑<sub>e&#x3D;(i,j) </sub>p<sub>e </sub>≤ w<sub>i</sub></p>
<p><strong>公平引理：</strong>对于任意顶点覆盖集合 S 和任意公平价格 p<sub>e</sub> ，有∑<sub>e</sub> p<sub>e </sub>≤ w(S)</p>
<p><img src="https://img.jwt1399.top/img/202111131323355.png"></p>
<p> 算法：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。</p>
<p>定价法求解点覆盖问题，举例如下：</p>
<p><img src="https://img.jwt1399.top/img/202111131334754.png"></p>
<p>上图中，最后 tight 的点 {a, b, d}，即为最小的带权点覆盖，权为 10</p>
<p><code>2倍近似度证明：</code></p>
<p>设 S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）</p>
<p>w(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。</p>
<p><img src="https://img.jwt1399.top/img/202111131352401.png"></p>
<p>∴ 定价算法是2倍近似算法</p>
<h4 id="➁2倍近似算法-ILP"><a href="#➁2倍近似算法-ILP" class="headerlink" title="➁2倍近似算法-ILP"></a>➁2倍近似算法-ILP</h4><p>对每一个点 i ，用 bool 变量 x<sub>i</sub> 表示其是否在点覆盖集合中。</p>
<ul>
<li>x<sub>i</sub>&#x3D;0，表示点 i 不在点覆盖中；</li>
<li>x<sub>i</sub>&#x3D;1，表示点 i 在点覆盖中。</li>
</ul>
<p>因此，整数规划带权点覆盖问题转换为：</p>
<p><img src="https://img.jwt1399.top/img/image-20211126210059636.png"></p>
<p>如果 x<sup>*</sup> 是 ILP 的最优解，那么 S&#x3D; { i∈V｜x<sub>i</sub>*&#x3D;1 }是最小权重顶点覆盖。</p>
<p>点覆盖的整数规划是一个NP难问题，因此我们希望能找到它的近似算法，牺牲准确度以快速求解。很容易想到把它转化为线性规划问题(LP)，并找到它的近似程度。建立如下线性规划，与整数线性规划区别在于第三式。</p>
<p><img src="https://img.jwt1399.top/img/image-20211126211321308.png"></p>
<p>线性规划的约束条件不如整数规划苛刻，所以<strong>线性规划(LP)的最优解 ≤  整数规划(ILP)的最优解</strong>。</p>
<p>但会带来一个问题，加入点覆盖集合中的点 i 其 x<sub>i</sub> 极有可能是分数，会呈现如下形式</p>
<p><img src="https://img.jwt1399.top/img/202112091214071.png"></p>
<p><strong>定理：</strong> 如果 x<sup>*</sup> 是 LP 的最优解，那么点覆盖S&#x3D;{i∈V｜x<sub>i</sub>* ≥ 1&#x2F;2}，且是准确解的2倍近似。</p>
<p><code>2倍近似度证明：</code></p>
<p>对于边 (i,j) ∈ E，点覆盖中有 x<sub>i</sub>* + x<sub>j</sub>*  ≥ 1，则 x<sub>i</sub>* ≥ 1&#x2F;2 或 x<sub>j</sub>* ≥ 1&#x2F;2  ⇒ 边 (i,j) 被覆盖<br>设ILP点覆盖的最优顶点覆盖为 S* ，有</p>
<p>     <img src="https://img.jwt1399.top/img/image-20211126213525333.png"></p>
<p>第一个不等式：根据整数规划的最优解不小于线性规划这一性质放缩；<br>第二个不等式：x<sub>i</sub>* ≥ 1&#x2F;2 </p>
<p>⇒∑<sub>i∈S</sub> W<sub>i</sub> ≤ 2∑<sub>i∈S*</sub> W<sub>i</sub> </p>
<p>∴ 整数规划是2倍近似算法</p>
<h3 id="❹01背包问题"><a href="#❹01背包问题" class="headerlink" title="❹01背包问题"></a>❹01背包问题</h3><p>。。。</p>
<h3 id="❺真题练习-1"><a href="#❺真题练习-1" class="headerlink" title="❺真题练习"></a>❺真题练习</h3><h4 id="➀题目1-4"><a href="#➀题目1-4" class="headerlink" title="➀题目1"></a>➀题目1</h4><p>(2020)给定正整数集合 A &#x3D; {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>} 和正整数 b，b ≥ max {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>}。当集合 A 的子集 S∈A 中的元素之和小于等于 b 时，即 ∑<sub>a<sub>i</sub>∈S[i]</sub> a<sub>i</sub>≤b，我们称 S 为可行集。请寻找元素之和最大的可行集 S 。例如，A &#x3D; {8,2,4}，b&#x3D; 11，则最优的可行集为 S &#x3D; {8,2}，最优解为 8＋2&#x3D;10 (10分)</p>
<p>(1)下面是求解这个问题的算法。集合 S 初始为空集；按照下标 i 从小到大的顺序依次考察集合 A 中的每个整数 a<sub>i</sub>，如果 α<sub>i</sub> + ∑<sub>a<sub>k</sub>∈S</sub> a<sub>k</sub>＜b ，则将 a<sub>i </sub>添加集合 S 中，即 S &#x3D; S U {a<sub>i</sub>}。证明这个算法不是1&#x2F;2倍近似算法。(3分)</p>
<hr>
<p>设集合 A &#x3D; {1，4}，b &#x3D; 4</p>
<p>根据该算法求得可行集 S &#x3D; {1} ，解为 ∑S &#x3D; 1 </p>
<p>​           而最优可行解 S* &#x3D; {4}，最优解 ∑S* &#x3D; 4</p>
<p>⇒ ∑S &#x3D; (1&#x2F;4)∑S* &lt; (1&#x2F;2)∑S*</p>
<p>∴该算法不是1&#x2F;2倍近似算法</p>
<hr>
<p>(2)为该问题设计O(nlogn)时间复杂度的近似算法，并证明该算法是1&#x2F;2倍近似算法(7分)</p>
<hr>
<p>在 (1) 中 所给算法基础上对集合 A 进行降序归并排序[O(nlogn)]</p>
<p>即： a<sub>1</sub>＞a<sub>2</sub>＞a<sub>3</sub>＞…＞a<sub>k</sub>＞a<sub>k+1</sub>＞…＞a<sub>n</sub></p>
<p>证明：设 a<sub>k</sub> 为可行集最后一个元素</p>
<p>a<sub>k </sub>≥ a<sub>k+1 </sub>⇒ ∑S ≥ a<sub>k+1 </sub>   ——①</p>
<p>a<sub>k</sub> 为可行集最后一个元素 ⇒ ∑S ≥ b - a<sub>k+1 </sub>——②</p>
<p>①+② ： ∑S ≥ (1&#x2F;2)b ，再又 b ≥ ∑S*</p>
<p>⇒∑S ≥ (1&#x2F;2)∑S*</p>
<p>∴ 该算法是 1&#x2F;2 倍近似算法</p>
<hr>
<h4 id="➁题目2-4"><a href="#➁题目2-4" class="headerlink" title="➁题目2"></a>➁题目2</h4><p>(2018)叙述带权重的点覆盖问题的竞价法（Pricing method）的步骤。</p>
<p>答：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。</p>
<h4 id="➂题目3-2"><a href="#➂题目3-2" class="headerlink" title="➂题目3"></a>➂题目3</h4><p>(2019)简单证明定价算法（Pricing method）求解带权重的点覆盖（Weighted Vertex Cover）问题是2倍近似的。</p>
<p>答： S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）</p>
<p>w(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。</p>
<p><img src="https://img.jwt1399.top/img/202111131352401.png"></p>
<p>∴ 定价算法是2倍近似算法</p>
<h4 id="➃题目4-2"><a href="#➃题目4-2" class="headerlink" title="➃题目4"></a>➃题目4</h4><p>为最大独立集问题建立一个整数规划模型。    （5分）</p>
<p> 参考答案：<br> 目标函数： max  ∑ x<sub>i</sub>              				（2分）<br> 条件：对每一条边(i,j)，  x<sub>i</sub> + x<sub>j</sub>  ≤ 1         （2分)<br>                对每个顶点i， x<sub>i</sub>  &#x3D; 0,1				（1分)</p>
<h2 id="⑨历年期末真题"><a href="#⑨历年期末真题" class="headerlink" title="⑨历年期末真题"></a>⑨历年期末真题</h2><blockquote>
<p>题目来源于课堂，由小简拍下来，手工整理，因此或多或少存在一些错误，望谅解！</p>
</blockquote>
<h3 id="❶选择题"><a href="#❶选择题" class="headerlink" title="❶选择题"></a>❶选择题</h3><h4 id="样题"><a href="#样题" class="headerlink" title="样题"></a>样题</h4><p>一、判断下列陈述的对错（共20分，共 10题，每题2分）</p>
<ol>
<li>一个计算问题的输入是n个数字a<sub>1</sub>，a<sub>2</sub>，…，a<sub>n</sub>。如果这个问题存在一个运行时间为O(a<sub>n</sub>n<sup>10</sup>)的算法，则这个问题可以在多项时间内被计算机求解。 <code>(F)</code></li>
<li>如果存在一个从问题A到问题B的多项式时间归约（Polynomial reduction），且问题A是NP难的，则可知问题B也是NP难的。 <code>(T)</code></li>
<li>一个2倍的近似算法一定会有在一个问题上得到正好是最优解的两倍的解。<code>(F)</code>                                                     </li>
<li>如果存在一个NP问题有多项式时间算法，则P&#x3D;NP。<code>(F)</code></li>
<li>一个图上的最大网络流是唯一的。 <code>(F)</code></li>
<li>当图中的顶点个数是常数时，最大独立集问题（Maximum Independent Set Problem）是多项式时间可解的.  <code>(T)</code></li>
<li>这里有两个解决排序问题的分而治之算法：算法A递归将需要排列的数字均分成2份，分别排序后再合并。算法B递归将需要排列的数字均分成3份，分别排序后再合并。从渐进分析的角度来看，算法B比算法A要快。<code>(F)</code></li>
<li>在并行计算中，一个计算问题能在CREW PRAM模型下O(n)处理器O(n<sup>3</sup>)时间被解决，则也可以在EREW PRAM模型下O(n)处理器O(n<sup>3</sup>)时间被解决.<code>(T)</code></li>
<li>对于任意一个动态规划算法，其使用的空间一定不比它使用的时间要大。<code>(T)</code></li>
<li>求一个图中两个点间最长路径的问题是属于NP的，但是求一个图中两个点间最短路径的问题则不是属于NP的。<code>(F)</code></li>
</ol>
<h4 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h4><p>一、判断下列陈述的对错（共30分，共 15题，每题2分）</p>
<ol>
<li>任何一个NP问题能被多项式时间算法解决则所有NP问题都能在多项式时间内被解决。<code>（F）</code></li>
<li>可以用如下方法来证明某结论X成立：先假设X不成立，在此假设基础上推导出X成立，则可以证明X成立。<code>（T）</code>                      </li>
<li>一个2倍近似算法得到的解总比一个4倍近似算法得到的解更好。<code>（F）</code></li>
<li>问一个图是否存在一个大小为k的点覆盖，很容易证明该问题是属于NP的；但是，问一个图是否不存在一个大小为k的点覆盖，却是很难证明这个问题是否属于NP。 <code>(T)</code></li>
<li>一个问题A可以多项式时间规约到一个NP完全问题B，那么问题A可能属于P也可能属于NP完全。<code>(T)</code>                                    </li>
<li>一个3倍近似算法如果对任何问题实例找到的解都在最优解的1.5倍以内，则这不是一个3倍近似率的算法。<code>（F）</code>                        </li>
<li>对某个问题以前最好的算法运行时间为O(n<sup>3</sup>)，新给出的算法运行时间为O(n<sup>2</sup>)。那么在该问题上运行时间改进了O(n)。<code>(F)</code></li>
<li>对于判断一个整数w是不是素数的问题，一个运行时间为O(w<sup>2</sup>)的算法是多项式时间算法，而一个运行时间为O(2<sup>w</sup>)的算法是指数时间算法。<code>(F)</code>	</li>
<li>证明一个算法不是2倍近似算法只需要构造一个例子使得在该例子上返回的解超过2倍最优解即可。<code>(T)</code>                                     </li>
<li>如果一个图上两点间的最大流是唯一的，则可以确定这两点间的最小割也唯一。 <code>(F)</code>                                                     </li>
<li>证明把问题A规约到了问题B，只需要证明对于任意问题A的实例 I 都可以构造一个问题B的实例 I’ 使得实例 I’ 的任意解可以构造出实例 I 的一个解。<code>（F）</code></li>
<li>动态规划算法有可能是多项式时间的也有可能是指数时间的。<code>（T）</code></li>
<li>一个二分图如果包含奇数个顶点，则这个图一定不存在一个哈密尔顿圈。<code>（T）</code></li>
<li>不属于NP中的问题一定不存在多项式时间算法。<code>（F）</code></li>
<li>对于每秒可以处理100万条基本指令的计算机，一个运行时间为 1.5<sup>n</sup> 的算法在 n&#x3D;100 的例子上可以1年内计算完。<code>(F)</code></li>
</ol>
<h4 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h4><p>一、判断下列陈述的对错（共20分，共 10题，每题2分）</p>
<ol>
<li>在背包问题中，如果规定所有输入的数值(包括背包的大小和各个物品的价值和体积)都是长整型数据，则动态规划算法可以在多项式内求解。<code>(T)</code></li>
<li>NP问题是目前没有找到多项式时间求解算法的判定问题集合。<code>(F)</code><ul>
<li>NP问题是所有可用多项式时间算法验证其猜测准确性的问题的集合。</li>
</ul>
</li>
<li>线性规划问题可以多项式求解，但是整数规划问题是NP-hard问题。<code>(T)</code><ul>
<li>整数规划是NPC，NPC ⊆ NP-hard</li>
</ul>
</li>
<li>找出一个图的哈密尔顿圈和判定该图是否存在哈密尔顿圈，这两个问题在不考虑多项式时间的差异基础上计算难度是相当的。<code>(T)</code></li>
<li>一个网络的最大流的值一定不大于任意一个割集的容量。<code>(T)</code><ul>
<li>网络的最大流应等于最小割集容量。</li>
</ul>
</li>
<li>如果我们不能在一个流网络中找到一条从S到T的路径，使得路径上所有边的流量都小于该边的容量，则我们得到了该网络上S到T的最大流。<code>(F)</code></li>
<li>证明一个算法不能达到2倍近似解只需要找到一个例子在该例子上得到的解要差于2倍最优解即可。反之，无论给出多少个例子在这些例子上都能得到优于2倍最优解的解也不能说明这个算法拥有2倍近似率。<code>(T)</code></li>
<li>如果一个问题A存在多项式算法可以推导出所有NP里的问题都存在多项式算法，那么可知问题A是NP完全的<code>(T)</code></li>
<li>问一个数是不是个合数，很容易证明该问题是属于NP的:但是问一个数是不是素数，这个问题却是很难证明是否属于NP的。<code>(F)</code><ul>
<li>都是 NP</li>
</ul>
</li>
<li>因为判断一个图是否存在哈密尔顿圈问题是属于NP的，所以判断一个图是否不存在哈密尔顿圈问题也是属于NP的。<code>(F)</code><ul>
<li>不存在是 Co-NP</li>
</ul>
</li>
</ol>
<h4 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h4><p>一、命题正确填T，命题错误填F（2分题x10题&#x3D;20分）</p>
<ol>
<li>如果f(n) &#x3D; O(g(n))，则有log<sub>2</sub>f(n) &#x3D; O(log<sub>2</sub>g(n))。<code>(T)</code></li>
<li>一个P类问题可以多项式时间归约到任意一个NP完全问题。<code>(T)</code></li>
<li>斐波那契数列定义f(1)&#x3D;f(2)&#x3D;1，当n≥3时，f(n)&#x3D;f(n-1)+f(n-2)。求解该数列第n个数f(n)的自顶向下的分治递归算法是指数时间算法，求解该数列第n个数f(n)的自底向上的动态规划算法也是指数时间算法。<code>(T)</code><ul>
<li>考虑输入规模</li>
</ul>
</li>
<li>给定边上容量均为正整数的流网络，网络流 f 的 ∆ 剩余网络 G<sub>f</sub>(∆) 中不存在从源点 s 到终点 t 的有向路径，如果 ∆ &#x3D; 1 则 f 是该网络的最大流。<code>(T)</code></li>
<li>给定求解负载均衡问题的 2 倍近似算法 A 和 3&#x2F;2 倍近似算法 B，对于该问题的任意实例，算法 B 得到的近似解都比算法 A 得到的近似解更接近最优解。<code>(F)</code></li>
<li>给定带权重的顶点覆盖问题，利用整数规划模型求得的顶点覆盖的最小权重之和为 x ，利用松驰化的线性规划模型求得的顶点覆盖的最小权重之和为 y，则总有x≤y。<code>(F)</code></li>
<li>判断给定简单无向图中是否不存在哈密尔顿圈是 NP 完全问题。<code>(F)</code><ul>
<li>co-NP</li>
</ul>
</li>
<li>给定两个判定问题 A 和 B ，如果 A ≤<sub>p</sub> B，B ≤<sub>p</sub> A，并且 A ∈ NPC，那么 B ∈ NPC。<code>(F)</code><ul>
<li>A 是否是 NP</li>
</ul>
</li>
<li>如果判断问题 A 存在多项式时间的求解算法，那么问题 A 是 P 问題，不是NP问题。<code>(F)</code><ul>
<li>是 P 肯定是 NP</li>
</ul>
</li>
<li>给定两个判定问题 A 和 B，A ≤<sub>p</sub> B 的意思是说，可以通过多项式次的调用求解问题 B 的方法来求解问题 A，也就是说，如果问题 B 可以多项式时间求解，则问题 A 可以多项式时间求解。<code>(T)</code></li>
</ol>
<h3 id="❷计算题-amp-简单题"><a href="#❷计算题-amp-简单题" class="headerlink" title="❷计算题&amp;简单题"></a>❷计算题&amp;简单题</h3><h4 id="样题-1"><a href="#样题-1" class="headerlink" title="样题"></a>样题</h4><p>二、计算题（共9分，共3题，每题3分）</p>
<ol>
<li><p>求如下有向图中的一个最长路径，要求给出路径和路径长度的值。</p>
<p><img src="https://img.jwt1399.top/img/image-20211124232947658.png"></p>
</li>
</ol>
<p>​			参考答案： CADB，长度：40+30+35&#x3D;105</p>
<hr>
<ol start="2">
<li>如下可满足问题（SAT）是否有解，若有解该如何给变量赋值：<img src="https://img.jwt1399.top/img/image-20211124232912948.png">参考答案：x1&#x3D;1,x2&#x3D;1,x3&#x3D;0或者x1&#x3D;0,x2&#x3D;0,x3&#x3D;0，答案正确即可给分。（说明：本题存在多种解，如x3&#x3D;1, x1和x2中有一个0，这种情况还是有解。只要任给出一种解就给分)</li>
</ol>
<hr>
<ol start="3">
<li><p>有一些区间段 (0,3), (2,4), (3,6), (5,7), (1,4), (3,5), (6,8),(7,9)，找出其中个数最多的一组相容的区间段（两个区间相容当且仅当两个区间的交集为空)。</p>
<p>参考答案：（0,3），（3,5），（5,7），（7,9）</p>
</li>
</ol>
<hr>
<h4 id="2018-1"><a href="#2018-1" class="headerlink" title="2018"></a>2018</h4><p>二、计算题和简答题，计算题可以只写答案不写过程（共16分，共4题，每题4分）</p>
<ol>
<li><p>一个数的序列中排在前面的数比排在后面的数要大的话则称为一对逆序。问下面这个序列中存在多少对逆序：5，10，7，9，13，1，8，4，12，2，6，3，11，14。（4分）</p>
<p>答：4+8+5+6+8+0+4+2+4+0+1+0+0&#x3D;42</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p>负载均衡（Load Balancing）问题要求将一些工作放到一些机械上进行处理，每个工作有一个固定的需要处理的时间。算法的思想如下：将任务按任意一个次序进行排序，再依次将任务分配到负载最轻的机器上。简单证明该算法是2倍近似的。（4分）</p>
<p>答：设机器 i 是瓶颈机器(则 L[i] 为贪心解)，任务 j 是最后一个在机器 i 上调度的任务（在调度前，机器 i 的工期是最小的）我们在考虑放入最后一个任务前，根据我们放置的规则，该机器 i 是所有机器中耗时最短的(L[i] − t<sub>j </sub>≤ L[k])，该机器此时的用时(L[i] - t<sub>j</sub>)是低于除掉最后一个任务 j 后的平均时长(1&#x2F;m)∑<sub>k</sub>L[k]，更低于所有任务的平均时长(1&#x2F;m)∑<sub>j</sub>t<sub>j</sub>(引理2)；再根据引理1，最后一个任务应该是小于最优解的。</p>
<p>L[i] − t<sub>j </sub>≤ L[k]，对任意 1 ≤ k ≤ m</p>
<p>L[i] − t<sub>j</sub> ≤ (1&#x2F;m) ∑<sub>k</sub>L[k] ≤ (1&#x2F;m)∑<sub>j</sub>t<sub>j</sub> ≤ L<sup>∗</sup> </p>
<p>L[i] &#x3D; (L[i] − t<sub>j</sub>) + t<sub>j</sub> </p>
<p>L[i] − t<sub>j</sub> ≤  L<sup>∗</sup> ，t<sub>j</sub> ≤ L<sup>∗</sup> </p>
<p>∴ L[i] ≤ 2L<sup>∗</sup></p>
</li>
</ol>
<hr>
<ol start="3">
<li><p>叙述带权重的点覆盖问题的竞价法（Pricing method）的步骤。（4分）</p>
<p>答：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。</p>
</li>
</ol>
<hr>
<ol start="4">
<li><p>在一个无向图中给出两个顶点对（s1，t1）和（s2，t2），需要求出同时从 s1 流向 t1 的流加上从 s2 流向 t2 的流的和达到最大。有一个算法是：添加一个新的顶点 s 仅连接 s1 和 s2 ，边的容量无穷大；再添加一个新的顶点 t 仅连接 t1 和 t2 ，边的容量无穷大；然后求 s 到 t 的最大流。请分析这个算法的正确性（认为它是错的就给出理由，认为它是对的则也给出说明并分析其时间复杂性）。（4分）</p>
<p>答：错误。（2分）</p>
<p>因为这样做将会包含从 s1 到 t2 的流和从 s2 到 t1 的流。（2分）</p>
</li>
</ol>
<hr>
<h4 id="2019-1"><a href="#2019-1" class="headerlink" title="2019"></a>2019</h4><p>(2019)计算题和简答题，计算题可以只写答案不写过程(共24分，共6题，每题4分)</p>
<ol>
<li><p>证明一个有奇数个顶点的二分图一定不存在哈密尔顿圈。(4分)</p>
<blockquote>
<p>设G&#x3D;(V,E)是无向图，如果 V 可以划分为子集 X 和 Y，使得对所有的e&#x3D;(u,v)∈E, 都有 u 和 v 分属于 X 和 Y，则称 G 是二分图，下图便是一个二分图。</p>
<p><img src="https://img.jwt1399.top/img/202112072047766.png"></p>
</blockquote>
<p>（数学归纳法）</p>
<p>当n &#x3D; 3个顶点时候，明显不存在哈密尔顿圈</p>
<p>假设当 n &#x3D; k ，k为奇数时，不存在哈密尔顿圈</p>
<p>当n &#x3D; k + 2 时，假设存在哈密尔顿圈</p>
<p>由于是二分图，圈中相邻顶点属于不同子集，假设ABCD是圈中四个相邻的顶点，则AC在二分图的一个子集 X 中，BD 在子集 Y 中，那么 AD 有边相连，取掉BC两点，链接AD，仍然存在哈密尔顿圈，而剩下点仍然是二分图，与假设矛盾，因此一个有奇数个顶点的二分图一定不存在哈密尔顿圈</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p>在一个图中给出 x 对顶点 (s<sub>1</sub>,t<sub>1</sub>)，(s<sub>2</sub>,t<sub>2</sub>)，…，(s<sub>x</sub>,t<sub>x</sub>) 求 (s<sub>i</sub>,t<sub>i</sub>) 这 x 对顶点之间同时能达到的最大流(s<sub>i </sub>只能流向 t<sub>i</sub>)。分析如下算法的正确性：添加一个顶点 s 连接所有 s<sub>i </sub>，且 s 到 s<sub>i</sub> 的容量无穷大；添加另一个顶点 t 连接所有 t<sub>i</sub>，且 t 到 t<sub>i</sub> 的容量无穷大；则只需求 s 到 t 之间的最大流。(4分)</p>
<p>答：正确</p>
</li>
</ol>
<hr>
<ol start="3">
<li><p>如下可满足问题(SAT)存在几组使得其值为真的赋值？给出具体的赋值方案。(4分)</p>
<p><img src="https://img.jwt1399.top/img/image-20211202215006674.png"></p>
<p>答：x1&#x3D;1，x2&#x3D;1，x3&#x3D;0，x4&#x3D;0</p>
</li>
</ol>
<hr>
<ol start="4">
<li>求如下有向图中一条从 A 到 D 的最长路径。要求给出路经和路经长度的值。(4分)</li>
</ol>
<p><img src="https://img.jwt1399.top/img/image-20211202214527833.png"></p>
<p>​				参考答案： CADB，长度：45+40+35&#x3D;120		</p>
<hr>
<ol start="5">
<li><p>给出如下一个带权重的图，图中每个顶点上的数字为该项点的权重，找出图中一个独立集(一组顶点之间没有任何边称为一个独立集)使得该独立集中顶点的权重之和达到最大。(4分)</p>
<p><img src="https://img.jwt1399.top/img/image-20211202212817151.png"></p>
<p>答：3 + 2 + 2 + 7 &#x3D; 14</p>
<p><img src="https://img.jwt1399.top/img/image-20211206221643616.png"></p>
</li>
</ol>
<hr>
<ol start="6">
<li><p>求解下面两个递归关系式(4分)</p>
<p>(1)f(n) &#x3D; 9f(n&#x2F;3) + O(n<sup>2</sup>)</p>
<p>答：利用主定理求解</p>
<p>a &#x3D; 9，b &#x3D; 3，f(n) &#x3D; n<sup>2</sup>，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>3</sub>9</sup> &#x3D; n<sup>2</sup> &#x3D; f(n)</p>
<p>所以T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn) &#x3D; Θ(n<sup>2</sup>logn)</p>
<p>(2)f(n) &#x3D; 3f(n-3) + O(1)</p>
<p>答：利用直接展开法求解</p>
<p>详细解题步骤请参考前面<a href="#toc-heading-35">分治算法-真题练习-题目一-第2问</a>，这里不再赘述。</p>
</li>
</ol>
<hr>
<h4 id="2020-1"><a href="#2020-1" class="headerlink" title="2020"></a>2020</h4><p>(2020)简答和计算题，无需计算过程，直接给出答案即可(5分题 x 6题 &#x3D; 30分)</p>
<ol>
<li><p>如果  P ≠ NP 时，请给出 P，NP，NPC 这3个集合两两之间的关系。</p>
<p>答：如果  P ≠ NP 时，P ⊆ NP，NPC ⊆ NP，P ≠ NPC</p>
</li>
</ol>
<hr>
<ol start="2">
<li><p>请用下图右侧所示的4种不同形状的L型骨牌，覆盖下图左侧给定棋盘上除阴影方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖，4种L型骨牌数量均不设限制。</p>
<p><img src="https://img.jwt1399.top/img/image-20211202205116026.png"></p>
</li>
</ol>
<p>​			答：</p>
<p><img src="https://img.jwt1399.top/img/D3BE67A2-F262-4E2E-8DC0-81053DBB99CB.jpg"></p>
<hr>
<ol start="3">
<li><p>给定整数序列{a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>}，如果 i &lt; j 但是 a<sub>i </sub>&gt; a<sub>j</sub>逆序。则(a<sub>i</sub>, a<sub>j</sub>)称为一对逆序，请计算整数序列{32,15,48,17,21,24,57,12,36}中有多少对逆序。</p>
<p>答：5+1+5+1+1+1+2+0+0&#x3D;16</p>
</li>
</ol>
<hr>
<ol start="4">
<li><p>给出下列2个递归关系式的渐近界。<br>(1)T(n) &#x3D; 4T(n&#x2F;2) + n<sup>1.9</sup>(logn)<sup>5</sup></p>
<p>答：a &#x3D; 4，b &#x3D; 2 ，f(n) &#x3D; n<sup>1.9</sup>(logn)<sup>5</sup>，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>2</sub>4</sup> &#x3D; n<sup>2</sup> &gt; f(n)</p>
<p>因此 T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>) &#x3D; Θ(n<sup>2</sup>)</p>
<p>(2)T(n) &#x3D; T(2n&#x2F;3) + 1</p>
<p>答：a &#x3D;1，b &#x3D; 3&#x2F;2 ，f(n) &#x3D; 1，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>0</sup> &#x3D; 1 &#x3D; f(n)</p>
<p>所以T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn) &#x3D; Θ(logn)</p>
</li>
</ol>
<hr>
<ol start="5">
<li><p>给定整数序列(23，4，-2，30，- 63，47，26，-53，58，97，-93，-23，84，-15，6),求这个序列的最大连续子序列之和，并给出相应的子序列。例如序列(-20，11，-4，13，-5，-2)的最大连续子序列之和为 20 &#x3D; sum(11, 4,13)。</p>
<p>答：175 &#x3D; sum(47,26,-53,58,97)</p>
</li>
</ol>
<hr>
<ol start="6">
<li><p>将下列6个函数按渐近增长率由低至高进行排序。<br>f<sub>1</sub>(n) &#x3D; log<sup>100</sup>n + logn<sup>100</sup>，f<sub>2</sub>(n) &#x3D; 2019n<sup>3</sup> +3<sup>n</sup>，f<sub>3</sub>(n) &#x3D; 2<sup>nlogn</sup> +log<sup>n</sup>n</p>
<p>f<sub>4</sub>(n) &#x3D; 2019√n<sup>2019</sup> ，f<sub>5</sub>(n) &#x3D; n! + 100n<sup>n</sup> + n<sup>100</sup>，f<sub>6</sub>(n) &#x3D; log(3<sup>n</sup>logn)</p>
<p>答：</p>
<p>f<sub>1</sub>(n) &#x3D; log<sup>100</sup>n + 100logn &#x3D; Θ(log<sup>100</sup>n)，f<sub>2</sub>(n) &#x3D; 2019n<sup>3</sup> +3<sup>n</sup>&#x3D; Θ(3<sup>n</sup>)</p>
<p>f<sub>3</sub>(n) &#x3D; n<sup>n</sup> +log<sup>n</sup>n &#x3D; Θ(n<sup>n</sup>)，f<sub>4</sub>(n) &#x3D; Θ(n<sup>1009.5</sup>)</p>
<p>f<sub>5</sub>(n) &#x3D;  Θ(n<sup>n</sup>)，f<sub>6</sub>(n) &#x3D;nlog3 + loglogn &#x3D; Θ(n)</p>
<p>显然 f<sub>6</sub>(n) ＜f<sub>4</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>3</sub>(n) &#x3D; f<sub>5</sub>(n) </p>
<p>f<sub>1</sub>(n) ，f<sub>6</sub>(n)同时取对数 ，因此 f<sub>1</sub>(n)＜ f<sub>6</sub>(n)</p>
<p>综上所述：f<sub>1</sub>(n)＜ f<sub>6</sub>(n)＜ f<sub>4</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>3</sub>(n) &#x3D; f<sub>5</sub>(n)</p>
</li>
</ol>
<hr>
<h3 id="❸解答题"><a href="#❸解答题" class="headerlink" title="❸解答题"></a>❸解答题</h3><blockquote>
<p>辅以每个章节的真题练习部分食用，效果更佳，又狂肝了一波，睡觉睡觉，狗命要紧。。。</p>
</blockquote>
<h4 id="2018-2"><a href="#2018-2" class="headerlink" title="2018"></a>2018</h4><p>三、将下列6个函数按渐近增长率由低至高进行排序，要求写出判断依据（8分）</p>
<p><img src="https://img.jwt1399.top/img/202112071844753.png"></p>
<p>f<sub>1</sub>(n) &#x3D; √n + log<sup>100</sup>n &#x3D; O(√n)</p>
<p>f<sub>2</sub>(n) &#x3D; 2<sup>logn</sup> * 2<sup>loglogn</sup> &#x3D; nlogn</p>
<p>f<sub>3</sub>(n) &#x3D; 100logn + nlog3 &#x3D; O(n)</p>
<p>f<sub>4</sub>(n) &#x3D; O(3<sup>n</sup>)、f<sub>5</sub>(n) &#x3D; 100log<sup>2</sup>n、f<sub>6</sub>(n) &#x3D;  O(n!)</p>
<p>(1)显然 f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) </p>
<p>(2)f<sub>5</sub>(n) 是对数的幂，f<sub>1</sub>(n) 是幂函数，因此 f<sub>5</sub>(n)＜ f<sub>1</sub>(n)</p>
<p>综上所述： f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)＜ f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) </p>
<hr>
<p>四、求如下有向图中s和t间的最小割，其中边上的数字表示边的容量。要求给出最少两个中间计算步骤（8分）。</p>
<p><img src="https://img.jwt1399.top//img/20211016201310.png"></p>
<p>将最小割问题转化为最大流问题</p>
<p>1增广路径：(<em>s</em>, <em>u</em>, <em>t</em>)，流量值+5</p>
<p>2增广路径：(<em>s</em>, <em>x</em>, <em>t</em>)，流量值+5</p>
<p>3增广路径：(<em>s</em>, <em>v</em>, <em>w</em>, <em>t</em>)，流量值+8</p>
<p>4增广路径：(<em>s</em>, <em>u</em>, <em>w</em>, <em>v</em>, <em>x</em>, <em>t</em>)，流量值+3</p>
<p><img src="https://img.jwt1399.top//img/20211016201317.png"></p>
<p>最小割为**[ {<em>s</em>, <em>u</em>}，{<em>w</em>, <em>v</em>, <em>x</em>, <em>t</em>} ]** 容量为 <strong>21</strong></p>
<hr>
<p>五、对某个输入大小为n的问题有如下三个分而治之算法：</p>
<p>（1）算法1将该问题分成5个子问题，子问题大小为n&#x2F;5，将子问题的解合并得到上一级问题的解需要O(n<sup>2</sup>)时间；<br>（2）算法2将该问题分成4个子问题，子问题大小为n&#x2F;2，将子问题的解合并得到上一级问题的解需要O(n)时间；<br>（3）算法3将该问题分成2个子问题，第一个子问题大小为n&#x2F;3，第二个子问题大小为2n&#x2F;3，将子问题的解合并得到上一级问题的解需要O(n)时间。<br>请分析以上3个算法的运行时间。（6分）</p>
<p>答：</p>
<p>(1) T(n) &#x3D; 5T(n&#x2F;5) + n<sup>2</sup></p>
<p>a &#x3D; 5，b &#x3D; 5 ，f(n) &#x3D;  n<sup>2</sup>，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>5</sub>5</sup> &#x3D; n &lt; f(n)</p>
<p>再判断是否满足不等式：af(n&#x2F;b) ≤ cf(n)，代入f(n) &#x3D; n<sup>2</sup></p>
<p>n<sup>2</sup>&#x2F;5和cn<sup>2</sup>，当 c ≥ 1&#x2F;5 即可满足 af(n&#x2F;b) ≤ cf(n) 的关系</p>
<p>因此 <strong>T(n) &#x3D; Θ(f(n)) &#x3D; Θ(n<sup>2</sup>)</strong></p>
<p>(2) T(n) &#x3D; 4T(n&#x2F;2) + n</p>
<p>a &#x3D; 4，b &#x3D; 2 ，f(n) &#x3D;  n，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>2</sub>4</sup> &#x3D; n<sup>2</sup> &gt; f(n)</p>
<p>存在 f(n) &#x3D; O(n<sup>log<sub>b</sub>a-ε</sup>) &#x3D; O(n<sup>log<sub>2</sub>4-2</sup>)，ε &#x3D; 2</p>
<p>因此 <strong>T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>) &#x3D; Θ(n<sup>2</sup>)</strong></p>
<p>(3) T(n) &#x3D; T(n&#x2F;3) + T(2n&#x2F;3) + n</p>
<p>T(n) &#x3D; 3T(n&#x2F;3)  + n</p>
<p>a &#x3D; 3，b &#x3D; 3 ，f(n) &#x3D;  n，n<sup>log<sub>b</sub>a</sup> &#x3D; n<sup>log<sub>3</sub>3</sup> &#x3D; n &#x3D; f(n)</p>
<p>因此 <strong>T(n) &#x3D; Θ(n<sup>log<sub>b</sub>a</sup>logn) &#x3D; Θ(nlogn)</strong></p>
<hr>
<p>六、对于三着色问题（对一个图的顶点进行三种颜色着色使得相邻两个点的颜色不一样），若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。 （8分）               </p>
<p>答：</p>
<p>解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。 </p>
<p>解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。</p>
<hr>
<p> 七、给出一个图和一个整数k，问是否可以在这个图上删除k个点使得剩余图上没有三角形（含有3个顶点的圈）。证明这个问题是NP完全的。 （10分）</p>
<p>答：从点覆盖问题规约过来（2分）。</p>
<p>对于一个点覆盖实例 G，构造一个该问题实例 G’；（1分）<br>对 G 中每一条边 ab，都添加一个新的顶点 c 然后连成三角形 abc。（4分）<br>说明 G 存在大小为 k 的点覆盖当且仅当 G’ 存在一个大小为 k 的解。（3分）</p>
<hr>
<p><img src="https://img.jwt1399.top/img/202112081252104.png"></p>
<p>（1）令计算**A<sub>1</sub> x A<sub>2</sub> x A<sub>3</sub> x … x A<sub>n</sub>*<em>所需要的最少乘法次数为</em>m*[<em>i</em>, <em>j</em>] </p>
<p>​			则递归关系式为<img src="https://img.jwt1399.top//img/20211011201529.png">  </p>
<p> （2）</p>
<table>
<thead>
<tr>
<th>m(<em>i</em>, <em>j</em>)</th>
<th><em>j</em> &#x3D; 1</th>
<th><em>j</em> &#x3D; 2</th>
<th><em>j</em> &#x3D; 3</th>
<th><em>j</em> &#x3D; 4</th>
<th><em>j</em> &#x3D; 5</th>
</tr>
</thead>
<tbody><tr>
<td><em>i</em> &#x3D; 1</td>
<td>0</td>
<td>1440</td>
<td>3360</td>
<td>4000</td>
<td><code>5856</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 2</td>
<td>&#x2F;</td>
<td>0</td>
<td>2400</td>
<td>2800</td>
<td>4800</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 3</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
<td>1600</td>
<td>2880</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 4</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
<td>3200</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 5</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>0</td>
</tr>
</tbody></table>
<p> 将对应<code>m(i,j)</code>的断开位置<code>k</code>记为<code>s(i,j)</code></p>
<table>
<thead>
<tr>
<th><em>s</em>(<em>i</em>, <em>j</em>)</th>
<th><em>j</em> &#x3D; 1</th>
<th><em>j</em> &#x3D; 2</th>
<th><em>j</em> &#x3D; 3</th>
<th><em>j</em> &#x3D; 4</th>
<th><em>j</em> &#x3D; 5</th>
</tr>
</thead>
<tbody><tr>
<td><em>i</em> &#x3D; 1</td>
<td>&#x2F;</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td><code>2</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 2</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 3</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>3</td>
<td><code>4</code></td>
</tr>
<tr>
<td><em>i</em> &#x3D; 4</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>4</td>
</tr>
<tr>
<td><em>i</em> &#x3D; 5</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<p> s(1,5) &#x3D; 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>)(A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>)</strong></p>
<p>s(3,5) &#x3D; 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 <strong>(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)</strong></p>
<p>最优加括号方式为**(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)**</p>
<hr>
<h4 id="2019-2"><a href="#2019-2" class="headerlink" title="2019"></a>2019</h4><p>四、简单证明定价算法（Pricing method）求解带权重的点覆盖（Weighted Vertex Cover）问题是2倍近似的。</p>
<p>答： S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）</p>
<p>w(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。</p>
<p><img src="https://img.jwt1399.top/img/202111131352401.png"></p>
<p>∴ 定价算法是2倍近似算法</p>
<hr>
<p>五、证明独立集问题（给定一个图，问图中是否存在k个顶点的子集，使得这个子集中任意两个顶点之间在原图中都不存在边）是NP完全的。</p>
<p>答：从点覆盖问题规约过来</p>
<p><strong>⇒</strong> </p>
<p>​	S 是图 G 的任一独立集<br>​	则任意边 (u,v) ∈ E，有u ∉ S 或 v ∉ S 或 u,v 都 ∉ S；那么 u∈V-S 或 v∈V-S 或 u,v 都 ∈ S<br>​	所以图的任意边 (u,v) 至少有一个顶点在集合 V-S 中，即集合 V-S 是一个顶点覆盖</p>
<p><strong>⇐</strong> </p>
<p>​	V-S 是图 G 的任一顶点覆盖<br>​	则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S 或 u,v 都 ∈ V-S ；那么 u ∉ S 或 v ∉ S 或 u,v 都 ∉ V-S<br>​	所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集</p>
<p>∴  Vertex-Cover ≤<sub>p</sub> Independent Set，即独立集问题NP完全的</p>
<hr>
<p>六、求如下有向图中s和t间的最小割，其中边上的数字表示边的容量，要求给出最少两个中间计算步骤(8分)。</p>
<p><img src="https://img.jwt1399.top/img/202112071837771.png"></p>
<p>将最小割问题转化为最大流问题</p>
<p>1增广路径：(<em>s</em>, <em>u</em>, <em>v</em>, <em>t</em>)，流量值+10</p>
<p>2增广路径：(<em>s</em>, <em>y</em>, <em>z</em>, <em>t</em>)，流量值+10</p>
<p>3增广路径：(<em>s</em>, <em>w</em>, <em>x</em>, t)，流量值+18</p>
<p>4增广路径：(<em>s</em>, <em>y</em>, <em>x</em>, <em>w</em>, <em>v</em>, <em>t</em>)，流量值+4</p>
<p>最小割为**[ {<em>s</em>,<em>y</em>,<em>z</em>}，{<em>w</em>,<em>x</em>,<em>u</em>,<em>v</em>,<em>t</em>} ]** 容量为 <strong>10+10+18+4&#x3D;42</strong></p>
<hr>
<p>七、证明图二着色问题（是否能给一个图的顶点进行两种颜色着色使得任意两个相邻顶点都有不同的颜色）是属于P的。(8分)</p>
<p>如果只用2种颜色，那么确定一个顶点的颜色之后，和它相邻的顶点的颜色也就确定了。因此，选择任意一个顶点出发，依次确定相邻顶点的颜色，就可以判断是否可以被2种颜色着色了。这个问题如果用深度优先搜索的话，能够简单地实现。</p>
<hr>
<p><img src="https://img.jwt1399.top//img/20211013180909.png"></p>
<p>设 <code>p(j)</code> 为与工作 j 相容的最大的工作 i 且 i &lt; j 。<code>OPT(j)</code>表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。则递归关系式为：</p>
<p><img src="https://img.jwt1399.top//img/20211013181235.png"></p>
<p>依据递推公式，计算出  <code>p(j)</code>、<code>OPT(j)</code></p>
<p><img src="https://img.jwt1399.top//img/20211013181844.png"></p>
<p>因为 OPT(17) &#x3D; 50 ，因此<strong>最大权重之和为 50</strong></p>
<p>OPT(17) &#x3D; OPT(16) &#x3D; OPT(15) &#x3D; 50 ，选择活动 15，p(15) &#x3D;13；</p>
<p>OPT(13) &#x3D; OPT(12) &#x3D; 45 ，选择活动 12，p(12) &#x3D; 7；</p>
<p>OPT(7) &#x3D; OPT(6) &#x3D; 25 ，选择活动 6，p(6) &#x3D; 3；</p>
<p>OPT(3) &#x3D; 18 ，p(3) &#x3D; 0，选择活动 3，且选择完毕。</p>
<p>因此<strong>最优活动子集为 3、6、12、15</strong></p>
<hr>
<p>九、对于三着色问题，若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。</p>
<p>解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。  </p>
<p>解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。</p>
<hr>
<h4 id="2020-2"><a href="#2020-2" class="headerlink" title="2020"></a>2020</h4><p>三、给定任意连通的无向有权图G，每条边上的权重c(e)都是不同的整数。G的最小生成树是G的一个连通的、无圈的、边的权重之和最小的包含图中所有顶点的子图。如果e*是图G上权重最小的边，那么一定有一棵图G的最小生成树T包含边e*。请问这个命题是否正确,如果正确，请给出证明。如果不正确,请给出反例。(8分)</p>
<p>答：正确</p>
<hr>
<p>四、工厂s生产的商品通过下图表示的运输网络运送到市场t，网络中边上的数值表示单位时间可以通过该边的商品数量的上限，求单位时间内从工厂s到市场t能运送的最大商品总量。要求给出求解过程(给出每条增广路径及其增加的流量值)。(8分)</p>
<p><img src="https://img.jwt1399.top/img/202112071837710.png"></p>
<p>1增广路径：(<em>s</em>, <em>s1</em>, <em>t</em>, <em>v1</em>, <em>t1</em>, <em>t</em>)，流量值+10</p>
<p>2增广路径：(<em>s</em>, <em>s2</em>, <em>v5</em>, <em>t2</em>, <em>t</em>)，流量值+10</p>
<p>3增广路径：(<em>s</em>, <em>s1</em>, <em>v2</em>, <em>v3</em>, <em>v4</em>, <em>t1</em>, <em>t</em>)，流量值+5</p>
<p>4增广路径：(<em>s</em>, <em>s2</em>, <em>v2</em>, <em>v1</em>, <em>t1</em>, <em>t</em>)，流量值+4</p>
<p>5增广路径：(<em>s</em>, <em>s2</em>, <em>v5</em>, <em>v3</em>, <em>v4</em>, <em>t2</em>, <em>t</em>)，流量值+3</p>
<p><strong>最大流 10 + 10 + 5 + 4 + 3 &#x3D; 32</strong></p>
<hr>
<p>五、若给定两个序列 X &#x3D; (x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,…,x<sub>n</sub>) 和 Y &#x3D; (y<sub>1</sub>,y<sub>2</sub>,y<sub>3</sub>,…,y<sub>m</sub>) 、如果对于所有 j &#x3D; 1,2,3,.,m-1 有 y<sub>j </sub>&lt; y<sub>j+1</sub> 并且存在一个严格递增下标序列 (i<sub>1</sub>,i<sub>2</sub>,i<sub>3</sub>,…,i<sub>k</sub>) 使得对于所有 j &#x3D; 1,2,3,…,m 有 y<sub>j</sub> &#x3D; x<sub>i </sub>，则称 Y 是 X 的单调递增子序列。(8分)</p>
<p>(1)给出动态规划算法求给定序列最长单调递增子序列长度的递归关系式。</p>
<p>对于数组序列 Y<sub>i</sub> ( 1 ≤ i ≤ m ) ，令 dp[i] 表示以第 i 个数 Y<sub>i</sub> 结尾的最长递增子序列的长度。那么，我们考虑以第 i 个数 Y<sub>i</sub>  结尾的最长递增子序列，它在这个序列中的前一个数 Y<sub>j</sub> ( 1 ≤ j &lt; i )，所以，如果我们已经知道了 dp[j]，那么就有 dp[i] &#x3D; dp[j] + 1 。显然，我们还需要满足 Y<sub>j</sub> &lt; Y<sub>i</sub>，这个递增的限制条件。</p>
<p>递归关系式：dp[i] &#x3D; max<sub>j&#x3D;1</sub>( dp[j] ∣ Y<sub>j</sub> &lt; Y<sub>i</sub> ) + 1</p>
<p>(2)求解序列(a,l,g,o,r,i,t,h,m)的最长单调递增子序列,画出求解过程表格。</p>
<p><img src="https://img.jwt1399.top/img/image-20211208230832866.png"></p>
<p>最长单调递增子序列：a，l，o，r，t 或 a，g，o，r，t</p>
<hr>
<p>六、判定问题A：给定包含奇数个结点的简单无向图，判断其是否包含哈密尔顿圈；判定问题B：给定包含偶数个结点的简单无向图，判断其是否包含哈密尔顿圈；证明问题A可多项式归约到问题B。</p>
<p>设奇数个节点的简单无向图为 G。</p>
<p>构造方法为：随机在 G 中选择一个点 u，假设这个点 u 存在 k 条边，我们断开一条边添加一个点 w，将 w 连接到断开边的两个顶点，这样便构造了一个偶数个顶点的图 G’，依次断开这 k 条边加点，这样我们可以构造 k 个 G’ ，则在这 k 个 G’ 中肯定能找到一个 G’ 存在一条边 (u,v) 是在哈密尔顿圈中，则这个图 G’ 肯定满足奇数结点的简单无向图包含哈密尔顿当且仅当偶数结点的简单无向图包含哈密尔顿。</p>
<p>大家可以在评论区留下你想法，一起交流！</p>
<hr>
<p>七、如果存在判断任意简单无向图是否存在哈密尔顿圈的多项式时间算法，请你设计构造任意简单无向图的哈密尔顿圈（如果存在的话）的多项式时间算法。</p>
<p>算法：</p>
<p>&#x2F;&#x2F;设该判断算法为A<br>S 初始化为空集；<br>首先算法 A 判断图 G 中是否存在哈密尔顿圈，如果不存在则算法结束，如果存在则继续寻找哈密尔顿圈；<br>For every edge e in G {<br>    如果 G – {e}中不存在哈密尔顿圈，则将 e 添加到集合 S 中；<br>    否则 G &#x3D; G – {e}；<br>}<br>最终所得集合 S 中的所有边构成图 G 的哈密尔顿圈。</p>
<hr>
<p>八、给定正整数集合 A &#x3D; {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>} 和正整数 b，b ≥ max {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>}。当集合 A 的子集 S∈A 中的元素之和小于等于 b 时，即 ∑<sub>a<sub>i</sub>∈S[i]</sub> a<sub>i</sub>≤b，我们称 S 为可行集。请寻找元素之和最大的可行集 S 。例如，A &#x3D; {8,2,4}，b&#x3D; 11，则最优的可行集为 S &#x3D; {8,2}，最优解为 8＋2&#x3D;10 (10分)</p>
<p>(1)下面是求解这个问题的算法。集合 S 初始为空集；按照下标 i 从小到大的顺序依次考察集合 A 中的每个整数 a<sub>i</sub>，如果 α<sub>i</sub> + ∑<sub>a<sub>k</sub>∈S</sub> a<sub>k</sub>＜b ，则将 a<sub>i </sub>添加集合 S 中，即 S &#x3D; S U {a<sub>i</sub>}。证明这个算法不是1&#x2F;2倍近似算法。(3分)</p>
<hr>
<p>设集合 A &#x3D; {1，4}，b &#x3D; 4</p>
<p>根据该算法求得可行集 S &#x3D; {1} ，解为 ∑S &#x3D; 1 </p>
<p>​           而最优可行解 S* &#x3D; {4}，最优解 ∑S* &#x3D; 4</p>
<p>⇒ ∑S &#x3D; (1&#x2F;4)∑S* &lt; (1&#x2F;2)∑S*</p>
<p>∴该算法不是1&#x2F;2倍近似算法</p>
<hr>
<p>(2)为该问题设计O(nlogn)时间复杂度的近似算法，并证明该算法是1&#x2F;2倍近似算法(7分)</p>
<hr>
<p>在 (1) 中 所给算法基础上对集合 A 进行降序归并排序[O(nlogn)]</p>
<p>即： a<sub>1</sub>＞a<sub>2</sub>＞a<sub>3</sub>＞…＞a<sub>k</sub>＞a<sub>k+1</sub>＞…＞a<sub>n</sub></p>
<p>证明：设 a<sub>k</sub> 为可行集最后一个元素</p>
<p>a<sub>k </sub>≥ a<sub>k+1 </sub>⇒ ∑S ≥ a<sub>k+1 </sub>   ——①</p>
<p>a<sub>k</sub> 为可行集最后一个元素 ⇒ ∑S ≥ b - a<sub>k+1 </sub>——②</p>
<p>①+② ： ∑S ≥ (1&#x2F;2)b ，再又 b ≥ ∑S*</p>
<p>⇒∑S ≥ (1&#x2F;2)∑S*</p>
<p>∴ 该算法是 1&#x2F;2 倍近似算法</p>
<hr>
<h4 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h4><blockquote>
<p>考试结束啦，考得一塌糊涂，以下是我的回忆</p>
</blockquote>
<p>大题：</p>
<ul>
<li><p>渐进增长率排序</p>
</li>
<li><p>矩阵连乘，求最小计算次数和最优加括号方式</p>
</li>
<li><p>贪心算法正确性证明(找零钱)</p>
</li>
<li><p>分治算法(类似2020年L型骨牌覆盖)</p>
</li>
<li><p>网络流(跟2020年的图相似)</p>
</li>
<li><p>归约(3着色归约到k着色)</p>
</li>
<li><p>自归约(支配集)</p>
</li>
<li><p>近似算法(给了一个算法，证明不是1&#x2F;2倍算法)</p>
</li>
<li><p>最大连续子序列(给出递归关系并求解)</p>
</li>
</ul>
<h2 id="⑩总结-amp-感谢"><a href="#⑩总结-amp-感谢" class="headerlink" title="⑩总结&amp;感谢"></a>⑩总结&amp;感谢</h2><p>看到这里你已经看完了所有正文部分了，相信你对算法设计也有了大致的了解，还是希望此文或多或少对你产生了一些帮助吧，这也是小简写此文的初衷之一。后面的内容是本文的版本管理记录，记录了小简写此文的过程，然后是本文的参考书籍和参考文章，最后是读者对小简的赞助渠道。（赞助将用于本博客运营【CDN和OBS续费】）</p>
<p>首先感谢各位前辈所写文章，没有他们本文也无法完成，其次自从文章开放以来，收到很多读者对文章错误指正的消息以及收到部分读者的赞助，这里就不一一列出了，小简在此真诚的感谢大家！🙏🙏</p>
<p>最后还想送给读者一句话，慢慢来，比较快！</p>
<h2 id="⑪版本管理"><a href="#⑪版本管理" class="headerlink" title="⑪版本管理"></a>⑪版本管理</h2><h3 id="v-1-0-2021-10-17"><a href="#v-1-0-2021-10-17" class="headerlink" title="v 1.0(2021-10-17)"></a>v 1.0(2021-10-17)</h3><ul>
<li>初步构建算法笔记<code>基本框架</code></li>
<li>完成<code>算法引论</code>、<code>算法复杂度</code>、<code>网络流</code>全部章节撰写</li>
<li>完成<code>贪心算法</code>、<code>分治算法</code>、<code>动态规划</code>部分章节撰写</li>
</ul>
<h3 id="v-1-1-2021-10-21"><a href="#v-1-1-2021-10-21" class="headerlink" title="v 1.1(2021-10-21)"></a>v 1.1(2021-10-21)</h3><ul>
<li>修复若干<code>已知错误</code>(感谢@tzj、@whh)</li>
<li>优化若干<code>小细节</code></li>
<li>完善<code>渐近增长率</code>比较习题解答</li>
<li>新增<code>动态规划</code>真题练习</li>
<li>新增<code>任意流</code>与<code>任意割</code>关系</li>
</ul>
<h3 id="v-1-2-2021-11-12"><a href="#v-1-2-2021-11-12" class="headerlink" title="v 1.2(2021-11-12)"></a>v 1.2(2021-11-12)</h3><ul>
<li>新增<code>判断问题</code>和<code>优化问题</code>概念</li>
<li>新增<code>NP完备性</code>理论章节</li>
<li>新增<code>01背包</code>问题</li>
<li>完善<code>动态规划</code>分析</li>
<li>新增<code>近似算法</code>部分章节</li>
</ul>
<h3 id="v-1-3-2021-11-27"><a href="#v-1-3-2021-11-27" class="headerlink" title="v 1.3(2021-11-27)"></a>v 1.3(2021-11-27)</h3><ul>
<li>完善<code>分治算法</code>章节</li>
<li>新增<code>历年期末真题</code>章节</li>
<li>完善<code>近似算法</code>章节</li>
<li>完善贪心算法<code>正确性证明</code></li>
<li>优化整体<code>文章结构</code></li>
<li>修改若干<code>已知错误</code>(感谢@whh)</li>
</ul>
<h3 id="v-1-4-2021-12-07"><a href="#v-1-4-2021-12-07" class="headerlink" title="v 1.4(2021-12-07)"></a>v 1.4(2021-12-07)</h3><ul>
<li>优化<code>NP完备性理论</code>章节</li>
<li>完善<code>历年期末真题</code>章节</li>
<li>修改若干<code>已知错误</code>(感谢若干不知名读者)</li>
</ul>
<h3 id="To-Do"><a href="#To-Do" class="headerlink" title="To Do"></a>To Do</h3><ul>
<li><input disabled="" type="checkbox"> 完善NP完备性理论章节</li>
<li><input disabled="" type="checkbox"> 完善近似算法章节</li>
</ul>
<h2 id="⑫Reference📖"><a href="#⑫Reference📖" class="headerlink" title="⑫Reference📖"></a>⑫Reference📖</h2><p><strong>书籍</strong></p>
<ul>
<li>《算法设计》 Kleinberg，J. ，Tardos，E.  著；张立昂，屈婉玲 译</li>
<li>《计算机算法设计与分析》王晓东 著</li>
<li>《算法图解》 Aditya Bhargava 著 ；袁国忠 译</li>
<li>《大话数据结构》程杰 著</li>
</ul>
<p><strong>贪心算法</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/pmd/4044055.html">AI产品经理必修——揭开算法的面纱（贪心算法）</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038224322">贪心算法刷完这些题目就够了 - SegmentFault 思否</a></li>
<li><a target="_blank" rel="noopener" href="https://imzhanghao.com/2020/04/15/5-classic-algorithms-2-greedy-algorithm/">五大经典算法|2.贪心算法 - 张浩在路上</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43424037/article/details/107175891">活动安排问题-计算机算法_笨手笨脚°的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pkueecscss/article/details/88578060"> 贪心算法的正确性证明</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26891045/article/details/51025619">ACM–贪心算法–活动安排问题_戎码人生-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44176696/article/details/105705481">活动安排问题贪心证明_AKGWSB ‘s blog-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~lszhuang/alg/ch16.pdf">USTC-算法基础-贪心算法</a></li>
</ul>
<p><strong>分治</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html">【算法16】递归算法的时间复杂度终结篇</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113406812">主定理(Master Theorem) - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/HIIM/p/12499319.html">算法设计与分析 - 主定理 - HIIM - 博客园</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wu246051/article/details/111464029?spm=1001.2014.3001.5501">动态规划—＞矩阵连乘问题</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43424037/article/details/106971000">矩阵连乘问题-动态规划</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39956356/article/details/101623749"> 算法之动态规划，问题二：带权重的任务安排问题_我爱加菲猫</a></li>
<li><a target="_blank" rel="noopener" href="http://www.voycn.com/article/dongtaiguihuasuanfa">动态规划算法 | 航行学园 </a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bajiaoyu517/article/details/109524684">动态规划算法_bajiaoyu517的博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39956356/article/details/101695289">算法之动态规划，问题三：0 1 背包问题_我爱加菲猫</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangkundentisy/p/9346376.html">最长公共子序列问题和最长公共子串问题 - Excaliburer - 博客园</a></li>
</ul>
<p><strong>网络流</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K64y1C7Do/?spm_id_from=333.788.recommend_more_video.0">网络流问题基础 Network Flow Problems</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Xing-Ling/p/11487554.html">网络流算法简单入门 - 辰星凌 - 博客园</a></li>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/flow/">网络流简介 - OI Wiki (oi-wiki.org)</a></li>
</ul>
<p><strong>NP完备性理论</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyly1995/article/details/109959064?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link"> 算法设计与分析-归约与复杂度的NP问题以及近似算法_lyly1995的博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ivdone.top/article/57.html">多项式时间归约 | | 清水寺修行生活记录</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37657182/article/details/102969574">多项式规约_小菜菜forever的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ddae993cc065">算法设计与分析笔记之独立集问题 - 简书</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37657182/article/details/103001996">多项式规约——续_小菜菜forever的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/024892e7cf04">算法设计与分析笔记之整数规划</a></li>
<li><a target="_blank" rel="noopener" href="https://sailist.github.io/AdAlgo/">高级算法 | AdAlgo </a></li>
</ul>
<p><strong>近似算法</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44075108/article/details/110604404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242.2">算法设计与分析之近似算法_猿归林的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37657182/article/details/103056025?spm=1001.2014.3001.5502">近似算法_小菜菜forever的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dac9620ec051">算法基础 - 简书</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangxiaoyang.me/categories/intro-to-algorithms-tutorial/intro-to-algorithms-tutorial-9.html">Yang的后花园</a></li>
<li><a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~xiaomj/teaching/sf10.pdf">ustc.edu.cn</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d8d7aa16f53f">算法设计与分析笔记之近似算法 - 简书</a></li>
</ul>
<h2 id="⑬Sponsor❤️"><a href="#⑬Sponsor❤️" class="headerlink" title="⑬Sponsor❤️"></a>⑬Sponsor❤️</h2><p>本文是 UESTC 研一 《高级算法设计与分析》课程总结，总结得不一定完善不一定完美，但是从查阅资料，到画图构思，再到文章编写前后也经历了大概一个多月的时间，在这个喧嚣浮躁的时代，个人博客越来越没有人看了，写博客感觉一直是用爱发电的状态。如果你恰巧财力雄厚，感觉本文对你有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用。</p>
<table>
  <tbody>
     <tr>
         <td style="text-align:center;">支付宝</td>
         <td style="text-align:center;">微信</td>
     </tr>
   <tr>
    <td style="text-align:center;" ><img width="200" src="https://jwt1399.top/medias/reward/alipay.png"></td>    
      <td style="text-align:center;"><img width="200" src="https://jwt1399.top/medias/reward/sponor_wechat.png"></td>
  </tr>
</tbody></table>



            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top" rel="external nofollow noreferrer">简简</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jwt1399.top/posts/46989.html">https://jwt1399.top/posts/46989.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jwt1399.top" target="_blank">简简</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo,linkedin,facebook,twitter,google,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">打</a>
	<a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>
    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        /*max-width: 100%;*/
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    .v[data-class=v] .vinput {
     padding: 0px 0px;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论<center>填上邮箱会收到评论回复提醒哦!!!</center></span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/valine/1.4.18/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Awf92dhT3VWqTfENqbCDoqbA-gzGzoHsz',
        appKey: '9uN7ODvigK9GAp8CYBz0fOrX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: '',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '[填上邮箱，会给你发送评论提醒]，ヾﾉ≧∀≦)o 请畅所欲言~',
        enableQQ: true,
        boolean: true,
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/52395.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top//img/20210619093103" class="responsive-img" alt="研一上总结">
                        
                        <span class="card-title">研一上总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            研一上碎碎念现在是 2021年12月03日08点43分，此时我正在成都开往XX的火车上，因为多臭美了 10 分钟，加之去往地铁站的路上有一点点堵车，我差点没有赶上火车，幸运的是我在停止检票的前一分钟顺利冲进了站点，此刻望着窗外转瞬即逝的风景
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-12-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Share/" class="post-category">
                                    Share
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%BB%E7%BB%93/">
                        <span class="chip bg-color">总结</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/9409.html">
                    <div class="card-image">
                        
                        <img src="https://img.jwt1399.top//img/20210726221844.png" class="responsive-img" alt="LeetCode 算法入门">
                        
                        <span class="card-title">LeetCode 算法入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            在数学和计算机科学之中，算法是一个被定义好的、计算机可施行之指示的有限步骤或次序，常用于计算、数据处理和自动推理。作为一个有效方法，算法被用于计算函数，它包含了一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Python/" class="post-category">
                                    Python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 简言之<br />'
            + '文章作者: 简简<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://jwt1399.top" target="_blank">简简</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;|

			<!-- <span>为♥️️发电</span> -->
            <a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img no-lazy src="https://img.jwt1399.top/img/20200824181422.png" style="width: 47px; vertical-align: middle;" ></a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1078.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "7";
                    var startDate = "2";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            <a href="https://search.google.com/search-console?resource_id=http%3A%2F%2Fjwt1399.top%2F" target="_blank"
                rel="nofollow noopener">谷歌统计</a>&nbsp;|
            
            <span id="icp"><img no-lazy src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://www.beian.miit.gov.cn/" target="_blank">蜀ICP备19020450号</a>
            </span>
            |
            
            <a href="https://tongji.baidu.com/web/10000159136/overview/index?siteId=14519996" target="_blank"
                rel="nofollow noopener">百度统计</a>

        </div>
        <div class="col s12 m4 l4 social-link social-statis">

    <a href="https://jwt1399.top/baidusitemap.xml" class="tooltipped" target="_blank" data-tooltip="访问我的sitemap" data-position="top" data-delay="50">
        <i class="fas fa-sitemap"></i>
    </a>


    <a href="https://pl.jwt1399.top" class="tooltipped" target="_blank" data-tooltip="valine评论: https://pl.jwt1399.top" data-position="top" data-delay="50">
        <i class="fab fa-optin-monster"></i>
    </a>


    <a href="mailto:1019084218@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope"></i>
    </a>













    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1019084218" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1019084218" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.json", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.staticfile.org/aos/3.0.0-beta.6/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
	<!--valine_人机验证-->
	<button id="TencentCaptcha"data-appid="2046265119"data-cbfn="callback"type="button" hidden></button>
	
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-160042502-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-160042502-1');
</script>


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0e306ce3426983ae6367d094d39f1190";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

        
</body>

</html>
